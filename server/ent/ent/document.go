// Code generated by ent, DO NOT EDIT.

package ent

import (
	"awe/ent/ent/document"
	"awe/ent/ent/documentcategory"
	"awe/ent/ent/user"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// Document is the model entity for the Document schema.
type Document struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Title holds the value of the "title" field.
	Title map[string]string `json:"title,omitempty"`
	// Type holds the value of the "type" field.
	Type document.Type `json:"type,omitempty"`
	// FileURL holds the value of the "file_url" field.
	FileURL string `json:"file_url,omitempty"`
	// FileName holds the value of the "file_name" field.
	FileName string `json:"file_name,omitempty"`
	// MimeType holds the value of the "mime_type" field.
	MimeType string `json:"mime_type,omitempty"`
	// Size holds the value of the "size" field.
	Size int `json:"size,omitempty"`
	// Description holds the value of the "description" field.
	Description map[string]string `json:"description,omitempty"`
	// Tags holds the value of the "tags" field.
	Tags []string `json:"tags,omitempty"`
	// Version holds the value of the "version" field.
	Version string `json:"version,omitempty"`
	// Language holds the value of the "language" field.
	Language string `json:"language,omitempty"`
	// IsPublic holds the value of the "is_public" field.
	IsPublic bool `json:"is_public,omitempty"`
	// AllowedRoles holds the value of the "allowed_roles" field.
	AllowedRoles []string `json:"allowed_roles,omitempty"`
	// AccessPassword holds the value of the "access_password" field.
	AccessPassword string `json:"-"`
	// RequiresApproval holds the value of the "requires_approval" field.
	RequiresApproval bool `json:"requires_approval,omitempty"`
	// IsApproved holds the value of the "is_approved" field.
	IsApproved bool `json:"is_approved,omitempty"`
	// ApprovedBy holds the value of the "approved_by" field.
	ApprovedBy string `json:"approved_by,omitempty"`
	// ApprovedAt holds the value of the "approved_at" field.
	ApprovedAt time.Time `json:"approved_at,omitempty"`
	// DownloadCount holds the value of the "download_count" field.
	DownloadCount int `json:"download_count,omitempty"`
	// LastAccessed holds the value of the "last_accessed" field.
	LastAccessed time.Time `json:"last_accessed,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the DocumentQuery when eager-loading is set.
	Edges                       DocumentEdges `json:"edges"`
	document_category_documents *int
	user_document_uploads       *int
	selectValues                sql.SelectValues
}

// DocumentEdges holds the relations/edges for other nodes in the graph.
type DocumentEdges struct {
	// Uploader holds the value of the uploader edge.
	Uploader *User `json:"uploader,omitempty"`
	// Category holds the value of the category edge.
	Category *DocumentCategory `json:"category,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// UploaderOrErr returns the Uploader value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e DocumentEdges) UploaderOrErr() (*User, error) {
	if e.Uploader != nil {
		return e.Uploader, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: user.Label}
	}
	return nil, &NotLoadedError{edge: "uploader"}
}

// CategoryOrErr returns the Category value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e DocumentEdges) CategoryOrErr() (*DocumentCategory, error) {
	if e.Category != nil {
		return e.Category, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: documentcategory.Label}
	}
	return nil, &NotLoadedError{edge: "category"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Document) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case document.FieldTitle, document.FieldDescription, document.FieldTags, document.FieldAllowedRoles:
			values[i] = new([]byte)
		case document.FieldIsPublic, document.FieldRequiresApproval, document.FieldIsApproved:
			values[i] = new(sql.NullBool)
		case document.FieldID, document.FieldSize, document.FieldDownloadCount:
			values[i] = new(sql.NullInt64)
		case document.FieldType, document.FieldFileURL, document.FieldFileName, document.FieldMimeType, document.FieldVersion, document.FieldLanguage, document.FieldAccessPassword, document.FieldApprovedBy:
			values[i] = new(sql.NullString)
		case document.FieldApprovedAt, document.FieldLastAccessed, document.FieldCreatedAt, document.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		case document.ForeignKeys[0]: // document_category_documents
			values[i] = new(sql.NullInt64)
		case document.ForeignKeys[1]: // user_document_uploads
			values[i] = new(sql.NullInt64)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Document fields.
func (_m *Document) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case document.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			_m.ID = int(value.Int64)
		case document.FieldTitle:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field title", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Title); err != nil {
					return fmt.Errorf("unmarshal field title: %w", err)
				}
			}
		case document.FieldType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field type", values[i])
			} else if value.Valid {
				_m.Type = document.Type(value.String)
			}
		case document.FieldFileURL:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field file_url", values[i])
			} else if value.Valid {
				_m.FileURL = value.String
			}
		case document.FieldFileName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field file_name", values[i])
			} else if value.Valid {
				_m.FileName = value.String
			}
		case document.FieldMimeType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mime_type", values[i])
			} else if value.Valid {
				_m.MimeType = value.String
			}
		case document.FieldSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field size", values[i])
			} else if value.Valid {
				_m.Size = int(value.Int64)
			}
		case document.FieldDescription:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field description", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Description); err != nil {
					return fmt.Errorf("unmarshal field description: %w", err)
				}
			}
		case document.FieldTags:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tags", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Tags); err != nil {
					return fmt.Errorf("unmarshal field tags: %w", err)
				}
			}
		case document.FieldVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field version", values[i])
			} else if value.Valid {
				_m.Version = value.String
			}
		case document.FieldLanguage:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field language", values[i])
			} else if value.Valid {
				_m.Language = value.String
			}
		case document.FieldIsPublic:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_public", values[i])
			} else if value.Valid {
				_m.IsPublic = value.Bool
			}
		case document.FieldAllowedRoles:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field allowed_roles", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.AllowedRoles); err != nil {
					return fmt.Errorf("unmarshal field allowed_roles: %w", err)
				}
			}
		case document.FieldAccessPassword:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field access_password", values[i])
			} else if value.Valid {
				_m.AccessPassword = value.String
			}
		case document.FieldRequiresApproval:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field requires_approval", values[i])
			} else if value.Valid {
				_m.RequiresApproval = value.Bool
			}
		case document.FieldIsApproved:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_approved", values[i])
			} else if value.Valid {
				_m.IsApproved = value.Bool
			}
		case document.FieldApprovedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field approved_by", values[i])
			} else if value.Valid {
				_m.ApprovedBy = value.String
			}
		case document.FieldApprovedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field approved_at", values[i])
			} else if value.Valid {
				_m.ApprovedAt = value.Time
			}
		case document.FieldDownloadCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field download_count", values[i])
			} else if value.Valid {
				_m.DownloadCount = int(value.Int64)
			}
		case document.FieldLastAccessed:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_accessed", values[i])
			} else if value.Valid {
				_m.LastAccessed = value.Time
			}
		case document.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case document.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case document.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field document_category_documents", value)
			} else if value.Valid {
				_m.document_category_documents = new(int)
				*_m.document_category_documents = int(value.Int64)
			}
		case document.ForeignKeys[1]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field user_document_uploads", value)
			} else if value.Valid {
				_m.user_document_uploads = new(int)
				*_m.user_document_uploads = int(value.Int64)
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Document.
// This includes values selected through modifiers, order, etc.
func (_m *Document) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryUploader queries the "uploader" edge of the Document entity.
func (_m *Document) QueryUploader() *UserQuery {
	return NewDocumentClient(_m.config).QueryUploader(_m)
}

// QueryCategory queries the "category" edge of the Document entity.
func (_m *Document) QueryCategory() *DocumentCategoryQuery {
	return NewDocumentClient(_m.config).QueryCategory(_m)
}

// Update returns a builder for updating this Document.
// Note that you need to call Document.Unwrap() before calling this method if this Document
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Document) Update() *DocumentUpdateOne {
	return NewDocumentClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the Document entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Document) Unwrap() *Document {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: Document is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *Document) String() string {
	var builder strings.Builder
	builder.WriteString("Document(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("title=")
	builder.WriteString(fmt.Sprintf("%v", _m.Title))
	builder.WriteString(", ")
	builder.WriteString("type=")
	builder.WriteString(fmt.Sprintf("%v", _m.Type))
	builder.WriteString(", ")
	builder.WriteString("file_url=")
	builder.WriteString(_m.FileURL)
	builder.WriteString(", ")
	builder.WriteString("file_name=")
	builder.WriteString(_m.FileName)
	builder.WriteString(", ")
	builder.WriteString("mime_type=")
	builder.WriteString(_m.MimeType)
	builder.WriteString(", ")
	builder.WriteString("size=")
	builder.WriteString(fmt.Sprintf("%v", _m.Size))
	builder.WriteString(", ")
	builder.WriteString("description=")
	builder.WriteString(fmt.Sprintf("%v", _m.Description))
	builder.WriteString(", ")
	builder.WriteString("tags=")
	builder.WriteString(fmt.Sprintf("%v", _m.Tags))
	builder.WriteString(", ")
	builder.WriteString("version=")
	builder.WriteString(_m.Version)
	builder.WriteString(", ")
	builder.WriteString("language=")
	builder.WriteString(_m.Language)
	builder.WriteString(", ")
	builder.WriteString("is_public=")
	builder.WriteString(fmt.Sprintf("%v", _m.IsPublic))
	builder.WriteString(", ")
	builder.WriteString("allowed_roles=")
	builder.WriteString(fmt.Sprintf("%v", _m.AllowedRoles))
	builder.WriteString(", ")
	builder.WriteString("access_password=<sensitive>")
	builder.WriteString(", ")
	builder.WriteString("requires_approval=")
	builder.WriteString(fmt.Sprintf("%v", _m.RequiresApproval))
	builder.WriteString(", ")
	builder.WriteString("is_approved=")
	builder.WriteString(fmt.Sprintf("%v", _m.IsApproved))
	builder.WriteString(", ")
	builder.WriteString("approved_by=")
	builder.WriteString(_m.ApprovedBy)
	builder.WriteString(", ")
	builder.WriteString("approved_at=")
	builder.WriteString(_m.ApprovedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("download_count=")
	builder.WriteString(fmt.Sprintf("%v", _m.DownloadCount))
	builder.WriteString(", ")
	builder.WriteString("last_accessed=")
	builder.WriteString(_m.LastAccessed.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// Documents is a parsable slice of Document.
type Documents []*Document
