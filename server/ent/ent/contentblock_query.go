// Code generated by ent, DO NOT EDIT.

package ent

import (
	"awe/ent/ent/blockaccordion"
	"awe/ent/ent/blockcontactform"
	"awe/ent/ent/blockcta"
	"awe/ent/ent/blockdivider"
	"awe/ent/ent/blockdonationform"
	"awe/ent/ent/blockfaq"
	"awe/ent/ent/blockgallery"
	"awe/ent/ent/blockhero"
	"awe/ent/ent/blockmap"
	"awe/ent/ent/blocknewslettersignup"
	"awe/ent/ent/blockpartnerlogos"
	"awe/ent/ent/blockprogramcards"
	"awe/ent/ent/blockstats"
	"awe/ent/ent/blocksuccessstories"
	"awe/ent/ent/blocktabs"
	"awe/ent/ent/blockteamgrid"
	"awe/ent/ent/blocktestimonials"
	"awe/ent/ent/blocktextcontent"
	"awe/ent/ent/blocktimeline"
	"awe/ent/ent/blockvideoembed"
	"awe/ent/ent/blockvolunteersignup"
	"awe/ent/ent/contentblock"
	"awe/ent/ent/page"
	"awe/ent/ent/predicate"
	"context"
	"database/sql/driver"
	"fmt"
	"math"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// ContentBlockQuery is the builder for querying ContentBlock entities.
type ContentBlockQuery struct {
	config
	ctx                       *QueryContext
	order                     []contentblock.OrderOption
	inters                    []Interceptor
	predicates                []predicate.ContentBlock
	withPage                  *PageQuery
	withBlockHero             *BlockHeroQuery
	withBlockTextContent      *BlockTextContentQuery
	withBlockFaq              *BlockFaqQuery
	withBlockCta              *BlockCtaQuery
	withBlockTestimonials     *BlockTestimonialsQuery
	withBlockStats            *BlockStatsQuery
	withBlockGallery          *BlockGalleryQuery
	withBlockProgramCards     *BlockProgramCardsQuery
	withBlockSuccessStories   *BlockSuccessStoriesQuery
	withBlockDonationForm     *BlockDonationFormQuery
	withBlockVolunteerSignup  *BlockVolunteerSignupQuery
	withBlockNewsletterSignup *BlockNewsletterSignupQuery
	withBlockPartnerLogos     *BlockPartnerLogosQuery
	withBlockTeamGrid         *BlockTeamGridQuery
	withBlockTimeline         *BlockTimelineQuery
	withBlockContactForm      *BlockContactFormQuery
	withBlockVideoEmbed       *BlockVideoEmbedQuery
	withBlockMap              *BlockMapQuery
	withBlockAccordion        *BlockAccordionQuery
	withBlockTabs             *BlockTabsQuery
	withBlockDivider          *BlockDividerQuery
	withFKs                   bool
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the ContentBlockQuery builder.
func (_q *ContentBlockQuery) Where(ps ...predicate.ContentBlock) *ContentBlockQuery {
	_q.predicates = append(_q.predicates, ps...)
	return _q
}

// Limit the number of records to be returned by this query.
func (_q *ContentBlockQuery) Limit(limit int) *ContentBlockQuery {
	_q.ctx.Limit = &limit
	return _q
}

// Offset to start from.
func (_q *ContentBlockQuery) Offset(offset int) *ContentBlockQuery {
	_q.ctx.Offset = &offset
	return _q
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (_q *ContentBlockQuery) Unique(unique bool) *ContentBlockQuery {
	_q.ctx.Unique = &unique
	return _q
}

// Order specifies how the records should be ordered.
func (_q *ContentBlockQuery) Order(o ...contentblock.OrderOption) *ContentBlockQuery {
	_q.order = append(_q.order, o...)
	return _q
}

// QueryPage chains the current query on the "page" edge.
func (_q *ContentBlockQuery) QueryPage() *PageQuery {
	query := (&PageClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(page.Table, page.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contentblock.PageTable, contentblock.PageColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockHero chains the current query on the "block_hero" edge.
func (_q *ContentBlockQuery) QueryBlockHero() *BlockHeroQuery {
	query := (&BlockHeroClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockhero.Table, blockhero.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockHeroTable, contentblock.BlockHeroColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockTextContent chains the current query on the "block_text_content" edge.
func (_q *ContentBlockQuery) QueryBlockTextContent() *BlockTextContentQuery {
	query := (&BlockTextContentClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blocktextcontent.Table, blocktextcontent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockTextContentTable, contentblock.BlockTextContentColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockFaq chains the current query on the "block_faq" edge.
func (_q *ContentBlockQuery) QueryBlockFaq() *BlockFaqQuery {
	query := (&BlockFaqClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockfaq.Table, blockfaq.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockFaqTable, contentblock.BlockFaqColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockCta chains the current query on the "block_cta" edge.
func (_q *ContentBlockQuery) QueryBlockCta() *BlockCtaQuery {
	query := (&BlockCtaClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockcta.Table, blockcta.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockCtaTable, contentblock.BlockCtaColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockTestimonials chains the current query on the "block_testimonials" edge.
func (_q *ContentBlockQuery) QueryBlockTestimonials() *BlockTestimonialsQuery {
	query := (&BlockTestimonialsClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blocktestimonials.Table, blocktestimonials.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockTestimonialsTable, contentblock.BlockTestimonialsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockStats chains the current query on the "block_stats" edge.
func (_q *ContentBlockQuery) QueryBlockStats() *BlockStatsQuery {
	query := (&BlockStatsClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockstats.Table, blockstats.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockStatsTable, contentblock.BlockStatsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockGallery chains the current query on the "block_gallery" edge.
func (_q *ContentBlockQuery) QueryBlockGallery() *BlockGalleryQuery {
	query := (&BlockGalleryClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockgallery.Table, blockgallery.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockGalleryTable, contentblock.BlockGalleryColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockProgramCards chains the current query on the "block_program_cards" edge.
func (_q *ContentBlockQuery) QueryBlockProgramCards() *BlockProgramCardsQuery {
	query := (&BlockProgramCardsClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockprogramcards.Table, blockprogramcards.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockProgramCardsTable, contentblock.BlockProgramCardsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockSuccessStories chains the current query on the "block_success_stories" edge.
func (_q *ContentBlockQuery) QueryBlockSuccessStories() *BlockSuccessStoriesQuery {
	query := (&BlockSuccessStoriesClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blocksuccessstories.Table, blocksuccessstories.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockSuccessStoriesTable, contentblock.BlockSuccessStoriesColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockDonationForm chains the current query on the "block_donation_form" edge.
func (_q *ContentBlockQuery) QueryBlockDonationForm() *BlockDonationFormQuery {
	query := (&BlockDonationFormClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockdonationform.Table, blockdonationform.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockDonationFormTable, contentblock.BlockDonationFormColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockVolunteerSignup chains the current query on the "block_volunteer_signup" edge.
func (_q *ContentBlockQuery) QueryBlockVolunteerSignup() *BlockVolunteerSignupQuery {
	query := (&BlockVolunteerSignupClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockvolunteersignup.Table, blockvolunteersignup.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockVolunteerSignupTable, contentblock.BlockVolunteerSignupColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockNewsletterSignup chains the current query on the "block_newsletter_signup" edge.
func (_q *ContentBlockQuery) QueryBlockNewsletterSignup() *BlockNewsletterSignupQuery {
	query := (&BlockNewsletterSignupClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blocknewslettersignup.Table, blocknewslettersignup.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockNewsletterSignupTable, contentblock.BlockNewsletterSignupColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockPartnerLogos chains the current query on the "block_partner_logos" edge.
func (_q *ContentBlockQuery) QueryBlockPartnerLogos() *BlockPartnerLogosQuery {
	query := (&BlockPartnerLogosClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockpartnerlogos.Table, blockpartnerlogos.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockPartnerLogosTable, contentblock.BlockPartnerLogosColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockTeamGrid chains the current query on the "block_team_grid" edge.
func (_q *ContentBlockQuery) QueryBlockTeamGrid() *BlockTeamGridQuery {
	query := (&BlockTeamGridClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockteamgrid.Table, blockteamgrid.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockTeamGridTable, contentblock.BlockTeamGridColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockTimeline chains the current query on the "block_timeline" edge.
func (_q *ContentBlockQuery) QueryBlockTimeline() *BlockTimelineQuery {
	query := (&BlockTimelineClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blocktimeline.Table, blocktimeline.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockTimelineTable, contentblock.BlockTimelineColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockContactForm chains the current query on the "block_contact_form" edge.
func (_q *ContentBlockQuery) QueryBlockContactForm() *BlockContactFormQuery {
	query := (&BlockContactFormClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockcontactform.Table, blockcontactform.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockContactFormTable, contentblock.BlockContactFormColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockVideoEmbed chains the current query on the "block_video_embed" edge.
func (_q *ContentBlockQuery) QueryBlockVideoEmbed() *BlockVideoEmbedQuery {
	query := (&BlockVideoEmbedClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockvideoembed.Table, blockvideoembed.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockVideoEmbedTable, contentblock.BlockVideoEmbedColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockMap chains the current query on the "block_map" edge.
func (_q *ContentBlockQuery) QueryBlockMap() *BlockMapQuery {
	query := (&BlockMapClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockmap.Table, blockmap.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockMapTable, contentblock.BlockMapColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockAccordion chains the current query on the "block_accordion" edge.
func (_q *ContentBlockQuery) QueryBlockAccordion() *BlockAccordionQuery {
	query := (&BlockAccordionClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockaccordion.Table, blockaccordion.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockAccordionTable, contentblock.BlockAccordionColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockTabs chains the current query on the "block_tabs" edge.
func (_q *ContentBlockQuery) QueryBlockTabs() *BlockTabsQuery {
	query := (&BlockTabsClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blocktabs.Table, blocktabs.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockTabsTable, contentblock.BlockTabsColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBlockDivider chains the current query on the "block_divider" edge.
func (_q *ContentBlockQuery) QueryBlockDivider() *BlockDividerQuery {
	query := (&BlockDividerClient{config: _q.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := _q.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := _q.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, selector),
			sqlgraph.To(blockdivider.Table, blockdivider.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockDividerTable, contentblock.BlockDividerColumn),
		)
		fromU = sqlgraph.SetNeighbors(_q.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first ContentBlock entity from the query.
// Returns a *NotFoundError when no ContentBlock was found.
func (_q *ContentBlockQuery) First(ctx context.Context) (*ContentBlock, error) {
	nodes, err := _q.Limit(1).All(setContextOp(ctx, _q.ctx, ent.OpQueryFirst))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{contentblock.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (_q *ContentBlockQuery) FirstX(ctx context.Context) *ContentBlock {
	node, err := _q.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first ContentBlock ID from the query.
// Returns a *NotFoundError when no ContentBlock ID was found.
func (_q *ContentBlockQuery) FirstID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = _q.Limit(1).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryFirstID)); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{contentblock.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (_q *ContentBlockQuery) FirstIDX(ctx context.Context) int {
	id, err := _q.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single ContentBlock entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one ContentBlock entity is found.
// Returns a *NotFoundError when no ContentBlock entities are found.
func (_q *ContentBlockQuery) Only(ctx context.Context) (*ContentBlock, error) {
	nodes, err := _q.Limit(2).All(setContextOp(ctx, _q.ctx, ent.OpQueryOnly))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{contentblock.Label}
	default:
		return nil, &NotSingularError{contentblock.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (_q *ContentBlockQuery) OnlyX(ctx context.Context) *ContentBlock {
	node, err := _q.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only ContentBlock ID in the query.
// Returns a *NotSingularError when more than one ContentBlock ID is found.
// Returns a *NotFoundError when no entities are found.
func (_q *ContentBlockQuery) OnlyID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = _q.Limit(2).IDs(setContextOp(ctx, _q.ctx, ent.OpQueryOnlyID)); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{contentblock.Label}
	default:
		err = &NotSingularError{contentblock.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (_q *ContentBlockQuery) OnlyIDX(ctx context.Context) int {
	id, err := _q.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of ContentBlocks.
func (_q *ContentBlockQuery) All(ctx context.Context) ([]*ContentBlock, error) {
	ctx = setContextOp(ctx, _q.ctx, ent.OpQueryAll)
	if err := _q.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*ContentBlock, *ContentBlockQuery]()
	return withInterceptors[[]*ContentBlock](ctx, _q, qr, _q.inters)
}

// AllX is like All, but panics if an error occurs.
func (_q *ContentBlockQuery) AllX(ctx context.Context) []*ContentBlock {
	nodes, err := _q.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of ContentBlock IDs.
func (_q *ContentBlockQuery) IDs(ctx context.Context) (ids []int, err error) {
	if _q.ctx.Unique == nil && _q.path != nil {
		_q.Unique(true)
	}
	ctx = setContextOp(ctx, _q.ctx, ent.OpQueryIDs)
	if err = _q.Select(contentblock.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (_q *ContentBlockQuery) IDsX(ctx context.Context) []int {
	ids, err := _q.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (_q *ContentBlockQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, _q.ctx, ent.OpQueryCount)
	if err := _q.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, _q, querierCount[*ContentBlockQuery](), _q.inters)
}

// CountX is like Count, but panics if an error occurs.
func (_q *ContentBlockQuery) CountX(ctx context.Context) int {
	count, err := _q.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (_q *ContentBlockQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, _q.ctx, ent.OpQueryExist)
	switch _, err := _q.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("ent: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (_q *ContentBlockQuery) ExistX(ctx context.Context) bool {
	exist, err := _q.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the ContentBlockQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (_q *ContentBlockQuery) Clone() *ContentBlockQuery {
	if _q == nil {
		return nil
	}
	return &ContentBlockQuery{
		config:                    _q.config,
		ctx:                       _q.ctx.Clone(),
		order:                     append([]contentblock.OrderOption{}, _q.order...),
		inters:                    append([]Interceptor{}, _q.inters...),
		predicates:                append([]predicate.ContentBlock{}, _q.predicates...),
		withPage:                  _q.withPage.Clone(),
		withBlockHero:             _q.withBlockHero.Clone(),
		withBlockTextContent:      _q.withBlockTextContent.Clone(),
		withBlockFaq:              _q.withBlockFaq.Clone(),
		withBlockCta:              _q.withBlockCta.Clone(),
		withBlockTestimonials:     _q.withBlockTestimonials.Clone(),
		withBlockStats:            _q.withBlockStats.Clone(),
		withBlockGallery:          _q.withBlockGallery.Clone(),
		withBlockProgramCards:     _q.withBlockProgramCards.Clone(),
		withBlockSuccessStories:   _q.withBlockSuccessStories.Clone(),
		withBlockDonationForm:     _q.withBlockDonationForm.Clone(),
		withBlockVolunteerSignup:  _q.withBlockVolunteerSignup.Clone(),
		withBlockNewsletterSignup: _q.withBlockNewsletterSignup.Clone(),
		withBlockPartnerLogos:     _q.withBlockPartnerLogos.Clone(),
		withBlockTeamGrid:         _q.withBlockTeamGrid.Clone(),
		withBlockTimeline:         _q.withBlockTimeline.Clone(),
		withBlockContactForm:      _q.withBlockContactForm.Clone(),
		withBlockVideoEmbed:       _q.withBlockVideoEmbed.Clone(),
		withBlockMap:              _q.withBlockMap.Clone(),
		withBlockAccordion:        _q.withBlockAccordion.Clone(),
		withBlockTabs:             _q.withBlockTabs.Clone(),
		withBlockDivider:          _q.withBlockDivider.Clone(),
		// clone intermediate query.
		sql:  _q.sql.Clone(),
		path: _q.path,
	}
}

// WithPage tells the query-builder to eager-load the nodes that are connected to
// the "page" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithPage(opts ...func(*PageQuery)) *ContentBlockQuery {
	query := (&PageClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withPage = query
	return _q
}

// WithBlockHero tells the query-builder to eager-load the nodes that are connected to
// the "block_hero" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockHero(opts ...func(*BlockHeroQuery)) *ContentBlockQuery {
	query := (&BlockHeroClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockHero = query
	return _q
}

// WithBlockTextContent tells the query-builder to eager-load the nodes that are connected to
// the "block_text_content" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockTextContent(opts ...func(*BlockTextContentQuery)) *ContentBlockQuery {
	query := (&BlockTextContentClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockTextContent = query
	return _q
}

// WithBlockFaq tells the query-builder to eager-load the nodes that are connected to
// the "block_faq" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockFaq(opts ...func(*BlockFaqQuery)) *ContentBlockQuery {
	query := (&BlockFaqClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockFaq = query
	return _q
}

// WithBlockCta tells the query-builder to eager-load the nodes that are connected to
// the "block_cta" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockCta(opts ...func(*BlockCtaQuery)) *ContentBlockQuery {
	query := (&BlockCtaClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockCta = query
	return _q
}

// WithBlockTestimonials tells the query-builder to eager-load the nodes that are connected to
// the "block_testimonials" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockTestimonials(opts ...func(*BlockTestimonialsQuery)) *ContentBlockQuery {
	query := (&BlockTestimonialsClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockTestimonials = query
	return _q
}

// WithBlockStats tells the query-builder to eager-load the nodes that are connected to
// the "block_stats" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockStats(opts ...func(*BlockStatsQuery)) *ContentBlockQuery {
	query := (&BlockStatsClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockStats = query
	return _q
}

// WithBlockGallery tells the query-builder to eager-load the nodes that are connected to
// the "block_gallery" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockGallery(opts ...func(*BlockGalleryQuery)) *ContentBlockQuery {
	query := (&BlockGalleryClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockGallery = query
	return _q
}

// WithBlockProgramCards tells the query-builder to eager-load the nodes that are connected to
// the "block_program_cards" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockProgramCards(opts ...func(*BlockProgramCardsQuery)) *ContentBlockQuery {
	query := (&BlockProgramCardsClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockProgramCards = query
	return _q
}

// WithBlockSuccessStories tells the query-builder to eager-load the nodes that are connected to
// the "block_success_stories" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockSuccessStories(opts ...func(*BlockSuccessStoriesQuery)) *ContentBlockQuery {
	query := (&BlockSuccessStoriesClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockSuccessStories = query
	return _q
}

// WithBlockDonationForm tells the query-builder to eager-load the nodes that are connected to
// the "block_donation_form" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockDonationForm(opts ...func(*BlockDonationFormQuery)) *ContentBlockQuery {
	query := (&BlockDonationFormClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockDonationForm = query
	return _q
}

// WithBlockVolunteerSignup tells the query-builder to eager-load the nodes that are connected to
// the "block_volunteer_signup" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockVolunteerSignup(opts ...func(*BlockVolunteerSignupQuery)) *ContentBlockQuery {
	query := (&BlockVolunteerSignupClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockVolunteerSignup = query
	return _q
}

// WithBlockNewsletterSignup tells the query-builder to eager-load the nodes that are connected to
// the "block_newsletter_signup" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockNewsletterSignup(opts ...func(*BlockNewsletterSignupQuery)) *ContentBlockQuery {
	query := (&BlockNewsletterSignupClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockNewsletterSignup = query
	return _q
}

// WithBlockPartnerLogos tells the query-builder to eager-load the nodes that are connected to
// the "block_partner_logos" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockPartnerLogos(opts ...func(*BlockPartnerLogosQuery)) *ContentBlockQuery {
	query := (&BlockPartnerLogosClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockPartnerLogos = query
	return _q
}

// WithBlockTeamGrid tells the query-builder to eager-load the nodes that are connected to
// the "block_team_grid" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockTeamGrid(opts ...func(*BlockTeamGridQuery)) *ContentBlockQuery {
	query := (&BlockTeamGridClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockTeamGrid = query
	return _q
}

// WithBlockTimeline tells the query-builder to eager-load the nodes that are connected to
// the "block_timeline" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockTimeline(opts ...func(*BlockTimelineQuery)) *ContentBlockQuery {
	query := (&BlockTimelineClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockTimeline = query
	return _q
}

// WithBlockContactForm tells the query-builder to eager-load the nodes that are connected to
// the "block_contact_form" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockContactForm(opts ...func(*BlockContactFormQuery)) *ContentBlockQuery {
	query := (&BlockContactFormClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockContactForm = query
	return _q
}

// WithBlockVideoEmbed tells the query-builder to eager-load the nodes that are connected to
// the "block_video_embed" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockVideoEmbed(opts ...func(*BlockVideoEmbedQuery)) *ContentBlockQuery {
	query := (&BlockVideoEmbedClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockVideoEmbed = query
	return _q
}

// WithBlockMap tells the query-builder to eager-load the nodes that are connected to
// the "block_map" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockMap(opts ...func(*BlockMapQuery)) *ContentBlockQuery {
	query := (&BlockMapClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockMap = query
	return _q
}

// WithBlockAccordion tells the query-builder to eager-load the nodes that are connected to
// the "block_accordion" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockAccordion(opts ...func(*BlockAccordionQuery)) *ContentBlockQuery {
	query := (&BlockAccordionClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockAccordion = query
	return _q
}

// WithBlockTabs tells the query-builder to eager-load the nodes that are connected to
// the "block_tabs" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockTabs(opts ...func(*BlockTabsQuery)) *ContentBlockQuery {
	query := (&BlockTabsClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockTabs = query
	return _q
}

// WithBlockDivider tells the query-builder to eager-load the nodes that are connected to
// the "block_divider" edge. The optional arguments are used to configure the query builder of the edge.
func (_q *ContentBlockQuery) WithBlockDivider(opts ...func(*BlockDividerQuery)) *ContentBlockQuery {
	query := (&BlockDividerClient{config: _q.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	_q.withBlockDivider = query
	return _q
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		Order int `json:"order,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.ContentBlock.Query().
//		GroupBy(contentblock.FieldOrder).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
func (_q *ContentBlockQuery) GroupBy(field string, fields ...string) *ContentBlockGroupBy {
	_q.ctx.Fields = append([]string{field}, fields...)
	grbuild := &ContentBlockGroupBy{build: _q}
	grbuild.flds = &_q.ctx.Fields
	grbuild.label = contentblock.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		Order int `json:"order,omitempty"`
//	}
//
//	client.ContentBlock.Query().
//		Select(contentblock.FieldOrder).
//		Scan(ctx, &v)
func (_q *ContentBlockQuery) Select(fields ...string) *ContentBlockSelect {
	_q.ctx.Fields = append(_q.ctx.Fields, fields...)
	sbuild := &ContentBlockSelect{ContentBlockQuery: _q}
	sbuild.label = contentblock.Label
	sbuild.flds, sbuild.scan = &_q.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a ContentBlockSelect configured with the given aggregations.
func (_q *ContentBlockQuery) Aggregate(fns ...AggregateFunc) *ContentBlockSelect {
	return _q.Select().Aggregate(fns...)
}

func (_q *ContentBlockQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range _q.inters {
		if inter == nil {
			return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, _q); err != nil {
				return err
			}
		}
	}
	for _, f := range _q.ctx.Fields {
		if !contentblock.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if _q.path != nil {
		prev, err := _q.path(ctx)
		if err != nil {
			return err
		}
		_q.sql = prev
	}
	return nil
}

func (_q *ContentBlockQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*ContentBlock, error) {
	var (
		nodes       = []*ContentBlock{}
		withFKs     = _q.withFKs
		_spec       = _q.querySpec()
		loadedTypes = [22]bool{
			_q.withPage != nil,
			_q.withBlockHero != nil,
			_q.withBlockTextContent != nil,
			_q.withBlockFaq != nil,
			_q.withBlockCta != nil,
			_q.withBlockTestimonials != nil,
			_q.withBlockStats != nil,
			_q.withBlockGallery != nil,
			_q.withBlockProgramCards != nil,
			_q.withBlockSuccessStories != nil,
			_q.withBlockDonationForm != nil,
			_q.withBlockVolunteerSignup != nil,
			_q.withBlockNewsletterSignup != nil,
			_q.withBlockPartnerLogos != nil,
			_q.withBlockTeamGrid != nil,
			_q.withBlockTimeline != nil,
			_q.withBlockContactForm != nil,
			_q.withBlockVideoEmbed != nil,
			_q.withBlockMap != nil,
			_q.withBlockAccordion != nil,
			_q.withBlockTabs != nil,
			_q.withBlockDivider != nil,
		}
	)
	if _q.withPage != nil {
		withFKs = true
	}
	if withFKs {
		_spec.Node.Columns = append(_spec.Node.Columns, contentblock.ForeignKeys...)
	}
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*ContentBlock).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &ContentBlock{config: _q.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, _q.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := _q.withPage; query != nil {
		if err := _q.loadPage(ctx, query, nodes, nil,
			func(n *ContentBlock, e *Page) { n.Edges.Page = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockHero; query != nil {
		if err := _q.loadBlockHero(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockHero) { n.Edges.BlockHero = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockTextContent; query != nil {
		if err := _q.loadBlockTextContent(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockTextContent) { n.Edges.BlockTextContent = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockFaq; query != nil {
		if err := _q.loadBlockFaq(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockFaq) { n.Edges.BlockFaq = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockCta; query != nil {
		if err := _q.loadBlockCta(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockCta) { n.Edges.BlockCta = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockTestimonials; query != nil {
		if err := _q.loadBlockTestimonials(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockTestimonials) { n.Edges.BlockTestimonials = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockStats; query != nil {
		if err := _q.loadBlockStats(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockStats) { n.Edges.BlockStats = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockGallery; query != nil {
		if err := _q.loadBlockGallery(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockGallery) { n.Edges.BlockGallery = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockProgramCards; query != nil {
		if err := _q.loadBlockProgramCards(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockProgramCards) { n.Edges.BlockProgramCards = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockSuccessStories; query != nil {
		if err := _q.loadBlockSuccessStories(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockSuccessStories) { n.Edges.BlockSuccessStories = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockDonationForm; query != nil {
		if err := _q.loadBlockDonationForm(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockDonationForm) { n.Edges.BlockDonationForm = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockVolunteerSignup; query != nil {
		if err := _q.loadBlockVolunteerSignup(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockVolunteerSignup) { n.Edges.BlockVolunteerSignup = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockNewsletterSignup; query != nil {
		if err := _q.loadBlockNewsletterSignup(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockNewsletterSignup) { n.Edges.BlockNewsletterSignup = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockPartnerLogos; query != nil {
		if err := _q.loadBlockPartnerLogos(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockPartnerLogos) { n.Edges.BlockPartnerLogos = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockTeamGrid; query != nil {
		if err := _q.loadBlockTeamGrid(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockTeamGrid) { n.Edges.BlockTeamGrid = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockTimeline; query != nil {
		if err := _q.loadBlockTimeline(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockTimeline) { n.Edges.BlockTimeline = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockContactForm; query != nil {
		if err := _q.loadBlockContactForm(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockContactForm) { n.Edges.BlockContactForm = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockVideoEmbed; query != nil {
		if err := _q.loadBlockVideoEmbed(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockVideoEmbed) { n.Edges.BlockVideoEmbed = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockMap; query != nil {
		if err := _q.loadBlockMap(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockMap) { n.Edges.BlockMap = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockAccordion; query != nil {
		if err := _q.loadBlockAccordion(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockAccordion) { n.Edges.BlockAccordion = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockTabs; query != nil {
		if err := _q.loadBlockTabs(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockTabs) { n.Edges.BlockTabs = e }); err != nil {
			return nil, err
		}
	}
	if query := _q.withBlockDivider; query != nil {
		if err := _q.loadBlockDivider(ctx, query, nodes, nil,
			func(n *ContentBlock, e *BlockDivider) { n.Edges.BlockDivider = e }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (_q *ContentBlockQuery) loadPage(ctx context.Context, query *PageQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *Page)) error {
	ids := make([]int, 0, len(nodes))
	nodeids := make(map[int][]*ContentBlock)
	for i := range nodes {
		if nodes[i].page_blocks == nil {
			continue
		}
		fk := *nodes[i].page_blocks
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(page.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "page_blocks" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockHero(ctx context.Context, query *BlockHeroQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockHero)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockHero(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockHeroColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_hero
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_hero" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_hero" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockTextContent(ctx context.Context, query *BlockTextContentQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockTextContent)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockTextContent(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockTextContentColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_text_content
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_text_content" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_text_content" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockFaq(ctx context.Context, query *BlockFaqQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockFaq)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockFaq(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockFaqColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_faq
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_faq" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_faq" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockCta(ctx context.Context, query *BlockCtaQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockCta)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockCta(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockCtaColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_cta
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_cta" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_cta" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockTestimonials(ctx context.Context, query *BlockTestimonialsQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockTestimonials)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockTestimonials(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockTestimonialsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_testimonials
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_testimonials" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_testimonials" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockStats(ctx context.Context, query *BlockStatsQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockStats)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockStats(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockStatsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_stats
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_stats" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_stats" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockGallery(ctx context.Context, query *BlockGalleryQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockGallery)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockGallery(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockGalleryColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_gallery
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_gallery" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_gallery" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockProgramCards(ctx context.Context, query *BlockProgramCardsQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockProgramCards)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockProgramCards(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockProgramCardsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_program_cards
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_program_cards" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_program_cards" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockSuccessStories(ctx context.Context, query *BlockSuccessStoriesQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockSuccessStories)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockSuccessStories(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockSuccessStoriesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_success_stories
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_success_stories" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_success_stories" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockDonationForm(ctx context.Context, query *BlockDonationFormQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockDonationForm)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockDonationForm(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockDonationFormColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_donation_form
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_donation_form" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_donation_form" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockVolunteerSignup(ctx context.Context, query *BlockVolunteerSignupQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockVolunteerSignup)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockVolunteerSignup(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockVolunteerSignupColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_volunteer_signup
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_volunteer_signup" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_volunteer_signup" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockNewsletterSignup(ctx context.Context, query *BlockNewsletterSignupQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockNewsletterSignup)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockNewsletterSignup(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockNewsletterSignupColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_newsletter_signup
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_newsletter_signup" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_newsletter_signup" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockPartnerLogos(ctx context.Context, query *BlockPartnerLogosQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockPartnerLogos)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockPartnerLogos(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockPartnerLogosColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_partner_logos
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_partner_logos" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_partner_logos" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockTeamGrid(ctx context.Context, query *BlockTeamGridQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockTeamGrid)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockTeamGrid(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockTeamGridColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_team_grid
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_team_grid" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_team_grid" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockTimeline(ctx context.Context, query *BlockTimelineQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockTimeline)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockTimeline(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockTimelineColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_timeline
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_timeline" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_timeline" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockContactForm(ctx context.Context, query *BlockContactFormQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockContactForm)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockContactForm(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockContactFormColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_contact_form
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_contact_form" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_contact_form" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockVideoEmbed(ctx context.Context, query *BlockVideoEmbedQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockVideoEmbed)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockVideoEmbed(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockVideoEmbedColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_video_embed
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_video_embed" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_video_embed" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockMap(ctx context.Context, query *BlockMapQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockMap)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockMap(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockMapColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_map
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_map" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_map" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockAccordion(ctx context.Context, query *BlockAccordionQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockAccordion)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockAccordion(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockAccordionColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_accordion
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_accordion" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_accordion" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockTabs(ctx context.Context, query *BlockTabsQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockTabs)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockTabs(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockTabsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_tabs
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_tabs" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_tabs" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (_q *ContentBlockQuery) loadBlockDivider(ctx context.Context, query *BlockDividerQuery, nodes []*ContentBlock, init func(*ContentBlock), assign func(*ContentBlock, *BlockDivider)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[int]*ContentBlock)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.BlockDivider(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(contentblock.BlockDividerColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.content_block_block_divider
		if fk == nil {
			return fmt.Errorf(`foreign-key "content_block_block_divider" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "content_block_block_divider" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}

func (_q *ContentBlockQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := _q.querySpec()
	_spec.Node.Columns = _q.ctx.Fields
	if len(_q.ctx.Fields) > 0 {
		_spec.Unique = _q.ctx.Unique != nil && *_q.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, _q.driver, _spec)
}

func (_q *ContentBlockQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(contentblock.Table, contentblock.Columns, sqlgraph.NewFieldSpec(contentblock.FieldID, field.TypeInt))
	_spec.From = _q.sql
	if unique := _q.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if _q.path != nil {
		_spec.Unique = true
	}
	if fields := _q.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, contentblock.FieldID)
		for i := range fields {
			if fields[i] != contentblock.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := _q.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := _q.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := _q.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := _q.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (_q *ContentBlockQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(_q.driver.Dialect())
	t1 := builder.Table(contentblock.Table)
	columns := _q.ctx.Fields
	if len(columns) == 0 {
		columns = contentblock.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if _q.sql != nil {
		selector = _q.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if _q.ctx.Unique != nil && *_q.ctx.Unique {
		selector.Distinct()
	}
	for _, p := range _q.predicates {
		p(selector)
	}
	for _, p := range _q.order {
		p(selector)
	}
	if offset := _q.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := _q.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// ContentBlockGroupBy is the group-by builder for ContentBlock entities.
type ContentBlockGroupBy struct {
	selector
	build *ContentBlockQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (_g *ContentBlockGroupBy) Aggregate(fns ...AggregateFunc) *ContentBlockGroupBy {
	_g.fns = append(_g.fns, fns...)
	return _g
}

// Scan applies the selector query and scans the result into the given value.
func (_g *ContentBlockGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, _g.build.ctx, ent.OpQueryGroupBy)
	if err := _g.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*ContentBlockQuery, *ContentBlockGroupBy](ctx, _g.build, _g, _g.build.inters, v)
}

func (_g *ContentBlockGroupBy) sqlScan(ctx context.Context, root *ContentBlockQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(_g.fns))
	for _, fn := range _g.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*_g.flds)+len(_g.fns))
		for _, f := range *_g.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*_g.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := _g.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// ContentBlockSelect is the builder for selecting fields of ContentBlock entities.
type ContentBlockSelect struct {
	*ContentBlockQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (_s *ContentBlockSelect) Aggregate(fns ...AggregateFunc) *ContentBlockSelect {
	_s.fns = append(_s.fns, fns...)
	return _s
}

// Scan applies the selector query and scans the result into the given value.
func (_s *ContentBlockSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, _s.ctx, ent.OpQuerySelect)
	if err := _s.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*ContentBlockQuery, *ContentBlockSelect](ctx, _s.ContentBlockQuery, _s, _s.inters, v)
}

func (_s *ContentBlockSelect) sqlScan(ctx context.Context, root *ContentBlockQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(_s.fns))
	for _, fn := range _s.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*_s.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := _s.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}
