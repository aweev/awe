// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"awe/ent/ent/migrate"

	"awe/ent/ent/accordionitem"
	"awe/ent/ent/actionitem"
	"awe/ent/ent/activitylog"
	"awe/ent/ent/address"
	"awe/ent/ent/agenda"
	"awe/ent/ent/agendaitem"
	"awe/ent/ent/analyticsdashboard"
	"awe/ent/ent/analyticsevent"
	"awe/ent/ent/appsetting"
	"awe/ent/ent/auditlog"
	"awe/ent/ent/badge"
	"awe/ent/ent/ballot"
	"awe/ent/ent/blockaccordion"
	"awe/ent/ent/blockcontactform"
	"awe/ent/ent/blockcta"
	"awe/ent/ent/blockdivider"
	"awe/ent/ent/blockdonationform"
	"awe/ent/ent/blockfaq"
	"awe/ent/ent/blockgallery"
	"awe/ent/ent/blockhero"
	"awe/ent/ent/blockmap"
	"awe/ent/ent/blocknewslettersignup"
	"awe/ent/ent/blockpartnerlogos"
	"awe/ent/ent/blockprogramcards"
	"awe/ent/ent/blockstats"
	"awe/ent/ent/blocksuccessstories"
	"awe/ent/ent/blocktabs"
	"awe/ent/ent/blockteamgrid"
	"awe/ent/ent/blocktestimonials"
	"awe/ent/ent/blocktextcontent"
	"awe/ent/ent/blocktimeline"
	"awe/ent/ent/blockvideoembed"
	"awe/ent/ent/blockvolunteersignup"
	"awe/ent/ent/brandbenefit"
	"awe/ent/ent/brandconfig"
	"awe/ent/ent/contentblock"
	"awe/ent/ent/conversation"
	"awe/ent/ent/conversationparticipant"
	"awe/ent/ent/dashboardwidget"
	"awe/ent/ent/document"
	"awe/ent/ent/documentcategory"
	"awe/ent/ent/donation"
	"awe/ent/ent/event"
	"awe/ent/ent/eventregistration"
	"awe/ent/ent/faqitem"
	"awe/ent/ent/featureflag"
	"awe/ent/ent/fundraisingcampaign"
	"awe/ent/ent/galleryimage"
	"awe/ent/ent/generatedreport"
	"awe/ent/ent/grant"
	"awe/ent/ent/grantreport"
	"awe/ent/ent/impactdatapoint"
	"awe/ent/ent/impactmetric"
	"awe/ent/ent/job"
	"awe/ent/ent/joblog"
	"awe/ent/ent/mentorshiprequest"
	"awe/ent/ent/mentorshipsession"
	"awe/ent/ent/message"
	"awe/ent/ent/newsarticle"
	"awe/ent/ent/organization"
	"awe/ent/ent/page"
	"awe/ent/ent/partnerlogoitem"
	"awe/ent/ent/partnership"
	"awe/ent/ent/partnershipinteraction"
	"awe/ent/ent/partnershiprenewal"
	"awe/ent/ent/partnershipreport"
	"awe/ent/ent/passwordhistory"
	"awe/ent/ent/permission"
	"awe/ent/ent/program"
	"awe/ent/ent/programcarditem"
	"awe/ent/ent/programcategory"
	"awe/ent/ent/programenrolment"
	"awe/ent/ent/programparticipant"
	"awe/ent/ent/reportdefinition"
	"awe/ent/ent/reportpermission"
	"awe/ent/ent/rolepermission"
	"awe/ent/ent/scheduledreport"
	"awe/ent/ent/seoconfig"
	"awe/ent/ent/sitevisit"
	"awe/ent/ent/skill"
	"awe/ent/ent/statitem"
	"awe/ent/ent/successstory"
	"awe/ent/ent/systemerror"
	"awe/ent/ent/systemlog"
	"awe/ent/ent/tabitem"
	"awe/ent/ent/teammember"
	"awe/ent/ent/teammemberitem"
	"awe/ent/ent/testimonialitem"
	"awe/ent/ent/timelineevent"
	"awe/ent/ent/token"
	"awe/ent/ent/trusteddevice"
	"awe/ent/ent/user"
	"awe/ent/ent/userachievement"
	"awe/ent/ent/userconsent"
	"awe/ent/ent/useronboarding"
	"awe/ent/ent/userprofile"
	"awe/ent/ent/usersession"
	"awe/ent/ent/userskill"
	"awe/ent/ent/volunteerapplication"
	"awe/ent/ent/volunteerassignment"
	"awe/ent/ent/volunteeropportunity"
	"awe/ent/ent/vote"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AccordionItem is the client for interacting with the AccordionItem builders.
	AccordionItem *AccordionItemClient
	// ActionItem is the client for interacting with the ActionItem builders.
	ActionItem *ActionItemClient
	// ActivityLog is the client for interacting with the ActivityLog builders.
	ActivityLog *ActivityLogClient
	// Address is the client for interacting with the Address builders.
	Address *AddressClient
	// Agenda is the client for interacting with the Agenda builders.
	Agenda *AgendaClient
	// AgendaItem is the client for interacting with the AgendaItem builders.
	AgendaItem *AgendaItemClient
	// AnalyticsDashboard is the client for interacting with the AnalyticsDashboard builders.
	AnalyticsDashboard *AnalyticsDashboardClient
	// AnalyticsEvent is the client for interacting with the AnalyticsEvent builders.
	AnalyticsEvent *AnalyticsEventClient
	// AppSetting is the client for interacting with the AppSetting builders.
	AppSetting *AppSettingClient
	// AuditLog is the client for interacting with the AuditLog builders.
	AuditLog *AuditLogClient
	// Badge is the client for interacting with the Badge builders.
	Badge *BadgeClient
	// Ballot is the client for interacting with the Ballot builders.
	Ballot *BallotClient
	// BlockAccordion is the client for interacting with the BlockAccordion builders.
	BlockAccordion *BlockAccordionClient
	// BlockContactForm is the client for interacting with the BlockContactForm builders.
	BlockContactForm *BlockContactFormClient
	// BlockCta is the client for interacting with the BlockCta builders.
	BlockCta *BlockCtaClient
	// BlockDivider is the client for interacting with the BlockDivider builders.
	BlockDivider *BlockDividerClient
	// BlockDonationForm is the client for interacting with the BlockDonationForm builders.
	BlockDonationForm *BlockDonationFormClient
	// BlockFaq is the client for interacting with the BlockFaq builders.
	BlockFaq *BlockFaqClient
	// BlockGallery is the client for interacting with the BlockGallery builders.
	BlockGallery *BlockGalleryClient
	// BlockHero is the client for interacting with the BlockHero builders.
	BlockHero *BlockHeroClient
	// BlockMap is the client for interacting with the BlockMap builders.
	BlockMap *BlockMapClient
	// BlockNewsletterSignup is the client for interacting with the BlockNewsletterSignup builders.
	BlockNewsletterSignup *BlockNewsletterSignupClient
	// BlockPartnerLogos is the client for interacting with the BlockPartnerLogos builders.
	BlockPartnerLogos *BlockPartnerLogosClient
	// BlockProgramCards is the client for interacting with the BlockProgramCards builders.
	BlockProgramCards *BlockProgramCardsClient
	// BlockStats is the client for interacting with the BlockStats builders.
	BlockStats *BlockStatsClient
	// BlockSuccessStories is the client for interacting with the BlockSuccessStories builders.
	BlockSuccessStories *BlockSuccessStoriesClient
	// BlockTabs is the client for interacting with the BlockTabs builders.
	BlockTabs *BlockTabsClient
	// BlockTeamGrid is the client for interacting with the BlockTeamGrid builders.
	BlockTeamGrid *BlockTeamGridClient
	// BlockTestimonials is the client for interacting with the BlockTestimonials builders.
	BlockTestimonials *BlockTestimonialsClient
	// BlockTextContent is the client for interacting with the BlockTextContent builders.
	BlockTextContent *BlockTextContentClient
	// BlockTimeline is the client for interacting with the BlockTimeline builders.
	BlockTimeline *BlockTimelineClient
	// BlockVideoEmbed is the client for interacting with the BlockVideoEmbed builders.
	BlockVideoEmbed *BlockVideoEmbedClient
	// BlockVolunteerSignup is the client for interacting with the BlockVolunteerSignup builders.
	BlockVolunteerSignup *BlockVolunteerSignupClient
	// BrandBenefit is the client for interacting with the BrandBenefit builders.
	BrandBenefit *BrandBenefitClient
	// BrandConfig is the client for interacting with the BrandConfig builders.
	BrandConfig *BrandConfigClient
	// ContentBlock is the client for interacting with the ContentBlock builders.
	ContentBlock *ContentBlockClient
	// Conversation is the client for interacting with the Conversation builders.
	Conversation *ConversationClient
	// ConversationParticipant is the client for interacting with the ConversationParticipant builders.
	ConversationParticipant *ConversationParticipantClient
	// DashboardWidget is the client for interacting with the DashboardWidget builders.
	DashboardWidget *DashboardWidgetClient
	// Document is the client for interacting with the Document builders.
	Document *DocumentClient
	// DocumentCategory is the client for interacting with the DocumentCategory builders.
	DocumentCategory *DocumentCategoryClient
	// Donation is the client for interacting with the Donation builders.
	Donation *DonationClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// EventRegistration is the client for interacting with the EventRegistration builders.
	EventRegistration *EventRegistrationClient
	// FaqItem is the client for interacting with the FaqItem builders.
	FaqItem *FaqItemClient
	// FeatureFlag is the client for interacting with the FeatureFlag builders.
	FeatureFlag *FeatureFlagClient
	// FundraisingCampaign is the client for interacting with the FundraisingCampaign builders.
	FundraisingCampaign *FundraisingCampaignClient
	// GalleryImage is the client for interacting with the GalleryImage builders.
	GalleryImage *GalleryImageClient
	// GeneratedReport is the client for interacting with the GeneratedReport builders.
	GeneratedReport *GeneratedReportClient
	// Grant is the client for interacting with the Grant builders.
	Grant *GrantClient
	// GrantReport is the client for interacting with the GrantReport builders.
	GrantReport *GrantReportClient
	// ImpactDataPoint is the client for interacting with the ImpactDataPoint builders.
	ImpactDataPoint *ImpactDataPointClient
	// ImpactMetric is the client for interacting with the ImpactMetric builders.
	ImpactMetric *ImpactMetricClient
	// Job is the client for interacting with the Job builders.
	Job *JobClient
	// JobLog is the client for interacting with the JobLog builders.
	JobLog *JobLogClient
	// MentorshipRequest is the client for interacting with the MentorshipRequest builders.
	MentorshipRequest *MentorshipRequestClient
	// MentorshipSession is the client for interacting with the MentorshipSession builders.
	MentorshipSession *MentorshipSessionClient
	// Message is the client for interacting with the Message builders.
	Message *MessageClient
	// NewsArticle is the client for interacting with the NewsArticle builders.
	NewsArticle *NewsArticleClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// Page is the client for interacting with the Page builders.
	Page *PageClient
	// PartnerLogoItem is the client for interacting with the PartnerLogoItem builders.
	PartnerLogoItem *PartnerLogoItemClient
	// Partnership is the client for interacting with the Partnership builders.
	Partnership *PartnershipClient
	// PartnershipInteraction is the client for interacting with the PartnershipInteraction builders.
	PartnershipInteraction *PartnershipInteractionClient
	// PartnershipRenewal is the client for interacting with the PartnershipRenewal builders.
	PartnershipRenewal *PartnershipRenewalClient
	// PartnershipReport is the client for interacting with the PartnershipReport builders.
	PartnershipReport *PartnershipReportClient
	// PasswordHistory is the client for interacting with the PasswordHistory builders.
	PasswordHistory *PasswordHistoryClient
	// Permission is the client for interacting with the Permission builders.
	Permission *PermissionClient
	// Program is the client for interacting with the Program builders.
	Program *ProgramClient
	// ProgramCardItem is the client for interacting with the ProgramCardItem builders.
	ProgramCardItem *ProgramCardItemClient
	// ProgramCategory is the client for interacting with the ProgramCategory builders.
	ProgramCategory *ProgramCategoryClient
	// ProgramEnrolment is the client for interacting with the ProgramEnrolment builders.
	ProgramEnrolment *ProgramEnrolmentClient
	// ProgramParticipant is the client for interacting with the ProgramParticipant builders.
	ProgramParticipant *ProgramParticipantClient
	// ReportDefinition is the client for interacting with the ReportDefinition builders.
	ReportDefinition *ReportDefinitionClient
	// ReportPermission is the client for interacting with the ReportPermission builders.
	ReportPermission *ReportPermissionClient
	// RolePermission is the client for interacting with the RolePermission builders.
	RolePermission *RolePermissionClient
	// ScheduledReport is the client for interacting with the ScheduledReport builders.
	ScheduledReport *ScheduledReportClient
	// SeoConfig is the client for interacting with the SeoConfig builders.
	SeoConfig *SeoConfigClient
	// SiteVisit is the client for interacting with the SiteVisit builders.
	SiteVisit *SiteVisitClient
	// Skill is the client for interacting with the Skill builders.
	Skill *SkillClient
	// StatItem is the client for interacting with the StatItem builders.
	StatItem *StatItemClient
	// SuccessStory is the client for interacting with the SuccessStory builders.
	SuccessStory *SuccessStoryClient
	// SystemError is the client for interacting with the SystemError builders.
	SystemError *SystemErrorClient
	// SystemLog is the client for interacting with the SystemLog builders.
	SystemLog *SystemLogClient
	// TabItem is the client for interacting with the TabItem builders.
	TabItem *TabItemClient
	// TeamMember is the client for interacting with the TeamMember builders.
	TeamMember *TeamMemberClient
	// TeamMemberItem is the client for interacting with the TeamMemberItem builders.
	TeamMemberItem *TeamMemberItemClient
	// TestimonialItem is the client for interacting with the TestimonialItem builders.
	TestimonialItem *TestimonialItemClient
	// TimelineEvent is the client for interacting with the TimelineEvent builders.
	TimelineEvent *TimelineEventClient
	// Token is the client for interacting with the Token builders.
	Token *TokenClient
	// TrustedDevice is the client for interacting with the TrustedDevice builders.
	TrustedDevice *TrustedDeviceClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserAchievement is the client for interacting with the UserAchievement builders.
	UserAchievement *UserAchievementClient
	// UserConsent is the client for interacting with the UserConsent builders.
	UserConsent *UserConsentClient
	// UserOnboarding is the client for interacting with the UserOnboarding builders.
	UserOnboarding *UserOnboardingClient
	// UserProfile is the client for interacting with the UserProfile builders.
	UserProfile *UserProfileClient
	// UserSession is the client for interacting with the UserSession builders.
	UserSession *UserSessionClient
	// UserSkill is the client for interacting with the UserSkill builders.
	UserSkill *UserSkillClient
	// VolunteerApplication is the client for interacting with the VolunteerApplication builders.
	VolunteerApplication *VolunteerApplicationClient
	// VolunteerAssignment is the client for interacting with the VolunteerAssignment builders.
	VolunteerAssignment *VolunteerAssignmentClient
	// VolunteerOpportunity is the client for interacting with the VolunteerOpportunity builders.
	VolunteerOpportunity *VolunteerOpportunityClient
	// Vote is the client for interacting with the Vote builders.
	Vote *VoteClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AccordionItem = NewAccordionItemClient(c.config)
	c.ActionItem = NewActionItemClient(c.config)
	c.ActivityLog = NewActivityLogClient(c.config)
	c.Address = NewAddressClient(c.config)
	c.Agenda = NewAgendaClient(c.config)
	c.AgendaItem = NewAgendaItemClient(c.config)
	c.AnalyticsDashboard = NewAnalyticsDashboardClient(c.config)
	c.AnalyticsEvent = NewAnalyticsEventClient(c.config)
	c.AppSetting = NewAppSettingClient(c.config)
	c.AuditLog = NewAuditLogClient(c.config)
	c.Badge = NewBadgeClient(c.config)
	c.Ballot = NewBallotClient(c.config)
	c.BlockAccordion = NewBlockAccordionClient(c.config)
	c.BlockContactForm = NewBlockContactFormClient(c.config)
	c.BlockCta = NewBlockCtaClient(c.config)
	c.BlockDivider = NewBlockDividerClient(c.config)
	c.BlockDonationForm = NewBlockDonationFormClient(c.config)
	c.BlockFaq = NewBlockFaqClient(c.config)
	c.BlockGallery = NewBlockGalleryClient(c.config)
	c.BlockHero = NewBlockHeroClient(c.config)
	c.BlockMap = NewBlockMapClient(c.config)
	c.BlockNewsletterSignup = NewBlockNewsletterSignupClient(c.config)
	c.BlockPartnerLogos = NewBlockPartnerLogosClient(c.config)
	c.BlockProgramCards = NewBlockProgramCardsClient(c.config)
	c.BlockStats = NewBlockStatsClient(c.config)
	c.BlockSuccessStories = NewBlockSuccessStoriesClient(c.config)
	c.BlockTabs = NewBlockTabsClient(c.config)
	c.BlockTeamGrid = NewBlockTeamGridClient(c.config)
	c.BlockTestimonials = NewBlockTestimonialsClient(c.config)
	c.BlockTextContent = NewBlockTextContentClient(c.config)
	c.BlockTimeline = NewBlockTimelineClient(c.config)
	c.BlockVideoEmbed = NewBlockVideoEmbedClient(c.config)
	c.BlockVolunteerSignup = NewBlockVolunteerSignupClient(c.config)
	c.BrandBenefit = NewBrandBenefitClient(c.config)
	c.BrandConfig = NewBrandConfigClient(c.config)
	c.ContentBlock = NewContentBlockClient(c.config)
	c.Conversation = NewConversationClient(c.config)
	c.ConversationParticipant = NewConversationParticipantClient(c.config)
	c.DashboardWidget = NewDashboardWidgetClient(c.config)
	c.Document = NewDocumentClient(c.config)
	c.DocumentCategory = NewDocumentCategoryClient(c.config)
	c.Donation = NewDonationClient(c.config)
	c.Event = NewEventClient(c.config)
	c.EventRegistration = NewEventRegistrationClient(c.config)
	c.FaqItem = NewFaqItemClient(c.config)
	c.FeatureFlag = NewFeatureFlagClient(c.config)
	c.FundraisingCampaign = NewFundraisingCampaignClient(c.config)
	c.GalleryImage = NewGalleryImageClient(c.config)
	c.GeneratedReport = NewGeneratedReportClient(c.config)
	c.Grant = NewGrantClient(c.config)
	c.GrantReport = NewGrantReportClient(c.config)
	c.ImpactDataPoint = NewImpactDataPointClient(c.config)
	c.ImpactMetric = NewImpactMetricClient(c.config)
	c.Job = NewJobClient(c.config)
	c.JobLog = NewJobLogClient(c.config)
	c.MentorshipRequest = NewMentorshipRequestClient(c.config)
	c.MentorshipSession = NewMentorshipSessionClient(c.config)
	c.Message = NewMessageClient(c.config)
	c.NewsArticle = NewNewsArticleClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.Page = NewPageClient(c.config)
	c.PartnerLogoItem = NewPartnerLogoItemClient(c.config)
	c.Partnership = NewPartnershipClient(c.config)
	c.PartnershipInteraction = NewPartnershipInteractionClient(c.config)
	c.PartnershipRenewal = NewPartnershipRenewalClient(c.config)
	c.PartnershipReport = NewPartnershipReportClient(c.config)
	c.PasswordHistory = NewPasswordHistoryClient(c.config)
	c.Permission = NewPermissionClient(c.config)
	c.Program = NewProgramClient(c.config)
	c.ProgramCardItem = NewProgramCardItemClient(c.config)
	c.ProgramCategory = NewProgramCategoryClient(c.config)
	c.ProgramEnrolment = NewProgramEnrolmentClient(c.config)
	c.ProgramParticipant = NewProgramParticipantClient(c.config)
	c.ReportDefinition = NewReportDefinitionClient(c.config)
	c.ReportPermission = NewReportPermissionClient(c.config)
	c.RolePermission = NewRolePermissionClient(c.config)
	c.ScheduledReport = NewScheduledReportClient(c.config)
	c.SeoConfig = NewSeoConfigClient(c.config)
	c.SiteVisit = NewSiteVisitClient(c.config)
	c.Skill = NewSkillClient(c.config)
	c.StatItem = NewStatItemClient(c.config)
	c.SuccessStory = NewSuccessStoryClient(c.config)
	c.SystemError = NewSystemErrorClient(c.config)
	c.SystemLog = NewSystemLogClient(c.config)
	c.TabItem = NewTabItemClient(c.config)
	c.TeamMember = NewTeamMemberClient(c.config)
	c.TeamMemberItem = NewTeamMemberItemClient(c.config)
	c.TestimonialItem = NewTestimonialItemClient(c.config)
	c.TimelineEvent = NewTimelineEventClient(c.config)
	c.Token = NewTokenClient(c.config)
	c.TrustedDevice = NewTrustedDeviceClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserAchievement = NewUserAchievementClient(c.config)
	c.UserConsent = NewUserConsentClient(c.config)
	c.UserOnboarding = NewUserOnboardingClient(c.config)
	c.UserProfile = NewUserProfileClient(c.config)
	c.UserSession = NewUserSessionClient(c.config)
	c.UserSkill = NewUserSkillClient(c.config)
	c.VolunteerApplication = NewVolunteerApplicationClient(c.config)
	c.VolunteerAssignment = NewVolunteerAssignmentClient(c.config)
	c.VolunteerOpportunity = NewVolunteerOpportunityClient(c.config)
	c.Vote = NewVoteClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		AccordionItem:           NewAccordionItemClient(cfg),
		ActionItem:              NewActionItemClient(cfg),
		ActivityLog:             NewActivityLogClient(cfg),
		Address:                 NewAddressClient(cfg),
		Agenda:                  NewAgendaClient(cfg),
		AgendaItem:              NewAgendaItemClient(cfg),
		AnalyticsDashboard:      NewAnalyticsDashboardClient(cfg),
		AnalyticsEvent:          NewAnalyticsEventClient(cfg),
		AppSetting:              NewAppSettingClient(cfg),
		AuditLog:                NewAuditLogClient(cfg),
		Badge:                   NewBadgeClient(cfg),
		Ballot:                  NewBallotClient(cfg),
		BlockAccordion:          NewBlockAccordionClient(cfg),
		BlockContactForm:        NewBlockContactFormClient(cfg),
		BlockCta:                NewBlockCtaClient(cfg),
		BlockDivider:            NewBlockDividerClient(cfg),
		BlockDonationForm:       NewBlockDonationFormClient(cfg),
		BlockFaq:                NewBlockFaqClient(cfg),
		BlockGallery:            NewBlockGalleryClient(cfg),
		BlockHero:               NewBlockHeroClient(cfg),
		BlockMap:                NewBlockMapClient(cfg),
		BlockNewsletterSignup:   NewBlockNewsletterSignupClient(cfg),
		BlockPartnerLogos:       NewBlockPartnerLogosClient(cfg),
		BlockProgramCards:       NewBlockProgramCardsClient(cfg),
		BlockStats:              NewBlockStatsClient(cfg),
		BlockSuccessStories:     NewBlockSuccessStoriesClient(cfg),
		BlockTabs:               NewBlockTabsClient(cfg),
		BlockTeamGrid:           NewBlockTeamGridClient(cfg),
		BlockTestimonials:       NewBlockTestimonialsClient(cfg),
		BlockTextContent:        NewBlockTextContentClient(cfg),
		BlockTimeline:           NewBlockTimelineClient(cfg),
		BlockVideoEmbed:         NewBlockVideoEmbedClient(cfg),
		BlockVolunteerSignup:    NewBlockVolunteerSignupClient(cfg),
		BrandBenefit:            NewBrandBenefitClient(cfg),
		BrandConfig:             NewBrandConfigClient(cfg),
		ContentBlock:            NewContentBlockClient(cfg),
		Conversation:            NewConversationClient(cfg),
		ConversationParticipant: NewConversationParticipantClient(cfg),
		DashboardWidget:         NewDashboardWidgetClient(cfg),
		Document:                NewDocumentClient(cfg),
		DocumentCategory:        NewDocumentCategoryClient(cfg),
		Donation:                NewDonationClient(cfg),
		Event:                   NewEventClient(cfg),
		EventRegistration:       NewEventRegistrationClient(cfg),
		FaqItem:                 NewFaqItemClient(cfg),
		FeatureFlag:             NewFeatureFlagClient(cfg),
		FundraisingCampaign:     NewFundraisingCampaignClient(cfg),
		GalleryImage:            NewGalleryImageClient(cfg),
		GeneratedReport:         NewGeneratedReportClient(cfg),
		Grant:                   NewGrantClient(cfg),
		GrantReport:             NewGrantReportClient(cfg),
		ImpactDataPoint:         NewImpactDataPointClient(cfg),
		ImpactMetric:            NewImpactMetricClient(cfg),
		Job:                     NewJobClient(cfg),
		JobLog:                  NewJobLogClient(cfg),
		MentorshipRequest:       NewMentorshipRequestClient(cfg),
		MentorshipSession:       NewMentorshipSessionClient(cfg),
		Message:                 NewMessageClient(cfg),
		NewsArticle:             NewNewsArticleClient(cfg),
		Organization:            NewOrganizationClient(cfg),
		Page:                    NewPageClient(cfg),
		PartnerLogoItem:         NewPartnerLogoItemClient(cfg),
		Partnership:             NewPartnershipClient(cfg),
		PartnershipInteraction:  NewPartnershipInteractionClient(cfg),
		PartnershipRenewal:      NewPartnershipRenewalClient(cfg),
		PartnershipReport:       NewPartnershipReportClient(cfg),
		PasswordHistory:         NewPasswordHistoryClient(cfg),
		Permission:              NewPermissionClient(cfg),
		Program:                 NewProgramClient(cfg),
		ProgramCardItem:         NewProgramCardItemClient(cfg),
		ProgramCategory:         NewProgramCategoryClient(cfg),
		ProgramEnrolment:        NewProgramEnrolmentClient(cfg),
		ProgramParticipant:      NewProgramParticipantClient(cfg),
		ReportDefinition:        NewReportDefinitionClient(cfg),
		ReportPermission:        NewReportPermissionClient(cfg),
		RolePermission:          NewRolePermissionClient(cfg),
		ScheduledReport:         NewScheduledReportClient(cfg),
		SeoConfig:               NewSeoConfigClient(cfg),
		SiteVisit:               NewSiteVisitClient(cfg),
		Skill:                   NewSkillClient(cfg),
		StatItem:                NewStatItemClient(cfg),
		SuccessStory:            NewSuccessStoryClient(cfg),
		SystemError:             NewSystemErrorClient(cfg),
		SystemLog:               NewSystemLogClient(cfg),
		TabItem:                 NewTabItemClient(cfg),
		TeamMember:              NewTeamMemberClient(cfg),
		TeamMemberItem:          NewTeamMemberItemClient(cfg),
		TestimonialItem:         NewTestimonialItemClient(cfg),
		TimelineEvent:           NewTimelineEventClient(cfg),
		Token:                   NewTokenClient(cfg),
		TrustedDevice:           NewTrustedDeviceClient(cfg),
		User:                    NewUserClient(cfg),
		UserAchievement:         NewUserAchievementClient(cfg),
		UserConsent:             NewUserConsentClient(cfg),
		UserOnboarding:          NewUserOnboardingClient(cfg),
		UserProfile:             NewUserProfileClient(cfg),
		UserSession:             NewUserSessionClient(cfg),
		UserSkill:               NewUserSkillClient(cfg),
		VolunteerApplication:    NewVolunteerApplicationClient(cfg),
		VolunteerAssignment:     NewVolunteerAssignmentClient(cfg),
		VolunteerOpportunity:    NewVolunteerOpportunityClient(cfg),
		Vote:                    NewVoteClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                     ctx,
		config:                  cfg,
		AccordionItem:           NewAccordionItemClient(cfg),
		ActionItem:              NewActionItemClient(cfg),
		ActivityLog:             NewActivityLogClient(cfg),
		Address:                 NewAddressClient(cfg),
		Agenda:                  NewAgendaClient(cfg),
		AgendaItem:              NewAgendaItemClient(cfg),
		AnalyticsDashboard:      NewAnalyticsDashboardClient(cfg),
		AnalyticsEvent:          NewAnalyticsEventClient(cfg),
		AppSetting:              NewAppSettingClient(cfg),
		AuditLog:                NewAuditLogClient(cfg),
		Badge:                   NewBadgeClient(cfg),
		Ballot:                  NewBallotClient(cfg),
		BlockAccordion:          NewBlockAccordionClient(cfg),
		BlockContactForm:        NewBlockContactFormClient(cfg),
		BlockCta:                NewBlockCtaClient(cfg),
		BlockDivider:            NewBlockDividerClient(cfg),
		BlockDonationForm:       NewBlockDonationFormClient(cfg),
		BlockFaq:                NewBlockFaqClient(cfg),
		BlockGallery:            NewBlockGalleryClient(cfg),
		BlockHero:               NewBlockHeroClient(cfg),
		BlockMap:                NewBlockMapClient(cfg),
		BlockNewsletterSignup:   NewBlockNewsletterSignupClient(cfg),
		BlockPartnerLogos:       NewBlockPartnerLogosClient(cfg),
		BlockProgramCards:       NewBlockProgramCardsClient(cfg),
		BlockStats:              NewBlockStatsClient(cfg),
		BlockSuccessStories:     NewBlockSuccessStoriesClient(cfg),
		BlockTabs:               NewBlockTabsClient(cfg),
		BlockTeamGrid:           NewBlockTeamGridClient(cfg),
		BlockTestimonials:       NewBlockTestimonialsClient(cfg),
		BlockTextContent:        NewBlockTextContentClient(cfg),
		BlockTimeline:           NewBlockTimelineClient(cfg),
		BlockVideoEmbed:         NewBlockVideoEmbedClient(cfg),
		BlockVolunteerSignup:    NewBlockVolunteerSignupClient(cfg),
		BrandBenefit:            NewBrandBenefitClient(cfg),
		BrandConfig:             NewBrandConfigClient(cfg),
		ContentBlock:            NewContentBlockClient(cfg),
		Conversation:            NewConversationClient(cfg),
		ConversationParticipant: NewConversationParticipantClient(cfg),
		DashboardWidget:         NewDashboardWidgetClient(cfg),
		Document:                NewDocumentClient(cfg),
		DocumentCategory:        NewDocumentCategoryClient(cfg),
		Donation:                NewDonationClient(cfg),
		Event:                   NewEventClient(cfg),
		EventRegistration:       NewEventRegistrationClient(cfg),
		FaqItem:                 NewFaqItemClient(cfg),
		FeatureFlag:             NewFeatureFlagClient(cfg),
		FundraisingCampaign:     NewFundraisingCampaignClient(cfg),
		GalleryImage:            NewGalleryImageClient(cfg),
		GeneratedReport:         NewGeneratedReportClient(cfg),
		Grant:                   NewGrantClient(cfg),
		GrantReport:             NewGrantReportClient(cfg),
		ImpactDataPoint:         NewImpactDataPointClient(cfg),
		ImpactMetric:            NewImpactMetricClient(cfg),
		Job:                     NewJobClient(cfg),
		JobLog:                  NewJobLogClient(cfg),
		MentorshipRequest:       NewMentorshipRequestClient(cfg),
		MentorshipSession:       NewMentorshipSessionClient(cfg),
		Message:                 NewMessageClient(cfg),
		NewsArticle:             NewNewsArticleClient(cfg),
		Organization:            NewOrganizationClient(cfg),
		Page:                    NewPageClient(cfg),
		PartnerLogoItem:         NewPartnerLogoItemClient(cfg),
		Partnership:             NewPartnershipClient(cfg),
		PartnershipInteraction:  NewPartnershipInteractionClient(cfg),
		PartnershipRenewal:      NewPartnershipRenewalClient(cfg),
		PartnershipReport:       NewPartnershipReportClient(cfg),
		PasswordHistory:         NewPasswordHistoryClient(cfg),
		Permission:              NewPermissionClient(cfg),
		Program:                 NewProgramClient(cfg),
		ProgramCardItem:         NewProgramCardItemClient(cfg),
		ProgramCategory:         NewProgramCategoryClient(cfg),
		ProgramEnrolment:        NewProgramEnrolmentClient(cfg),
		ProgramParticipant:      NewProgramParticipantClient(cfg),
		ReportDefinition:        NewReportDefinitionClient(cfg),
		ReportPermission:        NewReportPermissionClient(cfg),
		RolePermission:          NewRolePermissionClient(cfg),
		ScheduledReport:         NewScheduledReportClient(cfg),
		SeoConfig:               NewSeoConfigClient(cfg),
		SiteVisit:               NewSiteVisitClient(cfg),
		Skill:                   NewSkillClient(cfg),
		StatItem:                NewStatItemClient(cfg),
		SuccessStory:            NewSuccessStoryClient(cfg),
		SystemError:             NewSystemErrorClient(cfg),
		SystemLog:               NewSystemLogClient(cfg),
		TabItem:                 NewTabItemClient(cfg),
		TeamMember:              NewTeamMemberClient(cfg),
		TeamMemberItem:          NewTeamMemberItemClient(cfg),
		TestimonialItem:         NewTestimonialItemClient(cfg),
		TimelineEvent:           NewTimelineEventClient(cfg),
		Token:                   NewTokenClient(cfg),
		TrustedDevice:           NewTrustedDeviceClient(cfg),
		User:                    NewUserClient(cfg),
		UserAchievement:         NewUserAchievementClient(cfg),
		UserConsent:             NewUserConsentClient(cfg),
		UserOnboarding:          NewUserOnboardingClient(cfg),
		UserProfile:             NewUserProfileClient(cfg),
		UserSession:             NewUserSessionClient(cfg),
		UserSkill:               NewUserSkillClient(cfg),
		VolunteerApplication:    NewVolunteerApplicationClient(cfg),
		VolunteerAssignment:     NewVolunteerAssignmentClient(cfg),
		VolunteerOpportunity:    NewVolunteerOpportunityClient(cfg),
		Vote:                    NewVoteClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AccordionItem.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AccordionItem, c.ActionItem, c.ActivityLog, c.Address, c.Agenda, c.AgendaItem,
		c.AnalyticsDashboard, c.AnalyticsEvent, c.AppSetting, c.AuditLog, c.Badge,
		c.Ballot, c.BlockAccordion, c.BlockContactForm, c.BlockCta, c.BlockDivider,
		c.BlockDonationForm, c.BlockFaq, c.BlockGallery, c.BlockHero, c.BlockMap,
		c.BlockNewsletterSignup, c.BlockPartnerLogos, c.BlockProgramCards,
		c.BlockStats, c.BlockSuccessStories, c.BlockTabs, c.BlockTeamGrid,
		c.BlockTestimonials, c.BlockTextContent, c.BlockTimeline, c.BlockVideoEmbed,
		c.BlockVolunteerSignup, c.BrandBenefit, c.BrandConfig, c.ContentBlock,
		c.Conversation, c.ConversationParticipant, c.DashboardWidget, c.Document,
		c.DocumentCategory, c.Donation, c.Event, c.EventRegistration, c.FaqItem,
		c.FeatureFlag, c.FundraisingCampaign, c.GalleryImage, c.GeneratedReport,
		c.Grant, c.GrantReport, c.ImpactDataPoint, c.ImpactMetric, c.Job, c.JobLog,
		c.MentorshipRequest, c.MentorshipSession, c.Message, c.NewsArticle,
		c.Organization, c.Page, c.PartnerLogoItem, c.Partnership,
		c.PartnershipInteraction, c.PartnershipRenewal, c.PartnershipReport,
		c.PasswordHistory, c.Permission, c.Program, c.ProgramCardItem,
		c.ProgramCategory, c.ProgramEnrolment, c.ProgramParticipant,
		c.ReportDefinition, c.ReportPermission, c.RolePermission, c.ScheduledReport,
		c.SeoConfig, c.SiteVisit, c.Skill, c.StatItem, c.SuccessStory, c.SystemError,
		c.SystemLog, c.TabItem, c.TeamMember, c.TeamMemberItem, c.TestimonialItem,
		c.TimelineEvent, c.Token, c.TrustedDevice, c.User, c.UserAchievement,
		c.UserConsent, c.UserOnboarding, c.UserProfile, c.UserSession, c.UserSkill,
		c.VolunteerApplication, c.VolunteerAssignment, c.VolunteerOpportunity, c.Vote,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AccordionItem, c.ActionItem, c.ActivityLog, c.Address, c.Agenda, c.AgendaItem,
		c.AnalyticsDashboard, c.AnalyticsEvent, c.AppSetting, c.AuditLog, c.Badge,
		c.Ballot, c.BlockAccordion, c.BlockContactForm, c.BlockCta, c.BlockDivider,
		c.BlockDonationForm, c.BlockFaq, c.BlockGallery, c.BlockHero, c.BlockMap,
		c.BlockNewsletterSignup, c.BlockPartnerLogos, c.BlockProgramCards,
		c.BlockStats, c.BlockSuccessStories, c.BlockTabs, c.BlockTeamGrid,
		c.BlockTestimonials, c.BlockTextContent, c.BlockTimeline, c.BlockVideoEmbed,
		c.BlockVolunteerSignup, c.BrandBenefit, c.BrandConfig, c.ContentBlock,
		c.Conversation, c.ConversationParticipant, c.DashboardWidget, c.Document,
		c.DocumentCategory, c.Donation, c.Event, c.EventRegistration, c.FaqItem,
		c.FeatureFlag, c.FundraisingCampaign, c.GalleryImage, c.GeneratedReport,
		c.Grant, c.GrantReport, c.ImpactDataPoint, c.ImpactMetric, c.Job, c.JobLog,
		c.MentorshipRequest, c.MentorshipSession, c.Message, c.NewsArticle,
		c.Organization, c.Page, c.PartnerLogoItem, c.Partnership,
		c.PartnershipInteraction, c.PartnershipRenewal, c.PartnershipReport,
		c.PasswordHistory, c.Permission, c.Program, c.ProgramCardItem,
		c.ProgramCategory, c.ProgramEnrolment, c.ProgramParticipant,
		c.ReportDefinition, c.ReportPermission, c.RolePermission, c.ScheduledReport,
		c.SeoConfig, c.SiteVisit, c.Skill, c.StatItem, c.SuccessStory, c.SystemError,
		c.SystemLog, c.TabItem, c.TeamMember, c.TeamMemberItem, c.TestimonialItem,
		c.TimelineEvent, c.Token, c.TrustedDevice, c.User, c.UserAchievement,
		c.UserConsent, c.UserOnboarding, c.UserProfile, c.UserSession, c.UserSkill,
		c.VolunteerApplication, c.VolunteerAssignment, c.VolunteerOpportunity, c.Vote,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccordionItemMutation:
		return c.AccordionItem.mutate(ctx, m)
	case *ActionItemMutation:
		return c.ActionItem.mutate(ctx, m)
	case *ActivityLogMutation:
		return c.ActivityLog.mutate(ctx, m)
	case *AddressMutation:
		return c.Address.mutate(ctx, m)
	case *AgendaMutation:
		return c.Agenda.mutate(ctx, m)
	case *AgendaItemMutation:
		return c.AgendaItem.mutate(ctx, m)
	case *AnalyticsDashboardMutation:
		return c.AnalyticsDashboard.mutate(ctx, m)
	case *AnalyticsEventMutation:
		return c.AnalyticsEvent.mutate(ctx, m)
	case *AppSettingMutation:
		return c.AppSetting.mutate(ctx, m)
	case *AuditLogMutation:
		return c.AuditLog.mutate(ctx, m)
	case *BadgeMutation:
		return c.Badge.mutate(ctx, m)
	case *BallotMutation:
		return c.Ballot.mutate(ctx, m)
	case *BlockAccordionMutation:
		return c.BlockAccordion.mutate(ctx, m)
	case *BlockContactFormMutation:
		return c.BlockContactForm.mutate(ctx, m)
	case *BlockCtaMutation:
		return c.BlockCta.mutate(ctx, m)
	case *BlockDividerMutation:
		return c.BlockDivider.mutate(ctx, m)
	case *BlockDonationFormMutation:
		return c.BlockDonationForm.mutate(ctx, m)
	case *BlockFaqMutation:
		return c.BlockFaq.mutate(ctx, m)
	case *BlockGalleryMutation:
		return c.BlockGallery.mutate(ctx, m)
	case *BlockHeroMutation:
		return c.BlockHero.mutate(ctx, m)
	case *BlockMapMutation:
		return c.BlockMap.mutate(ctx, m)
	case *BlockNewsletterSignupMutation:
		return c.BlockNewsletterSignup.mutate(ctx, m)
	case *BlockPartnerLogosMutation:
		return c.BlockPartnerLogos.mutate(ctx, m)
	case *BlockProgramCardsMutation:
		return c.BlockProgramCards.mutate(ctx, m)
	case *BlockStatsMutation:
		return c.BlockStats.mutate(ctx, m)
	case *BlockSuccessStoriesMutation:
		return c.BlockSuccessStories.mutate(ctx, m)
	case *BlockTabsMutation:
		return c.BlockTabs.mutate(ctx, m)
	case *BlockTeamGridMutation:
		return c.BlockTeamGrid.mutate(ctx, m)
	case *BlockTestimonialsMutation:
		return c.BlockTestimonials.mutate(ctx, m)
	case *BlockTextContentMutation:
		return c.BlockTextContent.mutate(ctx, m)
	case *BlockTimelineMutation:
		return c.BlockTimeline.mutate(ctx, m)
	case *BlockVideoEmbedMutation:
		return c.BlockVideoEmbed.mutate(ctx, m)
	case *BlockVolunteerSignupMutation:
		return c.BlockVolunteerSignup.mutate(ctx, m)
	case *BrandBenefitMutation:
		return c.BrandBenefit.mutate(ctx, m)
	case *BrandConfigMutation:
		return c.BrandConfig.mutate(ctx, m)
	case *ContentBlockMutation:
		return c.ContentBlock.mutate(ctx, m)
	case *ConversationMutation:
		return c.Conversation.mutate(ctx, m)
	case *ConversationParticipantMutation:
		return c.ConversationParticipant.mutate(ctx, m)
	case *DashboardWidgetMutation:
		return c.DashboardWidget.mutate(ctx, m)
	case *DocumentMutation:
		return c.Document.mutate(ctx, m)
	case *DocumentCategoryMutation:
		return c.DocumentCategory.mutate(ctx, m)
	case *DonationMutation:
		return c.Donation.mutate(ctx, m)
	case *EventMutation:
		return c.Event.mutate(ctx, m)
	case *EventRegistrationMutation:
		return c.EventRegistration.mutate(ctx, m)
	case *FaqItemMutation:
		return c.FaqItem.mutate(ctx, m)
	case *FeatureFlagMutation:
		return c.FeatureFlag.mutate(ctx, m)
	case *FundraisingCampaignMutation:
		return c.FundraisingCampaign.mutate(ctx, m)
	case *GalleryImageMutation:
		return c.GalleryImage.mutate(ctx, m)
	case *GeneratedReportMutation:
		return c.GeneratedReport.mutate(ctx, m)
	case *GrantMutation:
		return c.Grant.mutate(ctx, m)
	case *GrantReportMutation:
		return c.GrantReport.mutate(ctx, m)
	case *ImpactDataPointMutation:
		return c.ImpactDataPoint.mutate(ctx, m)
	case *ImpactMetricMutation:
		return c.ImpactMetric.mutate(ctx, m)
	case *JobMutation:
		return c.Job.mutate(ctx, m)
	case *JobLogMutation:
		return c.JobLog.mutate(ctx, m)
	case *MentorshipRequestMutation:
		return c.MentorshipRequest.mutate(ctx, m)
	case *MentorshipSessionMutation:
		return c.MentorshipSession.mutate(ctx, m)
	case *MessageMutation:
		return c.Message.mutate(ctx, m)
	case *NewsArticleMutation:
		return c.NewsArticle.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *PageMutation:
		return c.Page.mutate(ctx, m)
	case *PartnerLogoItemMutation:
		return c.PartnerLogoItem.mutate(ctx, m)
	case *PartnershipMutation:
		return c.Partnership.mutate(ctx, m)
	case *PartnershipInteractionMutation:
		return c.PartnershipInteraction.mutate(ctx, m)
	case *PartnershipRenewalMutation:
		return c.PartnershipRenewal.mutate(ctx, m)
	case *PartnershipReportMutation:
		return c.PartnershipReport.mutate(ctx, m)
	case *PasswordHistoryMutation:
		return c.PasswordHistory.mutate(ctx, m)
	case *PermissionMutation:
		return c.Permission.mutate(ctx, m)
	case *ProgramMutation:
		return c.Program.mutate(ctx, m)
	case *ProgramCardItemMutation:
		return c.ProgramCardItem.mutate(ctx, m)
	case *ProgramCategoryMutation:
		return c.ProgramCategory.mutate(ctx, m)
	case *ProgramEnrolmentMutation:
		return c.ProgramEnrolment.mutate(ctx, m)
	case *ProgramParticipantMutation:
		return c.ProgramParticipant.mutate(ctx, m)
	case *ReportDefinitionMutation:
		return c.ReportDefinition.mutate(ctx, m)
	case *ReportPermissionMutation:
		return c.ReportPermission.mutate(ctx, m)
	case *RolePermissionMutation:
		return c.RolePermission.mutate(ctx, m)
	case *ScheduledReportMutation:
		return c.ScheduledReport.mutate(ctx, m)
	case *SeoConfigMutation:
		return c.SeoConfig.mutate(ctx, m)
	case *SiteVisitMutation:
		return c.SiteVisit.mutate(ctx, m)
	case *SkillMutation:
		return c.Skill.mutate(ctx, m)
	case *StatItemMutation:
		return c.StatItem.mutate(ctx, m)
	case *SuccessStoryMutation:
		return c.SuccessStory.mutate(ctx, m)
	case *SystemErrorMutation:
		return c.SystemError.mutate(ctx, m)
	case *SystemLogMutation:
		return c.SystemLog.mutate(ctx, m)
	case *TabItemMutation:
		return c.TabItem.mutate(ctx, m)
	case *TeamMemberMutation:
		return c.TeamMember.mutate(ctx, m)
	case *TeamMemberItemMutation:
		return c.TeamMemberItem.mutate(ctx, m)
	case *TestimonialItemMutation:
		return c.TestimonialItem.mutate(ctx, m)
	case *TimelineEventMutation:
		return c.TimelineEvent.mutate(ctx, m)
	case *TokenMutation:
		return c.Token.mutate(ctx, m)
	case *TrustedDeviceMutation:
		return c.TrustedDevice.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserAchievementMutation:
		return c.UserAchievement.mutate(ctx, m)
	case *UserConsentMutation:
		return c.UserConsent.mutate(ctx, m)
	case *UserOnboardingMutation:
		return c.UserOnboarding.mutate(ctx, m)
	case *UserProfileMutation:
		return c.UserProfile.mutate(ctx, m)
	case *UserSessionMutation:
		return c.UserSession.mutate(ctx, m)
	case *UserSkillMutation:
		return c.UserSkill.mutate(ctx, m)
	case *VolunteerApplicationMutation:
		return c.VolunteerApplication.mutate(ctx, m)
	case *VolunteerAssignmentMutation:
		return c.VolunteerAssignment.mutate(ctx, m)
	case *VolunteerOpportunityMutation:
		return c.VolunteerOpportunity.mutate(ctx, m)
	case *VoteMutation:
		return c.Vote.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AccordionItemClient is a client for the AccordionItem schema.
type AccordionItemClient struct {
	config
}

// NewAccordionItemClient returns a client for the AccordionItem from the given config.
func NewAccordionItemClient(c config) *AccordionItemClient {
	return &AccordionItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accordionitem.Hooks(f(g(h())))`.
func (c *AccordionItemClient) Use(hooks ...Hook) {
	c.hooks.AccordionItem = append(c.hooks.AccordionItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accordionitem.Intercept(f(g(h())))`.
func (c *AccordionItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccordionItem = append(c.inters.AccordionItem, interceptors...)
}

// Create returns a builder for creating a AccordionItem entity.
func (c *AccordionItemClient) Create() *AccordionItemCreate {
	mutation := newAccordionItemMutation(c.config, OpCreate)
	return &AccordionItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccordionItem entities.
func (c *AccordionItemClient) CreateBulk(builders ...*AccordionItemCreate) *AccordionItemCreateBulk {
	return &AccordionItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccordionItemClient) MapCreateBulk(slice any, setFunc func(*AccordionItemCreate, int)) *AccordionItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccordionItemCreateBulk{err: fmt.Errorf("calling to AccordionItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccordionItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccordionItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccordionItem.
func (c *AccordionItemClient) Update() *AccordionItemUpdate {
	mutation := newAccordionItemMutation(c.config, OpUpdate)
	return &AccordionItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccordionItemClient) UpdateOne(_m *AccordionItem) *AccordionItemUpdateOne {
	mutation := newAccordionItemMutation(c.config, OpUpdateOne, withAccordionItem(_m))
	return &AccordionItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccordionItemClient) UpdateOneID(id int) *AccordionItemUpdateOne {
	mutation := newAccordionItemMutation(c.config, OpUpdateOne, withAccordionItemID(id))
	return &AccordionItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccordionItem.
func (c *AccordionItemClient) Delete() *AccordionItemDelete {
	mutation := newAccordionItemMutation(c.config, OpDelete)
	return &AccordionItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccordionItemClient) DeleteOne(_m *AccordionItem) *AccordionItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccordionItemClient) DeleteOneID(id int) *AccordionItemDeleteOne {
	builder := c.Delete().Where(accordionitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccordionItemDeleteOne{builder}
}

// Query returns a query builder for AccordionItem.
func (c *AccordionItemClient) Query() *AccordionItemQuery {
	return &AccordionItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccordionItem},
		inters: c.Interceptors(),
	}
}

// Get returns a AccordionItem entity by its id.
func (c *AccordionItemClient) Get(ctx context.Context, id int) (*AccordionItem, error) {
	return c.Query().Where(accordionitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccordionItemClient) GetX(ctx context.Context, id int) *AccordionItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlock queries the block edge of a AccordionItem.
func (c *AccordionItemClient) QueryBlock(_m *AccordionItem) *BlockAccordionQuery {
	query := (&BlockAccordionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accordionitem.Table, accordionitem.FieldID, id),
			sqlgraph.To(blockaccordion.Table, blockaccordion.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accordionitem.BlockTable, accordionitem.BlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccordionItemClient) Hooks() []Hook {
	return c.hooks.AccordionItem
}

// Interceptors returns the client interceptors.
func (c *AccordionItemClient) Interceptors() []Interceptor {
	return c.inters.AccordionItem
}

func (c *AccordionItemClient) mutate(ctx context.Context, m *AccordionItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccordionItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccordionItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccordionItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccordionItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AccordionItem mutation op: %q", m.Op())
	}
}

// ActionItemClient is a client for the ActionItem schema.
type ActionItemClient struct {
	config
}

// NewActionItemClient returns a client for the ActionItem from the given config.
func NewActionItemClient(c config) *ActionItemClient {
	return &ActionItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `actionitem.Hooks(f(g(h())))`.
func (c *ActionItemClient) Use(hooks ...Hook) {
	c.hooks.ActionItem = append(c.hooks.ActionItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `actionitem.Intercept(f(g(h())))`.
func (c *ActionItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActionItem = append(c.inters.ActionItem, interceptors...)
}

// Create returns a builder for creating a ActionItem entity.
func (c *ActionItemClient) Create() *ActionItemCreate {
	mutation := newActionItemMutation(c.config, OpCreate)
	return &ActionItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActionItem entities.
func (c *ActionItemClient) CreateBulk(builders ...*ActionItemCreate) *ActionItemCreateBulk {
	return &ActionItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActionItemClient) MapCreateBulk(slice any, setFunc func(*ActionItemCreate, int)) *ActionItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActionItemCreateBulk{err: fmt.Errorf("calling to ActionItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActionItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActionItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActionItem.
func (c *ActionItemClient) Update() *ActionItemUpdate {
	mutation := newActionItemMutation(c.config, OpUpdate)
	return &ActionItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActionItemClient) UpdateOne(_m *ActionItem) *ActionItemUpdateOne {
	mutation := newActionItemMutation(c.config, OpUpdateOne, withActionItem(_m))
	return &ActionItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActionItemClient) UpdateOneID(id int) *ActionItemUpdateOne {
	mutation := newActionItemMutation(c.config, OpUpdateOne, withActionItemID(id))
	return &ActionItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActionItem.
func (c *ActionItemClient) Delete() *ActionItemDelete {
	mutation := newActionItemMutation(c.config, OpDelete)
	return &ActionItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActionItemClient) DeleteOne(_m *ActionItem) *ActionItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActionItemClient) DeleteOneID(id int) *ActionItemDeleteOne {
	builder := c.Delete().Where(actionitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActionItemDeleteOne{builder}
}

// Query returns a query builder for ActionItem.
func (c *ActionItemClient) Query() *ActionItemQuery {
	return &ActionItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActionItem},
		inters: c.Interceptors(),
	}
}

// Get returns a ActionItem entity by its id.
func (c *ActionItemClient) Get(ctx context.Context, id int) (*ActionItem, error) {
	return c.Query().Where(actionitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActionItemClient) GetX(ctx context.Context, id int) *ActionItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgendaItem queries the agenda_item edge of a ActionItem.
func (c *ActionItemClient) QueryAgendaItem(_m *ActionItem) *AgendaItemQuery {
	query := (&AgendaItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(actionitem.Table, actionitem.FieldID, id),
			sqlgraph.To(agendaitem.Table, agendaitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, actionitem.AgendaItemTable, actionitem.AgendaItemColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActionItemClient) Hooks() []Hook {
	return c.hooks.ActionItem
}

// Interceptors returns the client interceptors.
func (c *ActionItemClient) Interceptors() []Interceptor {
	return c.inters.ActionItem
}

func (c *ActionItemClient) mutate(ctx context.Context, m *ActionItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActionItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActionItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActionItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActionItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActionItem mutation op: %q", m.Op())
	}
}

// ActivityLogClient is a client for the ActivityLog schema.
type ActivityLogClient struct {
	config
}

// NewActivityLogClient returns a client for the ActivityLog from the given config.
func NewActivityLogClient(c config) *ActivityLogClient {
	return &ActivityLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `activitylog.Hooks(f(g(h())))`.
func (c *ActivityLogClient) Use(hooks ...Hook) {
	c.hooks.ActivityLog = append(c.hooks.ActivityLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `activitylog.Intercept(f(g(h())))`.
func (c *ActivityLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.ActivityLog = append(c.inters.ActivityLog, interceptors...)
}

// Create returns a builder for creating a ActivityLog entity.
func (c *ActivityLogClient) Create() *ActivityLogCreate {
	mutation := newActivityLogMutation(c.config, OpCreate)
	return &ActivityLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ActivityLog entities.
func (c *ActivityLogClient) CreateBulk(builders ...*ActivityLogCreate) *ActivityLogCreateBulk {
	return &ActivityLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ActivityLogClient) MapCreateBulk(slice any, setFunc func(*ActivityLogCreate, int)) *ActivityLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ActivityLogCreateBulk{err: fmt.Errorf("calling to ActivityLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ActivityLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ActivityLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ActivityLog.
func (c *ActivityLogClient) Update() *ActivityLogUpdate {
	mutation := newActivityLogMutation(c.config, OpUpdate)
	return &ActivityLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ActivityLogClient) UpdateOne(_m *ActivityLog) *ActivityLogUpdateOne {
	mutation := newActivityLogMutation(c.config, OpUpdateOne, withActivityLog(_m))
	return &ActivityLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ActivityLogClient) UpdateOneID(id int) *ActivityLogUpdateOne {
	mutation := newActivityLogMutation(c.config, OpUpdateOne, withActivityLogID(id))
	return &ActivityLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ActivityLog.
func (c *ActivityLogClient) Delete() *ActivityLogDelete {
	mutation := newActivityLogMutation(c.config, OpDelete)
	return &ActivityLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ActivityLogClient) DeleteOne(_m *ActivityLog) *ActivityLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ActivityLogClient) DeleteOneID(id int) *ActivityLogDeleteOne {
	builder := c.Delete().Where(activitylog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ActivityLogDeleteOne{builder}
}

// Query returns a query builder for ActivityLog.
func (c *ActivityLogClient) Query() *ActivityLogQuery {
	return &ActivityLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeActivityLog},
		inters: c.Interceptors(),
	}
}

// Get returns a ActivityLog entity by its id.
func (c *ActivityLogClient) Get(ctx context.Context, id int) (*ActivityLog, error) {
	return c.Query().Where(activitylog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ActivityLogClient) GetX(ctx context.Context, id int) *ActivityLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActor queries the actor edge of a ActivityLog.
func (c *ActivityLogClient) QueryActor(_m *ActivityLog) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(activitylog.Table, activitylog.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, activitylog.ActorTable, activitylog.ActorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ActivityLogClient) Hooks() []Hook {
	return c.hooks.ActivityLog
}

// Interceptors returns the client interceptors.
func (c *ActivityLogClient) Interceptors() []Interceptor {
	return c.inters.ActivityLog
}

func (c *ActivityLogClient) mutate(ctx context.Context, m *ActivityLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ActivityLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ActivityLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ActivityLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ActivityLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ActivityLog mutation op: %q", m.Op())
	}
}

// AddressClient is a client for the Address schema.
type AddressClient struct {
	config
}

// NewAddressClient returns a client for the Address from the given config.
func NewAddressClient(c config) *AddressClient {
	return &AddressClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `address.Hooks(f(g(h())))`.
func (c *AddressClient) Use(hooks ...Hook) {
	c.hooks.Address = append(c.hooks.Address, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `address.Intercept(f(g(h())))`.
func (c *AddressClient) Intercept(interceptors ...Interceptor) {
	c.inters.Address = append(c.inters.Address, interceptors...)
}

// Create returns a builder for creating a Address entity.
func (c *AddressClient) Create() *AddressCreate {
	mutation := newAddressMutation(c.config, OpCreate)
	return &AddressCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Address entities.
func (c *AddressClient) CreateBulk(builders ...*AddressCreate) *AddressCreateBulk {
	return &AddressCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AddressClient) MapCreateBulk(slice any, setFunc func(*AddressCreate, int)) *AddressCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AddressCreateBulk{err: fmt.Errorf("calling to AddressClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AddressCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AddressCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Address.
func (c *AddressClient) Update() *AddressUpdate {
	mutation := newAddressMutation(c.config, OpUpdate)
	return &AddressUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AddressClient) UpdateOne(_m *Address) *AddressUpdateOne {
	mutation := newAddressMutation(c.config, OpUpdateOne, withAddress(_m))
	return &AddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AddressClient) UpdateOneID(id int) *AddressUpdateOne {
	mutation := newAddressMutation(c.config, OpUpdateOne, withAddressID(id))
	return &AddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Address.
func (c *AddressClient) Delete() *AddressDelete {
	mutation := newAddressMutation(c.config, OpDelete)
	return &AddressDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AddressClient) DeleteOne(_m *Address) *AddressDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AddressClient) DeleteOneID(id int) *AddressDeleteOne {
	builder := c.Delete().Where(address.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AddressDeleteOne{builder}
}

// Query returns a query builder for Address.
func (c *AddressClient) Query() *AddressQuery {
	return &AddressQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAddress},
		inters: c.Interceptors(),
	}
}

// Get returns a Address entity by its id.
func (c *AddressClient) Get(ctx context.Context, id int) (*Address, error) {
	return c.Query().Where(address.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AddressClient) GetX(ctx context.Context, id int) *Address {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserProfiles queries the user_profiles edge of a Address.
func (c *AddressClient) QueryUserProfiles(_m *Address) *UserProfileQuery {
	query := (&UserProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(address.Table, address.FieldID, id),
			sqlgraph.To(userprofile.Table, userprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, address.UserProfilesTable, address.UserProfilesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Address.
func (c *AddressClient) QueryEvents(_m *Address) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(address.Table, address.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, address.EventsTable, address.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AddressClient) Hooks() []Hook {
	return c.hooks.Address
}

// Interceptors returns the client interceptors.
func (c *AddressClient) Interceptors() []Interceptor {
	return c.inters.Address
}

func (c *AddressClient) mutate(ctx context.Context, m *AddressMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AddressCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AddressUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AddressUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AddressDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Address mutation op: %q", m.Op())
	}
}

// AgendaClient is a client for the Agenda schema.
type AgendaClient struct {
	config
}

// NewAgendaClient returns a client for the Agenda from the given config.
func NewAgendaClient(c config) *AgendaClient {
	return &AgendaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agenda.Hooks(f(g(h())))`.
func (c *AgendaClient) Use(hooks ...Hook) {
	c.hooks.Agenda = append(c.hooks.Agenda, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agenda.Intercept(f(g(h())))`.
func (c *AgendaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Agenda = append(c.inters.Agenda, interceptors...)
}

// Create returns a builder for creating a Agenda entity.
func (c *AgendaClient) Create() *AgendaCreate {
	mutation := newAgendaMutation(c.config, OpCreate)
	return &AgendaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Agenda entities.
func (c *AgendaClient) CreateBulk(builders ...*AgendaCreate) *AgendaCreateBulk {
	return &AgendaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgendaClient) MapCreateBulk(slice any, setFunc func(*AgendaCreate, int)) *AgendaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgendaCreateBulk{err: fmt.Errorf("calling to AgendaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgendaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgendaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Agenda.
func (c *AgendaClient) Update() *AgendaUpdate {
	mutation := newAgendaMutation(c.config, OpUpdate)
	return &AgendaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgendaClient) UpdateOne(_m *Agenda) *AgendaUpdateOne {
	mutation := newAgendaMutation(c.config, OpUpdateOne, withAgenda(_m))
	return &AgendaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgendaClient) UpdateOneID(id int) *AgendaUpdateOne {
	mutation := newAgendaMutation(c.config, OpUpdateOne, withAgendaID(id))
	return &AgendaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Agenda.
func (c *AgendaClient) Delete() *AgendaDelete {
	mutation := newAgendaMutation(c.config, OpDelete)
	return &AgendaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgendaClient) DeleteOne(_m *Agenda) *AgendaDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgendaClient) DeleteOneID(id int) *AgendaDeleteOne {
	builder := c.Delete().Where(agenda.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgendaDeleteOne{builder}
}

// Query returns a query builder for Agenda.
func (c *AgendaClient) Query() *AgendaQuery {
	return &AgendaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgenda},
		inters: c.Interceptors(),
	}
}

// Get returns a Agenda entity by its id.
func (c *AgendaClient) Get(ctx context.Context, id int) (*Agenda, error) {
	return c.Query().Where(agenda.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgendaClient) GetX(ctx context.Context, id int) *Agenda {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a Agenda.
func (c *AgendaClient) QueryEvent(_m *Agenda) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenda.Table, agenda.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, agenda.EventTable, agenda.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItems queries the items edge of a Agenda.
func (c *AgendaClient) QueryItems(_m *Agenda) *AgendaItemQuery {
	query := (&AgendaItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenda.Table, agenda.FieldID, id),
			sqlgraph.To(agendaitem.Table, agendaitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agenda.ItemsTable, agenda.ItemsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMentorshipSession queries the mentorship_session edge of a Agenda.
func (c *AgendaClient) QueryMentorshipSession(_m *Agenda) *MentorshipSessionQuery {
	query := (&MentorshipSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenda.Table, agenda.FieldID, id),
			sqlgraph.To(mentorshipsession.Table, mentorshipsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, agenda.MentorshipSessionTable, agenda.MentorshipSessionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgendaClient) Hooks() []Hook {
	return c.hooks.Agenda
}

// Interceptors returns the client interceptors.
func (c *AgendaClient) Interceptors() []Interceptor {
	return c.inters.Agenda
}

func (c *AgendaClient) mutate(ctx context.Context, m *AgendaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgendaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgendaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgendaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgendaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Agenda mutation op: %q", m.Op())
	}
}

// AgendaItemClient is a client for the AgendaItem schema.
type AgendaItemClient struct {
	config
}

// NewAgendaItemClient returns a client for the AgendaItem from the given config.
func NewAgendaItemClient(c config) *AgendaItemClient {
	return &AgendaItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agendaitem.Hooks(f(g(h())))`.
func (c *AgendaItemClient) Use(hooks ...Hook) {
	c.hooks.AgendaItem = append(c.hooks.AgendaItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agendaitem.Intercept(f(g(h())))`.
func (c *AgendaItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgendaItem = append(c.inters.AgendaItem, interceptors...)
}

// Create returns a builder for creating a AgendaItem entity.
func (c *AgendaItemClient) Create() *AgendaItemCreate {
	mutation := newAgendaItemMutation(c.config, OpCreate)
	return &AgendaItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgendaItem entities.
func (c *AgendaItemClient) CreateBulk(builders ...*AgendaItemCreate) *AgendaItemCreateBulk {
	return &AgendaItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgendaItemClient) MapCreateBulk(slice any, setFunc func(*AgendaItemCreate, int)) *AgendaItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgendaItemCreateBulk{err: fmt.Errorf("calling to AgendaItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgendaItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgendaItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgendaItem.
func (c *AgendaItemClient) Update() *AgendaItemUpdate {
	mutation := newAgendaItemMutation(c.config, OpUpdate)
	return &AgendaItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgendaItemClient) UpdateOne(_m *AgendaItem) *AgendaItemUpdateOne {
	mutation := newAgendaItemMutation(c.config, OpUpdateOne, withAgendaItem(_m))
	return &AgendaItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgendaItemClient) UpdateOneID(id int) *AgendaItemUpdateOne {
	mutation := newAgendaItemMutation(c.config, OpUpdateOne, withAgendaItemID(id))
	return &AgendaItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgendaItem.
func (c *AgendaItemClient) Delete() *AgendaItemDelete {
	mutation := newAgendaItemMutation(c.config, OpDelete)
	return &AgendaItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgendaItemClient) DeleteOne(_m *AgendaItem) *AgendaItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgendaItemClient) DeleteOneID(id int) *AgendaItemDeleteOne {
	builder := c.Delete().Where(agendaitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgendaItemDeleteOne{builder}
}

// Query returns a query builder for AgendaItem.
func (c *AgendaItemClient) Query() *AgendaItemQuery {
	return &AgendaItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgendaItem},
		inters: c.Interceptors(),
	}
}

// Get returns a AgendaItem entity by its id.
func (c *AgendaItemClient) Get(ctx context.Context, id int) (*AgendaItem, error) {
	return c.Query().Where(agendaitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgendaItemClient) GetX(ctx context.Context, id int) *AgendaItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgenda queries the agenda edge of a AgendaItem.
func (c *AgendaItemClient) QueryAgenda(_m *AgendaItem) *AgendaQuery {
	query := (&AgendaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agendaitem.Table, agendaitem.FieldID, id),
			sqlgraph.To(agenda.Table, agenda.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agendaitem.AgendaTable, agendaitem.AgendaColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVote queries the vote edge of a AgendaItem.
func (c *AgendaItemClient) QueryVote(_m *AgendaItem) *VoteQuery {
	query := (&VoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agendaitem.Table, agendaitem.FieldID, id),
			sqlgraph.To(vote.Table, vote.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, agendaitem.VoteTable, agendaitem.VoteColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActionItems queries the action_items edge of a AgendaItem.
func (c *AgendaItemClient) QueryActionItems(_m *AgendaItem) *ActionItemQuery {
	query := (&ActionItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agendaitem.Table, agendaitem.FieldID, id),
			sqlgraph.To(actionitem.Table, actionitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agendaitem.ActionItemsTable, agendaitem.ActionItemsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgendaItemClient) Hooks() []Hook {
	return c.hooks.AgendaItem
}

// Interceptors returns the client interceptors.
func (c *AgendaItemClient) Interceptors() []Interceptor {
	return c.inters.AgendaItem
}

func (c *AgendaItemClient) mutate(ctx context.Context, m *AgendaItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgendaItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgendaItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgendaItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgendaItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgendaItem mutation op: %q", m.Op())
	}
}

// AnalyticsDashboardClient is a client for the AnalyticsDashboard schema.
type AnalyticsDashboardClient struct {
	config
}

// NewAnalyticsDashboardClient returns a client for the AnalyticsDashboard from the given config.
func NewAnalyticsDashboardClient(c config) *AnalyticsDashboardClient {
	return &AnalyticsDashboardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `analyticsdashboard.Hooks(f(g(h())))`.
func (c *AnalyticsDashboardClient) Use(hooks ...Hook) {
	c.hooks.AnalyticsDashboard = append(c.hooks.AnalyticsDashboard, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `analyticsdashboard.Intercept(f(g(h())))`.
func (c *AnalyticsDashboardClient) Intercept(interceptors ...Interceptor) {
	c.inters.AnalyticsDashboard = append(c.inters.AnalyticsDashboard, interceptors...)
}

// Create returns a builder for creating a AnalyticsDashboard entity.
func (c *AnalyticsDashboardClient) Create() *AnalyticsDashboardCreate {
	mutation := newAnalyticsDashboardMutation(c.config, OpCreate)
	return &AnalyticsDashboardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AnalyticsDashboard entities.
func (c *AnalyticsDashboardClient) CreateBulk(builders ...*AnalyticsDashboardCreate) *AnalyticsDashboardCreateBulk {
	return &AnalyticsDashboardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AnalyticsDashboardClient) MapCreateBulk(slice any, setFunc func(*AnalyticsDashboardCreate, int)) *AnalyticsDashboardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AnalyticsDashboardCreateBulk{err: fmt.Errorf("calling to AnalyticsDashboardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AnalyticsDashboardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AnalyticsDashboardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AnalyticsDashboard.
func (c *AnalyticsDashboardClient) Update() *AnalyticsDashboardUpdate {
	mutation := newAnalyticsDashboardMutation(c.config, OpUpdate)
	return &AnalyticsDashboardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnalyticsDashboardClient) UpdateOne(_m *AnalyticsDashboard) *AnalyticsDashboardUpdateOne {
	mutation := newAnalyticsDashboardMutation(c.config, OpUpdateOne, withAnalyticsDashboard(_m))
	return &AnalyticsDashboardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnalyticsDashboardClient) UpdateOneID(id int) *AnalyticsDashboardUpdateOne {
	mutation := newAnalyticsDashboardMutation(c.config, OpUpdateOne, withAnalyticsDashboardID(id))
	return &AnalyticsDashboardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AnalyticsDashboard.
func (c *AnalyticsDashboardClient) Delete() *AnalyticsDashboardDelete {
	mutation := newAnalyticsDashboardMutation(c.config, OpDelete)
	return &AnalyticsDashboardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AnalyticsDashboardClient) DeleteOne(_m *AnalyticsDashboard) *AnalyticsDashboardDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AnalyticsDashboardClient) DeleteOneID(id int) *AnalyticsDashboardDeleteOne {
	builder := c.Delete().Where(analyticsdashboard.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnalyticsDashboardDeleteOne{builder}
}

// Query returns a query builder for AnalyticsDashboard.
func (c *AnalyticsDashboardClient) Query() *AnalyticsDashboardQuery {
	return &AnalyticsDashboardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAnalyticsDashboard},
		inters: c.Interceptors(),
	}
}

// Get returns a AnalyticsDashboard entity by its id.
func (c *AnalyticsDashboardClient) Get(ctx context.Context, id int) (*AnalyticsDashboard, error) {
	return c.Query().Where(analyticsdashboard.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnalyticsDashboardClient) GetX(ctx context.Context, id int) *AnalyticsDashboard {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a AnalyticsDashboard.
func (c *AnalyticsDashboardClient) QueryOwner(_m *AnalyticsDashboard) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(analyticsdashboard.Table, analyticsdashboard.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, analyticsdashboard.OwnerTable, analyticsdashboard.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWidgets queries the widgets edge of a AnalyticsDashboard.
func (c *AnalyticsDashboardClient) QueryWidgets(_m *AnalyticsDashboard) *DashboardWidgetQuery {
	query := (&DashboardWidgetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(analyticsdashboard.Table, analyticsdashboard.FieldID, id),
			sqlgraph.To(dashboardwidget.Table, dashboardwidget.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, analyticsdashboard.WidgetsTable, analyticsdashboard.WidgetsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnalyticsDashboardClient) Hooks() []Hook {
	return c.hooks.AnalyticsDashboard
}

// Interceptors returns the client interceptors.
func (c *AnalyticsDashboardClient) Interceptors() []Interceptor {
	return c.inters.AnalyticsDashboard
}

func (c *AnalyticsDashboardClient) mutate(ctx context.Context, m *AnalyticsDashboardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AnalyticsDashboardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AnalyticsDashboardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AnalyticsDashboardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AnalyticsDashboardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AnalyticsDashboard mutation op: %q", m.Op())
	}
}

// AnalyticsEventClient is a client for the AnalyticsEvent schema.
type AnalyticsEventClient struct {
	config
}

// NewAnalyticsEventClient returns a client for the AnalyticsEvent from the given config.
func NewAnalyticsEventClient(c config) *AnalyticsEventClient {
	return &AnalyticsEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `analyticsevent.Hooks(f(g(h())))`.
func (c *AnalyticsEventClient) Use(hooks ...Hook) {
	c.hooks.AnalyticsEvent = append(c.hooks.AnalyticsEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `analyticsevent.Intercept(f(g(h())))`.
func (c *AnalyticsEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.AnalyticsEvent = append(c.inters.AnalyticsEvent, interceptors...)
}

// Create returns a builder for creating a AnalyticsEvent entity.
func (c *AnalyticsEventClient) Create() *AnalyticsEventCreate {
	mutation := newAnalyticsEventMutation(c.config, OpCreate)
	return &AnalyticsEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AnalyticsEvent entities.
func (c *AnalyticsEventClient) CreateBulk(builders ...*AnalyticsEventCreate) *AnalyticsEventCreateBulk {
	return &AnalyticsEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AnalyticsEventClient) MapCreateBulk(slice any, setFunc func(*AnalyticsEventCreate, int)) *AnalyticsEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AnalyticsEventCreateBulk{err: fmt.Errorf("calling to AnalyticsEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AnalyticsEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AnalyticsEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AnalyticsEvent.
func (c *AnalyticsEventClient) Update() *AnalyticsEventUpdate {
	mutation := newAnalyticsEventMutation(c.config, OpUpdate)
	return &AnalyticsEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnalyticsEventClient) UpdateOne(_m *AnalyticsEvent) *AnalyticsEventUpdateOne {
	mutation := newAnalyticsEventMutation(c.config, OpUpdateOne, withAnalyticsEvent(_m))
	return &AnalyticsEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnalyticsEventClient) UpdateOneID(id int) *AnalyticsEventUpdateOne {
	mutation := newAnalyticsEventMutation(c.config, OpUpdateOne, withAnalyticsEventID(id))
	return &AnalyticsEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AnalyticsEvent.
func (c *AnalyticsEventClient) Delete() *AnalyticsEventDelete {
	mutation := newAnalyticsEventMutation(c.config, OpDelete)
	return &AnalyticsEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AnalyticsEventClient) DeleteOne(_m *AnalyticsEvent) *AnalyticsEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AnalyticsEventClient) DeleteOneID(id int) *AnalyticsEventDeleteOne {
	builder := c.Delete().Where(analyticsevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnalyticsEventDeleteOne{builder}
}

// Query returns a query builder for AnalyticsEvent.
func (c *AnalyticsEventClient) Query() *AnalyticsEventQuery {
	return &AnalyticsEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAnalyticsEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a AnalyticsEvent entity by its id.
func (c *AnalyticsEventClient) Get(ctx context.Context, id int) (*AnalyticsEvent, error) {
	return c.Query().Where(analyticsevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnalyticsEventClient) GetX(ctx context.Context, id int) *AnalyticsEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a AnalyticsEvent.
func (c *AnalyticsEventClient) QueryUser(_m *AnalyticsEvent) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(analyticsevent.Table, analyticsevent.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, analyticsevent.UserTable, analyticsevent.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnalyticsEventClient) Hooks() []Hook {
	return c.hooks.AnalyticsEvent
}

// Interceptors returns the client interceptors.
func (c *AnalyticsEventClient) Interceptors() []Interceptor {
	return c.inters.AnalyticsEvent
}

func (c *AnalyticsEventClient) mutate(ctx context.Context, m *AnalyticsEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AnalyticsEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AnalyticsEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AnalyticsEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AnalyticsEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AnalyticsEvent mutation op: %q", m.Op())
	}
}

// AppSettingClient is a client for the AppSetting schema.
type AppSettingClient struct {
	config
}

// NewAppSettingClient returns a client for the AppSetting from the given config.
func NewAppSettingClient(c config) *AppSettingClient {
	return &AppSettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appsetting.Hooks(f(g(h())))`.
func (c *AppSettingClient) Use(hooks ...Hook) {
	c.hooks.AppSetting = append(c.hooks.AppSetting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appsetting.Intercept(f(g(h())))`.
func (c *AppSettingClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppSetting = append(c.inters.AppSetting, interceptors...)
}

// Create returns a builder for creating a AppSetting entity.
func (c *AppSettingClient) Create() *AppSettingCreate {
	mutation := newAppSettingMutation(c.config, OpCreate)
	return &AppSettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppSetting entities.
func (c *AppSettingClient) CreateBulk(builders ...*AppSettingCreate) *AppSettingCreateBulk {
	return &AppSettingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppSettingClient) MapCreateBulk(slice any, setFunc func(*AppSettingCreate, int)) *AppSettingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppSettingCreateBulk{err: fmt.Errorf("calling to AppSettingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppSettingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppSettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppSetting.
func (c *AppSettingClient) Update() *AppSettingUpdate {
	mutation := newAppSettingMutation(c.config, OpUpdate)
	return &AppSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppSettingClient) UpdateOne(_m *AppSetting) *AppSettingUpdateOne {
	mutation := newAppSettingMutation(c.config, OpUpdateOne, withAppSetting(_m))
	return &AppSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppSettingClient) UpdateOneID(id string) *AppSettingUpdateOne {
	mutation := newAppSettingMutation(c.config, OpUpdateOne, withAppSettingID(id))
	return &AppSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppSetting.
func (c *AppSettingClient) Delete() *AppSettingDelete {
	mutation := newAppSettingMutation(c.config, OpDelete)
	return &AppSettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppSettingClient) DeleteOne(_m *AppSetting) *AppSettingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppSettingClient) DeleteOneID(id string) *AppSettingDeleteOne {
	builder := c.Delete().Where(appsetting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppSettingDeleteOne{builder}
}

// Query returns a query builder for AppSetting.
func (c *AppSettingClient) Query() *AppSettingQuery {
	return &AppSettingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppSetting},
		inters: c.Interceptors(),
	}
}

// Get returns a AppSetting entity by its id.
func (c *AppSettingClient) Get(ctx context.Context, id string) (*AppSetting, error) {
	return c.Query().Where(appsetting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppSettingClient) GetX(ctx context.Context, id string) *AppSetting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppSettingClient) Hooks() []Hook {
	return c.hooks.AppSetting
}

// Interceptors returns the client interceptors.
func (c *AppSettingClient) Interceptors() []Interceptor {
	return c.inters.AppSetting
}

func (c *AppSettingClient) mutate(ctx context.Context, m *AppSettingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppSettingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppSettingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppSettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppSettingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AppSetting mutation op: %q", m.Op())
	}
}

// AuditLogClient is a client for the AuditLog schema.
type AuditLogClient struct {
	config
}

// NewAuditLogClient returns a client for the AuditLog from the given config.
func NewAuditLogClient(c config) *AuditLogClient {
	return &AuditLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auditlog.Hooks(f(g(h())))`.
func (c *AuditLogClient) Use(hooks ...Hook) {
	c.hooks.AuditLog = append(c.hooks.AuditLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auditlog.Intercept(f(g(h())))`.
func (c *AuditLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuditLog = append(c.inters.AuditLog, interceptors...)
}

// Create returns a builder for creating a AuditLog entity.
func (c *AuditLogClient) Create() *AuditLogCreate {
	mutation := newAuditLogMutation(c.config, OpCreate)
	return &AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuditLog entities.
func (c *AuditLogClient) CreateBulk(builders ...*AuditLogCreate) *AuditLogCreateBulk {
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuditLogClient) MapCreateBulk(slice any, setFunc func(*AuditLogCreate, int)) *AuditLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuditLogCreateBulk{err: fmt.Errorf("calling to AuditLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuditLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuditLog.
func (c *AuditLogClient) Update() *AuditLogUpdate {
	mutation := newAuditLogMutation(c.config, OpUpdate)
	return &AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuditLogClient) UpdateOne(_m *AuditLog) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLog(_m))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuditLogClient) UpdateOneID(id int) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLogID(id))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuditLog.
func (c *AuditLogClient) Delete() *AuditLogDelete {
	mutation := newAuditLogMutation(c.config, OpDelete)
	return &AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuditLogClient) DeleteOne(_m *AuditLog) *AuditLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuditLogClient) DeleteOneID(id int) *AuditLogDeleteOne {
	builder := c.Delete().Where(auditlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuditLogDeleteOne{builder}
}

// Query returns a query builder for AuditLog.
func (c *AuditLogClient) Query() *AuditLogQuery {
	return &AuditLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuditLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AuditLog entity by its id.
func (c *AuditLogClient) Get(ctx context.Context, id int) (*AuditLog, error) {
	return c.Query().Where(auditlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuditLogClient) GetX(ctx context.Context, id int) *AuditLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryActor queries the actor edge of a AuditLog.
func (c *AuditLogClient) QueryActor(_m *AuditLog) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(auditlog.Table, auditlog.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, auditlog.ActorTable, auditlog.ActorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuditLogClient) Hooks() []Hook {
	return c.hooks.AuditLog
}

// Interceptors returns the client interceptors.
func (c *AuditLogClient) Interceptors() []Interceptor {
	return c.inters.AuditLog
}

func (c *AuditLogClient) mutate(ctx context.Context, m *AuditLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuditLog mutation op: %q", m.Op())
	}
}

// BadgeClient is a client for the Badge schema.
type BadgeClient struct {
	config
}

// NewBadgeClient returns a client for the Badge from the given config.
func NewBadgeClient(c config) *BadgeClient {
	return &BadgeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `badge.Hooks(f(g(h())))`.
func (c *BadgeClient) Use(hooks ...Hook) {
	c.hooks.Badge = append(c.hooks.Badge, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `badge.Intercept(f(g(h())))`.
func (c *BadgeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Badge = append(c.inters.Badge, interceptors...)
}

// Create returns a builder for creating a Badge entity.
func (c *BadgeClient) Create() *BadgeCreate {
	mutation := newBadgeMutation(c.config, OpCreate)
	return &BadgeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Badge entities.
func (c *BadgeClient) CreateBulk(builders ...*BadgeCreate) *BadgeCreateBulk {
	return &BadgeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BadgeClient) MapCreateBulk(slice any, setFunc func(*BadgeCreate, int)) *BadgeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BadgeCreateBulk{err: fmt.Errorf("calling to BadgeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BadgeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BadgeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Badge.
func (c *BadgeClient) Update() *BadgeUpdate {
	mutation := newBadgeMutation(c.config, OpUpdate)
	return &BadgeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BadgeClient) UpdateOne(_m *Badge) *BadgeUpdateOne {
	mutation := newBadgeMutation(c.config, OpUpdateOne, withBadge(_m))
	return &BadgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BadgeClient) UpdateOneID(id int) *BadgeUpdateOne {
	mutation := newBadgeMutation(c.config, OpUpdateOne, withBadgeID(id))
	return &BadgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Badge.
func (c *BadgeClient) Delete() *BadgeDelete {
	mutation := newBadgeMutation(c.config, OpDelete)
	return &BadgeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BadgeClient) DeleteOne(_m *Badge) *BadgeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BadgeClient) DeleteOneID(id int) *BadgeDeleteOne {
	builder := c.Delete().Where(badge.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BadgeDeleteOne{builder}
}

// Query returns a query builder for Badge.
func (c *BadgeClient) Query() *BadgeQuery {
	return &BadgeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBadge},
		inters: c.Interceptors(),
	}
}

// Get returns a Badge entity by its id.
func (c *BadgeClient) Get(ctx context.Context, id int) (*Badge, error) {
	return c.Query().Where(badge.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BadgeClient) GetX(ctx context.Context, id int) *Badge {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserAchievements queries the user_achievements edge of a Badge.
func (c *BadgeClient) QueryUserAchievements(_m *Badge) *UserAchievementQuery {
	query := (&UserAchievementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(badge.Table, badge.FieldID, id),
			sqlgraph.To(userachievement.Table, userachievement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, badge.UserAchievementsTable, badge.UserAchievementsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BadgeClient) Hooks() []Hook {
	return c.hooks.Badge
}

// Interceptors returns the client interceptors.
func (c *BadgeClient) Interceptors() []Interceptor {
	return c.inters.Badge
}

func (c *BadgeClient) mutate(ctx context.Context, m *BadgeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BadgeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BadgeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BadgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BadgeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Badge mutation op: %q", m.Op())
	}
}

// BallotClient is a client for the Ballot schema.
type BallotClient struct {
	config
}

// NewBallotClient returns a client for the Ballot from the given config.
func NewBallotClient(c config) *BallotClient {
	return &BallotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ballot.Hooks(f(g(h())))`.
func (c *BallotClient) Use(hooks ...Hook) {
	c.hooks.Ballot = append(c.hooks.Ballot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ballot.Intercept(f(g(h())))`.
func (c *BallotClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ballot = append(c.inters.Ballot, interceptors...)
}

// Create returns a builder for creating a Ballot entity.
func (c *BallotClient) Create() *BallotCreate {
	mutation := newBallotMutation(c.config, OpCreate)
	return &BallotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ballot entities.
func (c *BallotClient) CreateBulk(builders ...*BallotCreate) *BallotCreateBulk {
	return &BallotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BallotClient) MapCreateBulk(slice any, setFunc func(*BallotCreate, int)) *BallotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BallotCreateBulk{err: fmt.Errorf("calling to BallotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BallotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BallotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ballot.
func (c *BallotClient) Update() *BallotUpdate {
	mutation := newBallotMutation(c.config, OpUpdate)
	return &BallotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BallotClient) UpdateOne(_m *Ballot) *BallotUpdateOne {
	mutation := newBallotMutation(c.config, OpUpdateOne, withBallot(_m))
	return &BallotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BallotClient) UpdateOneID(id int) *BallotUpdateOne {
	mutation := newBallotMutation(c.config, OpUpdateOne, withBallotID(id))
	return &BallotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ballot.
func (c *BallotClient) Delete() *BallotDelete {
	mutation := newBallotMutation(c.config, OpDelete)
	return &BallotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BallotClient) DeleteOne(_m *Ballot) *BallotDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BallotClient) DeleteOneID(id int) *BallotDeleteOne {
	builder := c.Delete().Where(ballot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BallotDeleteOne{builder}
}

// Query returns a query builder for Ballot.
func (c *BallotClient) Query() *BallotQuery {
	return &BallotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBallot},
		inters: c.Interceptors(),
	}
}

// Get returns a Ballot entity by its id.
func (c *BallotClient) Get(ctx context.Context, id int) (*Ballot, error) {
	return c.Query().Where(ballot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BallotClient) GetX(ctx context.Context, id int) *Ballot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVote queries the vote edge of a Ballot.
func (c *BallotClient) QueryVote(_m *Ballot) *VoteQuery {
	query := (&VoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ballot.Table, ballot.FieldID, id),
			sqlgraph.To(vote.Table, vote.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ballot.VoteTable, ballot.VoteColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BallotClient) Hooks() []Hook {
	return c.hooks.Ballot
}

// Interceptors returns the client interceptors.
func (c *BallotClient) Interceptors() []Interceptor {
	return c.inters.Ballot
}

func (c *BallotClient) mutate(ctx context.Context, m *BallotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BallotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BallotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BallotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BallotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Ballot mutation op: %q", m.Op())
	}
}

// BlockAccordionClient is a client for the BlockAccordion schema.
type BlockAccordionClient struct {
	config
}

// NewBlockAccordionClient returns a client for the BlockAccordion from the given config.
func NewBlockAccordionClient(c config) *BlockAccordionClient {
	return &BlockAccordionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockaccordion.Hooks(f(g(h())))`.
func (c *BlockAccordionClient) Use(hooks ...Hook) {
	c.hooks.BlockAccordion = append(c.hooks.BlockAccordion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockaccordion.Intercept(f(g(h())))`.
func (c *BlockAccordionClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockAccordion = append(c.inters.BlockAccordion, interceptors...)
}

// Create returns a builder for creating a BlockAccordion entity.
func (c *BlockAccordionClient) Create() *BlockAccordionCreate {
	mutation := newBlockAccordionMutation(c.config, OpCreate)
	return &BlockAccordionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockAccordion entities.
func (c *BlockAccordionClient) CreateBulk(builders ...*BlockAccordionCreate) *BlockAccordionCreateBulk {
	return &BlockAccordionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockAccordionClient) MapCreateBulk(slice any, setFunc func(*BlockAccordionCreate, int)) *BlockAccordionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockAccordionCreateBulk{err: fmt.Errorf("calling to BlockAccordionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockAccordionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockAccordionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockAccordion.
func (c *BlockAccordionClient) Update() *BlockAccordionUpdate {
	mutation := newBlockAccordionMutation(c.config, OpUpdate)
	return &BlockAccordionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockAccordionClient) UpdateOne(_m *BlockAccordion) *BlockAccordionUpdateOne {
	mutation := newBlockAccordionMutation(c.config, OpUpdateOne, withBlockAccordion(_m))
	return &BlockAccordionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockAccordionClient) UpdateOneID(id int) *BlockAccordionUpdateOne {
	mutation := newBlockAccordionMutation(c.config, OpUpdateOne, withBlockAccordionID(id))
	return &BlockAccordionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockAccordion.
func (c *BlockAccordionClient) Delete() *BlockAccordionDelete {
	mutation := newBlockAccordionMutation(c.config, OpDelete)
	return &BlockAccordionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockAccordionClient) DeleteOne(_m *BlockAccordion) *BlockAccordionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockAccordionClient) DeleteOneID(id int) *BlockAccordionDeleteOne {
	builder := c.Delete().Where(blockaccordion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockAccordionDeleteOne{builder}
}

// Query returns a query builder for BlockAccordion.
func (c *BlockAccordionClient) Query() *BlockAccordionQuery {
	return &BlockAccordionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockAccordion},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockAccordion entity by its id.
func (c *BlockAccordionClient) Get(ctx context.Context, id int) (*BlockAccordion, error) {
	return c.Query().Where(blockaccordion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockAccordionClient) GetX(ctx context.Context, id int) *BlockAccordion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockAccordion.
func (c *BlockAccordionClient) QueryContentBlock(_m *BlockAccordion) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockaccordion.Table, blockaccordion.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockaccordion.ContentBlockTable, blockaccordion.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItems queries the items edge of a BlockAccordion.
func (c *BlockAccordionClient) QueryItems(_m *BlockAccordion) *AccordionItemQuery {
	query := (&AccordionItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockaccordion.Table, blockaccordion.FieldID, id),
			sqlgraph.To(accordionitem.Table, accordionitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, blockaccordion.ItemsTable, blockaccordion.ItemsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockAccordionClient) Hooks() []Hook {
	return c.hooks.BlockAccordion
}

// Interceptors returns the client interceptors.
func (c *BlockAccordionClient) Interceptors() []Interceptor {
	return c.inters.BlockAccordion
}

func (c *BlockAccordionClient) mutate(ctx context.Context, m *BlockAccordionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockAccordionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockAccordionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockAccordionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockAccordionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockAccordion mutation op: %q", m.Op())
	}
}

// BlockContactFormClient is a client for the BlockContactForm schema.
type BlockContactFormClient struct {
	config
}

// NewBlockContactFormClient returns a client for the BlockContactForm from the given config.
func NewBlockContactFormClient(c config) *BlockContactFormClient {
	return &BlockContactFormClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockcontactform.Hooks(f(g(h())))`.
func (c *BlockContactFormClient) Use(hooks ...Hook) {
	c.hooks.BlockContactForm = append(c.hooks.BlockContactForm, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockcontactform.Intercept(f(g(h())))`.
func (c *BlockContactFormClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockContactForm = append(c.inters.BlockContactForm, interceptors...)
}

// Create returns a builder for creating a BlockContactForm entity.
func (c *BlockContactFormClient) Create() *BlockContactFormCreate {
	mutation := newBlockContactFormMutation(c.config, OpCreate)
	return &BlockContactFormCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockContactForm entities.
func (c *BlockContactFormClient) CreateBulk(builders ...*BlockContactFormCreate) *BlockContactFormCreateBulk {
	return &BlockContactFormCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockContactFormClient) MapCreateBulk(slice any, setFunc func(*BlockContactFormCreate, int)) *BlockContactFormCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockContactFormCreateBulk{err: fmt.Errorf("calling to BlockContactFormClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockContactFormCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockContactFormCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockContactForm.
func (c *BlockContactFormClient) Update() *BlockContactFormUpdate {
	mutation := newBlockContactFormMutation(c.config, OpUpdate)
	return &BlockContactFormUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockContactFormClient) UpdateOne(_m *BlockContactForm) *BlockContactFormUpdateOne {
	mutation := newBlockContactFormMutation(c.config, OpUpdateOne, withBlockContactForm(_m))
	return &BlockContactFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockContactFormClient) UpdateOneID(id int) *BlockContactFormUpdateOne {
	mutation := newBlockContactFormMutation(c.config, OpUpdateOne, withBlockContactFormID(id))
	return &BlockContactFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockContactForm.
func (c *BlockContactFormClient) Delete() *BlockContactFormDelete {
	mutation := newBlockContactFormMutation(c.config, OpDelete)
	return &BlockContactFormDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockContactFormClient) DeleteOne(_m *BlockContactForm) *BlockContactFormDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockContactFormClient) DeleteOneID(id int) *BlockContactFormDeleteOne {
	builder := c.Delete().Where(blockcontactform.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockContactFormDeleteOne{builder}
}

// Query returns a query builder for BlockContactForm.
func (c *BlockContactFormClient) Query() *BlockContactFormQuery {
	return &BlockContactFormQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockContactForm},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockContactForm entity by its id.
func (c *BlockContactFormClient) Get(ctx context.Context, id int) (*BlockContactForm, error) {
	return c.Query().Where(blockcontactform.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockContactFormClient) GetX(ctx context.Context, id int) *BlockContactForm {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockContactForm.
func (c *BlockContactFormClient) QueryContentBlock(_m *BlockContactForm) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockcontactform.Table, blockcontactform.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockcontactform.ContentBlockTable, blockcontactform.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockContactFormClient) Hooks() []Hook {
	return c.hooks.BlockContactForm
}

// Interceptors returns the client interceptors.
func (c *BlockContactFormClient) Interceptors() []Interceptor {
	return c.inters.BlockContactForm
}

func (c *BlockContactFormClient) mutate(ctx context.Context, m *BlockContactFormMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockContactFormCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockContactFormUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockContactFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockContactFormDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockContactForm mutation op: %q", m.Op())
	}
}

// BlockCtaClient is a client for the BlockCta schema.
type BlockCtaClient struct {
	config
}

// NewBlockCtaClient returns a client for the BlockCta from the given config.
func NewBlockCtaClient(c config) *BlockCtaClient {
	return &BlockCtaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockcta.Hooks(f(g(h())))`.
func (c *BlockCtaClient) Use(hooks ...Hook) {
	c.hooks.BlockCta = append(c.hooks.BlockCta, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockcta.Intercept(f(g(h())))`.
func (c *BlockCtaClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockCta = append(c.inters.BlockCta, interceptors...)
}

// Create returns a builder for creating a BlockCta entity.
func (c *BlockCtaClient) Create() *BlockCtaCreate {
	mutation := newBlockCtaMutation(c.config, OpCreate)
	return &BlockCtaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockCta entities.
func (c *BlockCtaClient) CreateBulk(builders ...*BlockCtaCreate) *BlockCtaCreateBulk {
	return &BlockCtaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockCtaClient) MapCreateBulk(slice any, setFunc func(*BlockCtaCreate, int)) *BlockCtaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockCtaCreateBulk{err: fmt.Errorf("calling to BlockCtaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockCtaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockCtaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockCta.
func (c *BlockCtaClient) Update() *BlockCtaUpdate {
	mutation := newBlockCtaMutation(c.config, OpUpdate)
	return &BlockCtaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockCtaClient) UpdateOne(_m *BlockCta) *BlockCtaUpdateOne {
	mutation := newBlockCtaMutation(c.config, OpUpdateOne, withBlockCta(_m))
	return &BlockCtaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockCtaClient) UpdateOneID(id int) *BlockCtaUpdateOne {
	mutation := newBlockCtaMutation(c.config, OpUpdateOne, withBlockCtaID(id))
	return &BlockCtaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockCta.
func (c *BlockCtaClient) Delete() *BlockCtaDelete {
	mutation := newBlockCtaMutation(c.config, OpDelete)
	return &BlockCtaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockCtaClient) DeleteOne(_m *BlockCta) *BlockCtaDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockCtaClient) DeleteOneID(id int) *BlockCtaDeleteOne {
	builder := c.Delete().Where(blockcta.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockCtaDeleteOne{builder}
}

// Query returns a query builder for BlockCta.
func (c *BlockCtaClient) Query() *BlockCtaQuery {
	return &BlockCtaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockCta},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockCta entity by its id.
func (c *BlockCtaClient) Get(ctx context.Context, id int) (*BlockCta, error) {
	return c.Query().Where(blockcta.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockCtaClient) GetX(ctx context.Context, id int) *BlockCta {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockCta.
func (c *BlockCtaClient) QueryContentBlock(_m *BlockCta) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockcta.Table, blockcta.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockcta.ContentBlockTable, blockcta.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockCtaClient) Hooks() []Hook {
	return c.hooks.BlockCta
}

// Interceptors returns the client interceptors.
func (c *BlockCtaClient) Interceptors() []Interceptor {
	return c.inters.BlockCta
}

func (c *BlockCtaClient) mutate(ctx context.Context, m *BlockCtaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockCtaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockCtaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockCtaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockCtaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockCta mutation op: %q", m.Op())
	}
}

// BlockDividerClient is a client for the BlockDivider schema.
type BlockDividerClient struct {
	config
}

// NewBlockDividerClient returns a client for the BlockDivider from the given config.
func NewBlockDividerClient(c config) *BlockDividerClient {
	return &BlockDividerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockdivider.Hooks(f(g(h())))`.
func (c *BlockDividerClient) Use(hooks ...Hook) {
	c.hooks.BlockDivider = append(c.hooks.BlockDivider, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockdivider.Intercept(f(g(h())))`.
func (c *BlockDividerClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockDivider = append(c.inters.BlockDivider, interceptors...)
}

// Create returns a builder for creating a BlockDivider entity.
func (c *BlockDividerClient) Create() *BlockDividerCreate {
	mutation := newBlockDividerMutation(c.config, OpCreate)
	return &BlockDividerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockDivider entities.
func (c *BlockDividerClient) CreateBulk(builders ...*BlockDividerCreate) *BlockDividerCreateBulk {
	return &BlockDividerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockDividerClient) MapCreateBulk(slice any, setFunc func(*BlockDividerCreate, int)) *BlockDividerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockDividerCreateBulk{err: fmt.Errorf("calling to BlockDividerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockDividerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockDividerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockDivider.
func (c *BlockDividerClient) Update() *BlockDividerUpdate {
	mutation := newBlockDividerMutation(c.config, OpUpdate)
	return &BlockDividerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockDividerClient) UpdateOne(_m *BlockDivider) *BlockDividerUpdateOne {
	mutation := newBlockDividerMutation(c.config, OpUpdateOne, withBlockDivider(_m))
	return &BlockDividerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockDividerClient) UpdateOneID(id int) *BlockDividerUpdateOne {
	mutation := newBlockDividerMutation(c.config, OpUpdateOne, withBlockDividerID(id))
	return &BlockDividerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockDivider.
func (c *BlockDividerClient) Delete() *BlockDividerDelete {
	mutation := newBlockDividerMutation(c.config, OpDelete)
	return &BlockDividerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockDividerClient) DeleteOne(_m *BlockDivider) *BlockDividerDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockDividerClient) DeleteOneID(id int) *BlockDividerDeleteOne {
	builder := c.Delete().Where(blockdivider.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockDividerDeleteOne{builder}
}

// Query returns a query builder for BlockDivider.
func (c *BlockDividerClient) Query() *BlockDividerQuery {
	return &BlockDividerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockDivider},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockDivider entity by its id.
func (c *BlockDividerClient) Get(ctx context.Context, id int) (*BlockDivider, error) {
	return c.Query().Where(blockdivider.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockDividerClient) GetX(ctx context.Context, id int) *BlockDivider {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockDivider.
func (c *BlockDividerClient) QueryContentBlock(_m *BlockDivider) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockdivider.Table, blockdivider.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockdivider.ContentBlockTable, blockdivider.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockDividerClient) Hooks() []Hook {
	return c.hooks.BlockDivider
}

// Interceptors returns the client interceptors.
func (c *BlockDividerClient) Interceptors() []Interceptor {
	return c.inters.BlockDivider
}

func (c *BlockDividerClient) mutate(ctx context.Context, m *BlockDividerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockDividerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockDividerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockDividerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockDividerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockDivider mutation op: %q", m.Op())
	}
}

// BlockDonationFormClient is a client for the BlockDonationForm schema.
type BlockDonationFormClient struct {
	config
}

// NewBlockDonationFormClient returns a client for the BlockDonationForm from the given config.
func NewBlockDonationFormClient(c config) *BlockDonationFormClient {
	return &BlockDonationFormClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockdonationform.Hooks(f(g(h())))`.
func (c *BlockDonationFormClient) Use(hooks ...Hook) {
	c.hooks.BlockDonationForm = append(c.hooks.BlockDonationForm, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockdonationform.Intercept(f(g(h())))`.
func (c *BlockDonationFormClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockDonationForm = append(c.inters.BlockDonationForm, interceptors...)
}

// Create returns a builder for creating a BlockDonationForm entity.
func (c *BlockDonationFormClient) Create() *BlockDonationFormCreate {
	mutation := newBlockDonationFormMutation(c.config, OpCreate)
	return &BlockDonationFormCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockDonationForm entities.
func (c *BlockDonationFormClient) CreateBulk(builders ...*BlockDonationFormCreate) *BlockDonationFormCreateBulk {
	return &BlockDonationFormCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockDonationFormClient) MapCreateBulk(slice any, setFunc func(*BlockDonationFormCreate, int)) *BlockDonationFormCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockDonationFormCreateBulk{err: fmt.Errorf("calling to BlockDonationFormClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockDonationFormCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockDonationFormCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockDonationForm.
func (c *BlockDonationFormClient) Update() *BlockDonationFormUpdate {
	mutation := newBlockDonationFormMutation(c.config, OpUpdate)
	return &BlockDonationFormUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockDonationFormClient) UpdateOne(_m *BlockDonationForm) *BlockDonationFormUpdateOne {
	mutation := newBlockDonationFormMutation(c.config, OpUpdateOne, withBlockDonationForm(_m))
	return &BlockDonationFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockDonationFormClient) UpdateOneID(id int) *BlockDonationFormUpdateOne {
	mutation := newBlockDonationFormMutation(c.config, OpUpdateOne, withBlockDonationFormID(id))
	return &BlockDonationFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockDonationForm.
func (c *BlockDonationFormClient) Delete() *BlockDonationFormDelete {
	mutation := newBlockDonationFormMutation(c.config, OpDelete)
	return &BlockDonationFormDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockDonationFormClient) DeleteOne(_m *BlockDonationForm) *BlockDonationFormDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockDonationFormClient) DeleteOneID(id int) *BlockDonationFormDeleteOne {
	builder := c.Delete().Where(blockdonationform.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockDonationFormDeleteOne{builder}
}

// Query returns a query builder for BlockDonationForm.
func (c *BlockDonationFormClient) Query() *BlockDonationFormQuery {
	return &BlockDonationFormQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockDonationForm},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockDonationForm entity by its id.
func (c *BlockDonationFormClient) Get(ctx context.Context, id int) (*BlockDonationForm, error) {
	return c.Query().Where(blockdonationform.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockDonationFormClient) GetX(ctx context.Context, id int) *BlockDonationForm {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockDonationForm.
func (c *BlockDonationFormClient) QueryContentBlock(_m *BlockDonationForm) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockdonationform.Table, blockdonationform.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockdonationform.ContentBlockTable, blockdonationform.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockDonationFormClient) Hooks() []Hook {
	return c.hooks.BlockDonationForm
}

// Interceptors returns the client interceptors.
func (c *BlockDonationFormClient) Interceptors() []Interceptor {
	return c.inters.BlockDonationForm
}

func (c *BlockDonationFormClient) mutate(ctx context.Context, m *BlockDonationFormMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockDonationFormCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockDonationFormUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockDonationFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockDonationFormDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockDonationForm mutation op: %q", m.Op())
	}
}

// BlockFaqClient is a client for the BlockFaq schema.
type BlockFaqClient struct {
	config
}

// NewBlockFaqClient returns a client for the BlockFaq from the given config.
func NewBlockFaqClient(c config) *BlockFaqClient {
	return &BlockFaqClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockfaq.Hooks(f(g(h())))`.
func (c *BlockFaqClient) Use(hooks ...Hook) {
	c.hooks.BlockFaq = append(c.hooks.BlockFaq, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockfaq.Intercept(f(g(h())))`.
func (c *BlockFaqClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockFaq = append(c.inters.BlockFaq, interceptors...)
}

// Create returns a builder for creating a BlockFaq entity.
func (c *BlockFaqClient) Create() *BlockFaqCreate {
	mutation := newBlockFaqMutation(c.config, OpCreate)
	return &BlockFaqCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockFaq entities.
func (c *BlockFaqClient) CreateBulk(builders ...*BlockFaqCreate) *BlockFaqCreateBulk {
	return &BlockFaqCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockFaqClient) MapCreateBulk(slice any, setFunc func(*BlockFaqCreate, int)) *BlockFaqCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockFaqCreateBulk{err: fmt.Errorf("calling to BlockFaqClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockFaqCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockFaqCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockFaq.
func (c *BlockFaqClient) Update() *BlockFaqUpdate {
	mutation := newBlockFaqMutation(c.config, OpUpdate)
	return &BlockFaqUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockFaqClient) UpdateOne(_m *BlockFaq) *BlockFaqUpdateOne {
	mutation := newBlockFaqMutation(c.config, OpUpdateOne, withBlockFaq(_m))
	return &BlockFaqUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockFaqClient) UpdateOneID(id int) *BlockFaqUpdateOne {
	mutation := newBlockFaqMutation(c.config, OpUpdateOne, withBlockFaqID(id))
	return &BlockFaqUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockFaq.
func (c *BlockFaqClient) Delete() *BlockFaqDelete {
	mutation := newBlockFaqMutation(c.config, OpDelete)
	return &BlockFaqDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockFaqClient) DeleteOne(_m *BlockFaq) *BlockFaqDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockFaqClient) DeleteOneID(id int) *BlockFaqDeleteOne {
	builder := c.Delete().Where(blockfaq.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockFaqDeleteOne{builder}
}

// Query returns a query builder for BlockFaq.
func (c *BlockFaqClient) Query() *BlockFaqQuery {
	return &BlockFaqQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockFaq},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockFaq entity by its id.
func (c *BlockFaqClient) Get(ctx context.Context, id int) (*BlockFaq, error) {
	return c.Query().Where(blockfaq.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockFaqClient) GetX(ctx context.Context, id int) *BlockFaq {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockFaq.
func (c *BlockFaqClient) QueryContentBlock(_m *BlockFaq) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockfaq.Table, blockfaq.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockfaq.ContentBlockTable, blockfaq.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItems queries the items edge of a BlockFaq.
func (c *BlockFaqClient) QueryItems(_m *BlockFaq) *FaqItemQuery {
	query := (&FaqItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockfaq.Table, blockfaq.FieldID, id),
			sqlgraph.To(faqitem.Table, faqitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, blockfaq.ItemsTable, blockfaq.ItemsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockFaqClient) Hooks() []Hook {
	return c.hooks.BlockFaq
}

// Interceptors returns the client interceptors.
func (c *BlockFaqClient) Interceptors() []Interceptor {
	return c.inters.BlockFaq
}

func (c *BlockFaqClient) mutate(ctx context.Context, m *BlockFaqMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockFaqCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockFaqUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockFaqUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockFaqDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockFaq mutation op: %q", m.Op())
	}
}

// BlockGalleryClient is a client for the BlockGallery schema.
type BlockGalleryClient struct {
	config
}

// NewBlockGalleryClient returns a client for the BlockGallery from the given config.
func NewBlockGalleryClient(c config) *BlockGalleryClient {
	return &BlockGalleryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockgallery.Hooks(f(g(h())))`.
func (c *BlockGalleryClient) Use(hooks ...Hook) {
	c.hooks.BlockGallery = append(c.hooks.BlockGallery, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockgallery.Intercept(f(g(h())))`.
func (c *BlockGalleryClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockGallery = append(c.inters.BlockGallery, interceptors...)
}

// Create returns a builder for creating a BlockGallery entity.
func (c *BlockGalleryClient) Create() *BlockGalleryCreate {
	mutation := newBlockGalleryMutation(c.config, OpCreate)
	return &BlockGalleryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockGallery entities.
func (c *BlockGalleryClient) CreateBulk(builders ...*BlockGalleryCreate) *BlockGalleryCreateBulk {
	return &BlockGalleryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockGalleryClient) MapCreateBulk(slice any, setFunc func(*BlockGalleryCreate, int)) *BlockGalleryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockGalleryCreateBulk{err: fmt.Errorf("calling to BlockGalleryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockGalleryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockGalleryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockGallery.
func (c *BlockGalleryClient) Update() *BlockGalleryUpdate {
	mutation := newBlockGalleryMutation(c.config, OpUpdate)
	return &BlockGalleryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockGalleryClient) UpdateOne(_m *BlockGallery) *BlockGalleryUpdateOne {
	mutation := newBlockGalleryMutation(c.config, OpUpdateOne, withBlockGallery(_m))
	return &BlockGalleryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockGalleryClient) UpdateOneID(id int) *BlockGalleryUpdateOne {
	mutation := newBlockGalleryMutation(c.config, OpUpdateOne, withBlockGalleryID(id))
	return &BlockGalleryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockGallery.
func (c *BlockGalleryClient) Delete() *BlockGalleryDelete {
	mutation := newBlockGalleryMutation(c.config, OpDelete)
	return &BlockGalleryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockGalleryClient) DeleteOne(_m *BlockGallery) *BlockGalleryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockGalleryClient) DeleteOneID(id int) *BlockGalleryDeleteOne {
	builder := c.Delete().Where(blockgallery.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockGalleryDeleteOne{builder}
}

// Query returns a query builder for BlockGallery.
func (c *BlockGalleryClient) Query() *BlockGalleryQuery {
	return &BlockGalleryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockGallery},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockGallery entity by its id.
func (c *BlockGalleryClient) Get(ctx context.Context, id int) (*BlockGallery, error) {
	return c.Query().Where(blockgallery.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockGalleryClient) GetX(ctx context.Context, id int) *BlockGallery {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockGallery.
func (c *BlockGalleryClient) QueryContentBlock(_m *BlockGallery) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockgallery.Table, blockgallery.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockgallery.ContentBlockTable, blockgallery.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImages queries the images edge of a BlockGallery.
func (c *BlockGalleryClient) QueryImages(_m *BlockGallery) *GalleryImageQuery {
	query := (&GalleryImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockgallery.Table, blockgallery.FieldID, id),
			sqlgraph.To(galleryimage.Table, galleryimage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, blockgallery.ImagesTable, blockgallery.ImagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockGalleryClient) Hooks() []Hook {
	return c.hooks.BlockGallery
}

// Interceptors returns the client interceptors.
func (c *BlockGalleryClient) Interceptors() []Interceptor {
	return c.inters.BlockGallery
}

func (c *BlockGalleryClient) mutate(ctx context.Context, m *BlockGalleryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockGalleryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockGalleryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockGalleryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockGalleryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockGallery mutation op: %q", m.Op())
	}
}

// BlockHeroClient is a client for the BlockHero schema.
type BlockHeroClient struct {
	config
}

// NewBlockHeroClient returns a client for the BlockHero from the given config.
func NewBlockHeroClient(c config) *BlockHeroClient {
	return &BlockHeroClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockhero.Hooks(f(g(h())))`.
func (c *BlockHeroClient) Use(hooks ...Hook) {
	c.hooks.BlockHero = append(c.hooks.BlockHero, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockhero.Intercept(f(g(h())))`.
func (c *BlockHeroClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockHero = append(c.inters.BlockHero, interceptors...)
}

// Create returns a builder for creating a BlockHero entity.
func (c *BlockHeroClient) Create() *BlockHeroCreate {
	mutation := newBlockHeroMutation(c.config, OpCreate)
	return &BlockHeroCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockHero entities.
func (c *BlockHeroClient) CreateBulk(builders ...*BlockHeroCreate) *BlockHeroCreateBulk {
	return &BlockHeroCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockHeroClient) MapCreateBulk(slice any, setFunc func(*BlockHeroCreate, int)) *BlockHeroCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockHeroCreateBulk{err: fmt.Errorf("calling to BlockHeroClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockHeroCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockHeroCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockHero.
func (c *BlockHeroClient) Update() *BlockHeroUpdate {
	mutation := newBlockHeroMutation(c.config, OpUpdate)
	return &BlockHeroUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockHeroClient) UpdateOne(_m *BlockHero) *BlockHeroUpdateOne {
	mutation := newBlockHeroMutation(c.config, OpUpdateOne, withBlockHero(_m))
	return &BlockHeroUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockHeroClient) UpdateOneID(id int) *BlockHeroUpdateOne {
	mutation := newBlockHeroMutation(c.config, OpUpdateOne, withBlockHeroID(id))
	return &BlockHeroUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockHero.
func (c *BlockHeroClient) Delete() *BlockHeroDelete {
	mutation := newBlockHeroMutation(c.config, OpDelete)
	return &BlockHeroDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockHeroClient) DeleteOne(_m *BlockHero) *BlockHeroDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockHeroClient) DeleteOneID(id int) *BlockHeroDeleteOne {
	builder := c.Delete().Where(blockhero.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockHeroDeleteOne{builder}
}

// Query returns a query builder for BlockHero.
func (c *BlockHeroClient) Query() *BlockHeroQuery {
	return &BlockHeroQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockHero},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockHero entity by its id.
func (c *BlockHeroClient) Get(ctx context.Context, id int) (*BlockHero, error) {
	return c.Query().Where(blockhero.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockHeroClient) GetX(ctx context.Context, id int) *BlockHero {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockHero.
func (c *BlockHeroClient) QueryContentBlock(_m *BlockHero) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockhero.Table, blockhero.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockhero.ContentBlockTable, blockhero.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockHeroClient) Hooks() []Hook {
	return c.hooks.BlockHero
}

// Interceptors returns the client interceptors.
func (c *BlockHeroClient) Interceptors() []Interceptor {
	return c.inters.BlockHero
}

func (c *BlockHeroClient) mutate(ctx context.Context, m *BlockHeroMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockHeroCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockHeroUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockHeroUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockHeroDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockHero mutation op: %q", m.Op())
	}
}

// BlockMapClient is a client for the BlockMap schema.
type BlockMapClient struct {
	config
}

// NewBlockMapClient returns a client for the BlockMap from the given config.
func NewBlockMapClient(c config) *BlockMapClient {
	return &BlockMapClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockmap.Hooks(f(g(h())))`.
func (c *BlockMapClient) Use(hooks ...Hook) {
	c.hooks.BlockMap = append(c.hooks.BlockMap, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockmap.Intercept(f(g(h())))`.
func (c *BlockMapClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockMap = append(c.inters.BlockMap, interceptors...)
}

// Create returns a builder for creating a BlockMap entity.
func (c *BlockMapClient) Create() *BlockMapCreate {
	mutation := newBlockMapMutation(c.config, OpCreate)
	return &BlockMapCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockMap entities.
func (c *BlockMapClient) CreateBulk(builders ...*BlockMapCreate) *BlockMapCreateBulk {
	return &BlockMapCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockMapClient) MapCreateBulk(slice any, setFunc func(*BlockMapCreate, int)) *BlockMapCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockMapCreateBulk{err: fmt.Errorf("calling to BlockMapClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockMapCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockMapCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockMap.
func (c *BlockMapClient) Update() *BlockMapUpdate {
	mutation := newBlockMapMutation(c.config, OpUpdate)
	return &BlockMapUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockMapClient) UpdateOne(_m *BlockMap) *BlockMapUpdateOne {
	mutation := newBlockMapMutation(c.config, OpUpdateOne, withBlockMap(_m))
	return &BlockMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockMapClient) UpdateOneID(id int) *BlockMapUpdateOne {
	mutation := newBlockMapMutation(c.config, OpUpdateOne, withBlockMapID(id))
	return &BlockMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockMap.
func (c *BlockMapClient) Delete() *BlockMapDelete {
	mutation := newBlockMapMutation(c.config, OpDelete)
	return &BlockMapDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockMapClient) DeleteOne(_m *BlockMap) *BlockMapDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockMapClient) DeleteOneID(id int) *BlockMapDeleteOne {
	builder := c.Delete().Where(blockmap.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockMapDeleteOne{builder}
}

// Query returns a query builder for BlockMap.
func (c *BlockMapClient) Query() *BlockMapQuery {
	return &BlockMapQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockMap},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockMap entity by its id.
func (c *BlockMapClient) Get(ctx context.Context, id int) (*BlockMap, error) {
	return c.Query().Where(blockmap.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockMapClient) GetX(ctx context.Context, id int) *BlockMap {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockMap.
func (c *BlockMapClient) QueryContentBlock(_m *BlockMap) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockmap.Table, blockmap.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockmap.ContentBlockTable, blockmap.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockMapClient) Hooks() []Hook {
	return c.hooks.BlockMap
}

// Interceptors returns the client interceptors.
func (c *BlockMapClient) Interceptors() []Interceptor {
	return c.inters.BlockMap
}

func (c *BlockMapClient) mutate(ctx context.Context, m *BlockMapMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockMapCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockMapUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockMapDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockMap mutation op: %q", m.Op())
	}
}

// BlockNewsletterSignupClient is a client for the BlockNewsletterSignup schema.
type BlockNewsletterSignupClient struct {
	config
}

// NewBlockNewsletterSignupClient returns a client for the BlockNewsletterSignup from the given config.
func NewBlockNewsletterSignupClient(c config) *BlockNewsletterSignupClient {
	return &BlockNewsletterSignupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blocknewslettersignup.Hooks(f(g(h())))`.
func (c *BlockNewsletterSignupClient) Use(hooks ...Hook) {
	c.hooks.BlockNewsletterSignup = append(c.hooks.BlockNewsletterSignup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blocknewslettersignup.Intercept(f(g(h())))`.
func (c *BlockNewsletterSignupClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockNewsletterSignup = append(c.inters.BlockNewsletterSignup, interceptors...)
}

// Create returns a builder for creating a BlockNewsletterSignup entity.
func (c *BlockNewsletterSignupClient) Create() *BlockNewsletterSignupCreate {
	mutation := newBlockNewsletterSignupMutation(c.config, OpCreate)
	return &BlockNewsletterSignupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockNewsletterSignup entities.
func (c *BlockNewsletterSignupClient) CreateBulk(builders ...*BlockNewsletterSignupCreate) *BlockNewsletterSignupCreateBulk {
	return &BlockNewsletterSignupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockNewsletterSignupClient) MapCreateBulk(slice any, setFunc func(*BlockNewsletterSignupCreate, int)) *BlockNewsletterSignupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockNewsletterSignupCreateBulk{err: fmt.Errorf("calling to BlockNewsletterSignupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockNewsletterSignupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockNewsletterSignupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockNewsletterSignup.
func (c *BlockNewsletterSignupClient) Update() *BlockNewsletterSignupUpdate {
	mutation := newBlockNewsletterSignupMutation(c.config, OpUpdate)
	return &BlockNewsletterSignupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockNewsletterSignupClient) UpdateOne(_m *BlockNewsletterSignup) *BlockNewsletterSignupUpdateOne {
	mutation := newBlockNewsletterSignupMutation(c.config, OpUpdateOne, withBlockNewsletterSignup(_m))
	return &BlockNewsletterSignupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockNewsletterSignupClient) UpdateOneID(id int) *BlockNewsletterSignupUpdateOne {
	mutation := newBlockNewsletterSignupMutation(c.config, OpUpdateOne, withBlockNewsletterSignupID(id))
	return &BlockNewsletterSignupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockNewsletterSignup.
func (c *BlockNewsletterSignupClient) Delete() *BlockNewsletterSignupDelete {
	mutation := newBlockNewsletterSignupMutation(c.config, OpDelete)
	return &BlockNewsletterSignupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockNewsletterSignupClient) DeleteOne(_m *BlockNewsletterSignup) *BlockNewsletterSignupDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockNewsletterSignupClient) DeleteOneID(id int) *BlockNewsletterSignupDeleteOne {
	builder := c.Delete().Where(blocknewslettersignup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockNewsletterSignupDeleteOne{builder}
}

// Query returns a query builder for BlockNewsletterSignup.
func (c *BlockNewsletterSignupClient) Query() *BlockNewsletterSignupQuery {
	return &BlockNewsletterSignupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockNewsletterSignup},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockNewsletterSignup entity by its id.
func (c *BlockNewsletterSignupClient) Get(ctx context.Context, id int) (*BlockNewsletterSignup, error) {
	return c.Query().Where(blocknewslettersignup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockNewsletterSignupClient) GetX(ctx context.Context, id int) *BlockNewsletterSignup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockNewsletterSignup.
func (c *BlockNewsletterSignupClient) QueryContentBlock(_m *BlockNewsletterSignup) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blocknewslettersignup.Table, blocknewslettersignup.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blocknewslettersignup.ContentBlockTable, blocknewslettersignup.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockNewsletterSignupClient) Hooks() []Hook {
	return c.hooks.BlockNewsletterSignup
}

// Interceptors returns the client interceptors.
func (c *BlockNewsletterSignupClient) Interceptors() []Interceptor {
	return c.inters.BlockNewsletterSignup
}

func (c *BlockNewsletterSignupClient) mutate(ctx context.Context, m *BlockNewsletterSignupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockNewsletterSignupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockNewsletterSignupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockNewsletterSignupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockNewsletterSignupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockNewsletterSignup mutation op: %q", m.Op())
	}
}

// BlockPartnerLogosClient is a client for the BlockPartnerLogos schema.
type BlockPartnerLogosClient struct {
	config
}

// NewBlockPartnerLogosClient returns a client for the BlockPartnerLogos from the given config.
func NewBlockPartnerLogosClient(c config) *BlockPartnerLogosClient {
	return &BlockPartnerLogosClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockpartnerlogos.Hooks(f(g(h())))`.
func (c *BlockPartnerLogosClient) Use(hooks ...Hook) {
	c.hooks.BlockPartnerLogos = append(c.hooks.BlockPartnerLogos, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockpartnerlogos.Intercept(f(g(h())))`.
func (c *BlockPartnerLogosClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockPartnerLogos = append(c.inters.BlockPartnerLogos, interceptors...)
}

// Create returns a builder for creating a BlockPartnerLogos entity.
func (c *BlockPartnerLogosClient) Create() *BlockPartnerLogosCreate {
	mutation := newBlockPartnerLogosMutation(c.config, OpCreate)
	return &BlockPartnerLogosCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockPartnerLogos entities.
func (c *BlockPartnerLogosClient) CreateBulk(builders ...*BlockPartnerLogosCreate) *BlockPartnerLogosCreateBulk {
	return &BlockPartnerLogosCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockPartnerLogosClient) MapCreateBulk(slice any, setFunc func(*BlockPartnerLogosCreate, int)) *BlockPartnerLogosCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockPartnerLogosCreateBulk{err: fmt.Errorf("calling to BlockPartnerLogosClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockPartnerLogosCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockPartnerLogosCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockPartnerLogos.
func (c *BlockPartnerLogosClient) Update() *BlockPartnerLogosUpdate {
	mutation := newBlockPartnerLogosMutation(c.config, OpUpdate)
	return &BlockPartnerLogosUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockPartnerLogosClient) UpdateOne(_m *BlockPartnerLogos) *BlockPartnerLogosUpdateOne {
	mutation := newBlockPartnerLogosMutation(c.config, OpUpdateOne, withBlockPartnerLogos(_m))
	return &BlockPartnerLogosUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockPartnerLogosClient) UpdateOneID(id int) *BlockPartnerLogosUpdateOne {
	mutation := newBlockPartnerLogosMutation(c.config, OpUpdateOne, withBlockPartnerLogosID(id))
	return &BlockPartnerLogosUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockPartnerLogos.
func (c *BlockPartnerLogosClient) Delete() *BlockPartnerLogosDelete {
	mutation := newBlockPartnerLogosMutation(c.config, OpDelete)
	return &BlockPartnerLogosDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockPartnerLogosClient) DeleteOne(_m *BlockPartnerLogos) *BlockPartnerLogosDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockPartnerLogosClient) DeleteOneID(id int) *BlockPartnerLogosDeleteOne {
	builder := c.Delete().Where(blockpartnerlogos.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockPartnerLogosDeleteOne{builder}
}

// Query returns a query builder for BlockPartnerLogos.
func (c *BlockPartnerLogosClient) Query() *BlockPartnerLogosQuery {
	return &BlockPartnerLogosQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockPartnerLogos},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockPartnerLogos entity by its id.
func (c *BlockPartnerLogosClient) Get(ctx context.Context, id int) (*BlockPartnerLogos, error) {
	return c.Query().Where(blockpartnerlogos.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockPartnerLogosClient) GetX(ctx context.Context, id int) *BlockPartnerLogos {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockPartnerLogos.
func (c *BlockPartnerLogosClient) QueryContentBlock(_m *BlockPartnerLogos) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockpartnerlogos.Table, blockpartnerlogos.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockpartnerlogos.ContentBlockTable, blockpartnerlogos.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPartners queries the partners edge of a BlockPartnerLogos.
func (c *BlockPartnerLogosClient) QueryPartners(_m *BlockPartnerLogos) *PartnerLogoItemQuery {
	query := (&PartnerLogoItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockpartnerlogos.Table, blockpartnerlogos.FieldID, id),
			sqlgraph.To(partnerlogoitem.Table, partnerlogoitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, blockpartnerlogos.PartnersTable, blockpartnerlogos.PartnersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockPartnerLogosClient) Hooks() []Hook {
	return c.hooks.BlockPartnerLogos
}

// Interceptors returns the client interceptors.
func (c *BlockPartnerLogosClient) Interceptors() []Interceptor {
	return c.inters.BlockPartnerLogos
}

func (c *BlockPartnerLogosClient) mutate(ctx context.Context, m *BlockPartnerLogosMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockPartnerLogosCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockPartnerLogosUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockPartnerLogosUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockPartnerLogosDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockPartnerLogos mutation op: %q", m.Op())
	}
}

// BlockProgramCardsClient is a client for the BlockProgramCards schema.
type BlockProgramCardsClient struct {
	config
}

// NewBlockProgramCardsClient returns a client for the BlockProgramCards from the given config.
func NewBlockProgramCardsClient(c config) *BlockProgramCardsClient {
	return &BlockProgramCardsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockprogramcards.Hooks(f(g(h())))`.
func (c *BlockProgramCardsClient) Use(hooks ...Hook) {
	c.hooks.BlockProgramCards = append(c.hooks.BlockProgramCards, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockprogramcards.Intercept(f(g(h())))`.
func (c *BlockProgramCardsClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockProgramCards = append(c.inters.BlockProgramCards, interceptors...)
}

// Create returns a builder for creating a BlockProgramCards entity.
func (c *BlockProgramCardsClient) Create() *BlockProgramCardsCreate {
	mutation := newBlockProgramCardsMutation(c.config, OpCreate)
	return &BlockProgramCardsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockProgramCards entities.
func (c *BlockProgramCardsClient) CreateBulk(builders ...*BlockProgramCardsCreate) *BlockProgramCardsCreateBulk {
	return &BlockProgramCardsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockProgramCardsClient) MapCreateBulk(slice any, setFunc func(*BlockProgramCardsCreate, int)) *BlockProgramCardsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockProgramCardsCreateBulk{err: fmt.Errorf("calling to BlockProgramCardsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockProgramCardsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockProgramCardsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockProgramCards.
func (c *BlockProgramCardsClient) Update() *BlockProgramCardsUpdate {
	mutation := newBlockProgramCardsMutation(c.config, OpUpdate)
	return &BlockProgramCardsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockProgramCardsClient) UpdateOne(_m *BlockProgramCards) *BlockProgramCardsUpdateOne {
	mutation := newBlockProgramCardsMutation(c.config, OpUpdateOne, withBlockProgramCards(_m))
	return &BlockProgramCardsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockProgramCardsClient) UpdateOneID(id int) *BlockProgramCardsUpdateOne {
	mutation := newBlockProgramCardsMutation(c.config, OpUpdateOne, withBlockProgramCardsID(id))
	return &BlockProgramCardsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockProgramCards.
func (c *BlockProgramCardsClient) Delete() *BlockProgramCardsDelete {
	mutation := newBlockProgramCardsMutation(c.config, OpDelete)
	return &BlockProgramCardsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockProgramCardsClient) DeleteOne(_m *BlockProgramCards) *BlockProgramCardsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockProgramCardsClient) DeleteOneID(id int) *BlockProgramCardsDeleteOne {
	builder := c.Delete().Where(blockprogramcards.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockProgramCardsDeleteOne{builder}
}

// Query returns a query builder for BlockProgramCards.
func (c *BlockProgramCardsClient) Query() *BlockProgramCardsQuery {
	return &BlockProgramCardsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockProgramCards},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockProgramCards entity by its id.
func (c *BlockProgramCardsClient) Get(ctx context.Context, id int) (*BlockProgramCards, error) {
	return c.Query().Where(blockprogramcards.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockProgramCardsClient) GetX(ctx context.Context, id int) *BlockProgramCards {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockProgramCards.
func (c *BlockProgramCardsClient) QueryContentBlock(_m *BlockProgramCards) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockprogramcards.Table, blockprogramcards.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockprogramcards.ContentBlockTable, blockprogramcards.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySelectedPrograms queries the selected_programs edge of a BlockProgramCards.
func (c *BlockProgramCardsClient) QuerySelectedPrograms(_m *BlockProgramCards) *ProgramCardItemQuery {
	query := (&ProgramCardItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockprogramcards.Table, blockprogramcards.FieldID, id),
			sqlgraph.To(programcarditem.Table, programcarditem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, blockprogramcards.SelectedProgramsTable, blockprogramcards.SelectedProgramsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockProgramCardsClient) Hooks() []Hook {
	return c.hooks.BlockProgramCards
}

// Interceptors returns the client interceptors.
func (c *BlockProgramCardsClient) Interceptors() []Interceptor {
	return c.inters.BlockProgramCards
}

func (c *BlockProgramCardsClient) mutate(ctx context.Context, m *BlockProgramCardsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockProgramCardsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockProgramCardsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockProgramCardsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockProgramCardsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockProgramCards mutation op: %q", m.Op())
	}
}

// BlockStatsClient is a client for the BlockStats schema.
type BlockStatsClient struct {
	config
}

// NewBlockStatsClient returns a client for the BlockStats from the given config.
func NewBlockStatsClient(c config) *BlockStatsClient {
	return &BlockStatsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockstats.Hooks(f(g(h())))`.
func (c *BlockStatsClient) Use(hooks ...Hook) {
	c.hooks.BlockStats = append(c.hooks.BlockStats, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockstats.Intercept(f(g(h())))`.
func (c *BlockStatsClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockStats = append(c.inters.BlockStats, interceptors...)
}

// Create returns a builder for creating a BlockStats entity.
func (c *BlockStatsClient) Create() *BlockStatsCreate {
	mutation := newBlockStatsMutation(c.config, OpCreate)
	return &BlockStatsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockStats entities.
func (c *BlockStatsClient) CreateBulk(builders ...*BlockStatsCreate) *BlockStatsCreateBulk {
	return &BlockStatsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockStatsClient) MapCreateBulk(slice any, setFunc func(*BlockStatsCreate, int)) *BlockStatsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockStatsCreateBulk{err: fmt.Errorf("calling to BlockStatsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockStatsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockStatsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockStats.
func (c *BlockStatsClient) Update() *BlockStatsUpdate {
	mutation := newBlockStatsMutation(c.config, OpUpdate)
	return &BlockStatsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockStatsClient) UpdateOne(_m *BlockStats) *BlockStatsUpdateOne {
	mutation := newBlockStatsMutation(c.config, OpUpdateOne, withBlockStats(_m))
	return &BlockStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockStatsClient) UpdateOneID(id int) *BlockStatsUpdateOne {
	mutation := newBlockStatsMutation(c.config, OpUpdateOne, withBlockStatsID(id))
	return &BlockStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockStats.
func (c *BlockStatsClient) Delete() *BlockStatsDelete {
	mutation := newBlockStatsMutation(c.config, OpDelete)
	return &BlockStatsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockStatsClient) DeleteOne(_m *BlockStats) *BlockStatsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockStatsClient) DeleteOneID(id int) *BlockStatsDeleteOne {
	builder := c.Delete().Where(blockstats.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockStatsDeleteOne{builder}
}

// Query returns a query builder for BlockStats.
func (c *BlockStatsClient) Query() *BlockStatsQuery {
	return &BlockStatsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockStats},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockStats entity by its id.
func (c *BlockStatsClient) Get(ctx context.Context, id int) (*BlockStats, error) {
	return c.Query().Where(blockstats.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockStatsClient) GetX(ctx context.Context, id int) *BlockStats {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockStats.
func (c *BlockStatsClient) QueryContentBlock(_m *BlockStats) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockstats.Table, blockstats.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockstats.ContentBlockTable, blockstats.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStats queries the stats edge of a BlockStats.
func (c *BlockStatsClient) QueryStats(_m *BlockStats) *StatItemQuery {
	query := (&StatItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockstats.Table, blockstats.FieldID, id),
			sqlgraph.To(statitem.Table, statitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, blockstats.StatsTable, blockstats.StatsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockStatsClient) Hooks() []Hook {
	return c.hooks.BlockStats
}

// Interceptors returns the client interceptors.
func (c *BlockStatsClient) Interceptors() []Interceptor {
	return c.inters.BlockStats
}

func (c *BlockStatsClient) mutate(ctx context.Context, m *BlockStatsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockStatsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockStatsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockStatsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockStats mutation op: %q", m.Op())
	}
}

// BlockSuccessStoriesClient is a client for the BlockSuccessStories schema.
type BlockSuccessStoriesClient struct {
	config
}

// NewBlockSuccessStoriesClient returns a client for the BlockSuccessStories from the given config.
func NewBlockSuccessStoriesClient(c config) *BlockSuccessStoriesClient {
	return &BlockSuccessStoriesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blocksuccessstories.Hooks(f(g(h())))`.
func (c *BlockSuccessStoriesClient) Use(hooks ...Hook) {
	c.hooks.BlockSuccessStories = append(c.hooks.BlockSuccessStories, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blocksuccessstories.Intercept(f(g(h())))`.
func (c *BlockSuccessStoriesClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockSuccessStories = append(c.inters.BlockSuccessStories, interceptors...)
}

// Create returns a builder for creating a BlockSuccessStories entity.
func (c *BlockSuccessStoriesClient) Create() *BlockSuccessStoriesCreate {
	mutation := newBlockSuccessStoriesMutation(c.config, OpCreate)
	return &BlockSuccessStoriesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockSuccessStories entities.
func (c *BlockSuccessStoriesClient) CreateBulk(builders ...*BlockSuccessStoriesCreate) *BlockSuccessStoriesCreateBulk {
	return &BlockSuccessStoriesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockSuccessStoriesClient) MapCreateBulk(slice any, setFunc func(*BlockSuccessStoriesCreate, int)) *BlockSuccessStoriesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockSuccessStoriesCreateBulk{err: fmt.Errorf("calling to BlockSuccessStoriesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockSuccessStoriesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockSuccessStoriesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockSuccessStories.
func (c *BlockSuccessStoriesClient) Update() *BlockSuccessStoriesUpdate {
	mutation := newBlockSuccessStoriesMutation(c.config, OpUpdate)
	return &BlockSuccessStoriesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockSuccessStoriesClient) UpdateOne(_m *BlockSuccessStories) *BlockSuccessStoriesUpdateOne {
	mutation := newBlockSuccessStoriesMutation(c.config, OpUpdateOne, withBlockSuccessStories(_m))
	return &BlockSuccessStoriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockSuccessStoriesClient) UpdateOneID(id int) *BlockSuccessStoriesUpdateOne {
	mutation := newBlockSuccessStoriesMutation(c.config, OpUpdateOne, withBlockSuccessStoriesID(id))
	return &BlockSuccessStoriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockSuccessStories.
func (c *BlockSuccessStoriesClient) Delete() *BlockSuccessStoriesDelete {
	mutation := newBlockSuccessStoriesMutation(c.config, OpDelete)
	return &BlockSuccessStoriesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockSuccessStoriesClient) DeleteOne(_m *BlockSuccessStories) *BlockSuccessStoriesDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockSuccessStoriesClient) DeleteOneID(id int) *BlockSuccessStoriesDeleteOne {
	builder := c.Delete().Where(blocksuccessstories.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockSuccessStoriesDeleteOne{builder}
}

// Query returns a query builder for BlockSuccessStories.
func (c *BlockSuccessStoriesClient) Query() *BlockSuccessStoriesQuery {
	return &BlockSuccessStoriesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockSuccessStories},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockSuccessStories entity by its id.
func (c *BlockSuccessStoriesClient) Get(ctx context.Context, id int) (*BlockSuccessStories, error) {
	return c.Query().Where(blocksuccessstories.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockSuccessStoriesClient) GetX(ctx context.Context, id int) *BlockSuccessStories {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockSuccessStories.
func (c *BlockSuccessStoriesClient) QueryContentBlock(_m *BlockSuccessStories) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blocksuccessstories.Table, blocksuccessstories.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blocksuccessstories.ContentBlockTable, blocksuccessstories.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockSuccessStoriesClient) Hooks() []Hook {
	return c.hooks.BlockSuccessStories
}

// Interceptors returns the client interceptors.
func (c *BlockSuccessStoriesClient) Interceptors() []Interceptor {
	return c.inters.BlockSuccessStories
}

func (c *BlockSuccessStoriesClient) mutate(ctx context.Context, m *BlockSuccessStoriesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockSuccessStoriesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockSuccessStoriesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockSuccessStoriesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockSuccessStoriesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockSuccessStories mutation op: %q", m.Op())
	}
}

// BlockTabsClient is a client for the BlockTabs schema.
type BlockTabsClient struct {
	config
}

// NewBlockTabsClient returns a client for the BlockTabs from the given config.
func NewBlockTabsClient(c config) *BlockTabsClient {
	return &BlockTabsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blocktabs.Hooks(f(g(h())))`.
func (c *BlockTabsClient) Use(hooks ...Hook) {
	c.hooks.BlockTabs = append(c.hooks.BlockTabs, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blocktabs.Intercept(f(g(h())))`.
func (c *BlockTabsClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockTabs = append(c.inters.BlockTabs, interceptors...)
}

// Create returns a builder for creating a BlockTabs entity.
func (c *BlockTabsClient) Create() *BlockTabsCreate {
	mutation := newBlockTabsMutation(c.config, OpCreate)
	return &BlockTabsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockTabs entities.
func (c *BlockTabsClient) CreateBulk(builders ...*BlockTabsCreate) *BlockTabsCreateBulk {
	return &BlockTabsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockTabsClient) MapCreateBulk(slice any, setFunc func(*BlockTabsCreate, int)) *BlockTabsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockTabsCreateBulk{err: fmt.Errorf("calling to BlockTabsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockTabsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockTabsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockTabs.
func (c *BlockTabsClient) Update() *BlockTabsUpdate {
	mutation := newBlockTabsMutation(c.config, OpUpdate)
	return &BlockTabsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockTabsClient) UpdateOne(_m *BlockTabs) *BlockTabsUpdateOne {
	mutation := newBlockTabsMutation(c.config, OpUpdateOne, withBlockTabs(_m))
	return &BlockTabsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockTabsClient) UpdateOneID(id int) *BlockTabsUpdateOne {
	mutation := newBlockTabsMutation(c.config, OpUpdateOne, withBlockTabsID(id))
	return &BlockTabsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockTabs.
func (c *BlockTabsClient) Delete() *BlockTabsDelete {
	mutation := newBlockTabsMutation(c.config, OpDelete)
	return &BlockTabsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockTabsClient) DeleteOne(_m *BlockTabs) *BlockTabsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockTabsClient) DeleteOneID(id int) *BlockTabsDeleteOne {
	builder := c.Delete().Where(blocktabs.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockTabsDeleteOne{builder}
}

// Query returns a query builder for BlockTabs.
func (c *BlockTabsClient) Query() *BlockTabsQuery {
	return &BlockTabsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockTabs},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockTabs entity by its id.
func (c *BlockTabsClient) Get(ctx context.Context, id int) (*BlockTabs, error) {
	return c.Query().Where(blocktabs.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockTabsClient) GetX(ctx context.Context, id int) *BlockTabs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockTabs.
func (c *BlockTabsClient) QueryContentBlock(_m *BlockTabs) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blocktabs.Table, blocktabs.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blocktabs.ContentBlockTable, blocktabs.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItems queries the items edge of a BlockTabs.
func (c *BlockTabsClient) QueryItems(_m *BlockTabs) *TabItemQuery {
	query := (&TabItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blocktabs.Table, blocktabs.FieldID, id),
			sqlgraph.To(tabitem.Table, tabitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, blocktabs.ItemsTable, blocktabs.ItemsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockTabsClient) Hooks() []Hook {
	return c.hooks.BlockTabs
}

// Interceptors returns the client interceptors.
func (c *BlockTabsClient) Interceptors() []Interceptor {
	return c.inters.BlockTabs
}

func (c *BlockTabsClient) mutate(ctx context.Context, m *BlockTabsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockTabsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockTabsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockTabsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockTabsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockTabs mutation op: %q", m.Op())
	}
}

// BlockTeamGridClient is a client for the BlockTeamGrid schema.
type BlockTeamGridClient struct {
	config
}

// NewBlockTeamGridClient returns a client for the BlockTeamGrid from the given config.
func NewBlockTeamGridClient(c config) *BlockTeamGridClient {
	return &BlockTeamGridClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockteamgrid.Hooks(f(g(h())))`.
func (c *BlockTeamGridClient) Use(hooks ...Hook) {
	c.hooks.BlockTeamGrid = append(c.hooks.BlockTeamGrid, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockteamgrid.Intercept(f(g(h())))`.
func (c *BlockTeamGridClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockTeamGrid = append(c.inters.BlockTeamGrid, interceptors...)
}

// Create returns a builder for creating a BlockTeamGrid entity.
func (c *BlockTeamGridClient) Create() *BlockTeamGridCreate {
	mutation := newBlockTeamGridMutation(c.config, OpCreate)
	return &BlockTeamGridCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockTeamGrid entities.
func (c *BlockTeamGridClient) CreateBulk(builders ...*BlockTeamGridCreate) *BlockTeamGridCreateBulk {
	return &BlockTeamGridCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockTeamGridClient) MapCreateBulk(slice any, setFunc func(*BlockTeamGridCreate, int)) *BlockTeamGridCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockTeamGridCreateBulk{err: fmt.Errorf("calling to BlockTeamGridClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockTeamGridCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockTeamGridCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockTeamGrid.
func (c *BlockTeamGridClient) Update() *BlockTeamGridUpdate {
	mutation := newBlockTeamGridMutation(c.config, OpUpdate)
	return &BlockTeamGridUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockTeamGridClient) UpdateOne(_m *BlockTeamGrid) *BlockTeamGridUpdateOne {
	mutation := newBlockTeamGridMutation(c.config, OpUpdateOne, withBlockTeamGrid(_m))
	return &BlockTeamGridUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockTeamGridClient) UpdateOneID(id int) *BlockTeamGridUpdateOne {
	mutation := newBlockTeamGridMutation(c.config, OpUpdateOne, withBlockTeamGridID(id))
	return &BlockTeamGridUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockTeamGrid.
func (c *BlockTeamGridClient) Delete() *BlockTeamGridDelete {
	mutation := newBlockTeamGridMutation(c.config, OpDelete)
	return &BlockTeamGridDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockTeamGridClient) DeleteOne(_m *BlockTeamGrid) *BlockTeamGridDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockTeamGridClient) DeleteOneID(id int) *BlockTeamGridDeleteOne {
	builder := c.Delete().Where(blockteamgrid.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockTeamGridDeleteOne{builder}
}

// Query returns a query builder for BlockTeamGrid.
func (c *BlockTeamGridClient) Query() *BlockTeamGridQuery {
	return &BlockTeamGridQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockTeamGrid},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockTeamGrid entity by its id.
func (c *BlockTeamGridClient) Get(ctx context.Context, id int) (*BlockTeamGrid, error) {
	return c.Query().Where(blockteamgrid.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockTeamGridClient) GetX(ctx context.Context, id int) *BlockTeamGrid {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockTeamGrid.
func (c *BlockTeamGridClient) QueryContentBlock(_m *BlockTeamGrid) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockteamgrid.Table, blockteamgrid.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockteamgrid.ContentBlockTable, blockteamgrid.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a BlockTeamGrid.
func (c *BlockTeamGridClient) QueryMembers(_m *BlockTeamGrid) *TeamMemberItemQuery {
	query := (&TeamMemberItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockteamgrid.Table, blockteamgrid.FieldID, id),
			sqlgraph.To(teammemberitem.Table, teammemberitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, blockteamgrid.MembersTable, blockteamgrid.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockTeamGridClient) Hooks() []Hook {
	return c.hooks.BlockTeamGrid
}

// Interceptors returns the client interceptors.
func (c *BlockTeamGridClient) Interceptors() []Interceptor {
	return c.inters.BlockTeamGrid
}

func (c *BlockTeamGridClient) mutate(ctx context.Context, m *BlockTeamGridMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockTeamGridCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockTeamGridUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockTeamGridUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockTeamGridDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockTeamGrid mutation op: %q", m.Op())
	}
}

// BlockTestimonialsClient is a client for the BlockTestimonials schema.
type BlockTestimonialsClient struct {
	config
}

// NewBlockTestimonialsClient returns a client for the BlockTestimonials from the given config.
func NewBlockTestimonialsClient(c config) *BlockTestimonialsClient {
	return &BlockTestimonialsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blocktestimonials.Hooks(f(g(h())))`.
func (c *BlockTestimonialsClient) Use(hooks ...Hook) {
	c.hooks.BlockTestimonials = append(c.hooks.BlockTestimonials, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blocktestimonials.Intercept(f(g(h())))`.
func (c *BlockTestimonialsClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockTestimonials = append(c.inters.BlockTestimonials, interceptors...)
}

// Create returns a builder for creating a BlockTestimonials entity.
func (c *BlockTestimonialsClient) Create() *BlockTestimonialsCreate {
	mutation := newBlockTestimonialsMutation(c.config, OpCreate)
	return &BlockTestimonialsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockTestimonials entities.
func (c *BlockTestimonialsClient) CreateBulk(builders ...*BlockTestimonialsCreate) *BlockTestimonialsCreateBulk {
	return &BlockTestimonialsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockTestimonialsClient) MapCreateBulk(slice any, setFunc func(*BlockTestimonialsCreate, int)) *BlockTestimonialsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockTestimonialsCreateBulk{err: fmt.Errorf("calling to BlockTestimonialsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockTestimonialsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockTestimonialsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockTestimonials.
func (c *BlockTestimonialsClient) Update() *BlockTestimonialsUpdate {
	mutation := newBlockTestimonialsMutation(c.config, OpUpdate)
	return &BlockTestimonialsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockTestimonialsClient) UpdateOne(_m *BlockTestimonials) *BlockTestimonialsUpdateOne {
	mutation := newBlockTestimonialsMutation(c.config, OpUpdateOne, withBlockTestimonials(_m))
	return &BlockTestimonialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockTestimonialsClient) UpdateOneID(id int) *BlockTestimonialsUpdateOne {
	mutation := newBlockTestimonialsMutation(c.config, OpUpdateOne, withBlockTestimonialsID(id))
	return &BlockTestimonialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockTestimonials.
func (c *BlockTestimonialsClient) Delete() *BlockTestimonialsDelete {
	mutation := newBlockTestimonialsMutation(c.config, OpDelete)
	return &BlockTestimonialsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockTestimonialsClient) DeleteOne(_m *BlockTestimonials) *BlockTestimonialsDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockTestimonialsClient) DeleteOneID(id int) *BlockTestimonialsDeleteOne {
	builder := c.Delete().Where(blocktestimonials.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockTestimonialsDeleteOne{builder}
}

// Query returns a query builder for BlockTestimonials.
func (c *BlockTestimonialsClient) Query() *BlockTestimonialsQuery {
	return &BlockTestimonialsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockTestimonials},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockTestimonials entity by its id.
func (c *BlockTestimonialsClient) Get(ctx context.Context, id int) (*BlockTestimonials, error) {
	return c.Query().Where(blocktestimonials.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockTestimonialsClient) GetX(ctx context.Context, id int) *BlockTestimonials {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockTestimonials.
func (c *BlockTestimonialsClient) QueryContentBlock(_m *BlockTestimonials) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blocktestimonials.Table, blocktestimonials.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blocktestimonials.ContentBlockTable, blocktestimonials.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestimonials queries the testimonials edge of a BlockTestimonials.
func (c *BlockTestimonialsClient) QueryTestimonials(_m *BlockTestimonials) *TestimonialItemQuery {
	query := (&TestimonialItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blocktestimonials.Table, blocktestimonials.FieldID, id),
			sqlgraph.To(testimonialitem.Table, testimonialitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, blocktestimonials.TestimonialsTable, blocktestimonials.TestimonialsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockTestimonialsClient) Hooks() []Hook {
	return c.hooks.BlockTestimonials
}

// Interceptors returns the client interceptors.
func (c *BlockTestimonialsClient) Interceptors() []Interceptor {
	return c.inters.BlockTestimonials
}

func (c *BlockTestimonialsClient) mutate(ctx context.Context, m *BlockTestimonialsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockTestimonialsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockTestimonialsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockTestimonialsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockTestimonialsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockTestimonials mutation op: %q", m.Op())
	}
}

// BlockTextContentClient is a client for the BlockTextContent schema.
type BlockTextContentClient struct {
	config
}

// NewBlockTextContentClient returns a client for the BlockTextContent from the given config.
func NewBlockTextContentClient(c config) *BlockTextContentClient {
	return &BlockTextContentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blocktextcontent.Hooks(f(g(h())))`.
func (c *BlockTextContentClient) Use(hooks ...Hook) {
	c.hooks.BlockTextContent = append(c.hooks.BlockTextContent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blocktextcontent.Intercept(f(g(h())))`.
func (c *BlockTextContentClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockTextContent = append(c.inters.BlockTextContent, interceptors...)
}

// Create returns a builder for creating a BlockTextContent entity.
func (c *BlockTextContentClient) Create() *BlockTextContentCreate {
	mutation := newBlockTextContentMutation(c.config, OpCreate)
	return &BlockTextContentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockTextContent entities.
func (c *BlockTextContentClient) CreateBulk(builders ...*BlockTextContentCreate) *BlockTextContentCreateBulk {
	return &BlockTextContentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockTextContentClient) MapCreateBulk(slice any, setFunc func(*BlockTextContentCreate, int)) *BlockTextContentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockTextContentCreateBulk{err: fmt.Errorf("calling to BlockTextContentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockTextContentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockTextContentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockTextContent.
func (c *BlockTextContentClient) Update() *BlockTextContentUpdate {
	mutation := newBlockTextContentMutation(c.config, OpUpdate)
	return &BlockTextContentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockTextContentClient) UpdateOne(_m *BlockTextContent) *BlockTextContentUpdateOne {
	mutation := newBlockTextContentMutation(c.config, OpUpdateOne, withBlockTextContent(_m))
	return &BlockTextContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockTextContentClient) UpdateOneID(id int) *BlockTextContentUpdateOne {
	mutation := newBlockTextContentMutation(c.config, OpUpdateOne, withBlockTextContentID(id))
	return &BlockTextContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockTextContent.
func (c *BlockTextContentClient) Delete() *BlockTextContentDelete {
	mutation := newBlockTextContentMutation(c.config, OpDelete)
	return &BlockTextContentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockTextContentClient) DeleteOne(_m *BlockTextContent) *BlockTextContentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockTextContentClient) DeleteOneID(id int) *BlockTextContentDeleteOne {
	builder := c.Delete().Where(blocktextcontent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockTextContentDeleteOne{builder}
}

// Query returns a query builder for BlockTextContent.
func (c *BlockTextContentClient) Query() *BlockTextContentQuery {
	return &BlockTextContentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockTextContent},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockTextContent entity by its id.
func (c *BlockTextContentClient) Get(ctx context.Context, id int) (*BlockTextContent, error) {
	return c.Query().Where(blocktextcontent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockTextContentClient) GetX(ctx context.Context, id int) *BlockTextContent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockTextContent.
func (c *BlockTextContentClient) QueryContentBlock(_m *BlockTextContent) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blocktextcontent.Table, blocktextcontent.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blocktextcontent.ContentBlockTable, blocktextcontent.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockTextContentClient) Hooks() []Hook {
	return c.hooks.BlockTextContent
}

// Interceptors returns the client interceptors.
func (c *BlockTextContentClient) Interceptors() []Interceptor {
	return c.inters.BlockTextContent
}

func (c *BlockTextContentClient) mutate(ctx context.Context, m *BlockTextContentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockTextContentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockTextContentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockTextContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockTextContentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockTextContent mutation op: %q", m.Op())
	}
}

// BlockTimelineClient is a client for the BlockTimeline schema.
type BlockTimelineClient struct {
	config
}

// NewBlockTimelineClient returns a client for the BlockTimeline from the given config.
func NewBlockTimelineClient(c config) *BlockTimelineClient {
	return &BlockTimelineClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blocktimeline.Hooks(f(g(h())))`.
func (c *BlockTimelineClient) Use(hooks ...Hook) {
	c.hooks.BlockTimeline = append(c.hooks.BlockTimeline, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blocktimeline.Intercept(f(g(h())))`.
func (c *BlockTimelineClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockTimeline = append(c.inters.BlockTimeline, interceptors...)
}

// Create returns a builder for creating a BlockTimeline entity.
func (c *BlockTimelineClient) Create() *BlockTimelineCreate {
	mutation := newBlockTimelineMutation(c.config, OpCreate)
	return &BlockTimelineCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockTimeline entities.
func (c *BlockTimelineClient) CreateBulk(builders ...*BlockTimelineCreate) *BlockTimelineCreateBulk {
	return &BlockTimelineCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockTimelineClient) MapCreateBulk(slice any, setFunc func(*BlockTimelineCreate, int)) *BlockTimelineCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockTimelineCreateBulk{err: fmt.Errorf("calling to BlockTimelineClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockTimelineCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockTimelineCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockTimeline.
func (c *BlockTimelineClient) Update() *BlockTimelineUpdate {
	mutation := newBlockTimelineMutation(c.config, OpUpdate)
	return &BlockTimelineUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockTimelineClient) UpdateOne(_m *BlockTimeline) *BlockTimelineUpdateOne {
	mutation := newBlockTimelineMutation(c.config, OpUpdateOne, withBlockTimeline(_m))
	return &BlockTimelineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockTimelineClient) UpdateOneID(id int) *BlockTimelineUpdateOne {
	mutation := newBlockTimelineMutation(c.config, OpUpdateOne, withBlockTimelineID(id))
	return &BlockTimelineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockTimeline.
func (c *BlockTimelineClient) Delete() *BlockTimelineDelete {
	mutation := newBlockTimelineMutation(c.config, OpDelete)
	return &BlockTimelineDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockTimelineClient) DeleteOne(_m *BlockTimeline) *BlockTimelineDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockTimelineClient) DeleteOneID(id int) *BlockTimelineDeleteOne {
	builder := c.Delete().Where(blocktimeline.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockTimelineDeleteOne{builder}
}

// Query returns a query builder for BlockTimeline.
func (c *BlockTimelineClient) Query() *BlockTimelineQuery {
	return &BlockTimelineQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockTimeline},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockTimeline entity by its id.
func (c *BlockTimelineClient) Get(ctx context.Context, id int) (*BlockTimeline, error) {
	return c.Query().Where(blocktimeline.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockTimelineClient) GetX(ctx context.Context, id int) *BlockTimeline {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockTimeline.
func (c *BlockTimelineClient) QueryContentBlock(_m *BlockTimeline) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blocktimeline.Table, blocktimeline.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blocktimeline.ContentBlockTable, blocktimeline.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a BlockTimeline.
func (c *BlockTimelineClient) QueryEvents(_m *BlockTimeline) *TimelineEventQuery {
	query := (&TimelineEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blocktimeline.Table, blocktimeline.FieldID, id),
			sqlgraph.To(timelineevent.Table, timelineevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, blocktimeline.EventsTable, blocktimeline.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockTimelineClient) Hooks() []Hook {
	return c.hooks.BlockTimeline
}

// Interceptors returns the client interceptors.
func (c *BlockTimelineClient) Interceptors() []Interceptor {
	return c.inters.BlockTimeline
}

func (c *BlockTimelineClient) mutate(ctx context.Context, m *BlockTimelineMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockTimelineCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockTimelineUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockTimelineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockTimelineDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockTimeline mutation op: %q", m.Op())
	}
}

// BlockVideoEmbedClient is a client for the BlockVideoEmbed schema.
type BlockVideoEmbedClient struct {
	config
}

// NewBlockVideoEmbedClient returns a client for the BlockVideoEmbed from the given config.
func NewBlockVideoEmbedClient(c config) *BlockVideoEmbedClient {
	return &BlockVideoEmbedClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockvideoembed.Hooks(f(g(h())))`.
func (c *BlockVideoEmbedClient) Use(hooks ...Hook) {
	c.hooks.BlockVideoEmbed = append(c.hooks.BlockVideoEmbed, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockvideoembed.Intercept(f(g(h())))`.
func (c *BlockVideoEmbedClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockVideoEmbed = append(c.inters.BlockVideoEmbed, interceptors...)
}

// Create returns a builder for creating a BlockVideoEmbed entity.
func (c *BlockVideoEmbedClient) Create() *BlockVideoEmbedCreate {
	mutation := newBlockVideoEmbedMutation(c.config, OpCreate)
	return &BlockVideoEmbedCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockVideoEmbed entities.
func (c *BlockVideoEmbedClient) CreateBulk(builders ...*BlockVideoEmbedCreate) *BlockVideoEmbedCreateBulk {
	return &BlockVideoEmbedCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockVideoEmbedClient) MapCreateBulk(slice any, setFunc func(*BlockVideoEmbedCreate, int)) *BlockVideoEmbedCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockVideoEmbedCreateBulk{err: fmt.Errorf("calling to BlockVideoEmbedClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockVideoEmbedCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockVideoEmbedCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockVideoEmbed.
func (c *BlockVideoEmbedClient) Update() *BlockVideoEmbedUpdate {
	mutation := newBlockVideoEmbedMutation(c.config, OpUpdate)
	return &BlockVideoEmbedUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockVideoEmbedClient) UpdateOne(_m *BlockVideoEmbed) *BlockVideoEmbedUpdateOne {
	mutation := newBlockVideoEmbedMutation(c.config, OpUpdateOne, withBlockVideoEmbed(_m))
	return &BlockVideoEmbedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockVideoEmbedClient) UpdateOneID(id int) *BlockVideoEmbedUpdateOne {
	mutation := newBlockVideoEmbedMutation(c.config, OpUpdateOne, withBlockVideoEmbedID(id))
	return &BlockVideoEmbedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockVideoEmbed.
func (c *BlockVideoEmbedClient) Delete() *BlockVideoEmbedDelete {
	mutation := newBlockVideoEmbedMutation(c.config, OpDelete)
	return &BlockVideoEmbedDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockVideoEmbedClient) DeleteOne(_m *BlockVideoEmbed) *BlockVideoEmbedDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockVideoEmbedClient) DeleteOneID(id int) *BlockVideoEmbedDeleteOne {
	builder := c.Delete().Where(blockvideoembed.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockVideoEmbedDeleteOne{builder}
}

// Query returns a query builder for BlockVideoEmbed.
func (c *BlockVideoEmbedClient) Query() *BlockVideoEmbedQuery {
	return &BlockVideoEmbedQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockVideoEmbed},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockVideoEmbed entity by its id.
func (c *BlockVideoEmbedClient) Get(ctx context.Context, id int) (*BlockVideoEmbed, error) {
	return c.Query().Where(blockvideoembed.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockVideoEmbedClient) GetX(ctx context.Context, id int) *BlockVideoEmbed {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockVideoEmbed.
func (c *BlockVideoEmbedClient) QueryContentBlock(_m *BlockVideoEmbed) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockvideoembed.Table, blockvideoembed.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockvideoembed.ContentBlockTable, blockvideoembed.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockVideoEmbedClient) Hooks() []Hook {
	return c.hooks.BlockVideoEmbed
}

// Interceptors returns the client interceptors.
func (c *BlockVideoEmbedClient) Interceptors() []Interceptor {
	return c.inters.BlockVideoEmbed
}

func (c *BlockVideoEmbedClient) mutate(ctx context.Context, m *BlockVideoEmbedMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockVideoEmbedCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockVideoEmbedUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockVideoEmbedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockVideoEmbedDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockVideoEmbed mutation op: %q", m.Op())
	}
}

// BlockVolunteerSignupClient is a client for the BlockVolunteerSignup schema.
type BlockVolunteerSignupClient struct {
	config
}

// NewBlockVolunteerSignupClient returns a client for the BlockVolunteerSignup from the given config.
func NewBlockVolunteerSignupClient(c config) *BlockVolunteerSignupClient {
	return &BlockVolunteerSignupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockvolunteersignup.Hooks(f(g(h())))`.
func (c *BlockVolunteerSignupClient) Use(hooks ...Hook) {
	c.hooks.BlockVolunteerSignup = append(c.hooks.BlockVolunteerSignup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockvolunteersignup.Intercept(f(g(h())))`.
func (c *BlockVolunteerSignupClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockVolunteerSignup = append(c.inters.BlockVolunteerSignup, interceptors...)
}

// Create returns a builder for creating a BlockVolunteerSignup entity.
func (c *BlockVolunteerSignupClient) Create() *BlockVolunteerSignupCreate {
	mutation := newBlockVolunteerSignupMutation(c.config, OpCreate)
	return &BlockVolunteerSignupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockVolunteerSignup entities.
func (c *BlockVolunteerSignupClient) CreateBulk(builders ...*BlockVolunteerSignupCreate) *BlockVolunteerSignupCreateBulk {
	return &BlockVolunteerSignupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlockVolunteerSignupClient) MapCreateBulk(slice any, setFunc func(*BlockVolunteerSignupCreate, int)) *BlockVolunteerSignupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlockVolunteerSignupCreateBulk{err: fmt.Errorf("calling to BlockVolunteerSignupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlockVolunteerSignupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlockVolunteerSignupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockVolunteerSignup.
func (c *BlockVolunteerSignupClient) Update() *BlockVolunteerSignupUpdate {
	mutation := newBlockVolunteerSignupMutation(c.config, OpUpdate)
	return &BlockVolunteerSignupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockVolunteerSignupClient) UpdateOne(_m *BlockVolunteerSignup) *BlockVolunteerSignupUpdateOne {
	mutation := newBlockVolunteerSignupMutation(c.config, OpUpdateOne, withBlockVolunteerSignup(_m))
	return &BlockVolunteerSignupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockVolunteerSignupClient) UpdateOneID(id int) *BlockVolunteerSignupUpdateOne {
	mutation := newBlockVolunteerSignupMutation(c.config, OpUpdateOne, withBlockVolunteerSignupID(id))
	return &BlockVolunteerSignupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockVolunteerSignup.
func (c *BlockVolunteerSignupClient) Delete() *BlockVolunteerSignupDelete {
	mutation := newBlockVolunteerSignupMutation(c.config, OpDelete)
	return &BlockVolunteerSignupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockVolunteerSignupClient) DeleteOne(_m *BlockVolunteerSignup) *BlockVolunteerSignupDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockVolunteerSignupClient) DeleteOneID(id int) *BlockVolunteerSignupDeleteOne {
	builder := c.Delete().Where(blockvolunteersignup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockVolunteerSignupDeleteOne{builder}
}

// Query returns a query builder for BlockVolunteerSignup.
func (c *BlockVolunteerSignupClient) Query() *BlockVolunteerSignupQuery {
	return &BlockVolunteerSignupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockVolunteerSignup},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockVolunteerSignup entity by its id.
func (c *BlockVolunteerSignupClient) Get(ctx context.Context, id int) (*BlockVolunteerSignup, error) {
	return c.Query().Where(blockvolunteersignup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockVolunteerSignupClient) GetX(ctx context.Context, id int) *BlockVolunteerSignup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryContentBlock queries the content_block edge of a BlockVolunteerSignup.
func (c *BlockVolunteerSignupClient) QueryContentBlock(_m *BlockVolunteerSignup) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockvolunteersignup.Table, blockvolunteersignup.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, blockvolunteersignup.ContentBlockTable, blockvolunteersignup.ContentBlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockVolunteerSignupClient) Hooks() []Hook {
	return c.hooks.BlockVolunteerSignup
}

// Interceptors returns the client interceptors.
func (c *BlockVolunteerSignupClient) Interceptors() []Interceptor {
	return c.inters.BlockVolunteerSignup
}

func (c *BlockVolunteerSignupClient) mutate(ctx context.Context, m *BlockVolunteerSignupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockVolunteerSignupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockVolunteerSignupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockVolunteerSignupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockVolunteerSignupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockVolunteerSignup mutation op: %q", m.Op())
	}
}

// BrandBenefitClient is a client for the BrandBenefit schema.
type BrandBenefitClient struct {
	config
}

// NewBrandBenefitClient returns a client for the BrandBenefit from the given config.
func NewBrandBenefitClient(c config) *BrandBenefitClient {
	return &BrandBenefitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `brandbenefit.Hooks(f(g(h())))`.
func (c *BrandBenefitClient) Use(hooks ...Hook) {
	c.hooks.BrandBenefit = append(c.hooks.BrandBenefit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `brandbenefit.Intercept(f(g(h())))`.
func (c *BrandBenefitClient) Intercept(interceptors ...Interceptor) {
	c.inters.BrandBenefit = append(c.inters.BrandBenefit, interceptors...)
}

// Create returns a builder for creating a BrandBenefit entity.
func (c *BrandBenefitClient) Create() *BrandBenefitCreate {
	mutation := newBrandBenefitMutation(c.config, OpCreate)
	return &BrandBenefitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BrandBenefit entities.
func (c *BrandBenefitClient) CreateBulk(builders ...*BrandBenefitCreate) *BrandBenefitCreateBulk {
	return &BrandBenefitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BrandBenefitClient) MapCreateBulk(slice any, setFunc func(*BrandBenefitCreate, int)) *BrandBenefitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BrandBenefitCreateBulk{err: fmt.Errorf("calling to BrandBenefitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BrandBenefitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BrandBenefitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BrandBenefit.
func (c *BrandBenefitClient) Update() *BrandBenefitUpdate {
	mutation := newBrandBenefitMutation(c.config, OpUpdate)
	return &BrandBenefitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BrandBenefitClient) UpdateOne(_m *BrandBenefit) *BrandBenefitUpdateOne {
	mutation := newBrandBenefitMutation(c.config, OpUpdateOne, withBrandBenefit(_m))
	return &BrandBenefitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BrandBenefitClient) UpdateOneID(id int) *BrandBenefitUpdateOne {
	mutation := newBrandBenefitMutation(c.config, OpUpdateOne, withBrandBenefitID(id))
	return &BrandBenefitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BrandBenefit.
func (c *BrandBenefitClient) Delete() *BrandBenefitDelete {
	mutation := newBrandBenefitMutation(c.config, OpDelete)
	return &BrandBenefitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BrandBenefitClient) DeleteOne(_m *BrandBenefit) *BrandBenefitDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BrandBenefitClient) DeleteOneID(id int) *BrandBenefitDeleteOne {
	builder := c.Delete().Where(brandbenefit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BrandBenefitDeleteOne{builder}
}

// Query returns a query builder for BrandBenefit.
func (c *BrandBenefitClient) Query() *BrandBenefitQuery {
	return &BrandBenefitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBrandBenefit},
		inters: c.Interceptors(),
	}
}

// Get returns a BrandBenefit entity by its id.
func (c *BrandBenefitClient) Get(ctx context.Context, id int) (*BrandBenefit, error) {
	return c.Query().Where(brandbenefit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BrandBenefitClient) GetX(ctx context.Context, id int) *BrandBenefit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPartnership queries the partnership edge of a BrandBenefit.
func (c *BrandBenefitClient) QueryPartnership(_m *BrandBenefit) *PartnershipQuery {
	query := (&PartnershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(brandbenefit.Table, brandbenefit.FieldID, id),
			sqlgraph.To(partnership.Table, partnership.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, brandbenefit.PartnershipTable, brandbenefit.PartnershipColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BrandBenefitClient) Hooks() []Hook {
	return c.hooks.BrandBenefit
}

// Interceptors returns the client interceptors.
func (c *BrandBenefitClient) Interceptors() []Interceptor {
	return c.inters.BrandBenefit
}

func (c *BrandBenefitClient) mutate(ctx context.Context, m *BrandBenefitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BrandBenefitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BrandBenefitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BrandBenefitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BrandBenefitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BrandBenefit mutation op: %q", m.Op())
	}
}

// BrandConfigClient is a client for the BrandConfig schema.
type BrandConfigClient struct {
	config
}

// NewBrandConfigClient returns a client for the BrandConfig from the given config.
func NewBrandConfigClient(c config) *BrandConfigClient {
	return &BrandConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `brandconfig.Hooks(f(g(h())))`.
func (c *BrandConfigClient) Use(hooks ...Hook) {
	c.hooks.BrandConfig = append(c.hooks.BrandConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `brandconfig.Intercept(f(g(h())))`.
func (c *BrandConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.BrandConfig = append(c.inters.BrandConfig, interceptors...)
}

// Create returns a builder for creating a BrandConfig entity.
func (c *BrandConfigClient) Create() *BrandConfigCreate {
	mutation := newBrandConfigMutation(c.config, OpCreate)
	return &BrandConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BrandConfig entities.
func (c *BrandConfigClient) CreateBulk(builders ...*BrandConfigCreate) *BrandConfigCreateBulk {
	return &BrandConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BrandConfigClient) MapCreateBulk(slice any, setFunc func(*BrandConfigCreate, int)) *BrandConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BrandConfigCreateBulk{err: fmt.Errorf("calling to BrandConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BrandConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BrandConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BrandConfig.
func (c *BrandConfigClient) Update() *BrandConfigUpdate {
	mutation := newBrandConfigMutation(c.config, OpUpdate)
	return &BrandConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BrandConfigClient) UpdateOne(_m *BrandConfig) *BrandConfigUpdateOne {
	mutation := newBrandConfigMutation(c.config, OpUpdateOne, withBrandConfig(_m))
	return &BrandConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BrandConfigClient) UpdateOneID(id int) *BrandConfigUpdateOne {
	mutation := newBrandConfigMutation(c.config, OpUpdateOne, withBrandConfigID(id))
	return &BrandConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BrandConfig.
func (c *BrandConfigClient) Delete() *BrandConfigDelete {
	mutation := newBrandConfigMutation(c.config, OpDelete)
	return &BrandConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BrandConfigClient) DeleteOne(_m *BrandConfig) *BrandConfigDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BrandConfigClient) DeleteOneID(id int) *BrandConfigDeleteOne {
	builder := c.Delete().Where(brandconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BrandConfigDeleteOne{builder}
}

// Query returns a query builder for BrandConfig.
func (c *BrandConfigClient) Query() *BrandConfigQuery {
	return &BrandConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBrandConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a BrandConfig entity by its id.
func (c *BrandConfigClient) Get(ctx context.Context, id int) (*BrandConfig, error) {
	return c.Query().Where(brandconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BrandConfigClient) GetX(ctx context.Context, id int) *BrandConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BrandConfigClient) Hooks() []Hook {
	return c.hooks.BrandConfig
}

// Interceptors returns the client interceptors.
func (c *BrandConfigClient) Interceptors() []Interceptor {
	return c.inters.BrandConfig
}

func (c *BrandConfigClient) mutate(ctx context.Context, m *BrandConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BrandConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BrandConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BrandConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BrandConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BrandConfig mutation op: %q", m.Op())
	}
}

// ContentBlockClient is a client for the ContentBlock schema.
type ContentBlockClient struct {
	config
}

// NewContentBlockClient returns a client for the ContentBlock from the given config.
func NewContentBlockClient(c config) *ContentBlockClient {
	return &ContentBlockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contentblock.Hooks(f(g(h())))`.
func (c *ContentBlockClient) Use(hooks ...Hook) {
	c.hooks.ContentBlock = append(c.hooks.ContentBlock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `contentblock.Intercept(f(g(h())))`.
func (c *ContentBlockClient) Intercept(interceptors ...Interceptor) {
	c.inters.ContentBlock = append(c.inters.ContentBlock, interceptors...)
}

// Create returns a builder for creating a ContentBlock entity.
func (c *ContentBlockClient) Create() *ContentBlockCreate {
	mutation := newContentBlockMutation(c.config, OpCreate)
	return &ContentBlockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ContentBlock entities.
func (c *ContentBlockClient) CreateBulk(builders ...*ContentBlockCreate) *ContentBlockCreateBulk {
	return &ContentBlockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ContentBlockClient) MapCreateBulk(slice any, setFunc func(*ContentBlockCreate, int)) *ContentBlockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ContentBlockCreateBulk{err: fmt.Errorf("calling to ContentBlockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ContentBlockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ContentBlockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ContentBlock.
func (c *ContentBlockClient) Update() *ContentBlockUpdate {
	mutation := newContentBlockMutation(c.config, OpUpdate)
	return &ContentBlockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContentBlockClient) UpdateOne(_m *ContentBlock) *ContentBlockUpdateOne {
	mutation := newContentBlockMutation(c.config, OpUpdateOne, withContentBlock(_m))
	return &ContentBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContentBlockClient) UpdateOneID(id int) *ContentBlockUpdateOne {
	mutation := newContentBlockMutation(c.config, OpUpdateOne, withContentBlockID(id))
	return &ContentBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ContentBlock.
func (c *ContentBlockClient) Delete() *ContentBlockDelete {
	mutation := newContentBlockMutation(c.config, OpDelete)
	return &ContentBlockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContentBlockClient) DeleteOne(_m *ContentBlock) *ContentBlockDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContentBlockClient) DeleteOneID(id int) *ContentBlockDeleteOne {
	builder := c.Delete().Where(contentblock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContentBlockDeleteOne{builder}
}

// Query returns a query builder for ContentBlock.
func (c *ContentBlockClient) Query() *ContentBlockQuery {
	return &ContentBlockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContentBlock},
		inters: c.Interceptors(),
	}
}

// Get returns a ContentBlock entity by its id.
func (c *ContentBlockClient) Get(ctx context.Context, id int) (*ContentBlock, error) {
	return c.Query().Where(contentblock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContentBlockClient) GetX(ctx context.Context, id int) *ContentBlock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPage queries the page edge of a ContentBlock.
func (c *ContentBlockClient) QueryPage(_m *ContentBlock) *PageQuery {
	query := (&PageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(page.Table, page.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contentblock.PageTable, contentblock.PageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockHero queries the block_hero edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockHero(_m *ContentBlock) *BlockHeroQuery {
	query := (&BlockHeroClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockhero.Table, blockhero.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockHeroTable, contentblock.BlockHeroColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockTextContent queries the block_text_content edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockTextContent(_m *ContentBlock) *BlockTextContentQuery {
	query := (&BlockTextContentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blocktextcontent.Table, blocktextcontent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockTextContentTable, contentblock.BlockTextContentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockFaq queries the block_faq edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockFaq(_m *ContentBlock) *BlockFaqQuery {
	query := (&BlockFaqClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockfaq.Table, blockfaq.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockFaqTable, contentblock.BlockFaqColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockCta queries the block_cta edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockCta(_m *ContentBlock) *BlockCtaQuery {
	query := (&BlockCtaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockcta.Table, blockcta.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockCtaTable, contentblock.BlockCtaColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockTestimonials queries the block_testimonials edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockTestimonials(_m *ContentBlock) *BlockTestimonialsQuery {
	query := (&BlockTestimonialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blocktestimonials.Table, blocktestimonials.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockTestimonialsTable, contentblock.BlockTestimonialsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockStats queries the block_stats edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockStats(_m *ContentBlock) *BlockStatsQuery {
	query := (&BlockStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockstats.Table, blockstats.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockStatsTable, contentblock.BlockStatsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockGallery queries the block_gallery edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockGallery(_m *ContentBlock) *BlockGalleryQuery {
	query := (&BlockGalleryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockgallery.Table, blockgallery.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockGalleryTable, contentblock.BlockGalleryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockProgramCards queries the block_program_cards edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockProgramCards(_m *ContentBlock) *BlockProgramCardsQuery {
	query := (&BlockProgramCardsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockprogramcards.Table, blockprogramcards.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockProgramCardsTable, contentblock.BlockProgramCardsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockSuccessStories queries the block_success_stories edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockSuccessStories(_m *ContentBlock) *BlockSuccessStoriesQuery {
	query := (&BlockSuccessStoriesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blocksuccessstories.Table, blocksuccessstories.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockSuccessStoriesTable, contentblock.BlockSuccessStoriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockDonationForm queries the block_donation_form edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockDonationForm(_m *ContentBlock) *BlockDonationFormQuery {
	query := (&BlockDonationFormClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockdonationform.Table, blockdonationform.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockDonationFormTable, contentblock.BlockDonationFormColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockVolunteerSignup queries the block_volunteer_signup edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockVolunteerSignup(_m *ContentBlock) *BlockVolunteerSignupQuery {
	query := (&BlockVolunteerSignupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockvolunteersignup.Table, blockvolunteersignup.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockVolunteerSignupTable, contentblock.BlockVolunteerSignupColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockNewsletterSignup queries the block_newsletter_signup edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockNewsletterSignup(_m *ContentBlock) *BlockNewsletterSignupQuery {
	query := (&BlockNewsletterSignupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blocknewslettersignup.Table, blocknewslettersignup.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockNewsletterSignupTable, contentblock.BlockNewsletterSignupColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockPartnerLogos queries the block_partner_logos edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockPartnerLogos(_m *ContentBlock) *BlockPartnerLogosQuery {
	query := (&BlockPartnerLogosClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockpartnerlogos.Table, blockpartnerlogos.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockPartnerLogosTable, contentblock.BlockPartnerLogosColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockTeamGrid queries the block_team_grid edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockTeamGrid(_m *ContentBlock) *BlockTeamGridQuery {
	query := (&BlockTeamGridClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockteamgrid.Table, blockteamgrid.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockTeamGridTable, contentblock.BlockTeamGridColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockTimeline queries the block_timeline edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockTimeline(_m *ContentBlock) *BlockTimelineQuery {
	query := (&BlockTimelineClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blocktimeline.Table, blocktimeline.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockTimelineTable, contentblock.BlockTimelineColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockContactForm queries the block_contact_form edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockContactForm(_m *ContentBlock) *BlockContactFormQuery {
	query := (&BlockContactFormClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockcontactform.Table, blockcontactform.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockContactFormTable, contentblock.BlockContactFormColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockVideoEmbed queries the block_video_embed edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockVideoEmbed(_m *ContentBlock) *BlockVideoEmbedQuery {
	query := (&BlockVideoEmbedClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockvideoembed.Table, blockvideoembed.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockVideoEmbedTable, contentblock.BlockVideoEmbedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockMap queries the block_map edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockMap(_m *ContentBlock) *BlockMapQuery {
	query := (&BlockMapClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockmap.Table, blockmap.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockMapTable, contentblock.BlockMapColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockAccordion queries the block_accordion edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockAccordion(_m *ContentBlock) *BlockAccordionQuery {
	query := (&BlockAccordionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockaccordion.Table, blockaccordion.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockAccordionTable, contentblock.BlockAccordionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockTabs queries the block_tabs edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockTabs(_m *ContentBlock) *BlockTabsQuery {
	query := (&BlockTabsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blocktabs.Table, blocktabs.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockTabsTable, contentblock.BlockTabsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockDivider queries the block_divider edge of a ContentBlock.
func (c *ContentBlockClient) QueryBlockDivider(_m *ContentBlock) *BlockDividerQuery {
	query := (&BlockDividerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contentblock.Table, contentblock.FieldID, id),
			sqlgraph.To(blockdivider.Table, blockdivider.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, contentblock.BlockDividerTable, contentblock.BlockDividerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContentBlockClient) Hooks() []Hook {
	return c.hooks.ContentBlock
}

// Interceptors returns the client interceptors.
func (c *ContentBlockClient) Interceptors() []Interceptor {
	return c.inters.ContentBlock
}

func (c *ContentBlockClient) mutate(ctx context.Context, m *ContentBlockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContentBlockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContentBlockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContentBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContentBlockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ContentBlock mutation op: %q", m.Op())
	}
}

// ConversationClient is a client for the Conversation schema.
type ConversationClient struct {
	config
}

// NewConversationClient returns a client for the Conversation from the given config.
func NewConversationClient(c config) *ConversationClient {
	return &ConversationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `conversation.Hooks(f(g(h())))`.
func (c *ConversationClient) Use(hooks ...Hook) {
	c.hooks.Conversation = append(c.hooks.Conversation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `conversation.Intercept(f(g(h())))`.
func (c *ConversationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Conversation = append(c.inters.Conversation, interceptors...)
}

// Create returns a builder for creating a Conversation entity.
func (c *ConversationClient) Create() *ConversationCreate {
	mutation := newConversationMutation(c.config, OpCreate)
	return &ConversationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Conversation entities.
func (c *ConversationClient) CreateBulk(builders ...*ConversationCreate) *ConversationCreateBulk {
	return &ConversationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConversationClient) MapCreateBulk(slice any, setFunc func(*ConversationCreate, int)) *ConversationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConversationCreateBulk{err: fmt.Errorf("calling to ConversationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConversationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConversationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Conversation.
func (c *ConversationClient) Update() *ConversationUpdate {
	mutation := newConversationMutation(c.config, OpUpdate)
	return &ConversationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConversationClient) UpdateOne(_m *Conversation) *ConversationUpdateOne {
	mutation := newConversationMutation(c.config, OpUpdateOne, withConversation(_m))
	return &ConversationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConversationClient) UpdateOneID(id int) *ConversationUpdateOne {
	mutation := newConversationMutation(c.config, OpUpdateOne, withConversationID(id))
	return &ConversationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Conversation.
func (c *ConversationClient) Delete() *ConversationDelete {
	mutation := newConversationMutation(c.config, OpDelete)
	return &ConversationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConversationClient) DeleteOne(_m *Conversation) *ConversationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConversationClient) DeleteOneID(id int) *ConversationDeleteOne {
	builder := c.Delete().Where(conversation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConversationDeleteOne{builder}
}

// Query returns a query builder for Conversation.
func (c *ConversationClient) Query() *ConversationQuery {
	return &ConversationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConversation},
		inters: c.Interceptors(),
	}
}

// Get returns a Conversation entity by its id.
func (c *ConversationClient) Get(ctx context.Context, id int) (*Conversation, error) {
	return c.Query().Where(conversation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConversationClient) GetX(ctx context.Context, id int) *Conversation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMessages queries the messages edge of a Conversation.
func (c *ConversationClient) QueryMessages(_m *Conversation) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(conversation.Table, conversation.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, conversation.MessagesTable, conversation.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParticipants queries the participants edge of a Conversation.
func (c *ConversationClient) QueryParticipants(_m *Conversation) *ConversationParticipantQuery {
	query := (&ConversationParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(conversation.Table, conversation.FieldID, id),
			sqlgraph.To(conversationparticipant.Table, conversationparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, conversation.ParticipantsTable, conversation.ParticipantsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConversationClient) Hooks() []Hook {
	return c.hooks.Conversation
}

// Interceptors returns the client interceptors.
func (c *ConversationClient) Interceptors() []Interceptor {
	return c.inters.Conversation
}

func (c *ConversationClient) mutate(ctx context.Context, m *ConversationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConversationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConversationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConversationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConversationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Conversation mutation op: %q", m.Op())
	}
}

// ConversationParticipantClient is a client for the ConversationParticipant schema.
type ConversationParticipantClient struct {
	config
}

// NewConversationParticipantClient returns a client for the ConversationParticipant from the given config.
func NewConversationParticipantClient(c config) *ConversationParticipantClient {
	return &ConversationParticipantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `conversationparticipant.Hooks(f(g(h())))`.
func (c *ConversationParticipantClient) Use(hooks ...Hook) {
	c.hooks.ConversationParticipant = append(c.hooks.ConversationParticipant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `conversationparticipant.Intercept(f(g(h())))`.
func (c *ConversationParticipantClient) Intercept(interceptors ...Interceptor) {
	c.inters.ConversationParticipant = append(c.inters.ConversationParticipant, interceptors...)
}

// Create returns a builder for creating a ConversationParticipant entity.
func (c *ConversationParticipantClient) Create() *ConversationParticipantCreate {
	mutation := newConversationParticipantMutation(c.config, OpCreate)
	return &ConversationParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ConversationParticipant entities.
func (c *ConversationParticipantClient) CreateBulk(builders ...*ConversationParticipantCreate) *ConversationParticipantCreateBulk {
	return &ConversationParticipantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConversationParticipantClient) MapCreateBulk(slice any, setFunc func(*ConversationParticipantCreate, int)) *ConversationParticipantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConversationParticipantCreateBulk{err: fmt.Errorf("calling to ConversationParticipantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConversationParticipantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConversationParticipantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ConversationParticipant.
func (c *ConversationParticipantClient) Update() *ConversationParticipantUpdate {
	mutation := newConversationParticipantMutation(c.config, OpUpdate)
	return &ConversationParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConversationParticipantClient) UpdateOne(_m *ConversationParticipant) *ConversationParticipantUpdateOne {
	mutation := newConversationParticipantMutation(c.config, OpUpdateOne, withConversationParticipant(_m))
	return &ConversationParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConversationParticipantClient) UpdateOneID(id int) *ConversationParticipantUpdateOne {
	mutation := newConversationParticipantMutation(c.config, OpUpdateOne, withConversationParticipantID(id))
	return &ConversationParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ConversationParticipant.
func (c *ConversationParticipantClient) Delete() *ConversationParticipantDelete {
	mutation := newConversationParticipantMutation(c.config, OpDelete)
	return &ConversationParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConversationParticipantClient) DeleteOne(_m *ConversationParticipant) *ConversationParticipantDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConversationParticipantClient) DeleteOneID(id int) *ConversationParticipantDeleteOne {
	builder := c.Delete().Where(conversationparticipant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConversationParticipantDeleteOne{builder}
}

// Query returns a query builder for ConversationParticipant.
func (c *ConversationParticipantClient) Query() *ConversationParticipantQuery {
	return &ConversationParticipantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConversationParticipant},
		inters: c.Interceptors(),
	}
}

// Get returns a ConversationParticipant entity by its id.
func (c *ConversationParticipantClient) Get(ctx context.Context, id int) (*ConversationParticipant, error) {
	return c.Query().Where(conversationparticipant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConversationParticipantClient) GetX(ctx context.Context, id int) *ConversationParticipant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConversation queries the conversation edge of a ConversationParticipant.
func (c *ConversationParticipantClient) QueryConversation(_m *ConversationParticipant) *ConversationQuery {
	query := (&ConversationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(conversationparticipant.Table, conversationparticipant.FieldID, id),
			sqlgraph.To(conversation.Table, conversation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, conversationparticipant.ConversationTable, conversationparticipant.ConversationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ConversationParticipant.
func (c *ConversationParticipantClient) QueryUser(_m *ConversationParticipant) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(conversationparticipant.Table, conversationparticipant.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, conversationparticipant.UserTable, conversationparticipant.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConversationParticipantClient) Hooks() []Hook {
	return c.hooks.ConversationParticipant
}

// Interceptors returns the client interceptors.
func (c *ConversationParticipantClient) Interceptors() []Interceptor {
	return c.inters.ConversationParticipant
}

func (c *ConversationParticipantClient) mutate(ctx context.Context, m *ConversationParticipantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConversationParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConversationParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConversationParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConversationParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ConversationParticipant mutation op: %q", m.Op())
	}
}

// DashboardWidgetClient is a client for the DashboardWidget schema.
type DashboardWidgetClient struct {
	config
}

// NewDashboardWidgetClient returns a client for the DashboardWidget from the given config.
func NewDashboardWidgetClient(c config) *DashboardWidgetClient {
	return &DashboardWidgetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dashboardwidget.Hooks(f(g(h())))`.
func (c *DashboardWidgetClient) Use(hooks ...Hook) {
	c.hooks.DashboardWidget = append(c.hooks.DashboardWidget, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dashboardwidget.Intercept(f(g(h())))`.
func (c *DashboardWidgetClient) Intercept(interceptors ...Interceptor) {
	c.inters.DashboardWidget = append(c.inters.DashboardWidget, interceptors...)
}

// Create returns a builder for creating a DashboardWidget entity.
func (c *DashboardWidgetClient) Create() *DashboardWidgetCreate {
	mutation := newDashboardWidgetMutation(c.config, OpCreate)
	return &DashboardWidgetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DashboardWidget entities.
func (c *DashboardWidgetClient) CreateBulk(builders ...*DashboardWidgetCreate) *DashboardWidgetCreateBulk {
	return &DashboardWidgetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DashboardWidgetClient) MapCreateBulk(slice any, setFunc func(*DashboardWidgetCreate, int)) *DashboardWidgetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DashboardWidgetCreateBulk{err: fmt.Errorf("calling to DashboardWidgetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DashboardWidgetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DashboardWidgetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DashboardWidget.
func (c *DashboardWidgetClient) Update() *DashboardWidgetUpdate {
	mutation := newDashboardWidgetMutation(c.config, OpUpdate)
	return &DashboardWidgetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DashboardWidgetClient) UpdateOne(_m *DashboardWidget) *DashboardWidgetUpdateOne {
	mutation := newDashboardWidgetMutation(c.config, OpUpdateOne, withDashboardWidget(_m))
	return &DashboardWidgetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DashboardWidgetClient) UpdateOneID(id int) *DashboardWidgetUpdateOne {
	mutation := newDashboardWidgetMutation(c.config, OpUpdateOne, withDashboardWidgetID(id))
	return &DashboardWidgetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DashboardWidget.
func (c *DashboardWidgetClient) Delete() *DashboardWidgetDelete {
	mutation := newDashboardWidgetMutation(c.config, OpDelete)
	return &DashboardWidgetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DashboardWidgetClient) DeleteOne(_m *DashboardWidget) *DashboardWidgetDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DashboardWidgetClient) DeleteOneID(id int) *DashboardWidgetDeleteOne {
	builder := c.Delete().Where(dashboardwidget.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DashboardWidgetDeleteOne{builder}
}

// Query returns a query builder for DashboardWidget.
func (c *DashboardWidgetClient) Query() *DashboardWidgetQuery {
	return &DashboardWidgetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDashboardWidget},
		inters: c.Interceptors(),
	}
}

// Get returns a DashboardWidget entity by its id.
func (c *DashboardWidgetClient) Get(ctx context.Context, id int) (*DashboardWidget, error) {
	return c.Query().Where(dashboardwidget.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DashboardWidgetClient) GetX(ctx context.Context, id int) *DashboardWidget {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDashboard queries the dashboard edge of a DashboardWidget.
func (c *DashboardWidgetClient) QueryDashboard(_m *DashboardWidget) *AnalyticsDashboardQuery {
	query := (&AnalyticsDashboardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dashboardwidget.Table, dashboardwidget.FieldID, id),
			sqlgraph.To(analyticsdashboard.Table, analyticsdashboard.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dashboardwidget.DashboardTable, dashboardwidget.DashboardColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DashboardWidgetClient) Hooks() []Hook {
	return c.hooks.DashboardWidget
}

// Interceptors returns the client interceptors.
func (c *DashboardWidgetClient) Interceptors() []Interceptor {
	return c.inters.DashboardWidget
}

func (c *DashboardWidgetClient) mutate(ctx context.Context, m *DashboardWidgetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DashboardWidgetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DashboardWidgetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DashboardWidgetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DashboardWidgetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DashboardWidget mutation op: %q", m.Op())
	}
}

// DocumentClient is a client for the Document schema.
type DocumentClient struct {
	config
}

// NewDocumentClient returns a client for the Document from the given config.
func NewDocumentClient(c config) *DocumentClient {
	return &DocumentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `document.Hooks(f(g(h())))`.
func (c *DocumentClient) Use(hooks ...Hook) {
	c.hooks.Document = append(c.hooks.Document, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `document.Intercept(f(g(h())))`.
func (c *DocumentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Document = append(c.inters.Document, interceptors...)
}

// Create returns a builder for creating a Document entity.
func (c *DocumentClient) Create() *DocumentCreate {
	mutation := newDocumentMutation(c.config, OpCreate)
	return &DocumentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Document entities.
func (c *DocumentClient) CreateBulk(builders ...*DocumentCreate) *DocumentCreateBulk {
	return &DocumentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentClient) MapCreateBulk(slice any, setFunc func(*DocumentCreate, int)) *DocumentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentCreateBulk{err: fmt.Errorf("calling to DocumentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Document.
func (c *DocumentClient) Update() *DocumentUpdate {
	mutation := newDocumentMutation(c.config, OpUpdate)
	return &DocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentClient) UpdateOne(_m *Document) *DocumentUpdateOne {
	mutation := newDocumentMutation(c.config, OpUpdateOne, withDocument(_m))
	return &DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentClient) UpdateOneID(id int) *DocumentUpdateOne {
	mutation := newDocumentMutation(c.config, OpUpdateOne, withDocumentID(id))
	return &DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Document.
func (c *DocumentClient) Delete() *DocumentDelete {
	mutation := newDocumentMutation(c.config, OpDelete)
	return &DocumentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentClient) DeleteOne(_m *Document) *DocumentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentClient) DeleteOneID(id int) *DocumentDeleteOne {
	builder := c.Delete().Where(document.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentDeleteOne{builder}
}

// Query returns a query builder for Document.
func (c *DocumentClient) Query() *DocumentQuery {
	return &DocumentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocument},
		inters: c.Interceptors(),
	}
}

// Get returns a Document entity by its id.
func (c *DocumentClient) Get(ctx context.Context, id int) (*Document, error) {
	return c.Query().Where(document.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentClient) GetX(ctx context.Context, id int) *Document {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUploader queries the uploader edge of a Document.
func (c *DocumentClient) QueryUploader(_m *Document) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(document.Table, document.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, document.UploaderTable, document.UploaderColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategory queries the category edge of a Document.
func (c *DocumentClient) QueryCategory(_m *Document) *DocumentCategoryQuery {
	query := (&DocumentCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(document.Table, document.FieldID, id),
			sqlgraph.To(documentcategory.Table, documentcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, document.CategoryTable, document.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DocumentClient) Hooks() []Hook {
	return c.hooks.Document
}

// Interceptors returns the client interceptors.
func (c *DocumentClient) Interceptors() []Interceptor {
	return c.inters.Document
}

func (c *DocumentClient) mutate(ctx context.Context, m *DocumentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Document mutation op: %q", m.Op())
	}
}

// DocumentCategoryClient is a client for the DocumentCategory schema.
type DocumentCategoryClient struct {
	config
}

// NewDocumentCategoryClient returns a client for the DocumentCategory from the given config.
func NewDocumentCategoryClient(c config) *DocumentCategoryClient {
	return &DocumentCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `documentcategory.Hooks(f(g(h())))`.
func (c *DocumentCategoryClient) Use(hooks ...Hook) {
	c.hooks.DocumentCategory = append(c.hooks.DocumentCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `documentcategory.Intercept(f(g(h())))`.
func (c *DocumentCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.DocumentCategory = append(c.inters.DocumentCategory, interceptors...)
}

// Create returns a builder for creating a DocumentCategory entity.
func (c *DocumentCategoryClient) Create() *DocumentCategoryCreate {
	mutation := newDocumentCategoryMutation(c.config, OpCreate)
	return &DocumentCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DocumentCategory entities.
func (c *DocumentCategoryClient) CreateBulk(builders ...*DocumentCategoryCreate) *DocumentCategoryCreateBulk {
	return &DocumentCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentCategoryClient) MapCreateBulk(slice any, setFunc func(*DocumentCategoryCreate, int)) *DocumentCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentCategoryCreateBulk{err: fmt.Errorf("calling to DocumentCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DocumentCategory.
func (c *DocumentCategoryClient) Update() *DocumentCategoryUpdate {
	mutation := newDocumentCategoryMutation(c.config, OpUpdate)
	return &DocumentCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentCategoryClient) UpdateOne(_m *DocumentCategory) *DocumentCategoryUpdateOne {
	mutation := newDocumentCategoryMutation(c.config, OpUpdateOne, withDocumentCategory(_m))
	return &DocumentCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentCategoryClient) UpdateOneID(id int) *DocumentCategoryUpdateOne {
	mutation := newDocumentCategoryMutation(c.config, OpUpdateOne, withDocumentCategoryID(id))
	return &DocumentCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DocumentCategory.
func (c *DocumentCategoryClient) Delete() *DocumentCategoryDelete {
	mutation := newDocumentCategoryMutation(c.config, OpDelete)
	return &DocumentCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentCategoryClient) DeleteOne(_m *DocumentCategory) *DocumentCategoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentCategoryClient) DeleteOneID(id int) *DocumentCategoryDeleteOne {
	builder := c.Delete().Where(documentcategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentCategoryDeleteOne{builder}
}

// Query returns a query builder for DocumentCategory.
func (c *DocumentCategoryClient) Query() *DocumentCategoryQuery {
	return &DocumentCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocumentCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a DocumentCategory entity by its id.
func (c *DocumentCategoryClient) Get(ctx context.Context, id int) (*DocumentCategory, error) {
	return c.Query().Where(documentcategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentCategoryClient) GetX(ctx context.Context, id int) *DocumentCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChildren queries the children edge of a DocumentCategory.
func (c *DocumentCategoryClient) QueryChildren(_m *DocumentCategory) *DocumentCategoryQuery {
	query := (&DocumentCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documentcategory.Table, documentcategory.FieldID, id),
			sqlgraph.To(documentcategory.Table, documentcategory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, documentcategory.ChildrenTable, documentcategory.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a DocumentCategory.
func (c *DocumentCategoryClient) QueryParent(_m *DocumentCategory) *DocumentCategoryQuery {
	query := (&DocumentCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documentcategory.Table, documentcategory.FieldID, id),
			sqlgraph.To(documentcategory.Table, documentcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, documentcategory.ParentTable, documentcategory.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocuments queries the documents edge of a DocumentCategory.
func (c *DocumentCategoryClient) QueryDocuments(_m *DocumentCategory) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(documentcategory.Table, documentcategory.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, documentcategory.DocumentsTable, documentcategory.DocumentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DocumentCategoryClient) Hooks() []Hook {
	return c.hooks.DocumentCategory
}

// Interceptors returns the client interceptors.
func (c *DocumentCategoryClient) Interceptors() []Interceptor {
	return c.inters.DocumentCategory
}

func (c *DocumentCategoryClient) mutate(ctx context.Context, m *DocumentCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DocumentCategory mutation op: %q", m.Op())
	}
}

// DonationClient is a client for the Donation schema.
type DonationClient struct {
	config
}

// NewDonationClient returns a client for the Donation from the given config.
func NewDonationClient(c config) *DonationClient {
	return &DonationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `donation.Hooks(f(g(h())))`.
func (c *DonationClient) Use(hooks ...Hook) {
	c.hooks.Donation = append(c.hooks.Donation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `donation.Intercept(f(g(h())))`.
func (c *DonationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Donation = append(c.inters.Donation, interceptors...)
}

// Create returns a builder for creating a Donation entity.
func (c *DonationClient) Create() *DonationCreate {
	mutation := newDonationMutation(c.config, OpCreate)
	return &DonationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Donation entities.
func (c *DonationClient) CreateBulk(builders ...*DonationCreate) *DonationCreateBulk {
	return &DonationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DonationClient) MapCreateBulk(slice any, setFunc func(*DonationCreate, int)) *DonationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DonationCreateBulk{err: fmt.Errorf("calling to DonationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DonationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DonationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Donation.
func (c *DonationClient) Update() *DonationUpdate {
	mutation := newDonationMutation(c.config, OpUpdate)
	return &DonationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DonationClient) UpdateOne(_m *Donation) *DonationUpdateOne {
	mutation := newDonationMutation(c.config, OpUpdateOne, withDonation(_m))
	return &DonationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DonationClient) UpdateOneID(id int) *DonationUpdateOne {
	mutation := newDonationMutation(c.config, OpUpdateOne, withDonationID(id))
	return &DonationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Donation.
func (c *DonationClient) Delete() *DonationDelete {
	mutation := newDonationMutation(c.config, OpDelete)
	return &DonationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DonationClient) DeleteOne(_m *Donation) *DonationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DonationClient) DeleteOneID(id int) *DonationDeleteOne {
	builder := c.Delete().Where(donation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DonationDeleteOne{builder}
}

// Query returns a query builder for Donation.
func (c *DonationClient) Query() *DonationQuery {
	return &DonationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDonation},
		inters: c.Interceptors(),
	}
}

// Get returns a Donation entity by its id.
func (c *DonationClient) Get(ctx context.Context, id int) (*Donation, error) {
	return c.Query().Where(donation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DonationClient) GetX(ctx context.Context, id int) *Donation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDonor queries the donor edge of a Donation.
func (c *DonationClient) QueryDonor(_m *Donation) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(donation.Table, donation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, donation.DonorTable, donation.DonorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a Donation.
func (c *DonationClient) QueryProgram(_m *Donation) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(donation.Table, donation.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, donation.ProgramTable, donation.ProgramColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCampaign queries the campaign edge of a Donation.
func (c *DonationClient) QueryCampaign(_m *Donation) *FundraisingCampaignQuery {
	query := (&FundraisingCampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(donation.Table, donation.FieldID, id),
			sqlgraph.To(fundraisingcampaign.Table, fundraisingcampaign.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, donation.CampaignTable, donation.CampaignColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DonationClient) Hooks() []Hook {
	return c.hooks.Donation
}

// Interceptors returns the client interceptors.
func (c *DonationClient) Interceptors() []Interceptor {
	return c.inters.Donation
}

func (c *DonationClient) mutate(ctx context.Context, m *DonationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DonationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DonationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DonationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DonationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Donation mutation op: %q", m.Op())
	}
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event.Intercept(f(g(h())))`.
func (c *EventClient) Intercept(interceptors ...Interceptor) {
	c.inters.Event = append(c.inters.Event, interceptors...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventClient) MapCreateBulk(slice any, setFunc func(*EventCreate, int)) *EventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventCreateBulk{err: fmt.Errorf("calling to EventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(_m *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(_m))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id int) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(_m *Event) *EventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id int) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id int) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id int) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProgram queries the program edge of a Event.
func (c *EventClient) QueryProgram(_m *Event) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, event.ProgramTable, event.ProgramColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the created_by edge of a Event.
func (c *EventClient) QueryCreatedBy(_m *Event) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, event.CreatedByTable, event.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRegistrations queries the registrations edge of a Event.
func (c *EventClient) QueryRegistrations(_m *Event) *EventRegistrationQuery {
	query := (&EventRegistrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(eventregistration.Table, eventregistration.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.RegistrationsTable, event.RegistrationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgenda queries the agenda edge of a Event.
func (c *EventClient) QueryAgenda(_m *Event) *AgendaQuery {
	query := (&AgendaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(agenda.Table, agenda.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, event.AgendaTable, event.AgendaColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLocation queries the location edge of a Event.
func (c *EventClient) QueryLocation(_m *Event) *AddressQuery {
	query := (&AddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(address.Table, address.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, event.LocationTable, event.LocationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	return c.hooks.Event
}

// Interceptors returns the client interceptors.
func (c *EventClient) Interceptors() []Interceptor {
	return c.inters.Event
}

func (c *EventClient) mutate(ctx context.Context, m *EventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Event mutation op: %q", m.Op())
	}
}

// EventRegistrationClient is a client for the EventRegistration schema.
type EventRegistrationClient struct {
	config
}

// NewEventRegistrationClient returns a client for the EventRegistration from the given config.
func NewEventRegistrationClient(c config) *EventRegistrationClient {
	return &EventRegistrationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventregistration.Hooks(f(g(h())))`.
func (c *EventRegistrationClient) Use(hooks ...Hook) {
	c.hooks.EventRegistration = append(c.hooks.EventRegistration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventregistration.Intercept(f(g(h())))`.
func (c *EventRegistrationClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventRegistration = append(c.inters.EventRegistration, interceptors...)
}

// Create returns a builder for creating a EventRegistration entity.
func (c *EventRegistrationClient) Create() *EventRegistrationCreate {
	mutation := newEventRegistrationMutation(c.config, OpCreate)
	return &EventRegistrationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventRegistration entities.
func (c *EventRegistrationClient) CreateBulk(builders ...*EventRegistrationCreate) *EventRegistrationCreateBulk {
	return &EventRegistrationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EventRegistrationClient) MapCreateBulk(slice any, setFunc func(*EventRegistrationCreate, int)) *EventRegistrationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EventRegistrationCreateBulk{err: fmt.Errorf("calling to EventRegistrationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EventRegistrationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EventRegistrationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventRegistration.
func (c *EventRegistrationClient) Update() *EventRegistrationUpdate {
	mutation := newEventRegistrationMutation(c.config, OpUpdate)
	return &EventRegistrationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventRegistrationClient) UpdateOne(_m *EventRegistration) *EventRegistrationUpdateOne {
	mutation := newEventRegistrationMutation(c.config, OpUpdateOne, withEventRegistration(_m))
	return &EventRegistrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventRegistrationClient) UpdateOneID(id int) *EventRegistrationUpdateOne {
	mutation := newEventRegistrationMutation(c.config, OpUpdateOne, withEventRegistrationID(id))
	return &EventRegistrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventRegistration.
func (c *EventRegistrationClient) Delete() *EventRegistrationDelete {
	mutation := newEventRegistrationMutation(c.config, OpDelete)
	return &EventRegistrationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventRegistrationClient) DeleteOne(_m *EventRegistration) *EventRegistrationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventRegistrationClient) DeleteOneID(id int) *EventRegistrationDeleteOne {
	builder := c.Delete().Where(eventregistration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventRegistrationDeleteOne{builder}
}

// Query returns a query builder for EventRegistration.
func (c *EventRegistrationClient) Query() *EventRegistrationQuery {
	return &EventRegistrationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventRegistration},
		inters: c.Interceptors(),
	}
}

// Get returns a EventRegistration entity by its id.
func (c *EventRegistrationClient) Get(ctx context.Context, id int) (*EventRegistration, error) {
	return c.Query().Where(eventregistration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventRegistrationClient) GetX(ctx context.Context, id int) *EventRegistration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a EventRegistration.
func (c *EventRegistrationClient) QueryEvent(_m *EventRegistration) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventregistration.Table, eventregistration.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, eventregistration.EventTable, eventregistration.EventColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a EventRegistration.
func (c *EventRegistrationClient) QueryUser(_m *EventRegistration) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventregistration.Table, eventregistration.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, eventregistration.UserTable, eventregistration.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventRegistrationClient) Hooks() []Hook {
	return c.hooks.EventRegistration
}

// Interceptors returns the client interceptors.
func (c *EventRegistrationClient) Interceptors() []Interceptor {
	return c.inters.EventRegistration
}

func (c *EventRegistrationClient) mutate(ctx context.Context, m *EventRegistrationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventRegistrationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventRegistrationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventRegistrationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventRegistrationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EventRegistration mutation op: %q", m.Op())
	}
}

// FaqItemClient is a client for the FaqItem schema.
type FaqItemClient struct {
	config
}

// NewFaqItemClient returns a client for the FaqItem from the given config.
func NewFaqItemClient(c config) *FaqItemClient {
	return &FaqItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `faqitem.Hooks(f(g(h())))`.
func (c *FaqItemClient) Use(hooks ...Hook) {
	c.hooks.FaqItem = append(c.hooks.FaqItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `faqitem.Intercept(f(g(h())))`.
func (c *FaqItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.FaqItem = append(c.inters.FaqItem, interceptors...)
}

// Create returns a builder for creating a FaqItem entity.
func (c *FaqItemClient) Create() *FaqItemCreate {
	mutation := newFaqItemMutation(c.config, OpCreate)
	return &FaqItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FaqItem entities.
func (c *FaqItemClient) CreateBulk(builders ...*FaqItemCreate) *FaqItemCreateBulk {
	return &FaqItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FaqItemClient) MapCreateBulk(slice any, setFunc func(*FaqItemCreate, int)) *FaqItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FaqItemCreateBulk{err: fmt.Errorf("calling to FaqItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FaqItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FaqItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FaqItem.
func (c *FaqItemClient) Update() *FaqItemUpdate {
	mutation := newFaqItemMutation(c.config, OpUpdate)
	return &FaqItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FaqItemClient) UpdateOne(_m *FaqItem) *FaqItemUpdateOne {
	mutation := newFaqItemMutation(c.config, OpUpdateOne, withFaqItem(_m))
	return &FaqItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FaqItemClient) UpdateOneID(id int) *FaqItemUpdateOne {
	mutation := newFaqItemMutation(c.config, OpUpdateOne, withFaqItemID(id))
	return &FaqItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FaqItem.
func (c *FaqItemClient) Delete() *FaqItemDelete {
	mutation := newFaqItemMutation(c.config, OpDelete)
	return &FaqItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FaqItemClient) DeleteOne(_m *FaqItem) *FaqItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FaqItemClient) DeleteOneID(id int) *FaqItemDeleteOne {
	builder := c.Delete().Where(faqitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FaqItemDeleteOne{builder}
}

// Query returns a query builder for FaqItem.
func (c *FaqItemClient) Query() *FaqItemQuery {
	return &FaqItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFaqItem},
		inters: c.Interceptors(),
	}
}

// Get returns a FaqItem entity by its id.
func (c *FaqItemClient) Get(ctx context.Context, id int) (*FaqItem, error) {
	return c.Query().Where(faqitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FaqItemClient) GetX(ctx context.Context, id int) *FaqItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlock queries the block edge of a FaqItem.
func (c *FaqItemClient) QueryBlock(_m *FaqItem) *BlockFaqQuery {
	query := (&BlockFaqClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(faqitem.Table, faqitem.FieldID, id),
			sqlgraph.To(blockfaq.Table, blockfaq.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, faqitem.BlockTable, faqitem.BlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FaqItemClient) Hooks() []Hook {
	return c.hooks.FaqItem
}

// Interceptors returns the client interceptors.
func (c *FaqItemClient) Interceptors() []Interceptor {
	return c.inters.FaqItem
}

func (c *FaqItemClient) mutate(ctx context.Context, m *FaqItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FaqItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FaqItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FaqItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FaqItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FaqItem mutation op: %q", m.Op())
	}
}

// FeatureFlagClient is a client for the FeatureFlag schema.
type FeatureFlagClient struct {
	config
}

// NewFeatureFlagClient returns a client for the FeatureFlag from the given config.
func NewFeatureFlagClient(c config) *FeatureFlagClient {
	return &FeatureFlagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `featureflag.Hooks(f(g(h())))`.
func (c *FeatureFlagClient) Use(hooks ...Hook) {
	c.hooks.FeatureFlag = append(c.hooks.FeatureFlag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `featureflag.Intercept(f(g(h())))`.
func (c *FeatureFlagClient) Intercept(interceptors ...Interceptor) {
	c.inters.FeatureFlag = append(c.inters.FeatureFlag, interceptors...)
}

// Create returns a builder for creating a FeatureFlag entity.
func (c *FeatureFlagClient) Create() *FeatureFlagCreate {
	mutation := newFeatureFlagMutation(c.config, OpCreate)
	return &FeatureFlagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FeatureFlag entities.
func (c *FeatureFlagClient) CreateBulk(builders ...*FeatureFlagCreate) *FeatureFlagCreateBulk {
	return &FeatureFlagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FeatureFlagClient) MapCreateBulk(slice any, setFunc func(*FeatureFlagCreate, int)) *FeatureFlagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FeatureFlagCreateBulk{err: fmt.Errorf("calling to FeatureFlagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FeatureFlagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FeatureFlagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FeatureFlag.
func (c *FeatureFlagClient) Update() *FeatureFlagUpdate {
	mutation := newFeatureFlagMutation(c.config, OpUpdate)
	return &FeatureFlagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeatureFlagClient) UpdateOne(_m *FeatureFlag) *FeatureFlagUpdateOne {
	mutation := newFeatureFlagMutation(c.config, OpUpdateOne, withFeatureFlag(_m))
	return &FeatureFlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeatureFlagClient) UpdateOneID(id string) *FeatureFlagUpdateOne {
	mutation := newFeatureFlagMutation(c.config, OpUpdateOne, withFeatureFlagID(id))
	return &FeatureFlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FeatureFlag.
func (c *FeatureFlagClient) Delete() *FeatureFlagDelete {
	mutation := newFeatureFlagMutation(c.config, OpDelete)
	return &FeatureFlagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeatureFlagClient) DeleteOne(_m *FeatureFlag) *FeatureFlagDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeatureFlagClient) DeleteOneID(id string) *FeatureFlagDeleteOne {
	builder := c.Delete().Where(featureflag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeatureFlagDeleteOne{builder}
}

// Query returns a query builder for FeatureFlag.
func (c *FeatureFlagClient) Query() *FeatureFlagQuery {
	return &FeatureFlagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFeatureFlag},
		inters: c.Interceptors(),
	}
}

// Get returns a FeatureFlag entity by its id.
func (c *FeatureFlagClient) Get(ctx context.Context, id string) (*FeatureFlag, error) {
	return c.Query().Where(featureflag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeatureFlagClient) GetX(ctx context.Context, id string) *FeatureFlag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FeatureFlagClient) Hooks() []Hook {
	return c.hooks.FeatureFlag
}

// Interceptors returns the client interceptors.
func (c *FeatureFlagClient) Interceptors() []Interceptor {
	return c.inters.FeatureFlag
}

func (c *FeatureFlagClient) mutate(ctx context.Context, m *FeatureFlagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FeatureFlagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FeatureFlagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FeatureFlagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FeatureFlagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FeatureFlag mutation op: %q", m.Op())
	}
}

// FundraisingCampaignClient is a client for the FundraisingCampaign schema.
type FundraisingCampaignClient struct {
	config
}

// NewFundraisingCampaignClient returns a client for the FundraisingCampaign from the given config.
func NewFundraisingCampaignClient(c config) *FundraisingCampaignClient {
	return &FundraisingCampaignClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fundraisingcampaign.Hooks(f(g(h())))`.
func (c *FundraisingCampaignClient) Use(hooks ...Hook) {
	c.hooks.FundraisingCampaign = append(c.hooks.FundraisingCampaign, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fundraisingcampaign.Intercept(f(g(h())))`.
func (c *FundraisingCampaignClient) Intercept(interceptors ...Interceptor) {
	c.inters.FundraisingCampaign = append(c.inters.FundraisingCampaign, interceptors...)
}

// Create returns a builder for creating a FundraisingCampaign entity.
func (c *FundraisingCampaignClient) Create() *FundraisingCampaignCreate {
	mutation := newFundraisingCampaignMutation(c.config, OpCreate)
	return &FundraisingCampaignCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FundraisingCampaign entities.
func (c *FundraisingCampaignClient) CreateBulk(builders ...*FundraisingCampaignCreate) *FundraisingCampaignCreateBulk {
	return &FundraisingCampaignCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FundraisingCampaignClient) MapCreateBulk(slice any, setFunc func(*FundraisingCampaignCreate, int)) *FundraisingCampaignCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FundraisingCampaignCreateBulk{err: fmt.Errorf("calling to FundraisingCampaignClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FundraisingCampaignCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FundraisingCampaignCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FundraisingCampaign.
func (c *FundraisingCampaignClient) Update() *FundraisingCampaignUpdate {
	mutation := newFundraisingCampaignMutation(c.config, OpUpdate)
	return &FundraisingCampaignUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FundraisingCampaignClient) UpdateOne(_m *FundraisingCampaign) *FundraisingCampaignUpdateOne {
	mutation := newFundraisingCampaignMutation(c.config, OpUpdateOne, withFundraisingCampaign(_m))
	return &FundraisingCampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FundraisingCampaignClient) UpdateOneID(id int) *FundraisingCampaignUpdateOne {
	mutation := newFundraisingCampaignMutation(c.config, OpUpdateOne, withFundraisingCampaignID(id))
	return &FundraisingCampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FundraisingCampaign.
func (c *FundraisingCampaignClient) Delete() *FundraisingCampaignDelete {
	mutation := newFundraisingCampaignMutation(c.config, OpDelete)
	return &FundraisingCampaignDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FundraisingCampaignClient) DeleteOne(_m *FundraisingCampaign) *FundraisingCampaignDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FundraisingCampaignClient) DeleteOneID(id int) *FundraisingCampaignDeleteOne {
	builder := c.Delete().Where(fundraisingcampaign.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FundraisingCampaignDeleteOne{builder}
}

// Query returns a query builder for FundraisingCampaign.
func (c *FundraisingCampaignClient) Query() *FundraisingCampaignQuery {
	return &FundraisingCampaignQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFundraisingCampaign},
		inters: c.Interceptors(),
	}
}

// Get returns a FundraisingCampaign entity by its id.
func (c *FundraisingCampaignClient) Get(ctx context.Context, id int) (*FundraisingCampaign, error) {
	return c.Query().Where(fundraisingcampaign.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FundraisingCampaignClient) GetX(ctx context.Context, id int) *FundraisingCampaign {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProgram queries the program edge of a FundraisingCampaign.
func (c *FundraisingCampaignClient) QueryProgram(_m *FundraisingCampaign) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fundraisingcampaign.Table, fundraisingcampaign.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fundraisingcampaign.ProgramTable, fundraisingcampaign.ProgramColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildCampaigns queries the child_campaigns edge of a FundraisingCampaign.
func (c *FundraisingCampaignClient) QueryChildCampaigns(_m *FundraisingCampaign) *FundraisingCampaignQuery {
	query := (&FundraisingCampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fundraisingcampaign.Table, fundraisingcampaign.FieldID, id),
			sqlgraph.To(fundraisingcampaign.Table, fundraisingcampaign.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, fundraisingcampaign.ChildCampaignsTable, fundraisingcampaign.ChildCampaignsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentCampaign queries the parent_campaign edge of a FundraisingCampaign.
func (c *FundraisingCampaignClient) QueryParentCampaign(_m *FundraisingCampaign) *FundraisingCampaignQuery {
	query := (&FundraisingCampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fundraisingcampaign.Table, fundraisingcampaign.FieldID, id),
			sqlgraph.To(fundraisingcampaign.Table, fundraisingcampaign.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, fundraisingcampaign.ParentCampaignTable, fundraisingcampaign.ParentCampaignColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDonations queries the donations edge of a FundraisingCampaign.
func (c *FundraisingCampaignClient) QueryDonations(_m *FundraisingCampaign) *DonationQuery {
	query := (&DonationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fundraisingcampaign.Table, fundraisingcampaign.FieldID, id),
			sqlgraph.To(donation.Table, donation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, fundraisingcampaign.DonationsTable, fundraisingcampaign.DonationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FundraisingCampaignClient) Hooks() []Hook {
	return c.hooks.FundraisingCampaign
}

// Interceptors returns the client interceptors.
func (c *FundraisingCampaignClient) Interceptors() []Interceptor {
	return c.inters.FundraisingCampaign
}

func (c *FundraisingCampaignClient) mutate(ctx context.Context, m *FundraisingCampaignMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FundraisingCampaignCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FundraisingCampaignUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FundraisingCampaignUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FundraisingCampaignDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FundraisingCampaign mutation op: %q", m.Op())
	}
}

// GalleryImageClient is a client for the GalleryImage schema.
type GalleryImageClient struct {
	config
}

// NewGalleryImageClient returns a client for the GalleryImage from the given config.
func NewGalleryImageClient(c config) *GalleryImageClient {
	return &GalleryImageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `galleryimage.Hooks(f(g(h())))`.
func (c *GalleryImageClient) Use(hooks ...Hook) {
	c.hooks.GalleryImage = append(c.hooks.GalleryImage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `galleryimage.Intercept(f(g(h())))`.
func (c *GalleryImageClient) Intercept(interceptors ...Interceptor) {
	c.inters.GalleryImage = append(c.inters.GalleryImage, interceptors...)
}

// Create returns a builder for creating a GalleryImage entity.
func (c *GalleryImageClient) Create() *GalleryImageCreate {
	mutation := newGalleryImageMutation(c.config, OpCreate)
	return &GalleryImageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GalleryImage entities.
func (c *GalleryImageClient) CreateBulk(builders ...*GalleryImageCreate) *GalleryImageCreateBulk {
	return &GalleryImageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GalleryImageClient) MapCreateBulk(slice any, setFunc func(*GalleryImageCreate, int)) *GalleryImageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GalleryImageCreateBulk{err: fmt.Errorf("calling to GalleryImageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GalleryImageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GalleryImageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GalleryImage.
func (c *GalleryImageClient) Update() *GalleryImageUpdate {
	mutation := newGalleryImageMutation(c.config, OpUpdate)
	return &GalleryImageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GalleryImageClient) UpdateOne(_m *GalleryImage) *GalleryImageUpdateOne {
	mutation := newGalleryImageMutation(c.config, OpUpdateOne, withGalleryImage(_m))
	return &GalleryImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GalleryImageClient) UpdateOneID(id int) *GalleryImageUpdateOne {
	mutation := newGalleryImageMutation(c.config, OpUpdateOne, withGalleryImageID(id))
	return &GalleryImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GalleryImage.
func (c *GalleryImageClient) Delete() *GalleryImageDelete {
	mutation := newGalleryImageMutation(c.config, OpDelete)
	return &GalleryImageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GalleryImageClient) DeleteOne(_m *GalleryImage) *GalleryImageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GalleryImageClient) DeleteOneID(id int) *GalleryImageDeleteOne {
	builder := c.Delete().Where(galleryimage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GalleryImageDeleteOne{builder}
}

// Query returns a query builder for GalleryImage.
func (c *GalleryImageClient) Query() *GalleryImageQuery {
	return &GalleryImageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGalleryImage},
		inters: c.Interceptors(),
	}
}

// Get returns a GalleryImage entity by its id.
func (c *GalleryImageClient) Get(ctx context.Context, id int) (*GalleryImage, error) {
	return c.Query().Where(galleryimage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GalleryImageClient) GetX(ctx context.Context, id int) *GalleryImage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlock queries the block edge of a GalleryImage.
func (c *GalleryImageClient) QueryBlock(_m *GalleryImage) *BlockGalleryQuery {
	query := (&BlockGalleryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(galleryimage.Table, galleryimage.FieldID, id),
			sqlgraph.To(blockgallery.Table, blockgallery.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, galleryimage.BlockTable, galleryimage.BlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GalleryImageClient) Hooks() []Hook {
	return c.hooks.GalleryImage
}

// Interceptors returns the client interceptors.
func (c *GalleryImageClient) Interceptors() []Interceptor {
	return c.inters.GalleryImage
}

func (c *GalleryImageClient) mutate(ctx context.Context, m *GalleryImageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GalleryImageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GalleryImageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GalleryImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GalleryImageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GalleryImage mutation op: %q", m.Op())
	}
}

// GeneratedReportClient is a client for the GeneratedReport schema.
type GeneratedReportClient struct {
	config
}

// NewGeneratedReportClient returns a client for the GeneratedReport from the given config.
func NewGeneratedReportClient(c config) *GeneratedReportClient {
	return &GeneratedReportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `generatedreport.Hooks(f(g(h())))`.
func (c *GeneratedReportClient) Use(hooks ...Hook) {
	c.hooks.GeneratedReport = append(c.hooks.GeneratedReport, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `generatedreport.Intercept(f(g(h())))`.
func (c *GeneratedReportClient) Intercept(interceptors ...Interceptor) {
	c.inters.GeneratedReport = append(c.inters.GeneratedReport, interceptors...)
}

// Create returns a builder for creating a GeneratedReport entity.
func (c *GeneratedReportClient) Create() *GeneratedReportCreate {
	mutation := newGeneratedReportMutation(c.config, OpCreate)
	return &GeneratedReportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GeneratedReport entities.
func (c *GeneratedReportClient) CreateBulk(builders ...*GeneratedReportCreate) *GeneratedReportCreateBulk {
	return &GeneratedReportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GeneratedReportClient) MapCreateBulk(slice any, setFunc func(*GeneratedReportCreate, int)) *GeneratedReportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GeneratedReportCreateBulk{err: fmt.Errorf("calling to GeneratedReportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GeneratedReportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GeneratedReportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GeneratedReport.
func (c *GeneratedReportClient) Update() *GeneratedReportUpdate {
	mutation := newGeneratedReportMutation(c.config, OpUpdate)
	return &GeneratedReportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GeneratedReportClient) UpdateOne(_m *GeneratedReport) *GeneratedReportUpdateOne {
	mutation := newGeneratedReportMutation(c.config, OpUpdateOne, withGeneratedReport(_m))
	return &GeneratedReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GeneratedReportClient) UpdateOneID(id int) *GeneratedReportUpdateOne {
	mutation := newGeneratedReportMutation(c.config, OpUpdateOne, withGeneratedReportID(id))
	return &GeneratedReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GeneratedReport.
func (c *GeneratedReportClient) Delete() *GeneratedReportDelete {
	mutation := newGeneratedReportMutation(c.config, OpDelete)
	return &GeneratedReportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GeneratedReportClient) DeleteOne(_m *GeneratedReport) *GeneratedReportDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GeneratedReportClient) DeleteOneID(id int) *GeneratedReportDeleteOne {
	builder := c.Delete().Where(generatedreport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GeneratedReportDeleteOne{builder}
}

// Query returns a query builder for GeneratedReport.
func (c *GeneratedReportClient) Query() *GeneratedReportQuery {
	return &GeneratedReportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGeneratedReport},
		inters: c.Interceptors(),
	}
}

// Get returns a GeneratedReport entity by its id.
func (c *GeneratedReportClient) Get(ctx context.Context, id int) (*GeneratedReport, error) {
	return c.Query().Where(generatedreport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GeneratedReportClient) GetX(ctx context.Context, id int) *GeneratedReport {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReportDefinition queries the report_definition edge of a GeneratedReport.
func (c *GeneratedReportClient) QueryReportDefinition(_m *GeneratedReport) *ReportDefinitionQuery {
	query := (&ReportDefinitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generatedreport.Table, generatedreport.FieldID, id),
			sqlgraph.To(reportdefinition.Table, reportdefinition.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generatedreport.ReportDefinitionTable, generatedreport.ReportDefinitionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGenerator queries the generator edge of a GeneratedReport.
func (c *GeneratedReportClient) QueryGenerator(_m *GeneratedReport) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generatedreport.Table, generatedreport.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generatedreport.GeneratorTable, generatedreport.GeneratorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJob queries the job edge of a GeneratedReport.
func (c *GeneratedReportClient) QueryJob(_m *GeneratedReport) *JobQuery {
	query := (&JobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(generatedreport.Table, generatedreport.FieldID, id),
			sqlgraph.To(job.Table, job.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, generatedreport.JobTable, generatedreport.JobColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GeneratedReportClient) Hooks() []Hook {
	return c.hooks.GeneratedReport
}

// Interceptors returns the client interceptors.
func (c *GeneratedReportClient) Interceptors() []Interceptor {
	return c.inters.GeneratedReport
}

func (c *GeneratedReportClient) mutate(ctx context.Context, m *GeneratedReportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GeneratedReportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GeneratedReportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GeneratedReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GeneratedReportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GeneratedReport mutation op: %q", m.Op())
	}
}

// GrantClient is a client for the Grant schema.
type GrantClient struct {
	config
}

// NewGrantClient returns a client for the Grant from the given config.
func NewGrantClient(c config) *GrantClient {
	return &GrantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `grant.Hooks(f(g(h())))`.
func (c *GrantClient) Use(hooks ...Hook) {
	c.hooks.Grant = append(c.hooks.Grant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `grant.Intercept(f(g(h())))`.
func (c *GrantClient) Intercept(interceptors ...Interceptor) {
	c.inters.Grant = append(c.inters.Grant, interceptors...)
}

// Create returns a builder for creating a Grant entity.
func (c *GrantClient) Create() *GrantCreate {
	mutation := newGrantMutation(c.config, OpCreate)
	return &GrantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Grant entities.
func (c *GrantClient) CreateBulk(builders ...*GrantCreate) *GrantCreateBulk {
	return &GrantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GrantClient) MapCreateBulk(slice any, setFunc func(*GrantCreate, int)) *GrantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GrantCreateBulk{err: fmt.Errorf("calling to GrantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GrantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GrantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Grant.
func (c *GrantClient) Update() *GrantUpdate {
	mutation := newGrantMutation(c.config, OpUpdate)
	return &GrantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GrantClient) UpdateOne(_m *Grant) *GrantUpdateOne {
	mutation := newGrantMutation(c.config, OpUpdateOne, withGrant(_m))
	return &GrantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GrantClient) UpdateOneID(id int) *GrantUpdateOne {
	mutation := newGrantMutation(c.config, OpUpdateOne, withGrantID(id))
	return &GrantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Grant.
func (c *GrantClient) Delete() *GrantDelete {
	mutation := newGrantMutation(c.config, OpDelete)
	return &GrantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GrantClient) DeleteOne(_m *Grant) *GrantDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GrantClient) DeleteOneID(id int) *GrantDeleteOne {
	builder := c.Delete().Where(grant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GrantDeleteOne{builder}
}

// Query returns a query builder for Grant.
func (c *GrantClient) Query() *GrantQuery {
	return &GrantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGrant},
		inters: c.Interceptors(),
	}
}

// Get returns a Grant entity by its id.
func (c *GrantClient) Get(ctx context.Context, id int) (*Grant, error) {
	return c.Query().Where(grant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GrantClient) GetX(ctx context.Context, id int) *Grant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a Grant.
func (c *GrantClient) QueryOrganization(_m *Grant) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grant.Table, grant.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, grant.OrganizationTable, grant.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a Grant.
func (c *GrantClient) QueryProgram(_m *Grant) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grant.Table, grant.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, grant.ProgramTable, grant.ProgramColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReports queries the reports edge of a Grant.
func (c *GrantClient) QueryReports(_m *Grant) *GrantReportQuery {
	query := (&GrantReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grant.Table, grant.FieldID, id),
			sqlgraph.To(grantreport.Table, grantreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, grant.ReportsTable, grant.ReportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GrantClient) Hooks() []Hook {
	return c.hooks.Grant
}

// Interceptors returns the client interceptors.
func (c *GrantClient) Interceptors() []Interceptor {
	return c.inters.Grant
}

func (c *GrantClient) mutate(ctx context.Context, m *GrantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GrantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GrantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GrantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GrantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Grant mutation op: %q", m.Op())
	}
}

// GrantReportClient is a client for the GrantReport schema.
type GrantReportClient struct {
	config
}

// NewGrantReportClient returns a client for the GrantReport from the given config.
func NewGrantReportClient(c config) *GrantReportClient {
	return &GrantReportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `grantreport.Hooks(f(g(h())))`.
func (c *GrantReportClient) Use(hooks ...Hook) {
	c.hooks.GrantReport = append(c.hooks.GrantReport, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `grantreport.Intercept(f(g(h())))`.
func (c *GrantReportClient) Intercept(interceptors ...Interceptor) {
	c.inters.GrantReport = append(c.inters.GrantReport, interceptors...)
}

// Create returns a builder for creating a GrantReport entity.
func (c *GrantReportClient) Create() *GrantReportCreate {
	mutation := newGrantReportMutation(c.config, OpCreate)
	return &GrantReportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GrantReport entities.
func (c *GrantReportClient) CreateBulk(builders ...*GrantReportCreate) *GrantReportCreateBulk {
	return &GrantReportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GrantReportClient) MapCreateBulk(slice any, setFunc func(*GrantReportCreate, int)) *GrantReportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GrantReportCreateBulk{err: fmt.Errorf("calling to GrantReportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GrantReportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GrantReportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GrantReport.
func (c *GrantReportClient) Update() *GrantReportUpdate {
	mutation := newGrantReportMutation(c.config, OpUpdate)
	return &GrantReportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GrantReportClient) UpdateOne(_m *GrantReport) *GrantReportUpdateOne {
	mutation := newGrantReportMutation(c.config, OpUpdateOne, withGrantReport(_m))
	return &GrantReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GrantReportClient) UpdateOneID(id int) *GrantReportUpdateOne {
	mutation := newGrantReportMutation(c.config, OpUpdateOne, withGrantReportID(id))
	return &GrantReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GrantReport.
func (c *GrantReportClient) Delete() *GrantReportDelete {
	mutation := newGrantReportMutation(c.config, OpDelete)
	return &GrantReportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GrantReportClient) DeleteOne(_m *GrantReport) *GrantReportDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GrantReportClient) DeleteOneID(id int) *GrantReportDeleteOne {
	builder := c.Delete().Where(grantreport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GrantReportDeleteOne{builder}
}

// Query returns a query builder for GrantReport.
func (c *GrantReportClient) Query() *GrantReportQuery {
	return &GrantReportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGrantReport},
		inters: c.Interceptors(),
	}
}

// Get returns a GrantReport entity by its id.
func (c *GrantReportClient) Get(ctx context.Context, id int) (*GrantReport, error) {
	return c.Query().Where(grantreport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GrantReportClient) GetX(ctx context.Context, id int) *GrantReport {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGrant queries the grant edge of a GrantReport.
func (c *GrantReportClient) QueryGrant(_m *GrantReport) *GrantQuery {
	query := (&GrantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grantreport.Table, grantreport.FieldID, id),
			sqlgraph.To(grant.Table, grant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, grantreport.GrantTable, grantreport.GrantColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GrantReportClient) Hooks() []Hook {
	return c.hooks.GrantReport
}

// Interceptors returns the client interceptors.
func (c *GrantReportClient) Interceptors() []Interceptor {
	return c.inters.GrantReport
}

func (c *GrantReportClient) mutate(ctx context.Context, m *GrantReportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GrantReportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GrantReportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GrantReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GrantReportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GrantReport mutation op: %q", m.Op())
	}
}

// ImpactDataPointClient is a client for the ImpactDataPoint schema.
type ImpactDataPointClient struct {
	config
}

// NewImpactDataPointClient returns a client for the ImpactDataPoint from the given config.
func NewImpactDataPointClient(c config) *ImpactDataPointClient {
	return &ImpactDataPointClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `impactdatapoint.Hooks(f(g(h())))`.
func (c *ImpactDataPointClient) Use(hooks ...Hook) {
	c.hooks.ImpactDataPoint = append(c.hooks.ImpactDataPoint, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `impactdatapoint.Intercept(f(g(h())))`.
func (c *ImpactDataPointClient) Intercept(interceptors ...Interceptor) {
	c.inters.ImpactDataPoint = append(c.inters.ImpactDataPoint, interceptors...)
}

// Create returns a builder for creating a ImpactDataPoint entity.
func (c *ImpactDataPointClient) Create() *ImpactDataPointCreate {
	mutation := newImpactDataPointMutation(c.config, OpCreate)
	return &ImpactDataPointCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ImpactDataPoint entities.
func (c *ImpactDataPointClient) CreateBulk(builders ...*ImpactDataPointCreate) *ImpactDataPointCreateBulk {
	return &ImpactDataPointCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImpactDataPointClient) MapCreateBulk(slice any, setFunc func(*ImpactDataPointCreate, int)) *ImpactDataPointCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImpactDataPointCreateBulk{err: fmt.Errorf("calling to ImpactDataPointClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImpactDataPointCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImpactDataPointCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ImpactDataPoint.
func (c *ImpactDataPointClient) Update() *ImpactDataPointUpdate {
	mutation := newImpactDataPointMutation(c.config, OpUpdate)
	return &ImpactDataPointUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImpactDataPointClient) UpdateOne(_m *ImpactDataPoint) *ImpactDataPointUpdateOne {
	mutation := newImpactDataPointMutation(c.config, OpUpdateOne, withImpactDataPoint(_m))
	return &ImpactDataPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImpactDataPointClient) UpdateOneID(id int) *ImpactDataPointUpdateOne {
	mutation := newImpactDataPointMutation(c.config, OpUpdateOne, withImpactDataPointID(id))
	return &ImpactDataPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ImpactDataPoint.
func (c *ImpactDataPointClient) Delete() *ImpactDataPointDelete {
	mutation := newImpactDataPointMutation(c.config, OpDelete)
	return &ImpactDataPointDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImpactDataPointClient) DeleteOne(_m *ImpactDataPoint) *ImpactDataPointDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImpactDataPointClient) DeleteOneID(id int) *ImpactDataPointDeleteOne {
	builder := c.Delete().Where(impactdatapoint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImpactDataPointDeleteOne{builder}
}

// Query returns a query builder for ImpactDataPoint.
func (c *ImpactDataPointClient) Query() *ImpactDataPointQuery {
	return &ImpactDataPointQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImpactDataPoint},
		inters: c.Interceptors(),
	}
}

// Get returns a ImpactDataPoint entity by its id.
func (c *ImpactDataPointClient) Get(ctx context.Context, id int) (*ImpactDataPoint, error) {
	return c.Query().Where(impactdatapoint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImpactDataPointClient) GetX(ctx context.Context, id int) *ImpactDataPoint {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMetric queries the metric edge of a ImpactDataPoint.
func (c *ImpactDataPointClient) QueryMetric(_m *ImpactDataPoint) *ImpactMetricQuery {
	query := (&ImpactMetricClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(impactdatapoint.Table, impactdatapoint.FieldID, id),
			sqlgraph.To(impactmetric.Table, impactmetric.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, impactdatapoint.MetricTable, impactdatapoint.MetricColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ImpactDataPointClient) Hooks() []Hook {
	return c.hooks.ImpactDataPoint
}

// Interceptors returns the client interceptors.
func (c *ImpactDataPointClient) Interceptors() []Interceptor {
	return c.inters.ImpactDataPoint
}

func (c *ImpactDataPointClient) mutate(ctx context.Context, m *ImpactDataPointMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImpactDataPointCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImpactDataPointUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImpactDataPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImpactDataPointDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ImpactDataPoint mutation op: %q", m.Op())
	}
}

// ImpactMetricClient is a client for the ImpactMetric schema.
type ImpactMetricClient struct {
	config
}

// NewImpactMetricClient returns a client for the ImpactMetric from the given config.
func NewImpactMetricClient(c config) *ImpactMetricClient {
	return &ImpactMetricClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `impactmetric.Hooks(f(g(h())))`.
func (c *ImpactMetricClient) Use(hooks ...Hook) {
	c.hooks.ImpactMetric = append(c.hooks.ImpactMetric, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `impactmetric.Intercept(f(g(h())))`.
func (c *ImpactMetricClient) Intercept(interceptors ...Interceptor) {
	c.inters.ImpactMetric = append(c.inters.ImpactMetric, interceptors...)
}

// Create returns a builder for creating a ImpactMetric entity.
func (c *ImpactMetricClient) Create() *ImpactMetricCreate {
	mutation := newImpactMetricMutation(c.config, OpCreate)
	return &ImpactMetricCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ImpactMetric entities.
func (c *ImpactMetricClient) CreateBulk(builders ...*ImpactMetricCreate) *ImpactMetricCreateBulk {
	return &ImpactMetricCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImpactMetricClient) MapCreateBulk(slice any, setFunc func(*ImpactMetricCreate, int)) *ImpactMetricCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImpactMetricCreateBulk{err: fmt.Errorf("calling to ImpactMetricClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImpactMetricCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImpactMetricCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ImpactMetric.
func (c *ImpactMetricClient) Update() *ImpactMetricUpdate {
	mutation := newImpactMetricMutation(c.config, OpUpdate)
	return &ImpactMetricUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImpactMetricClient) UpdateOne(_m *ImpactMetric) *ImpactMetricUpdateOne {
	mutation := newImpactMetricMutation(c.config, OpUpdateOne, withImpactMetric(_m))
	return &ImpactMetricUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImpactMetricClient) UpdateOneID(id int) *ImpactMetricUpdateOne {
	mutation := newImpactMetricMutation(c.config, OpUpdateOne, withImpactMetricID(id))
	return &ImpactMetricUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ImpactMetric.
func (c *ImpactMetricClient) Delete() *ImpactMetricDelete {
	mutation := newImpactMetricMutation(c.config, OpDelete)
	return &ImpactMetricDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImpactMetricClient) DeleteOne(_m *ImpactMetric) *ImpactMetricDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImpactMetricClient) DeleteOneID(id int) *ImpactMetricDeleteOne {
	builder := c.Delete().Where(impactmetric.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImpactMetricDeleteOne{builder}
}

// Query returns a query builder for ImpactMetric.
func (c *ImpactMetricClient) Query() *ImpactMetricQuery {
	return &ImpactMetricQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImpactMetric},
		inters: c.Interceptors(),
	}
}

// Get returns a ImpactMetric entity by its id.
func (c *ImpactMetricClient) Get(ctx context.Context, id int) (*ImpactMetric, error) {
	return c.Query().Where(impactmetric.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImpactMetricClient) GetX(ctx context.Context, id int) *ImpactMetric {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProgram queries the program edge of a ImpactMetric.
func (c *ImpactMetricClient) QueryProgram(_m *ImpactMetric) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(impactmetric.Table, impactmetric.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, impactmetric.ProgramTable, impactmetric.ProgramColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDataPoints queries the data_points edge of a ImpactMetric.
func (c *ImpactMetricClient) QueryDataPoints(_m *ImpactMetric) *ImpactDataPointQuery {
	query := (&ImpactDataPointClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(impactmetric.Table, impactmetric.FieldID, id),
			sqlgraph.To(impactdatapoint.Table, impactdatapoint.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, impactmetric.DataPointsTable, impactmetric.DataPointsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ImpactMetricClient) Hooks() []Hook {
	return c.hooks.ImpactMetric
}

// Interceptors returns the client interceptors.
func (c *ImpactMetricClient) Interceptors() []Interceptor {
	return c.inters.ImpactMetric
}

func (c *ImpactMetricClient) mutate(ctx context.Context, m *ImpactMetricMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImpactMetricCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImpactMetricUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImpactMetricUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImpactMetricDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ImpactMetric mutation op: %q", m.Op())
	}
}

// JobClient is a client for the Job schema.
type JobClient struct {
	config
}

// NewJobClient returns a client for the Job from the given config.
func NewJobClient(c config) *JobClient {
	return &JobClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `job.Hooks(f(g(h())))`.
func (c *JobClient) Use(hooks ...Hook) {
	c.hooks.Job = append(c.hooks.Job, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `job.Intercept(f(g(h())))`.
func (c *JobClient) Intercept(interceptors ...Interceptor) {
	c.inters.Job = append(c.inters.Job, interceptors...)
}

// Create returns a builder for creating a Job entity.
func (c *JobClient) Create() *JobCreate {
	mutation := newJobMutation(c.config, OpCreate)
	return &JobCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Job entities.
func (c *JobClient) CreateBulk(builders ...*JobCreate) *JobCreateBulk {
	return &JobCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JobClient) MapCreateBulk(slice any, setFunc func(*JobCreate, int)) *JobCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JobCreateBulk{err: fmt.Errorf("calling to JobClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JobCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JobCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Job.
func (c *JobClient) Update() *JobUpdate {
	mutation := newJobMutation(c.config, OpUpdate)
	return &JobUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobClient) UpdateOne(_m *Job) *JobUpdateOne {
	mutation := newJobMutation(c.config, OpUpdateOne, withJob(_m))
	return &JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobClient) UpdateOneID(id int) *JobUpdateOne {
	mutation := newJobMutation(c.config, OpUpdateOne, withJobID(id))
	return &JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Job.
func (c *JobClient) Delete() *JobDelete {
	mutation := newJobMutation(c.config, OpDelete)
	return &JobDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobClient) DeleteOne(_m *Job) *JobDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobClient) DeleteOneID(id int) *JobDeleteOne {
	builder := c.Delete().Where(job.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobDeleteOne{builder}
}

// Query returns a query builder for Job.
func (c *JobClient) Query() *JobQuery {
	return &JobQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJob},
		inters: c.Interceptors(),
	}
}

// Get returns a Job entity by its id.
func (c *JobClient) Get(ctx context.Context, id int) (*Job, error) {
	return c.Query().Where(job.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobClient) GetX(ctx context.Context, id int) *Job {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Job.
func (c *JobClient) QueryUser(_m *Job) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(job.Table, job.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, job.UserTable, job.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogs queries the logs edge of a Job.
func (c *JobClient) QueryLogs(_m *Job) *JobLogQuery {
	query := (&JobLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(job.Table, job.FieldID, id),
			sqlgraph.To(joblog.Table, joblog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, job.LogsTable, job.LogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependents queries the dependents edge of a Job.
func (c *JobClient) QueryDependents(_m *Job) *JobQuery {
	query := (&JobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(job.Table, job.FieldID, id),
			sqlgraph.To(job.Table, job.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, job.DependentsTable, job.DependentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependsOn queries the depends_on edge of a Job.
func (c *JobClient) QueryDependsOn(_m *Job) *JobQuery {
	query := (&JobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(job.Table, job.FieldID, id),
			sqlgraph.To(job.Table, job.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, job.DependsOnTable, job.DependsOnColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReports queries the reports edge of a Job.
func (c *JobClient) QueryReports(_m *Job) *GeneratedReportQuery {
	query := (&GeneratedReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(job.Table, job.FieldID, id),
			sqlgraph.To(generatedreport.Table, generatedreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, job.ReportsTable, job.ReportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JobClient) Hooks() []Hook {
	return c.hooks.Job
}

// Interceptors returns the client interceptors.
func (c *JobClient) Interceptors() []Interceptor {
	return c.inters.Job
}

func (c *JobClient) mutate(ctx context.Context, m *JobMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Job mutation op: %q", m.Op())
	}
}

// JobLogClient is a client for the JobLog schema.
type JobLogClient struct {
	config
}

// NewJobLogClient returns a client for the JobLog from the given config.
func NewJobLogClient(c config) *JobLogClient {
	return &JobLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `joblog.Hooks(f(g(h())))`.
func (c *JobLogClient) Use(hooks ...Hook) {
	c.hooks.JobLog = append(c.hooks.JobLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `joblog.Intercept(f(g(h())))`.
func (c *JobLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.JobLog = append(c.inters.JobLog, interceptors...)
}

// Create returns a builder for creating a JobLog entity.
func (c *JobLogClient) Create() *JobLogCreate {
	mutation := newJobLogMutation(c.config, OpCreate)
	return &JobLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JobLog entities.
func (c *JobLogClient) CreateBulk(builders ...*JobLogCreate) *JobLogCreateBulk {
	return &JobLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JobLogClient) MapCreateBulk(slice any, setFunc func(*JobLogCreate, int)) *JobLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JobLogCreateBulk{err: fmt.Errorf("calling to JobLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JobLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JobLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JobLog.
func (c *JobLogClient) Update() *JobLogUpdate {
	mutation := newJobLogMutation(c.config, OpUpdate)
	return &JobLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobLogClient) UpdateOne(_m *JobLog) *JobLogUpdateOne {
	mutation := newJobLogMutation(c.config, OpUpdateOne, withJobLog(_m))
	return &JobLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobLogClient) UpdateOneID(id int) *JobLogUpdateOne {
	mutation := newJobLogMutation(c.config, OpUpdateOne, withJobLogID(id))
	return &JobLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JobLog.
func (c *JobLogClient) Delete() *JobLogDelete {
	mutation := newJobLogMutation(c.config, OpDelete)
	return &JobLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobLogClient) DeleteOne(_m *JobLog) *JobLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobLogClient) DeleteOneID(id int) *JobLogDeleteOne {
	builder := c.Delete().Where(joblog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobLogDeleteOne{builder}
}

// Query returns a query builder for JobLog.
func (c *JobLogClient) Query() *JobLogQuery {
	return &JobLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJobLog},
		inters: c.Interceptors(),
	}
}

// Get returns a JobLog entity by its id.
func (c *JobLogClient) Get(ctx context.Context, id int) (*JobLog, error) {
	return c.Query().Where(joblog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobLogClient) GetX(ctx context.Context, id int) *JobLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryJob queries the job edge of a JobLog.
func (c *JobLogClient) QueryJob(_m *JobLog) *JobQuery {
	query := (&JobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(joblog.Table, joblog.FieldID, id),
			sqlgraph.To(job.Table, job.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, joblog.JobTable, joblog.JobColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JobLogClient) Hooks() []Hook {
	return c.hooks.JobLog
}

// Interceptors returns the client interceptors.
func (c *JobLogClient) Interceptors() []Interceptor {
	return c.inters.JobLog
}

func (c *JobLogClient) mutate(ctx context.Context, m *JobLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown JobLog mutation op: %q", m.Op())
	}
}

// MentorshipRequestClient is a client for the MentorshipRequest schema.
type MentorshipRequestClient struct {
	config
}

// NewMentorshipRequestClient returns a client for the MentorshipRequest from the given config.
func NewMentorshipRequestClient(c config) *MentorshipRequestClient {
	return &MentorshipRequestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mentorshiprequest.Hooks(f(g(h())))`.
func (c *MentorshipRequestClient) Use(hooks ...Hook) {
	c.hooks.MentorshipRequest = append(c.hooks.MentorshipRequest, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mentorshiprequest.Intercept(f(g(h())))`.
func (c *MentorshipRequestClient) Intercept(interceptors ...Interceptor) {
	c.inters.MentorshipRequest = append(c.inters.MentorshipRequest, interceptors...)
}

// Create returns a builder for creating a MentorshipRequest entity.
func (c *MentorshipRequestClient) Create() *MentorshipRequestCreate {
	mutation := newMentorshipRequestMutation(c.config, OpCreate)
	return &MentorshipRequestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MentorshipRequest entities.
func (c *MentorshipRequestClient) CreateBulk(builders ...*MentorshipRequestCreate) *MentorshipRequestCreateBulk {
	return &MentorshipRequestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MentorshipRequestClient) MapCreateBulk(slice any, setFunc func(*MentorshipRequestCreate, int)) *MentorshipRequestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MentorshipRequestCreateBulk{err: fmt.Errorf("calling to MentorshipRequestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MentorshipRequestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MentorshipRequestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MentorshipRequest.
func (c *MentorshipRequestClient) Update() *MentorshipRequestUpdate {
	mutation := newMentorshipRequestMutation(c.config, OpUpdate)
	return &MentorshipRequestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MentorshipRequestClient) UpdateOne(_m *MentorshipRequest) *MentorshipRequestUpdateOne {
	mutation := newMentorshipRequestMutation(c.config, OpUpdateOne, withMentorshipRequest(_m))
	return &MentorshipRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MentorshipRequestClient) UpdateOneID(id int) *MentorshipRequestUpdateOne {
	mutation := newMentorshipRequestMutation(c.config, OpUpdateOne, withMentorshipRequestID(id))
	return &MentorshipRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MentorshipRequest.
func (c *MentorshipRequestClient) Delete() *MentorshipRequestDelete {
	mutation := newMentorshipRequestMutation(c.config, OpDelete)
	return &MentorshipRequestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MentorshipRequestClient) DeleteOne(_m *MentorshipRequest) *MentorshipRequestDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MentorshipRequestClient) DeleteOneID(id int) *MentorshipRequestDeleteOne {
	builder := c.Delete().Where(mentorshiprequest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MentorshipRequestDeleteOne{builder}
}

// Query returns a query builder for MentorshipRequest.
func (c *MentorshipRequestClient) Query() *MentorshipRequestQuery {
	return &MentorshipRequestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMentorshipRequest},
		inters: c.Interceptors(),
	}
}

// Get returns a MentorshipRequest entity by its id.
func (c *MentorshipRequestClient) Get(ctx context.Context, id int) (*MentorshipRequest, error) {
	return c.Query().Where(mentorshiprequest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MentorshipRequestClient) GetX(ctx context.Context, id int) *MentorshipRequest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequester queries the requester edge of a MentorshipRequest.
func (c *MentorshipRequestClient) QueryRequester(_m *MentorshipRequest) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mentorshiprequest.Table, mentorshiprequest.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mentorshiprequest.RequesterTable, mentorshiprequest.RequesterColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMentor queries the mentor edge of a MentorshipRequest.
func (c *MentorshipRequestClient) QueryMentor(_m *MentorshipRequest) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mentorshiprequest.Table, mentorshiprequest.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mentorshiprequest.MentorTable, mentorshiprequest.MentorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySessions queries the sessions edge of a MentorshipRequest.
func (c *MentorshipRequestClient) QuerySessions(_m *MentorshipRequest) *MentorshipSessionQuery {
	query := (&MentorshipSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mentorshiprequest.Table, mentorshiprequest.FieldID, id),
			sqlgraph.To(mentorshipsession.Table, mentorshipsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mentorshiprequest.SessionsTable, mentorshiprequest.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MentorshipRequestClient) Hooks() []Hook {
	return c.hooks.MentorshipRequest
}

// Interceptors returns the client interceptors.
func (c *MentorshipRequestClient) Interceptors() []Interceptor {
	return c.inters.MentorshipRequest
}

func (c *MentorshipRequestClient) mutate(ctx context.Context, m *MentorshipRequestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MentorshipRequestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MentorshipRequestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MentorshipRequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MentorshipRequestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MentorshipRequest mutation op: %q", m.Op())
	}
}

// MentorshipSessionClient is a client for the MentorshipSession schema.
type MentorshipSessionClient struct {
	config
}

// NewMentorshipSessionClient returns a client for the MentorshipSession from the given config.
func NewMentorshipSessionClient(c config) *MentorshipSessionClient {
	return &MentorshipSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mentorshipsession.Hooks(f(g(h())))`.
func (c *MentorshipSessionClient) Use(hooks ...Hook) {
	c.hooks.MentorshipSession = append(c.hooks.MentorshipSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mentorshipsession.Intercept(f(g(h())))`.
func (c *MentorshipSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.MentorshipSession = append(c.inters.MentorshipSession, interceptors...)
}

// Create returns a builder for creating a MentorshipSession entity.
func (c *MentorshipSessionClient) Create() *MentorshipSessionCreate {
	mutation := newMentorshipSessionMutation(c.config, OpCreate)
	return &MentorshipSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MentorshipSession entities.
func (c *MentorshipSessionClient) CreateBulk(builders ...*MentorshipSessionCreate) *MentorshipSessionCreateBulk {
	return &MentorshipSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MentorshipSessionClient) MapCreateBulk(slice any, setFunc func(*MentorshipSessionCreate, int)) *MentorshipSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MentorshipSessionCreateBulk{err: fmt.Errorf("calling to MentorshipSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MentorshipSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MentorshipSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MentorshipSession.
func (c *MentorshipSessionClient) Update() *MentorshipSessionUpdate {
	mutation := newMentorshipSessionMutation(c.config, OpUpdate)
	return &MentorshipSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MentorshipSessionClient) UpdateOne(_m *MentorshipSession) *MentorshipSessionUpdateOne {
	mutation := newMentorshipSessionMutation(c.config, OpUpdateOne, withMentorshipSession(_m))
	return &MentorshipSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MentorshipSessionClient) UpdateOneID(id int) *MentorshipSessionUpdateOne {
	mutation := newMentorshipSessionMutation(c.config, OpUpdateOne, withMentorshipSessionID(id))
	return &MentorshipSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MentorshipSession.
func (c *MentorshipSessionClient) Delete() *MentorshipSessionDelete {
	mutation := newMentorshipSessionMutation(c.config, OpDelete)
	return &MentorshipSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MentorshipSessionClient) DeleteOne(_m *MentorshipSession) *MentorshipSessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MentorshipSessionClient) DeleteOneID(id int) *MentorshipSessionDeleteOne {
	builder := c.Delete().Where(mentorshipsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MentorshipSessionDeleteOne{builder}
}

// Query returns a query builder for MentorshipSession.
func (c *MentorshipSessionClient) Query() *MentorshipSessionQuery {
	return &MentorshipSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMentorshipSession},
		inters: c.Interceptors(),
	}
}

// Get returns a MentorshipSession entity by its id.
func (c *MentorshipSessionClient) Get(ctx context.Context, id int) (*MentorshipSession, error) {
	return c.Query().Where(mentorshipsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MentorshipSessionClient) GetX(ctx context.Context, id int) *MentorshipSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMentorshipRequest queries the mentorship_request edge of a MentorshipSession.
func (c *MentorshipSessionClient) QueryMentorshipRequest(_m *MentorshipSession) *MentorshipRequestQuery {
	query := (&MentorshipRequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mentorshipsession.Table, mentorshipsession.FieldID, id),
			sqlgraph.To(mentorshiprequest.Table, mentorshiprequest.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mentorshipsession.MentorshipRequestTable, mentorshipsession.MentorshipRequestColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgenda queries the agenda edge of a MentorshipSession.
func (c *MentorshipSessionClient) QueryAgenda(_m *MentorshipSession) *AgendaQuery {
	query := (&AgendaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mentorshipsession.Table, mentorshipsession.FieldID, id),
			sqlgraph.To(agenda.Table, agenda.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, mentorshipsession.AgendaTable, mentorshipsession.AgendaColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MentorshipSessionClient) Hooks() []Hook {
	return c.hooks.MentorshipSession
}

// Interceptors returns the client interceptors.
func (c *MentorshipSessionClient) Interceptors() []Interceptor {
	return c.inters.MentorshipSession
}

func (c *MentorshipSessionClient) mutate(ctx context.Context, m *MentorshipSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MentorshipSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MentorshipSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MentorshipSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MentorshipSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MentorshipSession mutation op: %q", m.Op())
	}
}

// MessageClient is a client for the Message schema.
type MessageClient struct {
	config
}

// NewMessageClient returns a client for the Message from the given config.
func NewMessageClient(c config) *MessageClient {
	return &MessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `message.Hooks(f(g(h())))`.
func (c *MessageClient) Use(hooks ...Hook) {
	c.hooks.Message = append(c.hooks.Message, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `message.Intercept(f(g(h())))`.
func (c *MessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Message = append(c.inters.Message, interceptors...)
}

// Create returns a builder for creating a Message entity.
func (c *MessageClient) Create() *MessageCreate {
	mutation := newMessageMutation(c.config, OpCreate)
	return &MessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Message entities.
func (c *MessageClient) CreateBulk(builders ...*MessageCreate) *MessageCreateBulk {
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageClient) MapCreateBulk(slice any, setFunc func(*MessageCreate, int)) *MessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageCreateBulk{err: fmt.Errorf("calling to MessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Message.
func (c *MessageClient) Update() *MessageUpdate {
	mutation := newMessageMutation(c.config, OpUpdate)
	return &MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageClient) UpdateOne(_m *Message) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessage(_m))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageClient) UpdateOneID(id int) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessageID(id))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Message.
func (c *MessageClient) Delete() *MessageDelete {
	mutation := newMessageMutation(c.config, OpDelete)
	return &MessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageClient) DeleteOne(_m *Message) *MessageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageClient) DeleteOneID(id int) *MessageDeleteOne {
	builder := c.Delete().Where(message.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageDeleteOne{builder}
}

// Query returns a query builder for Message.
func (c *MessageClient) Query() *MessageQuery {
	return &MessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a Message entity by its id.
func (c *MessageClient) Get(ctx context.Context, id int) (*Message, error) {
	return c.Query().Where(message.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageClient) GetX(ctx context.Context, id int) *Message {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConversation queries the conversation edge of a Message.
func (c *MessageClient) QueryConversation(_m *Message) *ConversationQuery {
	query := (&ConversationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(conversation.Table, conversation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, message.ConversationTable, message.ConversationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySender queries the sender edge of a Message.
func (c *MessageClient) QuerySender(_m *Message) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, message.SenderTable, message.SenderColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageClient) Hooks() []Hook {
	return c.hooks.Message
}

// Interceptors returns the client interceptors.
func (c *MessageClient) Interceptors() []Interceptor {
	return c.inters.Message
}

func (c *MessageClient) mutate(ctx context.Context, m *MessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Message mutation op: %q", m.Op())
	}
}

// NewsArticleClient is a client for the NewsArticle schema.
type NewsArticleClient struct {
	config
}

// NewNewsArticleClient returns a client for the NewsArticle from the given config.
func NewNewsArticleClient(c config) *NewsArticleClient {
	return &NewsArticleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `newsarticle.Hooks(f(g(h())))`.
func (c *NewsArticleClient) Use(hooks ...Hook) {
	c.hooks.NewsArticle = append(c.hooks.NewsArticle, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `newsarticle.Intercept(f(g(h())))`.
func (c *NewsArticleClient) Intercept(interceptors ...Interceptor) {
	c.inters.NewsArticle = append(c.inters.NewsArticle, interceptors...)
}

// Create returns a builder for creating a NewsArticle entity.
func (c *NewsArticleClient) Create() *NewsArticleCreate {
	mutation := newNewsArticleMutation(c.config, OpCreate)
	return &NewsArticleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NewsArticle entities.
func (c *NewsArticleClient) CreateBulk(builders ...*NewsArticleCreate) *NewsArticleCreateBulk {
	return &NewsArticleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NewsArticleClient) MapCreateBulk(slice any, setFunc func(*NewsArticleCreate, int)) *NewsArticleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NewsArticleCreateBulk{err: fmt.Errorf("calling to NewsArticleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NewsArticleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NewsArticleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NewsArticle.
func (c *NewsArticleClient) Update() *NewsArticleUpdate {
	mutation := newNewsArticleMutation(c.config, OpUpdate)
	return &NewsArticleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NewsArticleClient) UpdateOne(_m *NewsArticle) *NewsArticleUpdateOne {
	mutation := newNewsArticleMutation(c.config, OpUpdateOne, withNewsArticle(_m))
	return &NewsArticleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NewsArticleClient) UpdateOneID(id int) *NewsArticleUpdateOne {
	mutation := newNewsArticleMutation(c.config, OpUpdateOne, withNewsArticleID(id))
	return &NewsArticleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NewsArticle.
func (c *NewsArticleClient) Delete() *NewsArticleDelete {
	mutation := newNewsArticleMutation(c.config, OpDelete)
	return &NewsArticleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NewsArticleClient) DeleteOne(_m *NewsArticle) *NewsArticleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NewsArticleClient) DeleteOneID(id int) *NewsArticleDeleteOne {
	builder := c.Delete().Where(newsarticle.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NewsArticleDeleteOne{builder}
}

// Query returns a query builder for NewsArticle.
func (c *NewsArticleClient) Query() *NewsArticleQuery {
	return &NewsArticleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNewsArticle},
		inters: c.Interceptors(),
	}
}

// Get returns a NewsArticle entity by its id.
func (c *NewsArticleClient) Get(ctx context.Context, id int) (*NewsArticle, error) {
	return c.Query().Where(newsarticle.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NewsArticleClient) GetX(ctx context.Context, id int) *NewsArticle {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthor queries the author edge of a NewsArticle.
func (c *NewsArticleClient) QueryAuthor(_m *NewsArticle) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(newsarticle.Table, newsarticle.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, newsarticle.AuthorTable, newsarticle.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NewsArticleClient) Hooks() []Hook {
	return c.hooks.NewsArticle
}

// Interceptors returns the client interceptors.
func (c *NewsArticleClient) Interceptors() []Interceptor {
	return c.inters.NewsArticle
}

func (c *NewsArticleClient) mutate(ctx context.Context, m *NewsArticleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NewsArticleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NewsArticleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NewsArticleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NewsArticleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NewsArticle mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationClient) MapCreateBulk(slice any, setFunc func(*OrganizationCreate, int)) *OrganizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationCreateBulk{err: fmt.Errorf("calling to OrganizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(_m *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(_m))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id int) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(_m *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id int) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id int) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id int) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPartnerships queries the partnerships edge of a Organization.
func (c *OrganizationClient) QueryPartnerships(_m *Organization) *PartnershipQuery {
	query := (&PartnershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(partnership.Table, partnership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.PartnershipsTable, organization.PartnershipsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGrants queries the grants edge of a Organization.
func (c *OrganizationClient) QueryGrants(_m *Organization) *GrantQuery {
	query := (&GrantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(grant.Table, grant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.GrantsTable, organization.GrantsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Organization.
func (c *OrganizationClient) QueryUser(_m *Organization) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organization.UserTable, organization.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	return c.hooks.Organization
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	return c.inters.Organization
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Organization mutation op: %q", m.Op())
	}
}

// PageClient is a client for the Page schema.
type PageClient struct {
	config
}

// NewPageClient returns a client for the Page from the given config.
func NewPageClient(c config) *PageClient {
	return &PageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `page.Hooks(f(g(h())))`.
func (c *PageClient) Use(hooks ...Hook) {
	c.hooks.Page = append(c.hooks.Page, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `page.Intercept(f(g(h())))`.
func (c *PageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Page = append(c.inters.Page, interceptors...)
}

// Create returns a builder for creating a Page entity.
func (c *PageClient) Create() *PageCreate {
	mutation := newPageMutation(c.config, OpCreate)
	return &PageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Page entities.
func (c *PageClient) CreateBulk(builders ...*PageCreate) *PageCreateBulk {
	return &PageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PageClient) MapCreateBulk(slice any, setFunc func(*PageCreate, int)) *PageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PageCreateBulk{err: fmt.Errorf("calling to PageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Page.
func (c *PageClient) Update() *PageUpdate {
	mutation := newPageMutation(c.config, OpUpdate)
	return &PageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PageClient) UpdateOne(_m *Page) *PageUpdateOne {
	mutation := newPageMutation(c.config, OpUpdateOne, withPage(_m))
	return &PageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PageClient) UpdateOneID(id int) *PageUpdateOne {
	mutation := newPageMutation(c.config, OpUpdateOne, withPageID(id))
	return &PageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Page.
func (c *PageClient) Delete() *PageDelete {
	mutation := newPageMutation(c.config, OpDelete)
	return &PageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PageClient) DeleteOne(_m *Page) *PageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PageClient) DeleteOneID(id int) *PageDeleteOne {
	builder := c.Delete().Where(page.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PageDeleteOne{builder}
}

// Query returns a query builder for Page.
func (c *PageClient) Query() *PageQuery {
	return &PageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePage},
		inters: c.Interceptors(),
	}
}

// Get returns a Page entity by its id.
func (c *PageClient) Get(ctx context.Context, id int) (*Page, error) {
	return c.Query().Where(page.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PageClient) GetX(ctx context.Context, id int) *Page {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChildPages queries the child_pages edge of a Page.
func (c *PageClient) QueryChildPages(_m *Page) *PageQuery {
	query := (&PageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(page.Table, page.FieldID, id),
			sqlgraph.To(page.Table, page.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, page.ChildPagesTable, page.ChildPagesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParentPage queries the parent_page edge of a Page.
func (c *PageClient) QueryParentPage(_m *Page) *PageQuery {
	query := (&PageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(page.Table, page.FieldID, id),
			sqlgraph.To(page.Table, page.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, page.ParentPageTable, page.ParentPageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlocks queries the blocks edge of a Page.
func (c *PageClient) QueryBlocks(_m *Page) *ContentBlockQuery {
	query := (&ContentBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(page.Table, page.FieldID, id),
			sqlgraph.To(contentblock.Table, contentblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, page.BlocksTable, page.BlocksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeo queries the seo edge of a Page.
func (c *PageClient) QuerySeo(_m *Page) *SeoConfigQuery {
	query := (&SeoConfigClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(page.Table, page.FieldID, id),
			sqlgraph.To(seoconfig.Table, seoconfig.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, page.SeoTable, page.SeoColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PageClient) Hooks() []Hook {
	return c.hooks.Page
}

// Interceptors returns the client interceptors.
func (c *PageClient) Interceptors() []Interceptor {
	return c.inters.Page
}

func (c *PageClient) mutate(ctx context.Context, m *PageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Page mutation op: %q", m.Op())
	}
}

// PartnerLogoItemClient is a client for the PartnerLogoItem schema.
type PartnerLogoItemClient struct {
	config
}

// NewPartnerLogoItemClient returns a client for the PartnerLogoItem from the given config.
func NewPartnerLogoItemClient(c config) *PartnerLogoItemClient {
	return &PartnerLogoItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `partnerlogoitem.Hooks(f(g(h())))`.
func (c *PartnerLogoItemClient) Use(hooks ...Hook) {
	c.hooks.PartnerLogoItem = append(c.hooks.PartnerLogoItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `partnerlogoitem.Intercept(f(g(h())))`.
func (c *PartnerLogoItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.PartnerLogoItem = append(c.inters.PartnerLogoItem, interceptors...)
}

// Create returns a builder for creating a PartnerLogoItem entity.
func (c *PartnerLogoItemClient) Create() *PartnerLogoItemCreate {
	mutation := newPartnerLogoItemMutation(c.config, OpCreate)
	return &PartnerLogoItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PartnerLogoItem entities.
func (c *PartnerLogoItemClient) CreateBulk(builders ...*PartnerLogoItemCreate) *PartnerLogoItemCreateBulk {
	return &PartnerLogoItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PartnerLogoItemClient) MapCreateBulk(slice any, setFunc func(*PartnerLogoItemCreate, int)) *PartnerLogoItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PartnerLogoItemCreateBulk{err: fmt.Errorf("calling to PartnerLogoItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PartnerLogoItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PartnerLogoItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PartnerLogoItem.
func (c *PartnerLogoItemClient) Update() *PartnerLogoItemUpdate {
	mutation := newPartnerLogoItemMutation(c.config, OpUpdate)
	return &PartnerLogoItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PartnerLogoItemClient) UpdateOne(_m *PartnerLogoItem) *PartnerLogoItemUpdateOne {
	mutation := newPartnerLogoItemMutation(c.config, OpUpdateOne, withPartnerLogoItem(_m))
	return &PartnerLogoItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PartnerLogoItemClient) UpdateOneID(id int) *PartnerLogoItemUpdateOne {
	mutation := newPartnerLogoItemMutation(c.config, OpUpdateOne, withPartnerLogoItemID(id))
	return &PartnerLogoItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PartnerLogoItem.
func (c *PartnerLogoItemClient) Delete() *PartnerLogoItemDelete {
	mutation := newPartnerLogoItemMutation(c.config, OpDelete)
	return &PartnerLogoItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PartnerLogoItemClient) DeleteOne(_m *PartnerLogoItem) *PartnerLogoItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PartnerLogoItemClient) DeleteOneID(id int) *PartnerLogoItemDeleteOne {
	builder := c.Delete().Where(partnerlogoitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PartnerLogoItemDeleteOne{builder}
}

// Query returns a query builder for PartnerLogoItem.
func (c *PartnerLogoItemClient) Query() *PartnerLogoItemQuery {
	return &PartnerLogoItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePartnerLogoItem},
		inters: c.Interceptors(),
	}
}

// Get returns a PartnerLogoItem entity by its id.
func (c *PartnerLogoItemClient) Get(ctx context.Context, id int) (*PartnerLogoItem, error) {
	return c.Query().Where(partnerlogoitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PartnerLogoItemClient) GetX(ctx context.Context, id int) *PartnerLogoItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlock queries the block edge of a PartnerLogoItem.
func (c *PartnerLogoItemClient) QueryBlock(_m *PartnerLogoItem) *BlockPartnerLogosQuery {
	query := (&BlockPartnerLogosClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(partnerlogoitem.Table, partnerlogoitem.FieldID, id),
			sqlgraph.To(blockpartnerlogos.Table, blockpartnerlogos.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, partnerlogoitem.BlockTable, partnerlogoitem.BlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PartnerLogoItemClient) Hooks() []Hook {
	return c.hooks.PartnerLogoItem
}

// Interceptors returns the client interceptors.
func (c *PartnerLogoItemClient) Interceptors() []Interceptor {
	return c.inters.PartnerLogoItem
}

func (c *PartnerLogoItemClient) mutate(ctx context.Context, m *PartnerLogoItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PartnerLogoItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PartnerLogoItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PartnerLogoItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PartnerLogoItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PartnerLogoItem mutation op: %q", m.Op())
	}
}

// PartnershipClient is a client for the Partnership schema.
type PartnershipClient struct {
	config
}

// NewPartnershipClient returns a client for the Partnership from the given config.
func NewPartnershipClient(c config) *PartnershipClient {
	return &PartnershipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `partnership.Hooks(f(g(h())))`.
func (c *PartnershipClient) Use(hooks ...Hook) {
	c.hooks.Partnership = append(c.hooks.Partnership, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `partnership.Intercept(f(g(h())))`.
func (c *PartnershipClient) Intercept(interceptors ...Interceptor) {
	c.inters.Partnership = append(c.inters.Partnership, interceptors...)
}

// Create returns a builder for creating a Partnership entity.
func (c *PartnershipClient) Create() *PartnershipCreate {
	mutation := newPartnershipMutation(c.config, OpCreate)
	return &PartnershipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Partnership entities.
func (c *PartnershipClient) CreateBulk(builders ...*PartnershipCreate) *PartnershipCreateBulk {
	return &PartnershipCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PartnershipClient) MapCreateBulk(slice any, setFunc func(*PartnershipCreate, int)) *PartnershipCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PartnershipCreateBulk{err: fmt.Errorf("calling to PartnershipClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PartnershipCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PartnershipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Partnership.
func (c *PartnershipClient) Update() *PartnershipUpdate {
	mutation := newPartnershipMutation(c.config, OpUpdate)
	return &PartnershipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PartnershipClient) UpdateOne(_m *Partnership) *PartnershipUpdateOne {
	mutation := newPartnershipMutation(c.config, OpUpdateOne, withPartnership(_m))
	return &PartnershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PartnershipClient) UpdateOneID(id int) *PartnershipUpdateOne {
	mutation := newPartnershipMutation(c.config, OpUpdateOne, withPartnershipID(id))
	return &PartnershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Partnership.
func (c *PartnershipClient) Delete() *PartnershipDelete {
	mutation := newPartnershipMutation(c.config, OpDelete)
	return &PartnershipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PartnershipClient) DeleteOne(_m *Partnership) *PartnershipDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PartnershipClient) DeleteOneID(id int) *PartnershipDeleteOne {
	builder := c.Delete().Where(partnership.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PartnershipDeleteOne{builder}
}

// Query returns a query builder for Partnership.
func (c *PartnershipClient) Query() *PartnershipQuery {
	return &PartnershipQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePartnership},
		inters: c.Interceptors(),
	}
}

// Get returns a Partnership entity by its id.
func (c *PartnershipClient) Get(ctx context.Context, id int) (*Partnership, error) {
	return c.Query().Where(partnership.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PartnershipClient) GetX(ctx context.Context, id int) *Partnership {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a Partnership.
func (c *PartnershipClient) QueryOrganization(_m *Partnership) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(partnership.Table, partnership.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, partnership.OrganizationTable, partnership.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryManager queries the manager edge of a Partnership.
func (c *PartnershipClient) QueryManager(_m *Partnership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(partnership.Table, partnership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, partnership.ManagerTable, partnership.ManagerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrimaryContacts queries the primary_contacts edge of a Partnership.
func (c *PartnershipClient) QueryPrimaryContacts(_m *Partnership) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(partnership.Table, partnership.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, partnership.PrimaryContactsTable, partnership.PrimaryContactsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReports queries the reports edge of a Partnership.
func (c *PartnershipClient) QueryReports(_m *Partnership) *PartnershipReportQuery {
	query := (&PartnershipReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(partnership.Table, partnership.FieldID, id),
			sqlgraph.To(partnershipreport.Table, partnershipreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, partnership.ReportsTable, partnership.ReportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInteractions queries the interactions edge of a Partnership.
func (c *PartnershipClient) QueryInteractions(_m *Partnership) *PartnershipInteractionQuery {
	query := (&PartnershipInteractionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(partnership.Table, partnership.FieldID, id),
			sqlgraph.To(partnershipinteraction.Table, partnershipinteraction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, partnership.InteractionsTable, partnership.InteractionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRenewals queries the renewals edge of a Partnership.
func (c *PartnershipClient) QueryRenewals(_m *Partnership) *PartnershipRenewalQuery {
	query := (&PartnershipRenewalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(partnership.Table, partnership.FieldID, id),
			sqlgraph.To(partnershiprenewal.Table, partnershiprenewal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, partnership.RenewalsTable, partnership.RenewalsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBrandBenefits queries the brand_benefits edge of a Partnership.
func (c *PartnershipClient) QueryBrandBenefits(_m *Partnership) *BrandBenefitQuery {
	query := (&BrandBenefitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(partnership.Table, partnership.FieldID, id),
			sqlgraph.To(brandbenefit.Table, brandbenefit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, partnership.BrandBenefitsTable, partnership.BrandBenefitsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PartnershipClient) Hooks() []Hook {
	return c.hooks.Partnership
}

// Interceptors returns the client interceptors.
func (c *PartnershipClient) Interceptors() []Interceptor {
	return c.inters.Partnership
}

func (c *PartnershipClient) mutate(ctx context.Context, m *PartnershipMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PartnershipCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PartnershipUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PartnershipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PartnershipDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Partnership mutation op: %q", m.Op())
	}
}

// PartnershipInteractionClient is a client for the PartnershipInteraction schema.
type PartnershipInteractionClient struct {
	config
}

// NewPartnershipInteractionClient returns a client for the PartnershipInteraction from the given config.
func NewPartnershipInteractionClient(c config) *PartnershipInteractionClient {
	return &PartnershipInteractionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `partnershipinteraction.Hooks(f(g(h())))`.
func (c *PartnershipInteractionClient) Use(hooks ...Hook) {
	c.hooks.PartnershipInteraction = append(c.hooks.PartnershipInteraction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `partnershipinteraction.Intercept(f(g(h())))`.
func (c *PartnershipInteractionClient) Intercept(interceptors ...Interceptor) {
	c.inters.PartnershipInteraction = append(c.inters.PartnershipInteraction, interceptors...)
}

// Create returns a builder for creating a PartnershipInteraction entity.
func (c *PartnershipInteractionClient) Create() *PartnershipInteractionCreate {
	mutation := newPartnershipInteractionMutation(c.config, OpCreate)
	return &PartnershipInteractionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PartnershipInteraction entities.
func (c *PartnershipInteractionClient) CreateBulk(builders ...*PartnershipInteractionCreate) *PartnershipInteractionCreateBulk {
	return &PartnershipInteractionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PartnershipInteractionClient) MapCreateBulk(slice any, setFunc func(*PartnershipInteractionCreate, int)) *PartnershipInteractionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PartnershipInteractionCreateBulk{err: fmt.Errorf("calling to PartnershipInteractionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PartnershipInteractionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PartnershipInteractionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PartnershipInteraction.
func (c *PartnershipInteractionClient) Update() *PartnershipInteractionUpdate {
	mutation := newPartnershipInteractionMutation(c.config, OpUpdate)
	return &PartnershipInteractionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PartnershipInteractionClient) UpdateOne(_m *PartnershipInteraction) *PartnershipInteractionUpdateOne {
	mutation := newPartnershipInteractionMutation(c.config, OpUpdateOne, withPartnershipInteraction(_m))
	return &PartnershipInteractionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PartnershipInteractionClient) UpdateOneID(id int) *PartnershipInteractionUpdateOne {
	mutation := newPartnershipInteractionMutation(c.config, OpUpdateOne, withPartnershipInteractionID(id))
	return &PartnershipInteractionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PartnershipInteraction.
func (c *PartnershipInteractionClient) Delete() *PartnershipInteractionDelete {
	mutation := newPartnershipInteractionMutation(c.config, OpDelete)
	return &PartnershipInteractionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PartnershipInteractionClient) DeleteOne(_m *PartnershipInteraction) *PartnershipInteractionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PartnershipInteractionClient) DeleteOneID(id int) *PartnershipInteractionDeleteOne {
	builder := c.Delete().Where(partnershipinteraction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PartnershipInteractionDeleteOne{builder}
}

// Query returns a query builder for PartnershipInteraction.
func (c *PartnershipInteractionClient) Query() *PartnershipInteractionQuery {
	return &PartnershipInteractionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePartnershipInteraction},
		inters: c.Interceptors(),
	}
}

// Get returns a PartnershipInteraction entity by its id.
func (c *PartnershipInteractionClient) Get(ctx context.Context, id int) (*PartnershipInteraction, error) {
	return c.Query().Where(partnershipinteraction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PartnershipInteractionClient) GetX(ctx context.Context, id int) *PartnershipInteraction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPartnership queries the partnership edge of a PartnershipInteraction.
func (c *PartnershipInteractionClient) QueryPartnership(_m *PartnershipInteraction) *PartnershipQuery {
	query := (&PartnershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(partnershipinteraction.Table, partnershipinteraction.FieldID, id),
			sqlgraph.To(partnership.Table, partnership.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, partnershipinteraction.PartnershipTable, partnershipinteraction.PartnershipColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PartnershipInteractionClient) Hooks() []Hook {
	return c.hooks.PartnershipInteraction
}

// Interceptors returns the client interceptors.
func (c *PartnershipInteractionClient) Interceptors() []Interceptor {
	return c.inters.PartnershipInteraction
}

func (c *PartnershipInteractionClient) mutate(ctx context.Context, m *PartnershipInteractionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PartnershipInteractionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PartnershipInteractionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PartnershipInteractionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PartnershipInteractionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PartnershipInteraction mutation op: %q", m.Op())
	}
}

// PartnershipRenewalClient is a client for the PartnershipRenewal schema.
type PartnershipRenewalClient struct {
	config
}

// NewPartnershipRenewalClient returns a client for the PartnershipRenewal from the given config.
func NewPartnershipRenewalClient(c config) *PartnershipRenewalClient {
	return &PartnershipRenewalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `partnershiprenewal.Hooks(f(g(h())))`.
func (c *PartnershipRenewalClient) Use(hooks ...Hook) {
	c.hooks.PartnershipRenewal = append(c.hooks.PartnershipRenewal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `partnershiprenewal.Intercept(f(g(h())))`.
func (c *PartnershipRenewalClient) Intercept(interceptors ...Interceptor) {
	c.inters.PartnershipRenewal = append(c.inters.PartnershipRenewal, interceptors...)
}

// Create returns a builder for creating a PartnershipRenewal entity.
func (c *PartnershipRenewalClient) Create() *PartnershipRenewalCreate {
	mutation := newPartnershipRenewalMutation(c.config, OpCreate)
	return &PartnershipRenewalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PartnershipRenewal entities.
func (c *PartnershipRenewalClient) CreateBulk(builders ...*PartnershipRenewalCreate) *PartnershipRenewalCreateBulk {
	return &PartnershipRenewalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PartnershipRenewalClient) MapCreateBulk(slice any, setFunc func(*PartnershipRenewalCreate, int)) *PartnershipRenewalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PartnershipRenewalCreateBulk{err: fmt.Errorf("calling to PartnershipRenewalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PartnershipRenewalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PartnershipRenewalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PartnershipRenewal.
func (c *PartnershipRenewalClient) Update() *PartnershipRenewalUpdate {
	mutation := newPartnershipRenewalMutation(c.config, OpUpdate)
	return &PartnershipRenewalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PartnershipRenewalClient) UpdateOne(_m *PartnershipRenewal) *PartnershipRenewalUpdateOne {
	mutation := newPartnershipRenewalMutation(c.config, OpUpdateOne, withPartnershipRenewal(_m))
	return &PartnershipRenewalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PartnershipRenewalClient) UpdateOneID(id int) *PartnershipRenewalUpdateOne {
	mutation := newPartnershipRenewalMutation(c.config, OpUpdateOne, withPartnershipRenewalID(id))
	return &PartnershipRenewalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PartnershipRenewal.
func (c *PartnershipRenewalClient) Delete() *PartnershipRenewalDelete {
	mutation := newPartnershipRenewalMutation(c.config, OpDelete)
	return &PartnershipRenewalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PartnershipRenewalClient) DeleteOne(_m *PartnershipRenewal) *PartnershipRenewalDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PartnershipRenewalClient) DeleteOneID(id int) *PartnershipRenewalDeleteOne {
	builder := c.Delete().Where(partnershiprenewal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PartnershipRenewalDeleteOne{builder}
}

// Query returns a query builder for PartnershipRenewal.
func (c *PartnershipRenewalClient) Query() *PartnershipRenewalQuery {
	return &PartnershipRenewalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePartnershipRenewal},
		inters: c.Interceptors(),
	}
}

// Get returns a PartnershipRenewal entity by its id.
func (c *PartnershipRenewalClient) Get(ctx context.Context, id int) (*PartnershipRenewal, error) {
	return c.Query().Where(partnershiprenewal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PartnershipRenewalClient) GetX(ctx context.Context, id int) *PartnershipRenewal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPartnership queries the partnership edge of a PartnershipRenewal.
func (c *PartnershipRenewalClient) QueryPartnership(_m *PartnershipRenewal) *PartnershipQuery {
	query := (&PartnershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(partnershiprenewal.Table, partnershiprenewal.FieldID, id),
			sqlgraph.To(partnership.Table, partnership.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, partnershiprenewal.PartnershipTable, partnershiprenewal.PartnershipColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PartnershipRenewalClient) Hooks() []Hook {
	return c.hooks.PartnershipRenewal
}

// Interceptors returns the client interceptors.
func (c *PartnershipRenewalClient) Interceptors() []Interceptor {
	return c.inters.PartnershipRenewal
}

func (c *PartnershipRenewalClient) mutate(ctx context.Context, m *PartnershipRenewalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PartnershipRenewalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PartnershipRenewalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PartnershipRenewalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PartnershipRenewalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PartnershipRenewal mutation op: %q", m.Op())
	}
}

// PartnershipReportClient is a client for the PartnershipReport schema.
type PartnershipReportClient struct {
	config
}

// NewPartnershipReportClient returns a client for the PartnershipReport from the given config.
func NewPartnershipReportClient(c config) *PartnershipReportClient {
	return &PartnershipReportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `partnershipreport.Hooks(f(g(h())))`.
func (c *PartnershipReportClient) Use(hooks ...Hook) {
	c.hooks.PartnershipReport = append(c.hooks.PartnershipReport, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `partnershipreport.Intercept(f(g(h())))`.
func (c *PartnershipReportClient) Intercept(interceptors ...Interceptor) {
	c.inters.PartnershipReport = append(c.inters.PartnershipReport, interceptors...)
}

// Create returns a builder for creating a PartnershipReport entity.
func (c *PartnershipReportClient) Create() *PartnershipReportCreate {
	mutation := newPartnershipReportMutation(c.config, OpCreate)
	return &PartnershipReportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PartnershipReport entities.
func (c *PartnershipReportClient) CreateBulk(builders ...*PartnershipReportCreate) *PartnershipReportCreateBulk {
	return &PartnershipReportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PartnershipReportClient) MapCreateBulk(slice any, setFunc func(*PartnershipReportCreate, int)) *PartnershipReportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PartnershipReportCreateBulk{err: fmt.Errorf("calling to PartnershipReportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PartnershipReportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PartnershipReportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PartnershipReport.
func (c *PartnershipReportClient) Update() *PartnershipReportUpdate {
	mutation := newPartnershipReportMutation(c.config, OpUpdate)
	return &PartnershipReportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PartnershipReportClient) UpdateOne(_m *PartnershipReport) *PartnershipReportUpdateOne {
	mutation := newPartnershipReportMutation(c.config, OpUpdateOne, withPartnershipReport(_m))
	return &PartnershipReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PartnershipReportClient) UpdateOneID(id int) *PartnershipReportUpdateOne {
	mutation := newPartnershipReportMutation(c.config, OpUpdateOne, withPartnershipReportID(id))
	return &PartnershipReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PartnershipReport.
func (c *PartnershipReportClient) Delete() *PartnershipReportDelete {
	mutation := newPartnershipReportMutation(c.config, OpDelete)
	return &PartnershipReportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PartnershipReportClient) DeleteOne(_m *PartnershipReport) *PartnershipReportDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PartnershipReportClient) DeleteOneID(id int) *PartnershipReportDeleteOne {
	builder := c.Delete().Where(partnershipreport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PartnershipReportDeleteOne{builder}
}

// Query returns a query builder for PartnershipReport.
func (c *PartnershipReportClient) Query() *PartnershipReportQuery {
	return &PartnershipReportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePartnershipReport},
		inters: c.Interceptors(),
	}
}

// Get returns a PartnershipReport entity by its id.
func (c *PartnershipReportClient) Get(ctx context.Context, id int) (*PartnershipReport, error) {
	return c.Query().Where(partnershipreport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PartnershipReportClient) GetX(ctx context.Context, id int) *PartnershipReport {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPartnership queries the partnership edge of a PartnershipReport.
func (c *PartnershipReportClient) QueryPartnership(_m *PartnershipReport) *PartnershipQuery {
	query := (&PartnershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(partnershipreport.Table, partnershipreport.FieldID, id),
			sqlgraph.To(partnership.Table, partnership.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, partnershipreport.PartnershipTable, partnershipreport.PartnershipColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PartnershipReportClient) Hooks() []Hook {
	return c.hooks.PartnershipReport
}

// Interceptors returns the client interceptors.
func (c *PartnershipReportClient) Interceptors() []Interceptor {
	return c.inters.PartnershipReport
}

func (c *PartnershipReportClient) mutate(ctx context.Context, m *PartnershipReportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PartnershipReportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PartnershipReportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PartnershipReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PartnershipReportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PartnershipReport mutation op: %q", m.Op())
	}
}

// PasswordHistoryClient is a client for the PasswordHistory schema.
type PasswordHistoryClient struct {
	config
}

// NewPasswordHistoryClient returns a client for the PasswordHistory from the given config.
func NewPasswordHistoryClient(c config) *PasswordHistoryClient {
	return &PasswordHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `passwordhistory.Hooks(f(g(h())))`.
func (c *PasswordHistoryClient) Use(hooks ...Hook) {
	c.hooks.PasswordHistory = append(c.hooks.PasswordHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `passwordhistory.Intercept(f(g(h())))`.
func (c *PasswordHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.PasswordHistory = append(c.inters.PasswordHistory, interceptors...)
}

// Create returns a builder for creating a PasswordHistory entity.
func (c *PasswordHistoryClient) Create() *PasswordHistoryCreate {
	mutation := newPasswordHistoryMutation(c.config, OpCreate)
	return &PasswordHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PasswordHistory entities.
func (c *PasswordHistoryClient) CreateBulk(builders ...*PasswordHistoryCreate) *PasswordHistoryCreateBulk {
	return &PasswordHistoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PasswordHistoryClient) MapCreateBulk(slice any, setFunc func(*PasswordHistoryCreate, int)) *PasswordHistoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PasswordHistoryCreateBulk{err: fmt.Errorf("calling to PasswordHistoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PasswordHistoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PasswordHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PasswordHistory.
func (c *PasswordHistoryClient) Update() *PasswordHistoryUpdate {
	mutation := newPasswordHistoryMutation(c.config, OpUpdate)
	return &PasswordHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PasswordHistoryClient) UpdateOne(_m *PasswordHistory) *PasswordHistoryUpdateOne {
	mutation := newPasswordHistoryMutation(c.config, OpUpdateOne, withPasswordHistory(_m))
	return &PasswordHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PasswordHistoryClient) UpdateOneID(id int) *PasswordHistoryUpdateOne {
	mutation := newPasswordHistoryMutation(c.config, OpUpdateOne, withPasswordHistoryID(id))
	return &PasswordHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PasswordHistory.
func (c *PasswordHistoryClient) Delete() *PasswordHistoryDelete {
	mutation := newPasswordHistoryMutation(c.config, OpDelete)
	return &PasswordHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PasswordHistoryClient) DeleteOne(_m *PasswordHistory) *PasswordHistoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PasswordHistoryClient) DeleteOneID(id int) *PasswordHistoryDeleteOne {
	builder := c.Delete().Where(passwordhistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PasswordHistoryDeleteOne{builder}
}

// Query returns a query builder for PasswordHistory.
func (c *PasswordHistoryClient) Query() *PasswordHistoryQuery {
	return &PasswordHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePasswordHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a PasswordHistory entity by its id.
func (c *PasswordHistoryClient) Get(ctx context.Context, id int) (*PasswordHistory, error) {
	return c.Query().Where(passwordhistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PasswordHistoryClient) GetX(ctx context.Context, id int) *PasswordHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a PasswordHistory.
func (c *PasswordHistoryClient) QueryUser(_m *PasswordHistory) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(passwordhistory.Table, passwordhistory.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, passwordhistory.UserTable, passwordhistory.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PasswordHistoryClient) Hooks() []Hook {
	return c.hooks.PasswordHistory
}

// Interceptors returns the client interceptors.
func (c *PasswordHistoryClient) Interceptors() []Interceptor {
	return c.inters.PasswordHistory
}

func (c *PasswordHistoryClient) mutate(ctx context.Context, m *PasswordHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PasswordHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PasswordHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PasswordHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PasswordHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PasswordHistory mutation op: %q", m.Op())
	}
}

// PermissionClient is a client for the Permission schema.
type PermissionClient struct {
	config
}

// NewPermissionClient returns a client for the Permission from the given config.
func NewPermissionClient(c config) *PermissionClient {
	return &PermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `permission.Hooks(f(g(h())))`.
func (c *PermissionClient) Use(hooks ...Hook) {
	c.hooks.Permission = append(c.hooks.Permission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `permission.Intercept(f(g(h())))`.
func (c *PermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Permission = append(c.inters.Permission, interceptors...)
}

// Create returns a builder for creating a Permission entity.
func (c *PermissionClient) Create() *PermissionCreate {
	mutation := newPermissionMutation(c.config, OpCreate)
	return &PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Permission entities.
func (c *PermissionClient) CreateBulk(builders ...*PermissionCreate) *PermissionCreateBulk {
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PermissionClient) MapCreateBulk(slice any, setFunc func(*PermissionCreate, int)) *PermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PermissionCreateBulk{err: fmt.Errorf("calling to PermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Permission.
func (c *PermissionClient) Update() *PermissionUpdate {
	mutation := newPermissionMutation(c.config, OpUpdate)
	return &PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PermissionClient) UpdateOne(_m *Permission) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermission(_m))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PermissionClient) UpdateOneID(id int) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermissionID(id))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Permission.
func (c *PermissionClient) Delete() *PermissionDelete {
	mutation := newPermissionMutation(c.config, OpDelete)
	return &PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PermissionClient) DeleteOne(_m *Permission) *PermissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PermissionClient) DeleteOneID(id int) *PermissionDeleteOne {
	builder := c.Delete().Where(permission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PermissionDeleteOne{builder}
}

// Query returns a query builder for Permission.
func (c *PermissionClient) Query() *PermissionQuery {
	return &PermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a Permission entity by its id.
func (c *PermissionClient) Get(ctx context.Context, id int) (*Permission, error) {
	return c.Query().Where(permission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PermissionClient) GetX(ctx context.Context, id int) *Permission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a Permission.
func (c *PermissionClient) QueryRoles(_m *Permission) *RolePermissionQuery {
	query := (&RolePermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(rolepermission.Table, rolepermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, permission.RolesTable, permission.RolesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PermissionClient) Hooks() []Hook {
	return c.hooks.Permission
}

// Interceptors returns the client interceptors.
func (c *PermissionClient) Interceptors() []Interceptor {
	return c.inters.Permission
}

func (c *PermissionClient) mutate(ctx context.Context, m *PermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Permission mutation op: %q", m.Op())
	}
}

// ProgramClient is a client for the Program schema.
type ProgramClient struct {
	config
}

// NewProgramClient returns a client for the Program from the given config.
func NewProgramClient(c config) *ProgramClient {
	return &ProgramClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `program.Hooks(f(g(h())))`.
func (c *ProgramClient) Use(hooks ...Hook) {
	c.hooks.Program = append(c.hooks.Program, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `program.Intercept(f(g(h())))`.
func (c *ProgramClient) Intercept(interceptors ...Interceptor) {
	c.inters.Program = append(c.inters.Program, interceptors...)
}

// Create returns a builder for creating a Program entity.
func (c *ProgramClient) Create() *ProgramCreate {
	mutation := newProgramMutation(c.config, OpCreate)
	return &ProgramCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Program entities.
func (c *ProgramClient) CreateBulk(builders ...*ProgramCreate) *ProgramCreateBulk {
	return &ProgramCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramClient) MapCreateBulk(slice any, setFunc func(*ProgramCreate, int)) *ProgramCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramCreateBulk{err: fmt.Errorf("calling to ProgramClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Program.
func (c *ProgramClient) Update() *ProgramUpdate {
	mutation := newProgramMutation(c.config, OpUpdate)
	return &ProgramUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramClient) UpdateOne(_m *Program) *ProgramUpdateOne {
	mutation := newProgramMutation(c.config, OpUpdateOne, withProgram(_m))
	return &ProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramClient) UpdateOneID(id int) *ProgramUpdateOne {
	mutation := newProgramMutation(c.config, OpUpdateOne, withProgramID(id))
	return &ProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Program.
func (c *ProgramClient) Delete() *ProgramDelete {
	mutation := newProgramMutation(c.config, OpDelete)
	return &ProgramDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramClient) DeleteOne(_m *Program) *ProgramDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramClient) DeleteOneID(id int) *ProgramDeleteOne {
	builder := c.Delete().Where(program.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramDeleteOne{builder}
}

// Query returns a query builder for Program.
func (c *ProgramClient) Query() *ProgramQuery {
	return &ProgramQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgram},
		inters: c.Interceptors(),
	}
}

// Get returns a Program entity by its id.
func (c *ProgramClient) Get(ctx context.Context, id int) (*Program, error) {
	return c.Query().Where(program.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramClient) GetX(ctx context.Context, id int) *Program {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCategory queries the category edge of a Program.
func (c *ProgramClient) QueryCategory(_m *Program) *ProgramCategoryQuery {
	query := (&ProgramCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(programcategory.Table, programcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, program.CategoryTable, program.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnrolments queries the enrolments edge of a Program.
func (c *ProgramClient) QueryEnrolments(_m *Program) *ProgramEnrolmentQuery {
	query := (&ProgramEnrolmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(programenrolment.Table, programenrolment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.EnrolmentsTable, program.EnrolmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParticipants queries the participants edge of a Program.
func (c *ProgramClient) QueryParticipants(_m *Program) *ProgramParticipantQuery {
	query := (&ProgramParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(programparticipant.Table, programparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.ParticipantsTable, program.ParticipantsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the created_by edge of a Program.
func (c *ProgramClient) QueryCreatedBy(_m *Program) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, program.CreatedByTable, program.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUpdatedBy queries the updated_by edge of a Program.
func (c *ProgramClient) QueryUpdatedBy(_m *Program) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, program.UpdatedByTable, program.UpdatedByColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgramCardItems queries the program_card_items edge of a Program.
func (c *ProgramClient) QueryProgramCardItems(_m *Program) *ProgramCardItemQuery {
	query := (&ProgramCardItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(programcarditem.Table, programcarditem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.ProgramCardItemsTable, program.ProgramCardItemsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Program.
func (c *ProgramClient) QueryEvents(_m *Program) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.EventsTable, program.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySuccessStories queries the success_stories edge of a Program.
func (c *ProgramClient) QuerySuccessStories(_m *Program) *SuccessStoryQuery {
	query := (&SuccessStoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(successstory.Table, successstory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.SuccessStoriesTable, program.SuccessStoriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVolunteerOpportunities queries the volunteer_opportunities edge of a Program.
func (c *ProgramClient) QueryVolunteerOpportunities(_m *Program) *VolunteerOpportunityQuery {
	query := (&VolunteerOpportunityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(volunteeropportunity.Table, volunteeropportunity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.VolunteerOpportunitiesTable, program.VolunteerOpportunitiesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFundraisingCampaigns queries the fundraising_campaigns edge of a Program.
func (c *ProgramClient) QueryFundraisingCampaigns(_m *Program) *FundraisingCampaignQuery {
	query := (&FundraisingCampaignClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(fundraisingcampaign.Table, fundraisingcampaign.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.FundraisingCampaignsTable, program.FundraisingCampaignsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDonations queries the donations edge of a Program.
func (c *ProgramClient) QueryDonations(_m *Program) *DonationQuery {
	query := (&DonationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(donation.Table, donation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.DonationsTable, program.DonationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGrants queries the grants edge of a Program.
func (c *ProgramClient) QueryGrants(_m *Program) *GrantQuery {
	query := (&GrantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(grant.Table, grant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.GrantsTable, program.GrantsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySiteVisits queries the site_visits edge of a Program.
func (c *ProgramClient) QuerySiteVisits(_m *Program) *SiteVisitQuery {
	query := (&SiteVisitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(sitevisit.Table, sitevisit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.SiteVisitsTable, program.SiteVisitsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryImpactMetrics queries the impact_metrics edge of a Program.
func (c *ProgramClient) QueryImpactMetrics(_m *Program) *ImpactMetricQuery {
	query := (&ImpactMetricClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(program.Table, program.FieldID, id),
			sqlgraph.To(impactmetric.Table, impactmetric.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, program.ImpactMetricsTable, program.ImpactMetricsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProgramClient) Hooks() []Hook {
	return c.hooks.Program
}

// Interceptors returns the client interceptors.
func (c *ProgramClient) Interceptors() []Interceptor {
	return c.inters.Program
}

func (c *ProgramClient) mutate(ctx context.Context, m *ProgramMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Program mutation op: %q", m.Op())
	}
}

// ProgramCardItemClient is a client for the ProgramCardItem schema.
type ProgramCardItemClient struct {
	config
}

// NewProgramCardItemClient returns a client for the ProgramCardItem from the given config.
func NewProgramCardItemClient(c config) *ProgramCardItemClient {
	return &ProgramCardItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `programcarditem.Hooks(f(g(h())))`.
func (c *ProgramCardItemClient) Use(hooks ...Hook) {
	c.hooks.ProgramCardItem = append(c.hooks.ProgramCardItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `programcarditem.Intercept(f(g(h())))`.
func (c *ProgramCardItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProgramCardItem = append(c.inters.ProgramCardItem, interceptors...)
}

// Create returns a builder for creating a ProgramCardItem entity.
func (c *ProgramCardItemClient) Create() *ProgramCardItemCreate {
	mutation := newProgramCardItemMutation(c.config, OpCreate)
	return &ProgramCardItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProgramCardItem entities.
func (c *ProgramCardItemClient) CreateBulk(builders ...*ProgramCardItemCreate) *ProgramCardItemCreateBulk {
	return &ProgramCardItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramCardItemClient) MapCreateBulk(slice any, setFunc func(*ProgramCardItemCreate, int)) *ProgramCardItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramCardItemCreateBulk{err: fmt.Errorf("calling to ProgramCardItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramCardItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramCardItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProgramCardItem.
func (c *ProgramCardItemClient) Update() *ProgramCardItemUpdate {
	mutation := newProgramCardItemMutation(c.config, OpUpdate)
	return &ProgramCardItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramCardItemClient) UpdateOne(_m *ProgramCardItem) *ProgramCardItemUpdateOne {
	mutation := newProgramCardItemMutation(c.config, OpUpdateOne, withProgramCardItem(_m))
	return &ProgramCardItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramCardItemClient) UpdateOneID(id int) *ProgramCardItemUpdateOne {
	mutation := newProgramCardItemMutation(c.config, OpUpdateOne, withProgramCardItemID(id))
	return &ProgramCardItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProgramCardItem.
func (c *ProgramCardItemClient) Delete() *ProgramCardItemDelete {
	mutation := newProgramCardItemMutation(c.config, OpDelete)
	return &ProgramCardItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramCardItemClient) DeleteOne(_m *ProgramCardItem) *ProgramCardItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramCardItemClient) DeleteOneID(id int) *ProgramCardItemDeleteOne {
	builder := c.Delete().Where(programcarditem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramCardItemDeleteOne{builder}
}

// Query returns a query builder for ProgramCardItem.
func (c *ProgramCardItemClient) Query() *ProgramCardItemQuery {
	return &ProgramCardItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgramCardItem},
		inters: c.Interceptors(),
	}
}

// Get returns a ProgramCardItem entity by its id.
func (c *ProgramCardItemClient) Get(ctx context.Context, id int) (*ProgramCardItem, error) {
	return c.Query().Where(programcarditem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramCardItemClient) GetX(ctx context.Context, id int) *ProgramCardItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlock queries the block edge of a ProgramCardItem.
func (c *ProgramCardItemClient) QueryBlock(_m *ProgramCardItem) *BlockProgramCardsQuery {
	query := (&BlockProgramCardsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programcarditem.Table, programcarditem.FieldID, id),
			sqlgraph.To(blockprogramcards.Table, blockprogramcards.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, programcarditem.BlockTable, programcarditem.BlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a ProgramCardItem.
func (c *ProgramCardItemClient) QueryProgram(_m *ProgramCardItem) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programcarditem.Table, programcarditem.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, programcarditem.ProgramTable, programcarditem.ProgramColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProgramCardItemClient) Hooks() []Hook {
	return c.hooks.ProgramCardItem
}

// Interceptors returns the client interceptors.
func (c *ProgramCardItemClient) Interceptors() []Interceptor {
	return c.inters.ProgramCardItem
}

func (c *ProgramCardItemClient) mutate(ctx context.Context, m *ProgramCardItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramCardItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramCardItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramCardItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramCardItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProgramCardItem mutation op: %q", m.Op())
	}
}

// ProgramCategoryClient is a client for the ProgramCategory schema.
type ProgramCategoryClient struct {
	config
}

// NewProgramCategoryClient returns a client for the ProgramCategory from the given config.
func NewProgramCategoryClient(c config) *ProgramCategoryClient {
	return &ProgramCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `programcategory.Hooks(f(g(h())))`.
func (c *ProgramCategoryClient) Use(hooks ...Hook) {
	c.hooks.ProgramCategory = append(c.hooks.ProgramCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `programcategory.Intercept(f(g(h())))`.
func (c *ProgramCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProgramCategory = append(c.inters.ProgramCategory, interceptors...)
}

// Create returns a builder for creating a ProgramCategory entity.
func (c *ProgramCategoryClient) Create() *ProgramCategoryCreate {
	mutation := newProgramCategoryMutation(c.config, OpCreate)
	return &ProgramCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProgramCategory entities.
func (c *ProgramCategoryClient) CreateBulk(builders ...*ProgramCategoryCreate) *ProgramCategoryCreateBulk {
	return &ProgramCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramCategoryClient) MapCreateBulk(slice any, setFunc func(*ProgramCategoryCreate, int)) *ProgramCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramCategoryCreateBulk{err: fmt.Errorf("calling to ProgramCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProgramCategory.
func (c *ProgramCategoryClient) Update() *ProgramCategoryUpdate {
	mutation := newProgramCategoryMutation(c.config, OpUpdate)
	return &ProgramCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramCategoryClient) UpdateOne(_m *ProgramCategory) *ProgramCategoryUpdateOne {
	mutation := newProgramCategoryMutation(c.config, OpUpdateOne, withProgramCategory(_m))
	return &ProgramCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramCategoryClient) UpdateOneID(id int) *ProgramCategoryUpdateOne {
	mutation := newProgramCategoryMutation(c.config, OpUpdateOne, withProgramCategoryID(id))
	return &ProgramCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProgramCategory.
func (c *ProgramCategoryClient) Delete() *ProgramCategoryDelete {
	mutation := newProgramCategoryMutation(c.config, OpDelete)
	return &ProgramCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramCategoryClient) DeleteOne(_m *ProgramCategory) *ProgramCategoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramCategoryClient) DeleteOneID(id int) *ProgramCategoryDeleteOne {
	builder := c.Delete().Where(programcategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramCategoryDeleteOne{builder}
}

// Query returns a query builder for ProgramCategory.
func (c *ProgramCategoryClient) Query() *ProgramCategoryQuery {
	return &ProgramCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgramCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a ProgramCategory entity by its id.
func (c *ProgramCategoryClient) Get(ctx context.Context, id int) (*ProgramCategory, error) {
	return c.Query().Where(programcategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramCategoryClient) GetX(ctx context.Context, id int) *ProgramCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrograms queries the programs edge of a ProgramCategory.
func (c *ProgramCategoryClient) QueryPrograms(_m *ProgramCategory) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programcategory.Table, programcategory.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, programcategory.ProgramsTable, programcategory.ProgramsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProgramCategoryClient) Hooks() []Hook {
	return c.hooks.ProgramCategory
}

// Interceptors returns the client interceptors.
func (c *ProgramCategoryClient) Interceptors() []Interceptor {
	return c.inters.ProgramCategory
}

func (c *ProgramCategoryClient) mutate(ctx context.Context, m *ProgramCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProgramCategory mutation op: %q", m.Op())
	}
}

// ProgramEnrolmentClient is a client for the ProgramEnrolment schema.
type ProgramEnrolmentClient struct {
	config
}

// NewProgramEnrolmentClient returns a client for the ProgramEnrolment from the given config.
func NewProgramEnrolmentClient(c config) *ProgramEnrolmentClient {
	return &ProgramEnrolmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `programenrolment.Hooks(f(g(h())))`.
func (c *ProgramEnrolmentClient) Use(hooks ...Hook) {
	c.hooks.ProgramEnrolment = append(c.hooks.ProgramEnrolment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `programenrolment.Intercept(f(g(h())))`.
func (c *ProgramEnrolmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProgramEnrolment = append(c.inters.ProgramEnrolment, interceptors...)
}

// Create returns a builder for creating a ProgramEnrolment entity.
func (c *ProgramEnrolmentClient) Create() *ProgramEnrolmentCreate {
	mutation := newProgramEnrolmentMutation(c.config, OpCreate)
	return &ProgramEnrolmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProgramEnrolment entities.
func (c *ProgramEnrolmentClient) CreateBulk(builders ...*ProgramEnrolmentCreate) *ProgramEnrolmentCreateBulk {
	return &ProgramEnrolmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramEnrolmentClient) MapCreateBulk(slice any, setFunc func(*ProgramEnrolmentCreate, int)) *ProgramEnrolmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramEnrolmentCreateBulk{err: fmt.Errorf("calling to ProgramEnrolmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramEnrolmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramEnrolmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProgramEnrolment.
func (c *ProgramEnrolmentClient) Update() *ProgramEnrolmentUpdate {
	mutation := newProgramEnrolmentMutation(c.config, OpUpdate)
	return &ProgramEnrolmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramEnrolmentClient) UpdateOne(_m *ProgramEnrolment) *ProgramEnrolmentUpdateOne {
	mutation := newProgramEnrolmentMutation(c.config, OpUpdateOne, withProgramEnrolment(_m))
	return &ProgramEnrolmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramEnrolmentClient) UpdateOneID(id int) *ProgramEnrolmentUpdateOne {
	mutation := newProgramEnrolmentMutation(c.config, OpUpdateOne, withProgramEnrolmentID(id))
	return &ProgramEnrolmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProgramEnrolment.
func (c *ProgramEnrolmentClient) Delete() *ProgramEnrolmentDelete {
	mutation := newProgramEnrolmentMutation(c.config, OpDelete)
	return &ProgramEnrolmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramEnrolmentClient) DeleteOne(_m *ProgramEnrolment) *ProgramEnrolmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramEnrolmentClient) DeleteOneID(id int) *ProgramEnrolmentDeleteOne {
	builder := c.Delete().Where(programenrolment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramEnrolmentDeleteOne{builder}
}

// Query returns a query builder for ProgramEnrolment.
func (c *ProgramEnrolmentClient) Query() *ProgramEnrolmentQuery {
	return &ProgramEnrolmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgramEnrolment},
		inters: c.Interceptors(),
	}
}

// Get returns a ProgramEnrolment entity by its id.
func (c *ProgramEnrolmentClient) Get(ctx context.Context, id int) (*ProgramEnrolment, error) {
	return c.Query().Where(programenrolment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramEnrolmentClient) GetX(ctx context.Context, id int) *ProgramEnrolment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProgram queries the program edge of a ProgramEnrolment.
func (c *ProgramEnrolmentClient) QueryProgram(_m *ProgramEnrolment) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programenrolment.Table, programenrolment.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, programenrolment.ProgramTable, programenrolment.ProgramColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ProgramEnrolment.
func (c *ProgramEnrolmentClient) QueryUser(_m *ProgramEnrolment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programenrolment.Table, programenrolment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, programenrolment.UserTable, programenrolment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProgramEnrolmentClient) Hooks() []Hook {
	return c.hooks.ProgramEnrolment
}

// Interceptors returns the client interceptors.
func (c *ProgramEnrolmentClient) Interceptors() []Interceptor {
	return c.inters.ProgramEnrolment
}

func (c *ProgramEnrolmentClient) mutate(ctx context.Context, m *ProgramEnrolmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramEnrolmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramEnrolmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramEnrolmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramEnrolmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProgramEnrolment mutation op: %q", m.Op())
	}
}

// ProgramParticipantClient is a client for the ProgramParticipant schema.
type ProgramParticipantClient struct {
	config
}

// NewProgramParticipantClient returns a client for the ProgramParticipant from the given config.
func NewProgramParticipantClient(c config) *ProgramParticipantClient {
	return &ProgramParticipantClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `programparticipant.Hooks(f(g(h())))`.
func (c *ProgramParticipantClient) Use(hooks ...Hook) {
	c.hooks.ProgramParticipant = append(c.hooks.ProgramParticipant, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `programparticipant.Intercept(f(g(h())))`.
func (c *ProgramParticipantClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProgramParticipant = append(c.inters.ProgramParticipant, interceptors...)
}

// Create returns a builder for creating a ProgramParticipant entity.
func (c *ProgramParticipantClient) Create() *ProgramParticipantCreate {
	mutation := newProgramParticipantMutation(c.config, OpCreate)
	return &ProgramParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProgramParticipant entities.
func (c *ProgramParticipantClient) CreateBulk(builders ...*ProgramParticipantCreate) *ProgramParticipantCreateBulk {
	return &ProgramParticipantCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProgramParticipantClient) MapCreateBulk(slice any, setFunc func(*ProgramParticipantCreate, int)) *ProgramParticipantCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProgramParticipantCreateBulk{err: fmt.Errorf("calling to ProgramParticipantClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProgramParticipantCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProgramParticipantCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProgramParticipant.
func (c *ProgramParticipantClient) Update() *ProgramParticipantUpdate {
	mutation := newProgramParticipantMutation(c.config, OpUpdate)
	return &ProgramParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProgramParticipantClient) UpdateOne(_m *ProgramParticipant) *ProgramParticipantUpdateOne {
	mutation := newProgramParticipantMutation(c.config, OpUpdateOne, withProgramParticipant(_m))
	return &ProgramParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProgramParticipantClient) UpdateOneID(id int) *ProgramParticipantUpdateOne {
	mutation := newProgramParticipantMutation(c.config, OpUpdateOne, withProgramParticipantID(id))
	return &ProgramParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProgramParticipant.
func (c *ProgramParticipantClient) Delete() *ProgramParticipantDelete {
	mutation := newProgramParticipantMutation(c.config, OpDelete)
	return &ProgramParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProgramParticipantClient) DeleteOne(_m *ProgramParticipant) *ProgramParticipantDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProgramParticipantClient) DeleteOneID(id int) *ProgramParticipantDeleteOne {
	builder := c.Delete().Where(programparticipant.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProgramParticipantDeleteOne{builder}
}

// Query returns a query builder for ProgramParticipant.
func (c *ProgramParticipantClient) Query() *ProgramParticipantQuery {
	return &ProgramParticipantQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProgramParticipant},
		inters: c.Interceptors(),
	}
}

// Get returns a ProgramParticipant entity by its id.
func (c *ProgramParticipantClient) Get(ctx context.Context, id int) (*ProgramParticipant, error) {
	return c.Query().Where(programparticipant.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProgramParticipantClient) GetX(ctx context.Context, id int) *ProgramParticipant {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProgram queries the program edge of a ProgramParticipant.
func (c *ProgramParticipantClient) QueryProgram(_m *ProgramParticipant) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programparticipant.Table, programparticipant.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, programparticipant.ProgramTable, programparticipant.ProgramColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ProgramParticipant.
func (c *ProgramParticipantClient) QueryUser(_m *ProgramParticipant) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(programparticipant.Table, programparticipant.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, programparticipant.UserTable, programparticipant.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProgramParticipantClient) Hooks() []Hook {
	return c.hooks.ProgramParticipant
}

// Interceptors returns the client interceptors.
func (c *ProgramParticipantClient) Interceptors() []Interceptor {
	return c.inters.ProgramParticipant
}

func (c *ProgramParticipantClient) mutate(ctx context.Context, m *ProgramParticipantMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProgramParticipantCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProgramParticipantUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProgramParticipantUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProgramParticipantDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProgramParticipant mutation op: %q", m.Op())
	}
}

// ReportDefinitionClient is a client for the ReportDefinition schema.
type ReportDefinitionClient struct {
	config
}

// NewReportDefinitionClient returns a client for the ReportDefinition from the given config.
func NewReportDefinitionClient(c config) *ReportDefinitionClient {
	return &ReportDefinitionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reportdefinition.Hooks(f(g(h())))`.
func (c *ReportDefinitionClient) Use(hooks ...Hook) {
	c.hooks.ReportDefinition = append(c.hooks.ReportDefinition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reportdefinition.Intercept(f(g(h())))`.
func (c *ReportDefinitionClient) Intercept(interceptors ...Interceptor) {
	c.inters.ReportDefinition = append(c.inters.ReportDefinition, interceptors...)
}

// Create returns a builder for creating a ReportDefinition entity.
func (c *ReportDefinitionClient) Create() *ReportDefinitionCreate {
	mutation := newReportDefinitionMutation(c.config, OpCreate)
	return &ReportDefinitionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReportDefinition entities.
func (c *ReportDefinitionClient) CreateBulk(builders ...*ReportDefinitionCreate) *ReportDefinitionCreateBulk {
	return &ReportDefinitionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReportDefinitionClient) MapCreateBulk(slice any, setFunc func(*ReportDefinitionCreate, int)) *ReportDefinitionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReportDefinitionCreateBulk{err: fmt.Errorf("calling to ReportDefinitionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReportDefinitionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReportDefinitionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReportDefinition.
func (c *ReportDefinitionClient) Update() *ReportDefinitionUpdate {
	mutation := newReportDefinitionMutation(c.config, OpUpdate)
	return &ReportDefinitionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReportDefinitionClient) UpdateOne(_m *ReportDefinition) *ReportDefinitionUpdateOne {
	mutation := newReportDefinitionMutation(c.config, OpUpdateOne, withReportDefinition(_m))
	return &ReportDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReportDefinitionClient) UpdateOneID(id int) *ReportDefinitionUpdateOne {
	mutation := newReportDefinitionMutation(c.config, OpUpdateOne, withReportDefinitionID(id))
	return &ReportDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReportDefinition.
func (c *ReportDefinitionClient) Delete() *ReportDefinitionDelete {
	mutation := newReportDefinitionMutation(c.config, OpDelete)
	return &ReportDefinitionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReportDefinitionClient) DeleteOne(_m *ReportDefinition) *ReportDefinitionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReportDefinitionClient) DeleteOneID(id int) *ReportDefinitionDeleteOne {
	builder := c.Delete().Where(reportdefinition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReportDefinitionDeleteOne{builder}
}

// Query returns a query builder for ReportDefinition.
func (c *ReportDefinitionClient) Query() *ReportDefinitionQuery {
	return &ReportDefinitionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReportDefinition},
		inters: c.Interceptors(),
	}
}

// Get returns a ReportDefinition entity by its id.
func (c *ReportDefinitionClient) Get(ctx context.Context, id int) (*ReportDefinition, error) {
	return c.Query().Where(reportdefinition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReportDefinitionClient) GetX(ctx context.Context, id int) *ReportDefinition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCreator queries the creator edge of a ReportDefinition.
func (c *ReportDefinitionClient) QueryCreator(_m *ReportDefinition) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reportdefinition.Table, reportdefinition.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reportdefinition.CreatorTable, reportdefinition.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermissions queries the permissions edge of a ReportDefinition.
func (c *ReportDefinitionClient) QueryPermissions(_m *ReportDefinition) *ReportPermissionQuery {
	query := (&ReportPermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reportdefinition.Table, reportdefinition.FieldID, id),
			sqlgraph.To(reportpermission.Table, reportpermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, reportdefinition.PermissionsTable, reportdefinition.PermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGeneratedReports queries the generated_reports edge of a ReportDefinition.
func (c *ReportDefinitionClient) QueryGeneratedReports(_m *ReportDefinition) *GeneratedReportQuery {
	query := (&GeneratedReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reportdefinition.Table, reportdefinition.FieldID, id),
			sqlgraph.To(generatedreport.Table, generatedreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, reportdefinition.GeneratedReportsTable, reportdefinition.GeneratedReportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySchedules queries the schedules edge of a ReportDefinition.
func (c *ReportDefinitionClient) QuerySchedules(_m *ReportDefinition) *ScheduledReportQuery {
	query := (&ScheduledReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reportdefinition.Table, reportdefinition.FieldID, id),
			sqlgraph.To(scheduledreport.Table, scheduledreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, reportdefinition.SchedulesTable, reportdefinition.SchedulesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReportDefinitionClient) Hooks() []Hook {
	return c.hooks.ReportDefinition
}

// Interceptors returns the client interceptors.
func (c *ReportDefinitionClient) Interceptors() []Interceptor {
	return c.inters.ReportDefinition
}

func (c *ReportDefinitionClient) mutate(ctx context.Context, m *ReportDefinitionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReportDefinitionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReportDefinitionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReportDefinitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReportDefinitionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ReportDefinition mutation op: %q", m.Op())
	}
}

// ReportPermissionClient is a client for the ReportPermission schema.
type ReportPermissionClient struct {
	config
}

// NewReportPermissionClient returns a client for the ReportPermission from the given config.
func NewReportPermissionClient(c config) *ReportPermissionClient {
	return &ReportPermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reportpermission.Hooks(f(g(h())))`.
func (c *ReportPermissionClient) Use(hooks ...Hook) {
	c.hooks.ReportPermission = append(c.hooks.ReportPermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reportpermission.Intercept(f(g(h())))`.
func (c *ReportPermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.ReportPermission = append(c.inters.ReportPermission, interceptors...)
}

// Create returns a builder for creating a ReportPermission entity.
func (c *ReportPermissionClient) Create() *ReportPermissionCreate {
	mutation := newReportPermissionMutation(c.config, OpCreate)
	return &ReportPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ReportPermission entities.
func (c *ReportPermissionClient) CreateBulk(builders ...*ReportPermissionCreate) *ReportPermissionCreateBulk {
	return &ReportPermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReportPermissionClient) MapCreateBulk(slice any, setFunc func(*ReportPermissionCreate, int)) *ReportPermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReportPermissionCreateBulk{err: fmt.Errorf("calling to ReportPermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReportPermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReportPermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReportPermission.
func (c *ReportPermissionClient) Update() *ReportPermissionUpdate {
	mutation := newReportPermissionMutation(c.config, OpUpdate)
	return &ReportPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReportPermissionClient) UpdateOne(_m *ReportPermission) *ReportPermissionUpdateOne {
	mutation := newReportPermissionMutation(c.config, OpUpdateOne, withReportPermission(_m))
	return &ReportPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReportPermissionClient) UpdateOneID(id int) *ReportPermissionUpdateOne {
	mutation := newReportPermissionMutation(c.config, OpUpdateOne, withReportPermissionID(id))
	return &ReportPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReportPermission.
func (c *ReportPermissionClient) Delete() *ReportPermissionDelete {
	mutation := newReportPermissionMutation(c.config, OpDelete)
	return &ReportPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReportPermissionClient) DeleteOne(_m *ReportPermission) *ReportPermissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReportPermissionClient) DeleteOneID(id int) *ReportPermissionDeleteOne {
	builder := c.Delete().Where(reportpermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReportPermissionDeleteOne{builder}
}

// Query returns a query builder for ReportPermission.
func (c *ReportPermissionClient) Query() *ReportPermissionQuery {
	return &ReportPermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReportPermission},
		inters: c.Interceptors(),
	}
}

// Get returns a ReportPermission entity by its id.
func (c *ReportPermissionClient) Get(ctx context.Context, id int) (*ReportPermission, error) {
	return c.Query().Where(reportpermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReportPermissionClient) GetX(ctx context.Context, id int) *ReportPermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReportDefinition queries the report_definition edge of a ReportPermission.
func (c *ReportPermissionClient) QueryReportDefinition(_m *ReportPermission) *ReportDefinitionQuery {
	query := (&ReportDefinitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reportpermission.Table, reportpermission.FieldID, id),
			sqlgraph.To(reportdefinition.Table, reportdefinition.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reportpermission.ReportDefinitionTable, reportpermission.ReportDefinitionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a ReportPermission.
func (c *ReportPermissionClient) QueryUser(_m *ReportPermission) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reportpermission.Table, reportpermission.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reportpermission.UserTable, reportpermission.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReportPermissionClient) Hooks() []Hook {
	return c.hooks.ReportPermission
}

// Interceptors returns the client interceptors.
func (c *ReportPermissionClient) Interceptors() []Interceptor {
	return c.inters.ReportPermission
}

func (c *ReportPermissionClient) mutate(ctx context.Context, m *ReportPermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReportPermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReportPermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReportPermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReportPermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ReportPermission mutation op: %q", m.Op())
	}
}

// RolePermissionClient is a client for the RolePermission schema.
type RolePermissionClient struct {
	config
}

// NewRolePermissionClient returns a client for the RolePermission from the given config.
func NewRolePermissionClient(c config) *RolePermissionClient {
	return &RolePermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rolepermission.Hooks(f(g(h())))`.
func (c *RolePermissionClient) Use(hooks ...Hook) {
	c.hooks.RolePermission = append(c.hooks.RolePermission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rolepermission.Intercept(f(g(h())))`.
func (c *RolePermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.RolePermission = append(c.inters.RolePermission, interceptors...)
}

// Create returns a builder for creating a RolePermission entity.
func (c *RolePermissionClient) Create() *RolePermissionCreate {
	mutation := newRolePermissionMutation(c.config, OpCreate)
	return &RolePermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RolePermission entities.
func (c *RolePermissionClient) CreateBulk(builders ...*RolePermissionCreate) *RolePermissionCreateBulk {
	return &RolePermissionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RolePermissionClient) MapCreateBulk(slice any, setFunc func(*RolePermissionCreate, int)) *RolePermissionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RolePermissionCreateBulk{err: fmt.Errorf("calling to RolePermissionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RolePermissionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RolePermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RolePermission.
func (c *RolePermissionClient) Update() *RolePermissionUpdate {
	mutation := newRolePermissionMutation(c.config, OpUpdate)
	return &RolePermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RolePermissionClient) UpdateOne(_m *RolePermission) *RolePermissionUpdateOne {
	mutation := newRolePermissionMutation(c.config, OpUpdateOne, withRolePermission(_m))
	return &RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RolePermissionClient) UpdateOneID(id int) *RolePermissionUpdateOne {
	mutation := newRolePermissionMutation(c.config, OpUpdateOne, withRolePermissionID(id))
	return &RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RolePermission.
func (c *RolePermissionClient) Delete() *RolePermissionDelete {
	mutation := newRolePermissionMutation(c.config, OpDelete)
	return &RolePermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RolePermissionClient) DeleteOne(_m *RolePermission) *RolePermissionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RolePermissionClient) DeleteOneID(id int) *RolePermissionDeleteOne {
	builder := c.Delete().Where(rolepermission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RolePermissionDeleteOne{builder}
}

// Query returns a query builder for RolePermission.
func (c *RolePermissionClient) Query() *RolePermissionQuery {
	return &RolePermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRolePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a RolePermission entity by its id.
func (c *RolePermissionClient) Get(ctx context.Context, id int) (*RolePermission, error) {
	return c.Query().Where(rolepermission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RolePermissionClient) GetX(ctx context.Context, id int) *RolePermission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPermission queries the permission edge of a RolePermission.
func (c *RolePermissionClient) QueryPermission(_m *RolePermission) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rolepermission.Table, rolepermission.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rolepermission.PermissionTable, rolepermission.PermissionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RolePermissionClient) Hooks() []Hook {
	return c.hooks.RolePermission
}

// Interceptors returns the client interceptors.
func (c *RolePermissionClient) Interceptors() []Interceptor {
	return c.inters.RolePermission
}

func (c *RolePermissionClient) mutate(ctx context.Context, m *RolePermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RolePermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RolePermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RolePermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RolePermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RolePermission mutation op: %q", m.Op())
	}
}

// ScheduledReportClient is a client for the ScheduledReport schema.
type ScheduledReportClient struct {
	config
}

// NewScheduledReportClient returns a client for the ScheduledReport from the given config.
func NewScheduledReportClient(c config) *ScheduledReportClient {
	return &ScheduledReportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scheduledreport.Hooks(f(g(h())))`.
func (c *ScheduledReportClient) Use(hooks ...Hook) {
	c.hooks.ScheduledReport = append(c.hooks.ScheduledReport, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scheduledreport.Intercept(f(g(h())))`.
func (c *ScheduledReportClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScheduledReport = append(c.inters.ScheduledReport, interceptors...)
}

// Create returns a builder for creating a ScheduledReport entity.
func (c *ScheduledReportClient) Create() *ScheduledReportCreate {
	mutation := newScheduledReportMutation(c.config, OpCreate)
	return &ScheduledReportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScheduledReport entities.
func (c *ScheduledReportClient) CreateBulk(builders ...*ScheduledReportCreate) *ScheduledReportCreateBulk {
	return &ScheduledReportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScheduledReportClient) MapCreateBulk(slice any, setFunc func(*ScheduledReportCreate, int)) *ScheduledReportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScheduledReportCreateBulk{err: fmt.Errorf("calling to ScheduledReportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScheduledReportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScheduledReportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScheduledReport.
func (c *ScheduledReportClient) Update() *ScheduledReportUpdate {
	mutation := newScheduledReportMutation(c.config, OpUpdate)
	return &ScheduledReportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScheduledReportClient) UpdateOne(_m *ScheduledReport) *ScheduledReportUpdateOne {
	mutation := newScheduledReportMutation(c.config, OpUpdateOne, withScheduledReport(_m))
	return &ScheduledReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScheduledReportClient) UpdateOneID(id int) *ScheduledReportUpdateOne {
	mutation := newScheduledReportMutation(c.config, OpUpdateOne, withScheduledReportID(id))
	return &ScheduledReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScheduledReport.
func (c *ScheduledReportClient) Delete() *ScheduledReportDelete {
	mutation := newScheduledReportMutation(c.config, OpDelete)
	return &ScheduledReportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScheduledReportClient) DeleteOne(_m *ScheduledReport) *ScheduledReportDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScheduledReportClient) DeleteOneID(id int) *ScheduledReportDeleteOne {
	builder := c.Delete().Where(scheduledreport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScheduledReportDeleteOne{builder}
}

// Query returns a query builder for ScheduledReport.
func (c *ScheduledReportClient) Query() *ScheduledReportQuery {
	return &ScheduledReportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScheduledReport},
		inters: c.Interceptors(),
	}
}

// Get returns a ScheduledReport entity by its id.
func (c *ScheduledReportClient) Get(ctx context.Context, id int) (*ScheduledReport, error) {
	return c.Query().Where(scheduledreport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScheduledReportClient) GetX(ctx context.Context, id int) *ScheduledReport {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReportDefinition queries the report_definition edge of a ScheduledReport.
func (c *ScheduledReportClient) QueryReportDefinition(_m *ScheduledReport) *ReportDefinitionQuery {
	query := (&ReportDefinitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduledreport.Table, scheduledreport.FieldID, id),
			sqlgraph.To(reportdefinition.Table, reportdefinition.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scheduledreport.ReportDefinitionTable, scheduledreport.ReportDefinitionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a ScheduledReport.
func (c *ScheduledReportClient) QueryCreator(_m *ScheduledReport) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduledreport.Table, scheduledreport.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scheduledreport.CreatorTable, scheduledreport.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScheduledReportClient) Hooks() []Hook {
	return c.hooks.ScheduledReport
}

// Interceptors returns the client interceptors.
func (c *ScheduledReportClient) Interceptors() []Interceptor {
	return c.inters.ScheduledReport
}

func (c *ScheduledReportClient) mutate(ctx context.Context, m *ScheduledReportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScheduledReportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScheduledReportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScheduledReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScheduledReportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScheduledReport mutation op: %q", m.Op())
	}
}

// SeoConfigClient is a client for the SeoConfig schema.
type SeoConfigClient struct {
	config
}

// NewSeoConfigClient returns a client for the SeoConfig from the given config.
func NewSeoConfigClient(c config) *SeoConfigClient {
	return &SeoConfigClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `seoconfig.Hooks(f(g(h())))`.
func (c *SeoConfigClient) Use(hooks ...Hook) {
	c.hooks.SeoConfig = append(c.hooks.SeoConfig, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `seoconfig.Intercept(f(g(h())))`.
func (c *SeoConfigClient) Intercept(interceptors ...Interceptor) {
	c.inters.SeoConfig = append(c.inters.SeoConfig, interceptors...)
}

// Create returns a builder for creating a SeoConfig entity.
func (c *SeoConfigClient) Create() *SeoConfigCreate {
	mutation := newSeoConfigMutation(c.config, OpCreate)
	return &SeoConfigCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SeoConfig entities.
func (c *SeoConfigClient) CreateBulk(builders ...*SeoConfigCreate) *SeoConfigCreateBulk {
	return &SeoConfigCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SeoConfigClient) MapCreateBulk(slice any, setFunc func(*SeoConfigCreate, int)) *SeoConfigCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SeoConfigCreateBulk{err: fmt.Errorf("calling to SeoConfigClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SeoConfigCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SeoConfigCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SeoConfig.
func (c *SeoConfigClient) Update() *SeoConfigUpdate {
	mutation := newSeoConfigMutation(c.config, OpUpdate)
	return &SeoConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SeoConfigClient) UpdateOne(_m *SeoConfig) *SeoConfigUpdateOne {
	mutation := newSeoConfigMutation(c.config, OpUpdateOne, withSeoConfig(_m))
	return &SeoConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SeoConfigClient) UpdateOneID(id int) *SeoConfigUpdateOne {
	mutation := newSeoConfigMutation(c.config, OpUpdateOne, withSeoConfigID(id))
	return &SeoConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SeoConfig.
func (c *SeoConfigClient) Delete() *SeoConfigDelete {
	mutation := newSeoConfigMutation(c.config, OpDelete)
	return &SeoConfigDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SeoConfigClient) DeleteOne(_m *SeoConfig) *SeoConfigDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SeoConfigClient) DeleteOneID(id int) *SeoConfigDeleteOne {
	builder := c.Delete().Where(seoconfig.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SeoConfigDeleteOne{builder}
}

// Query returns a query builder for SeoConfig.
func (c *SeoConfigClient) Query() *SeoConfigQuery {
	return &SeoConfigQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSeoConfig},
		inters: c.Interceptors(),
	}
}

// Get returns a SeoConfig entity by its id.
func (c *SeoConfigClient) Get(ctx context.Context, id int) (*SeoConfig, error) {
	return c.Query().Where(seoconfig.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SeoConfigClient) GetX(ctx context.Context, id int) *SeoConfig {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPage queries the page edge of a SeoConfig.
func (c *SeoConfigClient) QueryPage(_m *SeoConfig) *PageQuery {
	query := (&PageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seoconfig.Table, seoconfig.FieldID, id),
			sqlgraph.To(page.Table, page.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, seoconfig.PageTable, seoconfig.PageColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SeoConfigClient) Hooks() []Hook {
	return c.hooks.SeoConfig
}

// Interceptors returns the client interceptors.
func (c *SeoConfigClient) Interceptors() []Interceptor {
	return c.inters.SeoConfig
}

func (c *SeoConfigClient) mutate(ctx context.Context, m *SeoConfigMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SeoConfigCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SeoConfigUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SeoConfigUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SeoConfigDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SeoConfig mutation op: %q", m.Op())
	}
}

// SiteVisitClient is a client for the SiteVisit schema.
type SiteVisitClient struct {
	config
}

// NewSiteVisitClient returns a client for the SiteVisit from the given config.
func NewSiteVisitClient(c config) *SiteVisitClient {
	return &SiteVisitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sitevisit.Hooks(f(g(h())))`.
func (c *SiteVisitClient) Use(hooks ...Hook) {
	c.hooks.SiteVisit = append(c.hooks.SiteVisit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sitevisit.Intercept(f(g(h())))`.
func (c *SiteVisitClient) Intercept(interceptors ...Interceptor) {
	c.inters.SiteVisit = append(c.inters.SiteVisit, interceptors...)
}

// Create returns a builder for creating a SiteVisit entity.
func (c *SiteVisitClient) Create() *SiteVisitCreate {
	mutation := newSiteVisitMutation(c.config, OpCreate)
	return &SiteVisitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SiteVisit entities.
func (c *SiteVisitClient) CreateBulk(builders ...*SiteVisitCreate) *SiteVisitCreateBulk {
	return &SiteVisitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SiteVisitClient) MapCreateBulk(slice any, setFunc func(*SiteVisitCreate, int)) *SiteVisitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SiteVisitCreateBulk{err: fmt.Errorf("calling to SiteVisitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SiteVisitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SiteVisitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SiteVisit.
func (c *SiteVisitClient) Update() *SiteVisitUpdate {
	mutation := newSiteVisitMutation(c.config, OpUpdate)
	return &SiteVisitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SiteVisitClient) UpdateOne(_m *SiteVisit) *SiteVisitUpdateOne {
	mutation := newSiteVisitMutation(c.config, OpUpdateOne, withSiteVisit(_m))
	return &SiteVisitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SiteVisitClient) UpdateOneID(id int) *SiteVisitUpdateOne {
	mutation := newSiteVisitMutation(c.config, OpUpdateOne, withSiteVisitID(id))
	return &SiteVisitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SiteVisit.
func (c *SiteVisitClient) Delete() *SiteVisitDelete {
	mutation := newSiteVisitMutation(c.config, OpDelete)
	return &SiteVisitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SiteVisitClient) DeleteOne(_m *SiteVisit) *SiteVisitDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SiteVisitClient) DeleteOneID(id int) *SiteVisitDeleteOne {
	builder := c.Delete().Where(sitevisit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SiteVisitDeleteOne{builder}
}

// Query returns a query builder for SiteVisit.
func (c *SiteVisitClient) Query() *SiteVisitQuery {
	return &SiteVisitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSiteVisit},
		inters: c.Interceptors(),
	}
}

// Get returns a SiteVisit entity by its id.
func (c *SiteVisitClient) Get(ctx context.Context, id int) (*SiteVisit, error) {
	return c.Query().Where(sitevisit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SiteVisitClient) GetX(ctx context.Context, id int) *SiteVisit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDonor queries the donor edge of a SiteVisit.
func (c *SiteVisitClient) QueryDonor(_m *SiteVisit) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sitevisit.Table, sitevisit.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sitevisit.DonorTable, sitevisit.DonorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a SiteVisit.
func (c *SiteVisitClient) QueryProgram(_m *SiteVisit) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sitevisit.Table, sitevisit.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sitevisit.ProgramTable, sitevisit.ProgramColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SiteVisitClient) Hooks() []Hook {
	return c.hooks.SiteVisit
}

// Interceptors returns the client interceptors.
func (c *SiteVisitClient) Interceptors() []Interceptor {
	return c.inters.SiteVisit
}

func (c *SiteVisitClient) mutate(ctx context.Context, m *SiteVisitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SiteVisitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SiteVisitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SiteVisitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SiteVisitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SiteVisit mutation op: %q", m.Op())
	}
}

// SkillClient is a client for the Skill schema.
type SkillClient struct {
	config
}

// NewSkillClient returns a client for the Skill from the given config.
func NewSkillClient(c config) *SkillClient {
	return &SkillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `skill.Hooks(f(g(h())))`.
func (c *SkillClient) Use(hooks ...Hook) {
	c.hooks.Skill = append(c.hooks.Skill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `skill.Intercept(f(g(h())))`.
func (c *SkillClient) Intercept(interceptors ...Interceptor) {
	c.inters.Skill = append(c.inters.Skill, interceptors...)
}

// Create returns a builder for creating a Skill entity.
func (c *SkillClient) Create() *SkillCreate {
	mutation := newSkillMutation(c.config, OpCreate)
	return &SkillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Skill entities.
func (c *SkillClient) CreateBulk(builders ...*SkillCreate) *SkillCreateBulk {
	return &SkillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SkillClient) MapCreateBulk(slice any, setFunc func(*SkillCreate, int)) *SkillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SkillCreateBulk{err: fmt.Errorf("calling to SkillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SkillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SkillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Skill.
func (c *SkillClient) Update() *SkillUpdate {
	mutation := newSkillMutation(c.config, OpUpdate)
	return &SkillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SkillClient) UpdateOne(_m *Skill) *SkillUpdateOne {
	mutation := newSkillMutation(c.config, OpUpdateOne, withSkill(_m))
	return &SkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SkillClient) UpdateOneID(id int) *SkillUpdateOne {
	mutation := newSkillMutation(c.config, OpUpdateOne, withSkillID(id))
	return &SkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Skill.
func (c *SkillClient) Delete() *SkillDelete {
	mutation := newSkillMutation(c.config, OpDelete)
	return &SkillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SkillClient) DeleteOne(_m *Skill) *SkillDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SkillClient) DeleteOneID(id int) *SkillDeleteOne {
	builder := c.Delete().Where(skill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SkillDeleteOne{builder}
}

// Query returns a query builder for Skill.
func (c *SkillClient) Query() *SkillQuery {
	return &SkillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSkill},
		inters: c.Interceptors(),
	}
}

// Get returns a Skill entity by its id.
func (c *SkillClient) Get(ctx context.Context, id int) (*Skill, error) {
	return c.Query().Where(skill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SkillClient) GetX(ctx context.Context, id int) *Skill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Skill.
func (c *SkillClient) QueryUsers(_m *Skill) *UserSkillQuery {
	query := (&UserSkillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(skill.Table, skill.FieldID, id),
			sqlgraph.To(userskill.Table, userskill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, skill.UsersTable, skill.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SkillClient) Hooks() []Hook {
	return c.hooks.Skill
}

// Interceptors returns the client interceptors.
func (c *SkillClient) Interceptors() []Interceptor {
	return c.inters.Skill
}

func (c *SkillClient) mutate(ctx context.Context, m *SkillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SkillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SkillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SkillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Skill mutation op: %q", m.Op())
	}
}

// StatItemClient is a client for the StatItem schema.
type StatItemClient struct {
	config
}

// NewStatItemClient returns a client for the StatItem from the given config.
func NewStatItemClient(c config) *StatItemClient {
	return &StatItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `statitem.Hooks(f(g(h())))`.
func (c *StatItemClient) Use(hooks ...Hook) {
	c.hooks.StatItem = append(c.hooks.StatItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `statitem.Intercept(f(g(h())))`.
func (c *StatItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.StatItem = append(c.inters.StatItem, interceptors...)
}

// Create returns a builder for creating a StatItem entity.
func (c *StatItemClient) Create() *StatItemCreate {
	mutation := newStatItemMutation(c.config, OpCreate)
	return &StatItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StatItem entities.
func (c *StatItemClient) CreateBulk(builders ...*StatItemCreate) *StatItemCreateBulk {
	return &StatItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StatItemClient) MapCreateBulk(slice any, setFunc func(*StatItemCreate, int)) *StatItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StatItemCreateBulk{err: fmt.Errorf("calling to StatItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StatItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StatItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StatItem.
func (c *StatItemClient) Update() *StatItemUpdate {
	mutation := newStatItemMutation(c.config, OpUpdate)
	return &StatItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatItemClient) UpdateOne(_m *StatItem) *StatItemUpdateOne {
	mutation := newStatItemMutation(c.config, OpUpdateOne, withStatItem(_m))
	return &StatItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatItemClient) UpdateOneID(id int) *StatItemUpdateOne {
	mutation := newStatItemMutation(c.config, OpUpdateOne, withStatItemID(id))
	return &StatItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StatItem.
func (c *StatItemClient) Delete() *StatItemDelete {
	mutation := newStatItemMutation(c.config, OpDelete)
	return &StatItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StatItemClient) DeleteOne(_m *StatItem) *StatItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StatItemClient) DeleteOneID(id int) *StatItemDeleteOne {
	builder := c.Delete().Where(statitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatItemDeleteOne{builder}
}

// Query returns a query builder for StatItem.
func (c *StatItemClient) Query() *StatItemQuery {
	return &StatItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStatItem},
		inters: c.Interceptors(),
	}
}

// Get returns a StatItem entity by its id.
func (c *StatItemClient) Get(ctx context.Context, id int) (*StatItem, error) {
	return c.Query().Where(statitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatItemClient) GetX(ctx context.Context, id int) *StatItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlock queries the block edge of a StatItem.
func (c *StatItemClient) QueryBlock(_m *StatItem) *BlockStatsQuery {
	query := (&BlockStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(statitem.Table, statitem.FieldID, id),
			sqlgraph.To(blockstats.Table, blockstats.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, statitem.BlockTable, statitem.BlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StatItemClient) Hooks() []Hook {
	return c.hooks.StatItem
}

// Interceptors returns the client interceptors.
func (c *StatItemClient) Interceptors() []Interceptor {
	return c.inters.StatItem
}

func (c *StatItemClient) mutate(ctx context.Context, m *StatItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StatItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StatItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StatItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StatItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown StatItem mutation op: %q", m.Op())
	}
}

// SuccessStoryClient is a client for the SuccessStory schema.
type SuccessStoryClient struct {
	config
}

// NewSuccessStoryClient returns a client for the SuccessStory from the given config.
func NewSuccessStoryClient(c config) *SuccessStoryClient {
	return &SuccessStoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `successstory.Hooks(f(g(h())))`.
func (c *SuccessStoryClient) Use(hooks ...Hook) {
	c.hooks.SuccessStory = append(c.hooks.SuccessStory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `successstory.Intercept(f(g(h())))`.
func (c *SuccessStoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.SuccessStory = append(c.inters.SuccessStory, interceptors...)
}

// Create returns a builder for creating a SuccessStory entity.
func (c *SuccessStoryClient) Create() *SuccessStoryCreate {
	mutation := newSuccessStoryMutation(c.config, OpCreate)
	return &SuccessStoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SuccessStory entities.
func (c *SuccessStoryClient) CreateBulk(builders ...*SuccessStoryCreate) *SuccessStoryCreateBulk {
	return &SuccessStoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SuccessStoryClient) MapCreateBulk(slice any, setFunc func(*SuccessStoryCreate, int)) *SuccessStoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SuccessStoryCreateBulk{err: fmt.Errorf("calling to SuccessStoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SuccessStoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SuccessStoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SuccessStory.
func (c *SuccessStoryClient) Update() *SuccessStoryUpdate {
	mutation := newSuccessStoryMutation(c.config, OpUpdate)
	return &SuccessStoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SuccessStoryClient) UpdateOne(_m *SuccessStory) *SuccessStoryUpdateOne {
	mutation := newSuccessStoryMutation(c.config, OpUpdateOne, withSuccessStory(_m))
	return &SuccessStoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SuccessStoryClient) UpdateOneID(id int) *SuccessStoryUpdateOne {
	mutation := newSuccessStoryMutation(c.config, OpUpdateOne, withSuccessStoryID(id))
	return &SuccessStoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SuccessStory.
func (c *SuccessStoryClient) Delete() *SuccessStoryDelete {
	mutation := newSuccessStoryMutation(c.config, OpDelete)
	return &SuccessStoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SuccessStoryClient) DeleteOne(_m *SuccessStory) *SuccessStoryDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SuccessStoryClient) DeleteOneID(id int) *SuccessStoryDeleteOne {
	builder := c.Delete().Where(successstory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SuccessStoryDeleteOne{builder}
}

// Query returns a query builder for SuccessStory.
func (c *SuccessStoryClient) Query() *SuccessStoryQuery {
	return &SuccessStoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSuccessStory},
		inters: c.Interceptors(),
	}
}

// Get returns a SuccessStory entity by its id.
func (c *SuccessStoryClient) Get(ctx context.Context, id int) (*SuccessStory, error) {
	return c.Query().Where(successstory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SuccessStoryClient) GetX(ctx context.Context, id int) *SuccessStory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthor queries the author edge of a SuccessStory.
func (c *SuccessStoryClient) QueryAuthor(_m *SuccessStory) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(successstory.Table, successstory.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, successstory.AuthorTable, successstory.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgram queries the program edge of a SuccessStory.
func (c *SuccessStoryClient) QueryProgram(_m *SuccessStory) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(successstory.Table, successstory.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, successstory.ProgramTable, successstory.ProgramColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTestimonials queries the testimonials edge of a SuccessStory.
func (c *SuccessStoryClient) QueryTestimonials(_m *SuccessStory) *TestimonialItemQuery {
	query := (&TestimonialItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(successstory.Table, successstory.FieldID, id),
			sqlgraph.To(testimonialitem.Table, testimonialitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, successstory.TestimonialsTable, successstory.TestimonialsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SuccessStoryClient) Hooks() []Hook {
	return c.hooks.SuccessStory
}

// Interceptors returns the client interceptors.
func (c *SuccessStoryClient) Interceptors() []Interceptor {
	return c.inters.SuccessStory
}

func (c *SuccessStoryClient) mutate(ctx context.Context, m *SuccessStoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SuccessStoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SuccessStoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SuccessStoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SuccessStoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SuccessStory mutation op: %q", m.Op())
	}
}

// SystemErrorClient is a client for the SystemError schema.
type SystemErrorClient struct {
	config
}

// NewSystemErrorClient returns a client for the SystemError from the given config.
func NewSystemErrorClient(c config) *SystemErrorClient {
	return &SystemErrorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemerror.Hooks(f(g(h())))`.
func (c *SystemErrorClient) Use(hooks ...Hook) {
	c.hooks.SystemError = append(c.hooks.SystemError, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemerror.Intercept(f(g(h())))`.
func (c *SystemErrorClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemError = append(c.inters.SystemError, interceptors...)
}

// Create returns a builder for creating a SystemError entity.
func (c *SystemErrorClient) Create() *SystemErrorCreate {
	mutation := newSystemErrorMutation(c.config, OpCreate)
	return &SystemErrorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemError entities.
func (c *SystemErrorClient) CreateBulk(builders ...*SystemErrorCreate) *SystemErrorCreateBulk {
	return &SystemErrorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemErrorClient) MapCreateBulk(slice any, setFunc func(*SystemErrorCreate, int)) *SystemErrorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemErrorCreateBulk{err: fmt.Errorf("calling to SystemErrorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemErrorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemErrorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemError.
func (c *SystemErrorClient) Update() *SystemErrorUpdate {
	mutation := newSystemErrorMutation(c.config, OpUpdate)
	return &SystemErrorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemErrorClient) UpdateOne(_m *SystemError) *SystemErrorUpdateOne {
	mutation := newSystemErrorMutation(c.config, OpUpdateOne, withSystemError(_m))
	return &SystemErrorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemErrorClient) UpdateOneID(id int) *SystemErrorUpdateOne {
	mutation := newSystemErrorMutation(c.config, OpUpdateOne, withSystemErrorID(id))
	return &SystemErrorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemError.
func (c *SystemErrorClient) Delete() *SystemErrorDelete {
	mutation := newSystemErrorMutation(c.config, OpDelete)
	return &SystemErrorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemErrorClient) DeleteOne(_m *SystemError) *SystemErrorDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemErrorClient) DeleteOneID(id int) *SystemErrorDeleteOne {
	builder := c.Delete().Where(systemerror.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemErrorDeleteOne{builder}
}

// Query returns a query builder for SystemError.
func (c *SystemErrorClient) Query() *SystemErrorQuery {
	return &SystemErrorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemError},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemError entity by its id.
func (c *SystemErrorClient) Get(ctx context.Context, id int) (*SystemError, error) {
	return c.Query().Where(systemerror.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemErrorClient) GetX(ctx context.Context, id int) *SystemError {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SystemErrorClient) Hooks() []Hook {
	return c.hooks.SystemError
}

// Interceptors returns the client interceptors.
func (c *SystemErrorClient) Interceptors() []Interceptor {
	return c.inters.SystemError
}

func (c *SystemErrorClient) mutate(ctx context.Context, m *SystemErrorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemErrorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemErrorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemErrorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemErrorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemError mutation op: %q", m.Op())
	}
}

// SystemLogClient is a client for the SystemLog schema.
type SystemLogClient struct {
	config
}

// NewSystemLogClient returns a client for the SystemLog from the given config.
func NewSystemLogClient(c config) *SystemLogClient {
	return &SystemLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `systemlog.Hooks(f(g(h())))`.
func (c *SystemLogClient) Use(hooks ...Hook) {
	c.hooks.SystemLog = append(c.hooks.SystemLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `systemlog.Intercept(f(g(h())))`.
func (c *SystemLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.SystemLog = append(c.inters.SystemLog, interceptors...)
}

// Create returns a builder for creating a SystemLog entity.
func (c *SystemLogClient) Create() *SystemLogCreate {
	mutation := newSystemLogMutation(c.config, OpCreate)
	return &SystemLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SystemLog entities.
func (c *SystemLogClient) CreateBulk(builders ...*SystemLogCreate) *SystemLogCreateBulk {
	return &SystemLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SystemLogClient) MapCreateBulk(slice any, setFunc func(*SystemLogCreate, int)) *SystemLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SystemLogCreateBulk{err: fmt.Errorf("calling to SystemLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SystemLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SystemLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SystemLog.
func (c *SystemLogClient) Update() *SystemLogUpdate {
	mutation := newSystemLogMutation(c.config, OpUpdate)
	return &SystemLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SystemLogClient) UpdateOne(_m *SystemLog) *SystemLogUpdateOne {
	mutation := newSystemLogMutation(c.config, OpUpdateOne, withSystemLog(_m))
	return &SystemLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SystemLogClient) UpdateOneID(id int) *SystemLogUpdateOne {
	mutation := newSystemLogMutation(c.config, OpUpdateOne, withSystemLogID(id))
	return &SystemLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SystemLog.
func (c *SystemLogClient) Delete() *SystemLogDelete {
	mutation := newSystemLogMutation(c.config, OpDelete)
	return &SystemLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SystemLogClient) DeleteOne(_m *SystemLog) *SystemLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SystemLogClient) DeleteOneID(id int) *SystemLogDeleteOne {
	builder := c.Delete().Where(systemlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SystemLogDeleteOne{builder}
}

// Query returns a query builder for SystemLog.
func (c *SystemLogClient) Query() *SystemLogQuery {
	return &SystemLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSystemLog},
		inters: c.Interceptors(),
	}
}

// Get returns a SystemLog entity by its id.
func (c *SystemLogClient) Get(ctx context.Context, id int) (*SystemLog, error) {
	return c.Query().Where(systemlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SystemLogClient) GetX(ctx context.Context, id int) *SystemLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SystemLogClient) Hooks() []Hook {
	return c.hooks.SystemLog
}

// Interceptors returns the client interceptors.
func (c *SystemLogClient) Interceptors() []Interceptor {
	return c.inters.SystemLog
}

func (c *SystemLogClient) mutate(ctx context.Context, m *SystemLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SystemLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SystemLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SystemLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SystemLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SystemLog mutation op: %q", m.Op())
	}
}

// TabItemClient is a client for the TabItem schema.
type TabItemClient struct {
	config
}

// NewTabItemClient returns a client for the TabItem from the given config.
func NewTabItemClient(c config) *TabItemClient {
	return &TabItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tabitem.Hooks(f(g(h())))`.
func (c *TabItemClient) Use(hooks ...Hook) {
	c.hooks.TabItem = append(c.hooks.TabItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tabitem.Intercept(f(g(h())))`.
func (c *TabItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.TabItem = append(c.inters.TabItem, interceptors...)
}

// Create returns a builder for creating a TabItem entity.
func (c *TabItemClient) Create() *TabItemCreate {
	mutation := newTabItemMutation(c.config, OpCreate)
	return &TabItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TabItem entities.
func (c *TabItemClient) CreateBulk(builders ...*TabItemCreate) *TabItemCreateBulk {
	return &TabItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TabItemClient) MapCreateBulk(slice any, setFunc func(*TabItemCreate, int)) *TabItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TabItemCreateBulk{err: fmt.Errorf("calling to TabItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TabItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TabItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TabItem.
func (c *TabItemClient) Update() *TabItemUpdate {
	mutation := newTabItemMutation(c.config, OpUpdate)
	return &TabItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TabItemClient) UpdateOne(_m *TabItem) *TabItemUpdateOne {
	mutation := newTabItemMutation(c.config, OpUpdateOne, withTabItem(_m))
	return &TabItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TabItemClient) UpdateOneID(id int) *TabItemUpdateOne {
	mutation := newTabItemMutation(c.config, OpUpdateOne, withTabItemID(id))
	return &TabItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TabItem.
func (c *TabItemClient) Delete() *TabItemDelete {
	mutation := newTabItemMutation(c.config, OpDelete)
	return &TabItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TabItemClient) DeleteOne(_m *TabItem) *TabItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TabItemClient) DeleteOneID(id int) *TabItemDeleteOne {
	builder := c.Delete().Where(tabitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TabItemDeleteOne{builder}
}

// Query returns a query builder for TabItem.
func (c *TabItemClient) Query() *TabItemQuery {
	return &TabItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTabItem},
		inters: c.Interceptors(),
	}
}

// Get returns a TabItem entity by its id.
func (c *TabItemClient) Get(ctx context.Context, id int) (*TabItem, error) {
	return c.Query().Where(tabitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TabItemClient) GetX(ctx context.Context, id int) *TabItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlock queries the block edge of a TabItem.
func (c *TabItemClient) QueryBlock(_m *TabItem) *BlockTabsQuery {
	query := (&BlockTabsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tabitem.Table, tabitem.FieldID, id),
			sqlgraph.To(blocktabs.Table, blocktabs.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tabitem.BlockTable, tabitem.BlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TabItemClient) Hooks() []Hook {
	return c.hooks.TabItem
}

// Interceptors returns the client interceptors.
func (c *TabItemClient) Interceptors() []Interceptor {
	return c.inters.TabItem
}

func (c *TabItemClient) mutate(ctx context.Context, m *TabItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TabItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TabItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TabItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TabItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TabItem mutation op: %q", m.Op())
	}
}

// TeamMemberClient is a client for the TeamMember schema.
type TeamMemberClient struct {
	config
}

// NewTeamMemberClient returns a client for the TeamMember from the given config.
func NewTeamMemberClient(c config) *TeamMemberClient {
	return &TeamMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `teammember.Hooks(f(g(h())))`.
func (c *TeamMemberClient) Use(hooks ...Hook) {
	c.hooks.TeamMember = append(c.hooks.TeamMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `teammember.Intercept(f(g(h())))`.
func (c *TeamMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.TeamMember = append(c.inters.TeamMember, interceptors...)
}

// Create returns a builder for creating a TeamMember entity.
func (c *TeamMemberClient) Create() *TeamMemberCreate {
	mutation := newTeamMemberMutation(c.config, OpCreate)
	return &TeamMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TeamMember entities.
func (c *TeamMemberClient) CreateBulk(builders ...*TeamMemberCreate) *TeamMemberCreateBulk {
	return &TeamMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamMemberClient) MapCreateBulk(slice any, setFunc func(*TeamMemberCreate, int)) *TeamMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamMemberCreateBulk{err: fmt.Errorf("calling to TeamMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TeamMember.
func (c *TeamMemberClient) Update() *TeamMemberUpdate {
	mutation := newTeamMemberMutation(c.config, OpUpdate)
	return &TeamMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamMemberClient) UpdateOne(_m *TeamMember) *TeamMemberUpdateOne {
	mutation := newTeamMemberMutation(c.config, OpUpdateOne, withTeamMember(_m))
	return &TeamMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamMemberClient) UpdateOneID(id int) *TeamMemberUpdateOne {
	mutation := newTeamMemberMutation(c.config, OpUpdateOne, withTeamMemberID(id))
	return &TeamMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TeamMember.
func (c *TeamMemberClient) Delete() *TeamMemberDelete {
	mutation := newTeamMemberMutation(c.config, OpDelete)
	return &TeamMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamMemberClient) DeleteOne(_m *TeamMember) *TeamMemberDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamMemberClient) DeleteOneID(id int) *TeamMemberDeleteOne {
	builder := c.Delete().Where(teammember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamMemberDeleteOne{builder}
}

// Query returns a query builder for TeamMember.
func (c *TeamMemberClient) Query() *TeamMemberQuery {
	return &TeamMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeamMember},
		inters: c.Interceptors(),
	}
}

// Get returns a TeamMember entity by its id.
func (c *TeamMemberClient) Get(ctx context.Context, id int) (*TeamMember, error) {
	return c.Query().Where(teammember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamMemberClient) GetX(ctx context.Context, id int) *TeamMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a TeamMember.
func (c *TeamMemberClient) QueryUser(_m *TeamMember) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(teammember.Table, teammember.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, teammember.UserTable, teammember.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamMemberClient) Hooks() []Hook {
	return c.hooks.TeamMember
}

// Interceptors returns the client interceptors.
func (c *TeamMemberClient) Interceptors() []Interceptor {
	return c.inters.TeamMember
}

func (c *TeamMemberClient) mutate(ctx context.Context, m *TeamMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TeamMember mutation op: %q", m.Op())
	}
}

// TeamMemberItemClient is a client for the TeamMemberItem schema.
type TeamMemberItemClient struct {
	config
}

// NewTeamMemberItemClient returns a client for the TeamMemberItem from the given config.
func NewTeamMemberItemClient(c config) *TeamMemberItemClient {
	return &TeamMemberItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `teammemberitem.Hooks(f(g(h())))`.
func (c *TeamMemberItemClient) Use(hooks ...Hook) {
	c.hooks.TeamMemberItem = append(c.hooks.TeamMemberItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `teammemberitem.Intercept(f(g(h())))`.
func (c *TeamMemberItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.TeamMemberItem = append(c.inters.TeamMemberItem, interceptors...)
}

// Create returns a builder for creating a TeamMemberItem entity.
func (c *TeamMemberItemClient) Create() *TeamMemberItemCreate {
	mutation := newTeamMemberItemMutation(c.config, OpCreate)
	return &TeamMemberItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TeamMemberItem entities.
func (c *TeamMemberItemClient) CreateBulk(builders ...*TeamMemberItemCreate) *TeamMemberItemCreateBulk {
	return &TeamMemberItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamMemberItemClient) MapCreateBulk(slice any, setFunc func(*TeamMemberItemCreate, int)) *TeamMemberItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamMemberItemCreateBulk{err: fmt.Errorf("calling to TeamMemberItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamMemberItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamMemberItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TeamMemberItem.
func (c *TeamMemberItemClient) Update() *TeamMemberItemUpdate {
	mutation := newTeamMemberItemMutation(c.config, OpUpdate)
	return &TeamMemberItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamMemberItemClient) UpdateOne(_m *TeamMemberItem) *TeamMemberItemUpdateOne {
	mutation := newTeamMemberItemMutation(c.config, OpUpdateOne, withTeamMemberItem(_m))
	return &TeamMemberItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamMemberItemClient) UpdateOneID(id int) *TeamMemberItemUpdateOne {
	mutation := newTeamMemberItemMutation(c.config, OpUpdateOne, withTeamMemberItemID(id))
	return &TeamMemberItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TeamMemberItem.
func (c *TeamMemberItemClient) Delete() *TeamMemberItemDelete {
	mutation := newTeamMemberItemMutation(c.config, OpDelete)
	return &TeamMemberItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamMemberItemClient) DeleteOne(_m *TeamMemberItem) *TeamMemberItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamMemberItemClient) DeleteOneID(id int) *TeamMemberItemDeleteOne {
	builder := c.Delete().Where(teammemberitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamMemberItemDeleteOne{builder}
}

// Query returns a query builder for TeamMemberItem.
func (c *TeamMemberItemClient) Query() *TeamMemberItemQuery {
	return &TeamMemberItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeamMemberItem},
		inters: c.Interceptors(),
	}
}

// Get returns a TeamMemberItem entity by its id.
func (c *TeamMemberItemClient) Get(ctx context.Context, id int) (*TeamMemberItem, error) {
	return c.Query().Where(teammemberitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamMemberItemClient) GetX(ctx context.Context, id int) *TeamMemberItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlock queries the block edge of a TeamMemberItem.
func (c *TeamMemberItemClient) QueryBlock(_m *TeamMemberItem) *BlockTeamGridQuery {
	query := (&BlockTeamGridClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(teammemberitem.Table, teammemberitem.FieldID, id),
			sqlgraph.To(blockteamgrid.Table, blockteamgrid.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, teammemberitem.BlockTable, teammemberitem.BlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamMemberItemClient) Hooks() []Hook {
	return c.hooks.TeamMemberItem
}

// Interceptors returns the client interceptors.
func (c *TeamMemberItemClient) Interceptors() []Interceptor {
	return c.inters.TeamMemberItem
}

func (c *TeamMemberItemClient) mutate(ctx context.Context, m *TeamMemberItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamMemberItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamMemberItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamMemberItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamMemberItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TeamMemberItem mutation op: %q", m.Op())
	}
}

// TestimonialItemClient is a client for the TestimonialItem schema.
type TestimonialItemClient struct {
	config
}

// NewTestimonialItemClient returns a client for the TestimonialItem from the given config.
func NewTestimonialItemClient(c config) *TestimonialItemClient {
	return &TestimonialItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testimonialitem.Hooks(f(g(h())))`.
func (c *TestimonialItemClient) Use(hooks ...Hook) {
	c.hooks.TestimonialItem = append(c.hooks.TestimonialItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testimonialitem.Intercept(f(g(h())))`.
func (c *TestimonialItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestimonialItem = append(c.inters.TestimonialItem, interceptors...)
}

// Create returns a builder for creating a TestimonialItem entity.
func (c *TestimonialItemClient) Create() *TestimonialItemCreate {
	mutation := newTestimonialItemMutation(c.config, OpCreate)
	return &TestimonialItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestimonialItem entities.
func (c *TestimonialItemClient) CreateBulk(builders ...*TestimonialItemCreate) *TestimonialItemCreateBulk {
	return &TestimonialItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TestimonialItemClient) MapCreateBulk(slice any, setFunc func(*TestimonialItemCreate, int)) *TestimonialItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TestimonialItemCreateBulk{err: fmt.Errorf("calling to TestimonialItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TestimonialItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TestimonialItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestimonialItem.
func (c *TestimonialItemClient) Update() *TestimonialItemUpdate {
	mutation := newTestimonialItemMutation(c.config, OpUpdate)
	return &TestimonialItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestimonialItemClient) UpdateOne(_m *TestimonialItem) *TestimonialItemUpdateOne {
	mutation := newTestimonialItemMutation(c.config, OpUpdateOne, withTestimonialItem(_m))
	return &TestimonialItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestimonialItemClient) UpdateOneID(id int) *TestimonialItemUpdateOne {
	mutation := newTestimonialItemMutation(c.config, OpUpdateOne, withTestimonialItemID(id))
	return &TestimonialItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestimonialItem.
func (c *TestimonialItemClient) Delete() *TestimonialItemDelete {
	mutation := newTestimonialItemMutation(c.config, OpDelete)
	return &TestimonialItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestimonialItemClient) DeleteOne(_m *TestimonialItem) *TestimonialItemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestimonialItemClient) DeleteOneID(id int) *TestimonialItemDeleteOne {
	builder := c.Delete().Where(testimonialitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestimonialItemDeleteOne{builder}
}

// Query returns a query builder for TestimonialItem.
func (c *TestimonialItemClient) Query() *TestimonialItemQuery {
	return &TestimonialItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestimonialItem},
		inters: c.Interceptors(),
	}
}

// Get returns a TestimonialItem entity by its id.
func (c *TestimonialItemClient) Get(ctx context.Context, id int) (*TestimonialItem, error) {
	return c.Query().Where(testimonialitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestimonialItemClient) GetX(ctx context.Context, id int) *TestimonialItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlock queries the block edge of a TestimonialItem.
func (c *TestimonialItemClient) QueryBlock(_m *TestimonialItem) *BlockTestimonialsQuery {
	query := (&BlockTestimonialsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testimonialitem.Table, testimonialitem.FieldID, id),
			sqlgraph.To(blocktestimonials.Table, blocktestimonials.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, testimonialitem.BlockTable, testimonialitem.BlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySuccessStory queries the success_story edge of a TestimonialItem.
func (c *TestimonialItemClient) QuerySuccessStory(_m *TestimonialItem) *SuccessStoryQuery {
	query := (&SuccessStoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(testimonialitem.Table, testimonialitem.FieldID, id),
			sqlgraph.To(successstory.Table, successstory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, testimonialitem.SuccessStoryTable, testimonialitem.SuccessStoryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TestimonialItemClient) Hooks() []Hook {
	return c.hooks.TestimonialItem
}

// Interceptors returns the client interceptors.
func (c *TestimonialItemClient) Interceptors() []Interceptor {
	return c.inters.TestimonialItem
}

func (c *TestimonialItemClient) mutate(ctx context.Context, m *TestimonialItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestimonialItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestimonialItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestimonialItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestimonialItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestimonialItem mutation op: %q", m.Op())
	}
}

// TimelineEventClient is a client for the TimelineEvent schema.
type TimelineEventClient struct {
	config
}

// NewTimelineEventClient returns a client for the TimelineEvent from the given config.
func NewTimelineEventClient(c config) *TimelineEventClient {
	return &TimelineEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `timelineevent.Hooks(f(g(h())))`.
func (c *TimelineEventClient) Use(hooks ...Hook) {
	c.hooks.TimelineEvent = append(c.hooks.TimelineEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `timelineevent.Intercept(f(g(h())))`.
func (c *TimelineEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.TimelineEvent = append(c.inters.TimelineEvent, interceptors...)
}

// Create returns a builder for creating a TimelineEvent entity.
func (c *TimelineEventClient) Create() *TimelineEventCreate {
	mutation := newTimelineEventMutation(c.config, OpCreate)
	return &TimelineEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TimelineEvent entities.
func (c *TimelineEventClient) CreateBulk(builders ...*TimelineEventCreate) *TimelineEventCreateBulk {
	return &TimelineEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TimelineEventClient) MapCreateBulk(slice any, setFunc func(*TimelineEventCreate, int)) *TimelineEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TimelineEventCreateBulk{err: fmt.Errorf("calling to TimelineEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TimelineEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TimelineEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TimelineEvent.
func (c *TimelineEventClient) Update() *TimelineEventUpdate {
	mutation := newTimelineEventMutation(c.config, OpUpdate)
	return &TimelineEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TimelineEventClient) UpdateOne(_m *TimelineEvent) *TimelineEventUpdateOne {
	mutation := newTimelineEventMutation(c.config, OpUpdateOne, withTimelineEvent(_m))
	return &TimelineEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TimelineEventClient) UpdateOneID(id int) *TimelineEventUpdateOne {
	mutation := newTimelineEventMutation(c.config, OpUpdateOne, withTimelineEventID(id))
	return &TimelineEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TimelineEvent.
func (c *TimelineEventClient) Delete() *TimelineEventDelete {
	mutation := newTimelineEventMutation(c.config, OpDelete)
	return &TimelineEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TimelineEventClient) DeleteOne(_m *TimelineEvent) *TimelineEventDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TimelineEventClient) DeleteOneID(id int) *TimelineEventDeleteOne {
	builder := c.Delete().Where(timelineevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TimelineEventDeleteOne{builder}
}

// Query returns a query builder for TimelineEvent.
func (c *TimelineEventClient) Query() *TimelineEventQuery {
	return &TimelineEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTimelineEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a TimelineEvent entity by its id.
func (c *TimelineEventClient) Get(ctx context.Context, id int) (*TimelineEvent, error) {
	return c.Query().Where(timelineevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TimelineEventClient) GetX(ctx context.Context, id int) *TimelineEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlock queries the block edge of a TimelineEvent.
func (c *TimelineEventClient) QueryBlock(_m *TimelineEvent) *BlockTimelineQuery {
	query := (&BlockTimelineClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timelineevent.Table, timelineevent.FieldID, id),
			sqlgraph.To(blocktimeline.Table, blocktimeline.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, timelineevent.BlockTable, timelineevent.BlockColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TimelineEventClient) Hooks() []Hook {
	return c.hooks.TimelineEvent
}

// Interceptors returns the client interceptors.
func (c *TimelineEventClient) Interceptors() []Interceptor {
	return c.inters.TimelineEvent
}

func (c *TimelineEventClient) mutate(ctx context.Context, m *TimelineEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TimelineEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TimelineEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TimelineEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TimelineEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TimelineEvent mutation op: %q", m.Op())
	}
}

// TokenClient is a client for the Token schema.
type TokenClient struct {
	config
}

// NewTokenClient returns a client for the Token from the given config.
func NewTokenClient(c config) *TokenClient {
	return &TokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `token.Hooks(f(g(h())))`.
func (c *TokenClient) Use(hooks ...Hook) {
	c.hooks.Token = append(c.hooks.Token, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `token.Intercept(f(g(h())))`.
func (c *TokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.Token = append(c.inters.Token, interceptors...)
}

// Create returns a builder for creating a Token entity.
func (c *TokenClient) Create() *TokenCreate {
	mutation := newTokenMutation(c.config, OpCreate)
	return &TokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Token entities.
func (c *TokenClient) CreateBulk(builders ...*TokenCreate) *TokenCreateBulk {
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenClient) MapCreateBulk(slice any, setFunc func(*TokenCreate, int)) *TokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenCreateBulk{err: fmt.Errorf("calling to TokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Token.
func (c *TokenClient) Update() *TokenUpdate {
	mutation := newTokenMutation(c.config, OpUpdate)
	return &TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenClient) UpdateOne(_m *Token) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withToken(_m))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenClient) UpdateOneID(id int) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withTokenID(id))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Token.
func (c *TokenClient) Delete() *TokenDelete {
	mutation := newTokenMutation(c.config, OpDelete)
	return &TokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenClient) DeleteOne(_m *Token) *TokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenClient) DeleteOneID(id int) *TokenDeleteOne {
	builder := c.Delete().Where(token.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenDeleteOne{builder}
}

// Query returns a query builder for Token.
func (c *TokenClient) Query() *TokenQuery {
	return &TokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToken},
		inters: c.Interceptors(),
	}
}

// Get returns a Token entity by its id.
func (c *TokenClient) Get(ctx context.Context, id int) (*Token, error) {
	return c.Query().Where(token.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenClient) GetX(ctx context.Context, id int) *Token {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Token.
func (c *TokenClient) QueryUser(_m *Token) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(token.Table, token.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, token.UserTable, token.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TokenClient) Hooks() []Hook {
	return c.hooks.Token
}

// Interceptors returns the client interceptors.
func (c *TokenClient) Interceptors() []Interceptor {
	return c.inters.Token
}

func (c *TokenClient) mutate(ctx context.Context, m *TokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Token mutation op: %q", m.Op())
	}
}

// TrustedDeviceClient is a client for the TrustedDevice schema.
type TrustedDeviceClient struct {
	config
}

// NewTrustedDeviceClient returns a client for the TrustedDevice from the given config.
func NewTrustedDeviceClient(c config) *TrustedDeviceClient {
	return &TrustedDeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `trusteddevice.Hooks(f(g(h())))`.
func (c *TrustedDeviceClient) Use(hooks ...Hook) {
	c.hooks.TrustedDevice = append(c.hooks.TrustedDevice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `trusteddevice.Intercept(f(g(h())))`.
func (c *TrustedDeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.TrustedDevice = append(c.inters.TrustedDevice, interceptors...)
}

// Create returns a builder for creating a TrustedDevice entity.
func (c *TrustedDeviceClient) Create() *TrustedDeviceCreate {
	mutation := newTrustedDeviceMutation(c.config, OpCreate)
	return &TrustedDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TrustedDevice entities.
func (c *TrustedDeviceClient) CreateBulk(builders ...*TrustedDeviceCreate) *TrustedDeviceCreateBulk {
	return &TrustedDeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TrustedDeviceClient) MapCreateBulk(slice any, setFunc func(*TrustedDeviceCreate, int)) *TrustedDeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TrustedDeviceCreateBulk{err: fmt.Errorf("calling to TrustedDeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TrustedDeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TrustedDeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TrustedDevice.
func (c *TrustedDeviceClient) Update() *TrustedDeviceUpdate {
	mutation := newTrustedDeviceMutation(c.config, OpUpdate)
	return &TrustedDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TrustedDeviceClient) UpdateOne(_m *TrustedDevice) *TrustedDeviceUpdateOne {
	mutation := newTrustedDeviceMutation(c.config, OpUpdateOne, withTrustedDevice(_m))
	return &TrustedDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TrustedDeviceClient) UpdateOneID(id int) *TrustedDeviceUpdateOne {
	mutation := newTrustedDeviceMutation(c.config, OpUpdateOne, withTrustedDeviceID(id))
	return &TrustedDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TrustedDevice.
func (c *TrustedDeviceClient) Delete() *TrustedDeviceDelete {
	mutation := newTrustedDeviceMutation(c.config, OpDelete)
	return &TrustedDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TrustedDeviceClient) DeleteOne(_m *TrustedDevice) *TrustedDeviceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TrustedDeviceClient) DeleteOneID(id int) *TrustedDeviceDeleteOne {
	builder := c.Delete().Where(trusteddevice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TrustedDeviceDeleteOne{builder}
}

// Query returns a query builder for TrustedDevice.
func (c *TrustedDeviceClient) Query() *TrustedDeviceQuery {
	return &TrustedDeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTrustedDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a TrustedDevice entity by its id.
func (c *TrustedDeviceClient) Get(ctx context.Context, id int) (*TrustedDevice, error) {
	return c.Query().Where(trusteddevice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TrustedDeviceClient) GetX(ctx context.Context, id int) *TrustedDevice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a TrustedDevice.
func (c *TrustedDeviceClient) QueryUser(_m *TrustedDevice) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(trusteddevice.Table, trusteddevice.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, trusteddevice.UserTable, trusteddevice.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TrustedDeviceClient) Hooks() []Hook {
	return c.hooks.TrustedDevice
}

// Interceptors returns the client interceptors.
func (c *TrustedDeviceClient) Interceptors() []Interceptor {
	return c.inters.TrustedDevice
}

func (c *TrustedDeviceClient) mutate(ctx context.Context, m *TrustedDeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TrustedDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TrustedDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TrustedDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TrustedDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TrustedDevice mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a User.
func (c *UserClient) QueryProfile(_m *User) *UserProfileQuery {
	query := (&UserProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userprofile.Table, userprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.ProfileTable, user.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(_m *User) *UserSessionQuery {
	query := (&UserSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usersession.Table, usersession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTokens queries the tokens edge of a User.
func (c *UserClient) QueryTokens(_m *User) *TokenQuery {
	query := (&TokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(token.Table, token.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TokensTable, user.TokensColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrustedDevices queries the trusted_devices edge of a User.
func (c *UserClient) QueryTrustedDevices(_m *User) *TrustedDeviceQuery {
	query := (&TrustedDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(trusteddevice.Table, trusteddevice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TrustedDevicesTable, user.TrustedDevicesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPasswordHistory queries the password_history edge of a User.
func (c *UserClient) QueryPasswordHistory(_m *User) *PasswordHistoryQuery {
	query := (&PasswordHistoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(passwordhistory.Table, passwordhistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PasswordHistoryTable, user.PasswordHistoryColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeamMember queries the team_member edge of a User.
func (c *UserClient) QueryTeamMember(_m *User) *TeamMemberQuery {
	query := (&TeamMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(teammember.Table, teammember.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, user.TeamMemberTable, user.TeamMemberColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuditLogs queries the audit_logs edge of a User.
func (c *UserClient) QueryAuditLogs(_m *User) *AuditLogQuery {
	query := (&AuditLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(auditlog.Table, auditlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AuditLogsTable, user.AuditLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJobs queries the jobs edge of a User.
func (c *UserClient) QueryJobs(_m *User) *JobQuery {
	query := (&JobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(job.Table, job.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.JobsTable, user.JobsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDashboards queries the dashboards edge of a User.
func (c *UserClient) QueryDashboards(_m *User) *AnalyticsDashboardQuery {
	query := (&AnalyticsDashboardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(analyticsdashboard.Table, analyticsdashboard.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DashboardsTable, user.DashboardsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnalyticsEvents queries the analytics_events edge of a User.
func (c *UserClient) QueryAnalyticsEvents(_m *User) *AnalyticsEventQuery {
	query := (&AnalyticsEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(analyticsevent.Table, analyticsevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AnalyticsEventsTable, user.AnalyticsEventsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedReports queries the created_reports edge of a User.
func (c *UserClient) QueryCreatedReports(_m *User) *ReportDefinitionQuery {
	query := (&ReportDefinitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(reportdefinition.Table, reportdefinition.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedReportsTable, user.CreatedReportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGeneratedReports queries the generated_reports edge of a User.
func (c *UserClient) QueryGeneratedReports(_m *User) *GeneratedReportQuery {
	query := (&GeneratedReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(generatedreport.Table, generatedreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.GeneratedReportsTable, user.GeneratedReportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReportPermissions queries the report_permissions edge of a User.
func (c *UserClient) QueryReportPermissions(_m *User) *ReportPermissionQuery {
	query := (&ReportPermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(reportpermission.Table, reportpermission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReportPermissionsTable, user.ReportPermissionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledReports queries the scheduled_reports edge of a User.
func (c *UserClient) QueryScheduledReports(_m *User) *ScheduledReportQuery {
	query := (&ScheduledReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(scheduledreport.Table, scheduledreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ScheduledReportsTable, user.ScheduledReportsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedPrograms queries the created_programs edge of a User.
func (c *UserClient) QueryCreatedPrograms(_m *User) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedProgramsTable, user.CreatedProgramsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUpdatedPrograms queries the updated_programs edge of a User.
func (c *UserClient) QueryUpdatedPrograms(_m *User) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UpdatedProgramsTable, user.UpdatedProgramsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProgramEnrolments queries the program_enrolments edge of a User.
func (c *UserClient) QueryProgramEnrolments(_m *User) *ProgramEnrolmentQuery {
	query := (&ProgramEnrolmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(programenrolment.Table, programenrolment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ProgramEnrolmentsTable, user.ProgramEnrolmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParticipantIn queries the participant_in edge of a User.
func (c *UserClient) QueryParticipantIn(_m *User) *ProgramParticipantQuery {
	query := (&ProgramParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(programparticipant.Table, programparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ParticipantInTable, user.ParticipantInColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySuccessStories queries the success_stories edge of a User.
func (c *UserClient) QuerySuccessStories(_m *User) *SuccessStoryQuery {
	query := (&SuccessStoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(successstory.Table, successstory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SuccessStoriesTable, user.SuccessStoriesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNewsArticles queries the news_articles edge of a User.
func (c *UserClient) QueryNewsArticles(_m *User) *NewsArticleQuery {
	query := (&NewsArticleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(newsarticle.Table, newsarticle.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.NewsArticlesTable, user.NewsArticlesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedEvents queries the created_events edge of a User.
func (c *UserClient) QueryCreatedEvents(_m *User) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedEventsTable, user.CreatedEventsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventRegistrations queries the event_registrations edge of a User.
func (c *UserClient) QueryEventRegistrations(_m *User) *EventRegistrationQuery {
	query := (&EventRegistrationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(eventregistration.Table, eventregistration.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.EventRegistrationsTable, user.EventRegistrationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessagesSent queries the messages_sent edge of a User.
func (c *UserClient) QueryMessagesSent(_m *User) *MessageQuery {
	query := (&MessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MessagesSentTable, user.MessagesSentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConversationLinks queries the conversation_links edge of a User.
func (c *UserClient) QueryConversationLinks(_m *User) *ConversationParticipantQuery {
	query := (&ConversationParticipantClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(conversationparticipant.Table, conversationparticipant.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ConversationLinksTable, user.ConversationLinksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVolunteerApplications queries the volunteer_applications edge of a User.
func (c *UserClient) QueryVolunteerApplications(_m *User) *VolunteerApplicationQuery {
	query := (&VolunteerApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(volunteerapplication.Table, volunteerapplication.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.VolunteerApplicationsTable, user.VolunteerApplicationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMentorshipRequests queries the mentorship_requests edge of a User.
func (c *UserClient) QueryMentorshipRequests(_m *User) *MentorshipRequestQuery {
	query := (&MentorshipRequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(mentorshiprequest.Table, mentorshiprequest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MentorshipRequestsTable, user.MentorshipRequestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMentorshipsMentoring queries the mentorships_mentoring edge of a User.
func (c *UserClient) QueryMentorshipsMentoring(_m *User) *MentorshipRequestQuery {
	query := (&MentorshipRequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(mentorshiprequest.Table, mentorshiprequest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MentorshipsMentoringTable, user.MentorshipsMentoringColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAchievements queries the achievements edge of a User.
func (c *UserClient) QueryAchievements(_m *User) *UserAchievementQuery {
	query := (&UserAchievementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userachievement.Table, userachievement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AchievementsTable, user.AchievementsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDonations queries the donations edge of a User.
func (c *UserClient) QueryDonations(_m *User) *DonationQuery {
	query := (&DonationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(donation.Table, donation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DonationsTable, user.DonationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganization queries the organization edge of a User.
func (c *UserClient) QueryOrganization(_m *User) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.OrganizationTable, user.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryManagedPartnerships queries the managed_partnerships edge of a User.
func (c *UserClient) QueryManagedPartnerships(_m *User) *PartnershipQuery {
	query := (&PartnershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(partnership.Table, partnership.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ManagedPartnershipsTable, user.ManagedPartnershipsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPartnershipContacts queries the partnership_contacts edge of a User.
func (c *UserClient) QueryPartnershipContacts(_m *User) *PartnershipQuery {
	query := (&PartnershipClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(partnership.Table, partnership.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.PartnershipContactsTable, user.PartnershipContactsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySiteVisits queries the site_visits edge of a User.
func (c *UserClient) QuerySiteVisits(_m *User) *SiteVisitQuery {
	query := (&SiteVisitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(sitevisit.Table, sitevisit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SiteVisitsTable, user.SiteVisitsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocumentUploads queries the document_uploads edge of a User.
func (c *UserClient) QueryDocumentUploads(_m *User) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DocumentUploadsTable, user.DocumentUploadsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActivityLogs queries the activity_logs edge of a User.
func (c *UserClient) QueryActivityLogs(_m *User) *ActivityLogQuery {
	query := (&ActivityLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(activitylog.Table, activitylog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ActivityLogsTable, user.ActivityLogsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConsents queries the consents edge of a User.
func (c *UserClient) QueryConsents(_m *User) *UserConsentQuery {
	query := (&UserConsentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userconsent.Table, userconsent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.ConsentsTable, user.ConsentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOnboarding queries the onboarding edge of a User.
func (c *UserClient) QueryOnboarding(_m *User) *UserOnboardingQuery {
	query := (&UserOnboardingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(useronboarding.Table, useronboarding.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.OnboardingTable, user.OnboardingColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserAchievementClient is a client for the UserAchievement schema.
type UserAchievementClient struct {
	config
}

// NewUserAchievementClient returns a client for the UserAchievement from the given config.
func NewUserAchievementClient(c config) *UserAchievementClient {
	return &UserAchievementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userachievement.Hooks(f(g(h())))`.
func (c *UserAchievementClient) Use(hooks ...Hook) {
	c.hooks.UserAchievement = append(c.hooks.UserAchievement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userachievement.Intercept(f(g(h())))`.
func (c *UserAchievementClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserAchievement = append(c.inters.UserAchievement, interceptors...)
}

// Create returns a builder for creating a UserAchievement entity.
func (c *UserAchievementClient) Create() *UserAchievementCreate {
	mutation := newUserAchievementMutation(c.config, OpCreate)
	return &UserAchievementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserAchievement entities.
func (c *UserAchievementClient) CreateBulk(builders ...*UserAchievementCreate) *UserAchievementCreateBulk {
	return &UserAchievementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserAchievementClient) MapCreateBulk(slice any, setFunc func(*UserAchievementCreate, int)) *UserAchievementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserAchievementCreateBulk{err: fmt.Errorf("calling to UserAchievementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserAchievementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserAchievementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserAchievement.
func (c *UserAchievementClient) Update() *UserAchievementUpdate {
	mutation := newUserAchievementMutation(c.config, OpUpdate)
	return &UserAchievementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserAchievementClient) UpdateOne(_m *UserAchievement) *UserAchievementUpdateOne {
	mutation := newUserAchievementMutation(c.config, OpUpdateOne, withUserAchievement(_m))
	return &UserAchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserAchievementClient) UpdateOneID(id int) *UserAchievementUpdateOne {
	mutation := newUserAchievementMutation(c.config, OpUpdateOne, withUserAchievementID(id))
	return &UserAchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserAchievement.
func (c *UserAchievementClient) Delete() *UserAchievementDelete {
	mutation := newUserAchievementMutation(c.config, OpDelete)
	return &UserAchievementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserAchievementClient) DeleteOne(_m *UserAchievement) *UserAchievementDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserAchievementClient) DeleteOneID(id int) *UserAchievementDeleteOne {
	builder := c.Delete().Where(userachievement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserAchievementDeleteOne{builder}
}

// Query returns a query builder for UserAchievement.
func (c *UserAchievementClient) Query() *UserAchievementQuery {
	return &UserAchievementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserAchievement},
		inters: c.Interceptors(),
	}
}

// Get returns a UserAchievement entity by its id.
func (c *UserAchievementClient) Get(ctx context.Context, id int) (*UserAchievement, error) {
	return c.Query().Where(userachievement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserAchievementClient) GetX(ctx context.Context, id int) *UserAchievement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserAchievement.
func (c *UserAchievementClient) QueryUser(_m *UserAchievement) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userachievement.Table, userachievement.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userachievement.UserTable, userachievement.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBadge queries the badge edge of a UserAchievement.
func (c *UserAchievementClient) QueryBadge(_m *UserAchievement) *BadgeQuery {
	query := (&BadgeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userachievement.Table, userachievement.FieldID, id),
			sqlgraph.To(badge.Table, badge.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userachievement.BadgeTable, userachievement.BadgeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserAchievementClient) Hooks() []Hook {
	return c.hooks.UserAchievement
}

// Interceptors returns the client interceptors.
func (c *UserAchievementClient) Interceptors() []Interceptor {
	return c.inters.UserAchievement
}

func (c *UserAchievementClient) mutate(ctx context.Context, m *UserAchievementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserAchievementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserAchievementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserAchievementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserAchievementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserAchievement mutation op: %q", m.Op())
	}
}

// UserConsentClient is a client for the UserConsent schema.
type UserConsentClient struct {
	config
}

// NewUserConsentClient returns a client for the UserConsent from the given config.
func NewUserConsentClient(c config) *UserConsentClient {
	return &UserConsentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userconsent.Hooks(f(g(h())))`.
func (c *UserConsentClient) Use(hooks ...Hook) {
	c.hooks.UserConsent = append(c.hooks.UserConsent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userconsent.Intercept(f(g(h())))`.
func (c *UserConsentClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserConsent = append(c.inters.UserConsent, interceptors...)
}

// Create returns a builder for creating a UserConsent entity.
func (c *UserConsentClient) Create() *UserConsentCreate {
	mutation := newUserConsentMutation(c.config, OpCreate)
	return &UserConsentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserConsent entities.
func (c *UserConsentClient) CreateBulk(builders ...*UserConsentCreate) *UserConsentCreateBulk {
	return &UserConsentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserConsentClient) MapCreateBulk(slice any, setFunc func(*UserConsentCreate, int)) *UserConsentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserConsentCreateBulk{err: fmt.Errorf("calling to UserConsentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserConsentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserConsentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserConsent.
func (c *UserConsentClient) Update() *UserConsentUpdate {
	mutation := newUserConsentMutation(c.config, OpUpdate)
	return &UserConsentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserConsentClient) UpdateOne(_m *UserConsent) *UserConsentUpdateOne {
	mutation := newUserConsentMutation(c.config, OpUpdateOne, withUserConsent(_m))
	return &UserConsentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserConsentClient) UpdateOneID(id int) *UserConsentUpdateOne {
	mutation := newUserConsentMutation(c.config, OpUpdateOne, withUserConsentID(id))
	return &UserConsentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserConsent.
func (c *UserConsentClient) Delete() *UserConsentDelete {
	mutation := newUserConsentMutation(c.config, OpDelete)
	return &UserConsentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserConsentClient) DeleteOne(_m *UserConsent) *UserConsentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserConsentClient) DeleteOneID(id int) *UserConsentDeleteOne {
	builder := c.Delete().Where(userconsent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserConsentDeleteOne{builder}
}

// Query returns a query builder for UserConsent.
func (c *UserConsentClient) Query() *UserConsentQuery {
	return &UserConsentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserConsent},
		inters: c.Interceptors(),
	}
}

// Get returns a UserConsent entity by its id.
func (c *UserConsentClient) Get(ctx context.Context, id int) (*UserConsent, error) {
	return c.Query().Where(userconsent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserConsentClient) GetX(ctx context.Context, id int) *UserConsent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserConsent.
func (c *UserConsentClient) QueryUser(_m *UserConsent) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userconsent.Table, userconsent.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, userconsent.UserTable, userconsent.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserConsentClient) Hooks() []Hook {
	return c.hooks.UserConsent
}

// Interceptors returns the client interceptors.
func (c *UserConsentClient) Interceptors() []Interceptor {
	return c.inters.UserConsent
}

func (c *UserConsentClient) mutate(ctx context.Context, m *UserConsentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserConsentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserConsentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserConsentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserConsentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserConsent mutation op: %q", m.Op())
	}
}

// UserOnboardingClient is a client for the UserOnboarding schema.
type UserOnboardingClient struct {
	config
}

// NewUserOnboardingClient returns a client for the UserOnboarding from the given config.
func NewUserOnboardingClient(c config) *UserOnboardingClient {
	return &UserOnboardingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `useronboarding.Hooks(f(g(h())))`.
func (c *UserOnboardingClient) Use(hooks ...Hook) {
	c.hooks.UserOnboarding = append(c.hooks.UserOnboarding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `useronboarding.Intercept(f(g(h())))`.
func (c *UserOnboardingClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserOnboarding = append(c.inters.UserOnboarding, interceptors...)
}

// Create returns a builder for creating a UserOnboarding entity.
func (c *UserOnboardingClient) Create() *UserOnboardingCreate {
	mutation := newUserOnboardingMutation(c.config, OpCreate)
	return &UserOnboardingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserOnboarding entities.
func (c *UserOnboardingClient) CreateBulk(builders ...*UserOnboardingCreate) *UserOnboardingCreateBulk {
	return &UserOnboardingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserOnboardingClient) MapCreateBulk(slice any, setFunc func(*UserOnboardingCreate, int)) *UserOnboardingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserOnboardingCreateBulk{err: fmt.Errorf("calling to UserOnboardingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserOnboardingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserOnboardingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserOnboarding.
func (c *UserOnboardingClient) Update() *UserOnboardingUpdate {
	mutation := newUserOnboardingMutation(c.config, OpUpdate)
	return &UserOnboardingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserOnboardingClient) UpdateOne(_m *UserOnboarding) *UserOnboardingUpdateOne {
	mutation := newUserOnboardingMutation(c.config, OpUpdateOne, withUserOnboarding(_m))
	return &UserOnboardingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserOnboardingClient) UpdateOneID(id int) *UserOnboardingUpdateOne {
	mutation := newUserOnboardingMutation(c.config, OpUpdateOne, withUserOnboardingID(id))
	return &UserOnboardingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserOnboarding.
func (c *UserOnboardingClient) Delete() *UserOnboardingDelete {
	mutation := newUserOnboardingMutation(c.config, OpDelete)
	return &UserOnboardingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserOnboardingClient) DeleteOne(_m *UserOnboarding) *UserOnboardingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserOnboardingClient) DeleteOneID(id int) *UserOnboardingDeleteOne {
	builder := c.Delete().Where(useronboarding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserOnboardingDeleteOne{builder}
}

// Query returns a query builder for UserOnboarding.
func (c *UserOnboardingClient) Query() *UserOnboardingQuery {
	return &UserOnboardingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserOnboarding},
		inters: c.Interceptors(),
	}
}

// Get returns a UserOnboarding entity by its id.
func (c *UserOnboardingClient) Get(ctx context.Context, id int) (*UserOnboarding, error) {
	return c.Query().Where(useronboarding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserOnboardingClient) GetX(ctx context.Context, id int) *UserOnboarding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserOnboarding.
func (c *UserOnboardingClient) QueryUser(_m *UserOnboarding) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(useronboarding.Table, useronboarding.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, useronboarding.UserTable, useronboarding.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserOnboardingClient) Hooks() []Hook {
	return c.hooks.UserOnboarding
}

// Interceptors returns the client interceptors.
func (c *UserOnboardingClient) Interceptors() []Interceptor {
	return c.inters.UserOnboarding
}

func (c *UserOnboardingClient) mutate(ctx context.Context, m *UserOnboardingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserOnboardingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserOnboardingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserOnboardingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserOnboardingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserOnboarding mutation op: %q", m.Op())
	}
}

// UserProfileClient is a client for the UserProfile schema.
type UserProfileClient struct {
	config
}

// NewUserProfileClient returns a client for the UserProfile from the given config.
func NewUserProfileClient(c config) *UserProfileClient {
	return &UserProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userprofile.Hooks(f(g(h())))`.
func (c *UserProfileClient) Use(hooks ...Hook) {
	c.hooks.UserProfile = append(c.hooks.UserProfile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userprofile.Intercept(f(g(h())))`.
func (c *UserProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserProfile = append(c.inters.UserProfile, interceptors...)
}

// Create returns a builder for creating a UserProfile entity.
func (c *UserProfileClient) Create() *UserProfileCreate {
	mutation := newUserProfileMutation(c.config, OpCreate)
	return &UserProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserProfile entities.
func (c *UserProfileClient) CreateBulk(builders ...*UserProfileCreate) *UserProfileCreateBulk {
	return &UserProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserProfileClient) MapCreateBulk(slice any, setFunc func(*UserProfileCreate, int)) *UserProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserProfileCreateBulk{err: fmt.Errorf("calling to UserProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserProfile.
func (c *UserProfileClient) Update() *UserProfileUpdate {
	mutation := newUserProfileMutation(c.config, OpUpdate)
	return &UserProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserProfileClient) UpdateOne(_m *UserProfile) *UserProfileUpdateOne {
	mutation := newUserProfileMutation(c.config, OpUpdateOne, withUserProfile(_m))
	return &UserProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserProfileClient) UpdateOneID(id int) *UserProfileUpdateOne {
	mutation := newUserProfileMutation(c.config, OpUpdateOne, withUserProfileID(id))
	return &UserProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserProfile.
func (c *UserProfileClient) Delete() *UserProfileDelete {
	mutation := newUserProfileMutation(c.config, OpDelete)
	return &UserProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserProfileClient) DeleteOne(_m *UserProfile) *UserProfileDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserProfileClient) DeleteOneID(id int) *UserProfileDeleteOne {
	builder := c.Delete().Where(userprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserProfileDeleteOne{builder}
}

// Query returns a query builder for UserProfile.
func (c *UserProfileClient) Query() *UserProfileQuery {
	return &UserProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a UserProfile entity by its id.
func (c *UserProfileClient) Get(ctx context.Context, id int) (*UserProfile, error) {
	return c.Query().Where(userprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserProfileClient) GetX(ctx context.Context, id int) *UserProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserProfile.
func (c *UserProfileClient) QueryUser(_m *UserProfile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userprofile.Table, userprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, userprofile.UserTable, userprofile.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignments queries the assignments edge of a UserProfile.
func (c *UserProfileClient) QueryAssignments(_m *UserProfile) *VolunteerAssignmentQuery {
	query := (&VolunteerAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userprofile.Table, userprofile.FieldID, id),
			sqlgraph.To(volunteerassignment.Table, volunteerassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, userprofile.AssignmentsTable, userprofile.AssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySkills queries the skills edge of a UserProfile.
func (c *UserProfileClient) QuerySkills(_m *UserProfile) *UserSkillQuery {
	query := (&UserSkillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userprofile.Table, userprofile.FieldID, id),
			sqlgraph.To(userskill.Table, userskill.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, userprofile.SkillsTable, userprofile.SkillsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAddress queries the address edge of a UserProfile.
func (c *UserProfileClient) QueryAddress(_m *UserProfile) *AddressQuery {
	query := (&AddressClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userprofile.Table, userprofile.FieldID, id),
			sqlgraph.To(address.Table, address.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userprofile.AddressTable, userprofile.AddressColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserProfileClient) Hooks() []Hook {
	return c.hooks.UserProfile
}

// Interceptors returns the client interceptors.
func (c *UserProfileClient) Interceptors() []Interceptor {
	return c.inters.UserProfile
}

func (c *UserProfileClient) mutate(ctx context.Context, m *UserProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserProfile mutation op: %q", m.Op())
	}
}

// UserSessionClient is a client for the UserSession schema.
type UserSessionClient struct {
	config
}

// NewUserSessionClient returns a client for the UserSession from the given config.
func NewUserSessionClient(c config) *UserSessionClient {
	return &UserSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersession.Hooks(f(g(h())))`.
func (c *UserSessionClient) Use(hooks ...Hook) {
	c.hooks.UserSession = append(c.hooks.UserSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usersession.Intercept(f(g(h())))`.
func (c *UserSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserSession = append(c.inters.UserSession, interceptors...)
}

// Create returns a builder for creating a UserSession entity.
func (c *UserSessionClient) Create() *UserSessionCreate {
	mutation := newUserSessionMutation(c.config, OpCreate)
	return &UserSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSession entities.
func (c *UserSessionClient) CreateBulk(builders ...*UserSessionCreate) *UserSessionCreateBulk {
	return &UserSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSessionClient) MapCreateBulk(slice any, setFunc func(*UserSessionCreate, int)) *UserSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSessionCreateBulk{err: fmt.Errorf("calling to UserSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSession.
func (c *UserSessionClient) Update() *UserSessionUpdate {
	mutation := newUserSessionMutation(c.config, OpUpdate)
	return &UserSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSessionClient) UpdateOne(_m *UserSession) *UserSessionUpdateOne {
	mutation := newUserSessionMutation(c.config, OpUpdateOne, withUserSession(_m))
	return &UserSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSessionClient) UpdateOneID(id int) *UserSessionUpdateOne {
	mutation := newUserSessionMutation(c.config, OpUpdateOne, withUserSessionID(id))
	return &UserSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSession.
func (c *UserSessionClient) Delete() *UserSessionDelete {
	mutation := newUserSessionMutation(c.config, OpDelete)
	return &UserSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSessionClient) DeleteOne(_m *UserSession) *UserSessionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSessionClient) DeleteOneID(id int) *UserSessionDeleteOne {
	builder := c.Delete().Where(usersession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSessionDeleteOne{builder}
}

// Query returns a query builder for UserSession.
func (c *UserSessionClient) Query() *UserSessionQuery {
	return &UserSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserSession},
		inters: c.Interceptors(),
	}
}

// Get returns a UserSession entity by its id.
func (c *UserSessionClient) Get(ctx context.Context, id int) (*UserSession, error) {
	return c.Query().Where(usersession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSessionClient) GetX(ctx context.Context, id int) *UserSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserSession.
func (c *UserSessionClient) QueryUser(_m *UserSession) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersession.Table, usersession.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usersession.UserTable, usersession.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserSessionClient) Hooks() []Hook {
	return c.hooks.UserSession
}

// Interceptors returns the client interceptors.
func (c *UserSessionClient) Interceptors() []Interceptor {
	return c.inters.UserSession
}

func (c *UserSessionClient) mutate(ctx context.Context, m *UserSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserSession mutation op: %q", m.Op())
	}
}

// UserSkillClient is a client for the UserSkill schema.
type UserSkillClient struct {
	config
}

// NewUserSkillClient returns a client for the UserSkill from the given config.
func NewUserSkillClient(c config) *UserSkillClient {
	return &UserSkillClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userskill.Hooks(f(g(h())))`.
func (c *UserSkillClient) Use(hooks ...Hook) {
	c.hooks.UserSkill = append(c.hooks.UserSkill, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userskill.Intercept(f(g(h())))`.
func (c *UserSkillClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserSkill = append(c.inters.UserSkill, interceptors...)
}

// Create returns a builder for creating a UserSkill entity.
func (c *UserSkillClient) Create() *UserSkillCreate {
	mutation := newUserSkillMutation(c.config, OpCreate)
	return &UserSkillCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSkill entities.
func (c *UserSkillClient) CreateBulk(builders ...*UserSkillCreate) *UserSkillCreateBulk {
	return &UserSkillCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSkillClient) MapCreateBulk(slice any, setFunc func(*UserSkillCreate, int)) *UserSkillCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSkillCreateBulk{err: fmt.Errorf("calling to UserSkillClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSkillCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSkillCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSkill.
func (c *UserSkillClient) Update() *UserSkillUpdate {
	mutation := newUserSkillMutation(c.config, OpUpdate)
	return &UserSkillUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSkillClient) UpdateOne(_m *UserSkill) *UserSkillUpdateOne {
	mutation := newUserSkillMutation(c.config, OpUpdateOne, withUserSkill(_m))
	return &UserSkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSkillClient) UpdateOneID(id int) *UserSkillUpdateOne {
	mutation := newUserSkillMutation(c.config, OpUpdateOne, withUserSkillID(id))
	return &UserSkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSkill.
func (c *UserSkillClient) Delete() *UserSkillDelete {
	mutation := newUserSkillMutation(c.config, OpDelete)
	return &UserSkillDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSkillClient) DeleteOne(_m *UserSkill) *UserSkillDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSkillClient) DeleteOneID(id int) *UserSkillDeleteOne {
	builder := c.Delete().Where(userskill.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSkillDeleteOne{builder}
}

// Query returns a query builder for UserSkill.
func (c *UserSkillClient) Query() *UserSkillQuery {
	return &UserSkillQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserSkill},
		inters: c.Interceptors(),
	}
}

// Get returns a UserSkill entity by its id.
func (c *UserSkillClient) Get(ctx context.Context, id int) (*UserSkill, error) {
	return c.Query().Where(userskill.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSkillClient) GetX(ctx context.Context, id int) *UserSkill {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a UserSkill.
func (c *UserSkillClient) QueryProfile(_m *UserSkill) *UserProfileQuery {
	query := (&UserProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userskill.Table, userskill.FieldID, id),
			sqlgraph.To(userprofile.Table, userprofile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userskill.ProfileTable, userskill.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySkill queries the skill edge of a UserSkill.
func (c *UserSkillClient) QuerySkill(_m *UserSkill) *SkillQuery {
	query := (&SkillClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userskill.Table, userskill.FieldID, id),
			sqlgraph.To(skill.Table, skill.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userskill.SkillTable, userskill.SkillColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserSkillClient) Hooks() []Hook {
	return c.hooks.UserSkill
}

// Interceptors returns the client interceptors.
func (c *UserSkillClient) Interceptors() []Interceptor {
	return c.inters.UserSkill
}

func (c *UserSkillClient) mutate(ctx context.Context, m *UserSkillMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSkillCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSkillUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSkillUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSkillDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserSkill mutation op: %q", m.Op())
	}
}

// VolunteerApplicationClient is a client for the VolunteerApplication schema.
type VolunteerApplicationClient struct {
	config
}

// NewVolunteerApplicationClient returns a client for the VolunteerApplication from the given config.
func NewVolunteerApplicationClient(c config) *VolunteerApplicationClient {
	return &VolunteerApplicationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `volunteerapplication.Hooks(f(g(h())))`.
func (c *VolunteerApplicationClient) Use(hooks ...Hook) {
	c.hooks.VolunteerApplication = append(c.hooks.VolunteerApplication, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `volunteerapplication.Intercept(f(g(h())))`.
func (c *VolunteerApplicationClient) Intercept(interceptors ...Interceptor) {
	c.inters.VolunteerApplication = append(c.inters.VolunteerApplication, interceptors...)
}

// Create returns a builder for creating a VolunteerApplication entity.
func (c *VolunteerApplicationClient) Create() *VolunteerApplicationCreate {
	mutation := newVolunteerApplicationMutation(c.config, OpCreate)
	return &VolunteerApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VolunteerApplication entities.
func (c *VolunteerApplicationClient) CreateBulk(builders ...*VolunteerApplicationCreate) *VolunteerApplicationCreateBulk {
	return &VolunteerApplicationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VolunteerApplicationClient) MapCreateBulk(slice any, setFunc func(*VolunteerApplicationCreate, int)) *VolunteerApplicationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VolunteerApplicationCreateBulk{err: fmt.Errorf("calling to VolunteerApplicationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VolunteerApplicationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VolunteerApplicationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VolunteerApplication.
func (c *VolunteerApplicationClient) Update() *VolunteerApplicationUpdate {
	mutation := newVolunteerApplicationMutation(c.config, OpUpdate)
	return &VolunteerApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VolunteerApplicationClient) UpdateOne(_m *VolunteerApplication) *VolunteerApplicationUpdateOne {
	mutation := newVolunteerApplicationMutation(c.config, OpUpdateOne, withVolunteerApplication(_m))
	return &VolunteerApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VolunteerApplicationClient) UpdateOneID(id int) *VolunteerApplicationUpdateOne {
	mutation := newVolunteerApplicationMutation(c.config, OpUpdateOne, withVolunteerApplicationID(id))
	return &VolunteerApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VolunteerApplication.
func (c *VolunteerApplicationClient) Delete() *VolunteerApplicationDelete {
	mutation := newVolunteerApplicationMutation(c.config, OpDelete)
	return &VolunteerApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VolunteerApplicationClient) DeleteOne(_m *VolunteerApplication) *VolunteerApplicationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VolunteerApplicationClient) DeleteOneID(id int) *VolunteerApplicationDeleteOne {
	builder := c.Delete().Where(volunteerapplication.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VolunteerApplicationDeleteOne{builder}
}

// Query returns a query builder for VolunteerApplication.
func (c *VolunteerApplicationClient) Query() *VolunteerApplicationQuery {
	return &VolunteerApplicationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVolunteerApplication},
		inters: c.Interceptors(),
	}
}

// Get returns a VolunteerApplication entity by its id.
func (c *VolunteerApplicationClient) Get(ctx context.Context, id int) (*VolunteerApplication, error) {
	return c.Query().Where(volunteerapplication.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VolunteerApplicationClient) GetX(ctx context.Context, id int) *VolunteerApplication {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a VolunteerApplication.
func (c *VolunteerApplicationClient) QueryUser(_m *VolunteerApplication) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(volunteerapplication.Table, volunteerapplication.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, volunteerapplication.UserTable, volunteerapplication.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInterestedOpportunities queries the interested_opportunities edge of a VolunteerApplication.
func (c *VolunteerApplicationClient) QueryInterestedOpportunities(_m *VolunteerApplication) *VolunteerOpportunityQuery {
	query := (&VolunteerOpportunityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(volunteerapplication.Table, volunteerapplication.FieldID, id),
			sqlgraph.To(volunteeropportunity.Table, volunteeropportunity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, volunteerapplication.InterestedOpportunitiesTable, volunteerapplication.InterestedOpportunitiesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VolunteerApplicationClient) Hooks() []Hook {
	return c.hooks.VolunteerApplication
}

// Interceptors returns the client interceptors.
func (c *VolunteerApplicationClient) Interceptors() []Interceptor {
	return c.inters.VolunteerApplication
}

func (c *VolunteerApplicationClient) mutate(ctx context.Context, m *VolunteerApplicationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VolunteerApplicationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VolunteerApplicationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VolunteerApplicationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VolunteerApplicationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VolunteerApplication mutation op: %q", m.Op())
	}
}

// VolunteerAssignmentClient is a client for the VolunteerAssignment schema.
type VolunteerAssignmentClient struct {
	config
}

// NewVolunteerAssignmentClient returns a client for the VolunteerAssignment from the given config.
func NewVolunteerAssignmentClient(c config) *VolunteerAssignmentClient {
	return &VolunteerAssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `volunteerassignment.Hooks(f(g(h())))`.
func (c *VolunteerAssignmentClient) Use(hooks ...Hook) {
	c.hooks.VolunteerAssignment = append(c.hooks.VolunteerAssignment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `volunteerassignment.Intercept(f(g(h())))`.
func (c *VolunteerAssignmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.VolunteerAssignment = append(c.inters.VolunteerAssignment, interceptors...)
}

// Create returns a builder for creating a VolunteerAssignment entity.
func (c *VolunteerAssignmentClient) Create() *VolunteerAssignmentCreate {
	mutation := newVolunteerAssignmentMutation(c.config, OpCreate)
	return &VolunteerAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VolunteerAssignment entities.
func (c *VolunteerAssignmentClient) CreateBulk(builders ...*VolunteerAssignmentCreate) *VolunteerAssignmentCreateBulk {
	return &VolunteerAssignmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VolunteerAssignmentClient) MapCreateBulk(slice any, setFunc func(*VolunteerAssignmentCreate, int)) *VolunteerAssignmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VolunteerAssignmentCreateBulk{err: fmt.Errorf("calling to VolunteerAssignmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VolunteerAssignmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VolunteerAssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VolunteerAssignment.
func (c *VolunteerAssignmentClient) Update() *VolunteerAssignmentUpdate {
	mutation := newVolunteerAssignmentMutation(c.config, OpUpdate)
	return &VolunteerAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VolunteerAssignmentClient) UpdateOne(_m *VolunteerAssignment) *VolunteerAssignmentUpdateOne {
	mutation := newVolunteerAssignmentMutation(c.config, OpUpdateOne, withVolunteerAssignment(_m))
	return &VolunteerAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VolunteerAssignmentClient) UpdateOneID(id int) *VolunteerAssignmentUpdateOne {
	mutation := newVolunteerAssignmentMutation(c.config, OpUpdateOne, withVolunteerAssignmentID(id))
	return &VolunteerAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VolunteerAssignment.
func (c *VolunteerAssignmentClient) Delete() *VolunteerAssignmentDelete {
	mutation := newVolunteerAssignmentMutation(c.config, OpDelete)
	return &VolunteerAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VolunteerAssignmentClient) DeleteOne(_m *VolunteerAssignment) *VolunteerAssignmentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VolunteerAssignmentClient) DeleteOneID(id int) *VolunteerAssignmentDeleteOne {
	builder := c.Delete().Where(volunteerassignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VolunteerAssignmentDeleteOne{builder}
}

// Query returns a query builder for VolunteerAssignment.
func (c *VolunteerAssignmentClient) Query() *VolunteerAssignmentQuery {
	return &VolunteerAssignmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVolunteerAssignment},
		inters: c.Interceptors(),
	}
}

// Get returns a VolunteerAssignment entity by its id.
func (c *VolunteerAssignmentClient) Get(ctx context.Context, id int) (*VolunteerAssignment, error) {
	return c.Query().Where(volunteerassignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VolunteerAssignmentClient) GetX(ctx context.Context, id int) *VolunteerAssignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOpportunity queries the opportunity edge of a VolunteerAssignment.
func (c *VolunteerAssignmentClient) QueryOpportunity(_m *VolunteerAssignment) *VolunteerOpportunityQuery {
	query := (&VolunteerOpportunityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(volunteerassignment.Table, volunteerassignment.FieldID, id),
			sqlgraph.To(volunteeropportunity.Table, volunteeropportunity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, volunteerassignment.OpportunityTable, volunteerassignment.OpportunityColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVolunteer queries the volunteer edge of a VolunteerAssignment.
func (c *VolunteerAssignmentClient) QueryVolunteer(_m *VolunteerAssignment) *UserProfileQuery {
	query := (&UserProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(volunteerassignment.Table, volunteerassignment.FieldID, id),
			sqlgraph.To(userprofile.Table, userprofile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, volunteerassignment.VolunteerTable, volunteerassignment.VolunteerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VolunteerAssignmentClient) Hooks() []Hook {
	return c.hooks.VolunteerAssignment
}

// Interceptors returns the client interceptors.
func (c *VolunteerAssignmentClient) Interceptors() []Interceptor {
	return c.inters.VolunteerAssignment
}

func (c *VolunteerAssignmentClient) mutate(ctx context.Context, m *VolunteerAssignmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VolunteerAssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VolunteerAssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VolunteerAssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VolunteerAssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VolunteerAssignment mutation op: %q", m.Op())
	}
}

// VolunteerOpportunityClient is a client for the VolunteerOpportunity schema.
type VolunteerOpportunityClient struct {
	config
}

// NewVolunteerOpportunityClient returns a client for the VolunteerOpportunity from the given config.
func NewVolunteerOpportunityClient(c config) *VolunteerOpportunityClient {
	return &VolunteerOpportunityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `volunteeropportunity.Hooks(f(g(h())))`.
func (c *VolunteerOpportunityClient) Use(hooks ...Hook) {
	c.hooks.VolunteerOpportunity = append(c.hooks.VolunteerOpportunity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `volunteeropportunity.Intercept(f(g(h())))`.
func (c *VolunteerOpportunityClient) Intercept(interceptors ...Interceptor) {
	c.inters.VolunteerOpportunity = append(c.inters.VolunteerOpportunity, interceptors...)
}

// Create returns a builder for creating a VolunteerOpportunity entity.
func (c *VolunteerOpportunityClient) Create() *VolunteerOpportunityCreate {
	mutation := newVolunteerOpportunityMutation(c.config, OpCreate)
	return &VolunteerOpportunityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VolunteerOpportunity entities.
func (c *VolunteerOpportunityClient) CreateBulk(builders ...*VolunteerOpportunityCreate) *VolunteerOpportunityCreateBulk {
	return &VolunteerOpportunityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VolunteerOpportunityClient) MapCreateBulk(slice any, setFunc func(*VolunteerOpportunityCreate, int)) *VolunteerOpportunityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VolunteerOpportunityCreateBulk{err: fmt.Errorf("calling to VolunteerOpportunityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VolunteerOpportunityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VolunteerOpportunityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VolunteerOpportunity.
func (c *VolunteerOpportunityClient) Update() *VolunteerOpportunityUpdate {
	mutation := newVolunteerOpportunityMutation(c.config, OpUpdate)
	return &VolunteerOpportunityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VolunteerOpportunityClient) UpdateOne(_m *VolunteerOpportunity) *VolunteerOpportunityUpdateOne {
	mutation := newVolunteerOpportunityMutation(c.config, OpUpdateOne, withVolunteerOpportunity(_m))
	return &VolunteerOpportunityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VolunteerOpportunityClient) UpdateOneID(id int) *VolunteerOpportunityUpdateOne {
	mutation := newVolunteerOpportunityMutation(c.config, OpUpdateOne, withVolunteerOpportunityID(id))
	return &VolunteerOpportunityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VolunteerOpportunity.
func (c *VolunteerOpportunityClient) Delete() *VolunteerOpportunityDelete {
	mutation := newVolunteerOpportunityMutation(c.config, OpDelete)
	return &VolunteerOpportunityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VolunteerOpportunityClient) DeleteOne(_m *VolunteerOpportunity) *VolunteerOpportunityDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VolunteerOpportunityClient) DeleteOneID(id int) *VolunteerOpportunityDeleteOne {
	builder := c.Delete().Where(volunteeropportunity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VolunteerOpportunityDeleteOne{builder}
}

// Query returns a query builder for VolunteerOpportunity.
func (c *VolunteerOpportunityClient) Query() *VolunteerOpportunityQuery {
	return &VolunteerOpportunityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVolunteerOpportunity},
		inters: c.Interceptors(),
	}
}

// Get returns a VolunteerOpportunity entity by its id.
func (c *VolunteerOpportunityClient) Get(ctx context.Context, id int) (*VolunteerOpportunity, error) {
	return c.Query().Where(volunteeropportunity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VolunteerOpportunityClient) GetX(ctx context.Context, id int) *VolunteerOpportunity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProgram queries the program edge of a VolunteerOpportunity.
func (c *VolunteerOpportunityClient) QueryProgram(_m *VolunteerOpportunity) *ProgramQuery {
	query := (&ProgramClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(volunteeropportunity.Table, volunteeropportunity.FieldID, id),
			sqlgraph.To(program.Table, program.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, volunteeropportunity.ProgramTable, volunteeropportunity.ProgramColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInterestedVolunteers queries the interested_volunteers edge of a VolunteerOpportunity.
func (c *VolunteerOpportunityClient) QueryInterestedVolunteers(_m *VolunteerOpportunity) *VolunteerApplicationQuery {
	query := (&VolunteerApplicationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(volunteeropportunity.Table, volunteeropportunity.FieldID, id),
			sqlgraph.To(volunteerapplication.Table, volunteerapplication.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, volunteeropportunity.InterestedVolunteersTable, volunteeropportunity.InterestedVolunteersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignments queries the assignments edge of a VolunteerOpportunity.
func (c *VolunteerOpportunityClient) QueryAssignments(_m *VolunteerOpportunity) *VolunteerAssignmentQuery {
	query := (&VolunteerAssignmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(volunteeropportunity.Table, volunteeropportunity.FieldID, id),
			sqlgraph.To(volunteerassignment.Table, volunteerassignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, volunteeropportunity.AssignmentsTable, volunteeropportunity.AssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VolunteerOpportunityClient) Hooks() []Hook {
	return c.hooks.VolunteerOpportunity
}

// Interceptors returns the client interceptors.
func (c *VolunteerOpportunityClient) Interceptors() []Interceptor {
	return c.inters.VolunteerOpportunity
}

func (c *VolunteerOpportunityClient) mutate(ctx context.Context, m *VolunteerOpportunityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VolunteerOpportunityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VolunteerOpportunityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VolunteerOpportunityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VolunteerOpportunityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VolunteerOpportunity mutation op: %q", m.Op())
	}
}

// VoteClient is a client for the Vote schema.
type VoteClient struct {
	config
}

// NewVoteClient returns a client for the Vote from the given config.
func NewVoteClient(c config) *VoteClient {
	return &VoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vote.Hooks(f(g(h())))`.
func (c *VoteClient) Use(hooks ...Hook) {
	c.hooks.Vote = append(c.hooks.Vote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vote.Intercept(f(g(h())))`.
func (c *VoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Vote = append(c.inters.Vote, interceptors...)
}

// Create returns a builder for creating a Vote entity.
func (c *VoteClient) Create() *VoteCreate {
	mutation := newVoteMutation(c.config, OpCreate)
	return &VoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vote entities.
func (c *VoteClient) CreateBulk(builders ...*VoteCreate) *VoteCreateBulk {
	return &VoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VoteClient) MapCreateBulk(slice any, setFunc func(*VoteCreate, int)) *VoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VoteCreateBulk{err: fmt.Errorf("calling to VoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vote.
func (c *VoteClient) Update() *VoteUpdate {
	mutation := newVoteMutation(c.config, OpUpdate)
	return &VoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VoteClient) UpdateOne(_m *Vote) *VoteUpdateOne {
	mutation := newVoteMutation(c.config, OpUpdateOne, withVote(_m))
	return &VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VoteClient) UpdateOneID(id int) *VoteUpdateOne {
	mutation := newVoteMutation(c.config, OpUpdateOne, withVoteID(id))
	return &VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vote.
func (c *VoteClient) Delete() *VoteDelete {
	mutation := newVoteMutation(c.config, OpDelete)
	return &VoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VoteClient) DeleteOne(_m *Vote) *VoteDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VoteClient) DeleteOneID(id int) *VoteDeleteOne {
	builder := c.Delete().Where(vote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VoteDeleteOne{builder}
}

// Query returns a query builder for Vote.
func (c *VoteClient) Query() *VoteQuery {
	return &VoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVote},
		inters: c.Interceptors(),
	}
}

// Get returns a Vote entity by its id.
func (c *VoteClient) Get(ctx context.Context, id int) (*Vote, error) {
	return c.Query().Where(vote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VoteClient) GetX(ctx context.Context, id int) *Vote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgendaItem queries the agenda_item edge of a Vote.
func (c *VoteClient) QueryAgendaItem(_m *Vote) *AgendaItemQuery {
	query := (&AgendaItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vote.Table, vote.FieldID, id),
			sqlgraph.To(agendaitem.Table, agendaitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, vote.AgendaItemTable, vote.AgendaItemColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBallots queries the ballots edge of a Vote.
func (c *VoteClient) QueryBallots(_m *Vote) *BallotQuery {
	query := (&BallotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vote.Table, vote.FieldID, id),
			sqlgraph.To(ballot.Table, ballot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vote.BallotsTable, vote.BallotsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VoteClient) Hooks() []Hook {
	return c.hooks.Vote
}

// Interceptors returns the client interceptors.
func (c *VoteClient) Interceptors() []Interceptor {
	return c.inters.Vote
}

func (c *VoteClient) mutate(ctx context.Context, m *VoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Vote mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AccordionItem, ActionItem, ActivityLog, Address, Agenda, AgendaItem,
		AnalyticsDashboard, AnalyticsEvent, AppSetting, AuditLog, Badge, Ballot,
		BlockAccordion, BlockContactForm, BlockCta, BlockDivider, BlockDonationForm,
		BlockFaq, BlockGallery, BlockHero, BlockMap, BlockNewsletterSignup,
		BlockPartnerLogos, BlockProgramCards, BlockStats, BlockSuccessStories,
		BlockTabs, BlockTeamGrid, BlockTestimonials, BlockTextContent, BlockTimeline,
		BlockVideoEmbed, BlockVolunteerSignup, BrandBenefit, BrandConfig, ContentBlock,
		Conversation, ConversationParticipant, DashboardWidget, Document,
		DocumentCategory, Donation, Event, EventRegistration, FaqItem, FeatureFlag,
		FundraisingCampaign, GalleryImage, GeneratedReport, Grant, GrantReport,
		ImpactDataPoint, ImpactMetric, Job, JobLog, MentorshipRequest,
		MentorshipSession, Message, NewsArticle, Organization, Page, PartnerLogoItem,
		Partnership, PartnershipInteraction, PartnershipRenewal, PartnershipReport,
		PasswordHistory, Permission, Program, ProgramCardItem, ProgramCategory,
		ProgramEnrolment, ProgramParticipant, ReportDefinition, ReportPermission,
		RolePermission, ScheduledReport, SeoConfig, SiteVisit, Skill, StatItem,
		SuccessStory, SystemError, SystemLog, TabItem, TeamMember, TeamMemberItem,
		TestimonialItem, TimelineEvent, Token, TrustedDevice, User, UserAchievement,
		UserConsent, UserOnboarding, UserProfile, UserSession, UserSkill,
		VolunteerApplication, VolunteerAssignment, VolunteerOpportunity,
		Vote []ent.Hook
	}
	inters struct {
		AccordionItem, ActionItem, ActivityLog, Address, Agenda, AgendaItem,
		AnalyticsDashboard, AnalyticsEvent, AppSetting, AuditLog, Badge, Ballot,
		BlockAccordion, BlockContactForm, BlockCta, BlockDivider, BlockDonationForm,
		BlockFaq, BlockGallery, BlockHero, BlockMap, BlockNewsletterSignup,
		BlockPartnerLogos, BlockProgramCards, BlockStats, BlockSuccessStories,
		BlockTabs, BlockTeamGrid, BlockTestimonials, BlockTextContent, BlockTimeline,
		BlockVideoEmbed, BlockVolunteerSignup, BrandBenefit, BrandConfig, ContentBlock,
		Conversation, ConversationParticipant, DashboardWidget, Document,
		DocumentCategory, Donation, Event, EventRegistration, FaqItem, FeatureFlag,
		FundraisingCampaign, GalleryImage, GeneratedReport, Grant, GrantReport,
		ImpactDataPoint, ImpactMetric, Job, JobLog, MentorshipRequest,
		MentorshipSession, Message, NewsArticle, Organization, Page, PartnerLogoItem,
		Partnership, PartnershipInteraction, PartnershipRenewal, PartnershipReport,
		PasswordHistory, Permission, Program, ProgramCardItem, ProgramCategory,
		ProgramEnrolment, ProgramParticipant, ReportDefinition, ReportPermission,
		RolePermission, ScheduledReport, SeoConfig, SiteVisit, Skill, StatItem,
		SuccessStory, SystemError, SystemLog, TabItem, TeamMember, TeamMemberItem,
		TestimonialItem, TimelineEvent, Token, TrustedDevice, User, UserAchievement,
		UserConsent, UserOnboarding, UserProfile, UserSession, UserSkill,
		VolunteerApplication, VolunteerAssignment, VolunteerOpportunity,
		Vote []ent.Interceptor
	}
)
