// Code generated by ent, DO NOT EDIT.

package ent

import (
	"awe/ent/ent/accordionitem"
	"awe/ent/ent/actionitem"
	"awe/ent/ent/activitylog"
	"awe/ent/ent/address"
	"awe/ent/ent/agenda"
	"awe/ent/ent/agendaitem"
	"awe/ent/ent/analyticsdashboard"
	"awe/ent/ent/analyticsevent"
	"awe/ent/ent/appsetting"
	"awe/ent/ent/auditlog"
	"awe/ent/ent/badge"
	"awe/ent/ent/ballot"
	"awe/ent/ent/blockaccordion"
	"awe/ent/ent/blockcontactform"
	"awe/ent/ent/blockcta"
	"awe/ent/ent/blockdivider"
	"awe/ent/ent/blockdonationform"
	"awe/ent/ent/blockfaq"
	"awe/ent/ent/blockgallery"
	"awe/ent/ent/blockhero"
	"awe/ent/ent/blockmap"
	"awe/ent/ent/blocknewslettersignup"
	"awe/ent/ent/blockpartnerlogos"
	"awe/ent/ent/blockprogramcards"
	"awe/ent/ent/blockstats"
	"awe/ent/ent/blocksuccessstories"
	"awe/ent/ent/blocktabs"
	"awe/ent/ent/blockteamgrid"
	"awe/ent/ent/blocktestimonials"
	"awe/ent/ent/blocktextcontent"
	"awe/ent/ent/blocktimeline"
	"awe/ent/ent/blockvideoembed"
	"awe/ent/ent/blockvolunteersignup"
	"awe/ent/ent/brandbenefit"
	"awe/ent/ent/brandconfig"
	"awe/ent/ent/contentblock"
	"awe/ent/ent/conversation"
	"awe/ent/ent/conversationparticipant"
	"awe/ent/ent/dashboardwidget"
	"awe/ent/ent/document"
	"awe/ent/ent/documentcategory"
	"awe/ent/ent/donation"
	"awe/ent/ent/event"
	"awe/ent/ent/eventregistration"
	"awe/ent/ent/faqitem"
	"awe/ent/ent/featureflag"
	"awe/ent/ent/fundraisingcampaign"
	"awe/ent/ent/galleryimage"
	"awe/ent/ent/generatedreport"
	"awe/ent/ent/grant"
	"awe/ent/ent/grantreport"
	"awe/ent/ent/impactdatapoint"
	"awe/ent/ent/impactmetric"
	"awe/ent/ent/job"
	"awe/ent/ent/joblog"
	"awe/ent/ent/mentorshiprequest"
	"awe/ent/ent/mentorshipsession"
	"awe/ent/ent/message"
	"awe/ent/ent/newsarticle"
	"awe/ent/ent/organization"
	"awe/ent/ent/page"
	"awe/ent/ent/partnerlogoitem"
	"awe/ent/ent/partnership"
	"awe/ent/ent/partnershipinteraction"
	"awe/ent/ent/partnershiprenewal"
	"awe/ent/ent/partnershipreport"
	"awe/ent/ent/passwordhistory"
	"awe/ent/ent/permission"
	"awe/ent/ent/predicate"
	"awe/ent/ent/program"
	"awe/ent/ent/programcarditem"
	"awe/ent/ent/programcategory"
	"awe/ent/ent/programenrolment"
	"awe/ent/ent/programparticipant"
	"awe/ent/ent/reportdefinition"
	"awe/ent/ent/reportpermission"
	"awe/ent/ent/rolepermission"
	"awe/ent/ent/scheduledreport"
	"awe/ent/ent/seoconfig"
	"awe/ent/ent/sitevisit"
	"awe/ent/ent/skill"
	"awe/ent/ent/statitem"
	"awe/ent/ent/successstory"
	"awe/ent/ent/systemerror"
	"awe/ent/ent/systemlog"
	"awe/ent/ent/tabitem"
	"awe/ent/ent/teammember"
	"awe/ent/ent/teammemberitem"
	"awe/ent/ent/testimonialitem"
	"awe/ent/ent/timelineevent"
	"awe/ent/ent/token"
	"awe/ent/ent/trusteddevice"
	"awe/ent/ent/user"
	"awe/ent/ent/userachievement"
	"awe/ent/ent/userconsent"
	"awe/ent/ent/useronboarding"
	"awe/ent/ent/userprofile"
	"awe/ent/ent/usersession"
	"awe/ent/ent/userskill"
	"awe/ent/ent/volunteerapplication"
	"awe/ent/ent/volunteerassignment"
	"awe/ent/ent/volunteeropportunity"
	"awe/ent/ent/vote"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccordionItem           = "AccordionItem"
	TypeActionItem              = "ActionItem"
	TypeActivityLog             = "ActivityLog"
	TypeAddress                 = "Address"
	TypeAgenda                  = "Agenda"
	TypeAgendaItem              = "AgendaItem"
	TypeAnalyticsDashboard      = "AnalyticsDashboard"
	TypeAnalyticsEvent          = "AnalyticsEvent"
	TypeAppSetting              = "AppSetting"
	TypeAuditLog                = "AuditLog"
	TypeBadge                   = "Badge"
	TypeBallot                  = "Ballot"
	TypeBlockAccordion          = "BlockAccordion"
	TypeBlockContactForm        = "BlockContactForm"
	TypeBlockCta                = "BlockCta"
	TypeBlockDivider            = "BlockDivider"
	TypeBlockDonationForm       = "BlockDonationForm"
	TypeBlockFaq                = "BlockFaq"
	TypeBlockGallery            = "BlockGallery"
	TypeBlockHero               = "BlockHero"
	TypeBlockMap                = "BlockMap"
	TypeBlockNewsletterSignup   = "BlockNewsletterSignup"
	TypeBlockPartnerLogos       = "BlockPartnerLogos"
	TypeBlockProgramCards       = "BlockProgramCards"
	TypeBlockStats              = "BlockStats"
	TypeBlockSuccessStories     = "BlockSuccessStories"
	TypeBlockTabs               = "BlockTabs"
	TypeBlockTeamGrid           = "BlockTeamGrid"
	TypeBlockTestimonials       = "BlockTestimonials"
	TypeBlockTextContent        = "BlockTextContent"
	TypeBlockTimeline           = "BlockTimeline"
	TypeBlockVideoEmbed         = "BlockVideoEmbed"
	TypeBlockVolunteerSignup    = "BlockVolunteerSignup"
	TypeBrandBenefit            = "BrandBenefit"
	TypeBrandConfig             = "BrandConfig"
	TypeContentBlock            = "ContentBlock"
	TypeConversation            = "Conversation"
	TypeConversationParticipant = "ConversationParticipant"
	TypeDashboardWidget         = "DashboardWidget"
	TypeDocument                = "Document"
	TypeDocumentCategory        = "DocumentCategory"
	TypeDonation                = "Donation"
	TypeEvent                   = "Event"
	TypeEventRegistration       = "EventRegistration"
	TypeFaqItem                 = "FaqItem"
	TypeFeatureFlag             = "FeatureFlag"
	TypeFundraisingCampaign     = "FundraisingCampaign"
	TypeGalleryImage            = "GalleryImage"
	TypeGeneratedReport         = "GeneratedReport"
	TypeGrant                   = "Grant"
	TypeGrantReport             = "GrantReport"
	TypeImpactDataPoint         = "ImpactDataPoint"
	TypeImpactMetric            = "ImpactMetric"
	TypeJob                     = "Job"
	TypeJobLog                  = "JobLog"
	TypeMentorshipRequest       = "MentorshipRequest"
	TypeMentorshipSession       = "MentorshipSession"
	TypeMessage                 = "Message"
	TypeNewsArticle             = "NewsArticle"
	TypeOrganization            = "Organization"
	TypePage                    = "Page"
	TypePartnerLogoItem         = "PartnerLogoItem"
	TypePartnership             = "Partnership"
	TypePartnershipInteraction  = "PartnershipInteraction"
	TypePartnershipRenewal      = "PartnershipRenewal"
	TypePartnershipReport       = "PartnershipReport"
	TypePasswordHistory         = "PasswordHistory"
	TypePermission              = "Permission"
	TypeProgram                 = "Program"
	TypeProgramCardItem         = "ProgramCardItem"
	TypeProgramCategory         = "ProgramCategory"
	TypeProgramEnrolment        = "ProgramEnrolment"
	TypeProgramParticipant      = "ProgramParticipant"
	TypeReportDefinition        = "ReportDefinition"
	TypeReportPermission        = "ReportPermission"
	TypeRolePermission          = "RolePermission"
	TypeScheduledReport         = "ScheduledReport"
	TypeSeoConfig               = "SeoConfig"
	TypeSiteVisit               = "SiteVisit"
	TypeSkill                   = "Skill"
	TypeStatItem                = "StatItem"
	TypeSuccessStory            = "SuccessStory"
	TypeSystemError             = "SystemError"
	TypeSystemLog               = "SystemLog"
	TypeTabItem                 = "TabItem"
	TypeTeamMember              = "TeamMember"
	TypeTeamMemberItem          = "TeamMemberItem"
	TypeTestimonialItem         = "TestimonialItem"
	TypeTimelineEvent           = "TimelineEvent"
	TypeToken                   = "Token"
	TypeTrustedDevice           = "TrustedDevice"
	TypeUser                    = "User"
	TypeUserAchievement         = "UserAchievement"
	TypeUserConsent             = "UserConsent"
	TypeUserOnboarding          = "UserOnboarding"
	TypeUserProfile             = "UserProfile"
	TypeUserSession             = "UserSession"
	TypeUserSkill               = "UserSkill"
	TypeVolunteerApplication    = "VolunteerApplication"
	TypeVolunteerAssignment     = "VolunteerAssignment"
	TypeVolunteerOpportunity    = "VolunteerOpportunity"
	TypeVote                    = "Vote"
)

// AccordionItemMutation represents an operation that mutates the AccordionItem nodes in the graph.
type AccordionItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_order        *int
	add_order     *int
	title         *map[string]string
	content       *map[string]string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	block         *int
	clearedblock  bool
	done          bool
	oldValue      func(context.Context) (*AccordionItem, error)
	predicates    []predicate.AccordionItem
}

var _ ent.Mutation = (*AccordionItemMutation)(nil)

// accordionitemOption allows management of the mutation configuration using functional options.
type accordionitemOption func(*AccordionItemMutation)

// newAccordionItemMutation creates new mutation for the AccordionItem entity.
func newAccordionItemMutation(c config, op Op, opts ...accordionitemOption) *AccordionItemMutation {
	m := &AccordionItemMutation{
		config:        c,
		op:            op,
		typ:           TypeAccordionItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccordionItemID sets the ID field of the mutation.
func withAccordionItemID(id int) accordionitemOption {
	return func(m *AccordionItemMutation) {
		var (
			err   error
			once  sync.Once
			value *AccordionItem
		)
		m.oldValue = func(ctx context.Context) (*AccordionItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccordionItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccordionItem sets the old AccordionItem of the mutation.
func withAccordionItem(node *AccordionItem) accordionitemOption {
	return func(m *AccordionItemMutation) {
		m.oldValue = func(context.Context) (*AccordionItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccordionItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccordionItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccordionItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccordionItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccordionItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *AccordionItemMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *AccordionItemMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the AccordionItem entity.
// If the AccordionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccordionItemMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *AccordionItemMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *AccordionItemMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *AccordionItemMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetTitle sets the "title" field.
func (m *AccordionItemMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *AccordionItemMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the AccordionItem entity.
// If the AccordionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccordionItemMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AccordionItemMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *AccordionItemMutation) SetContent(value map[string]string) {
	m.content = &value
}

// Content returns the value of the "content" field in the mutation.
func (m *AccordionItemMutation) Content() (r map[string]string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the AccordionItem entity.
// If the AccordionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccordionItemMutation) OldContent(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *AccordionItemMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccordionItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccordionItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccordionItem entity.
// If the AccordionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccordionItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccordionItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccordionItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccordionItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccordionItem entity.
// If the AccordionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccordionItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccordionItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBlockID sets the "block" edge to the BlockAccordion entity by id.
func (m *AccordionItemMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the BlockAccordion entity.
func (m *AccordionItemMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the BlockAccordion entity was cleared.
func (m *AccordionItemMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *AccordionItemMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *AccordionItemMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *AccordionItemMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// Where appends a list predicates to the AccordionItemMutation builder.
func (m *AccordionItemMutation) Where(ps ...predicate.AccordionItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccordionItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccordionItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccordionItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccordionItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccordionItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccordionItem).
func (m *AccordionItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccordionItemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._order != nil {
		fields = append(fields, accordionitem.FieldOrder)
	}
	if m.title != nil {
		fields = append(fields, accordionitem.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, accordionitem.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, accordionitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accordionitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccordionItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accordionitem.FieldOrder:
		return m.Order()
	case accordionitem.FieldTitle:
		return m.Title()
	case accordionitem.FieldContent:
		return m.Content()
	case accordionitem.FieldCreatedAt:
		return m.CreatedAt()
	case accordionitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccordionItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accordionitem.FieldOrder:
		return m.OldOrder(ctx)
	case accordionitem.FieldTitle:
		return m.OldTitle(ctx)
	case accordionitem.FieldContent:
		return m.OldContent(ctx)
	case accordionitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accordionitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AccordionItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccordionItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accordionitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case accordionitem.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case accordionitem.FieldContent:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case accordionitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accordionitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AccordionItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccordionItemMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, accordionitem.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccordionItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accordionitem.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccordionItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accordionitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown AccordionItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccordionItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccordionItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccordionItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccordionItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccordionItemMutation) ResetField(name string) error {
	switch name {
	case accordionitem.FieldOrder:
		m.ResetOrder()
		return nil
	case accordionitem.FieldTitle:
		m.ResetTitle()
		return nil
	case accordionitem.FieldContent:
		m.ResetContent()
		return nil
	case accordionitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accordionitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AccordionItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccordionItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.block != nil {
		edges = append(edges, accordionitem.EdgeBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccordionItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accordionitem.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccordionItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccordionItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccordionItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblock {
		edges = append(edges, accordionitem.EdgeBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccordionItemMutation) EdgeCleared(name string) bool {
	switch name {
	case accordionitem.EdgeBlock:
		return m.clearedblock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccordionItemMutation) ClearEdge(name string) error {
	switch name {
	case accordionitem.EdgeBlock:
		m.ClearBlock()
		return nil
	}
	return fmt.Errorf("unknown AccordionItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccordionItemMutation) ResetEdge(name string) error {
	switch name {
	case accordionitem.EdgeBlock:
		m.ResetBlock()
		return nil
	}
	return fmt.Errorf("unknown AccordionItem edge %s", name)
}

// ActionItemMutation represents an operation that mutates the ActionItem nodes in the graph.
type ActionItemMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	description        *string
	owner_id           *string
	due_date           *time.Time
	status             *string
	created_at         *time.Time
	completed_at       *time.Time
	clearedFields      map[string]struct{}
	agenda_item        *int
	clearedagenda_item bool
	done               bool
	oldValue           func(context.Context) (*ActionItem, error)
	predicates         []predicate.ActionItem
}

var _ ent.Mutation = (*ActionItemMutation)(nil)

// actionitemOption allows management of the mutation configuration using functional options.
type actionitemOption func(*ActionItemMutation)

// newActionItemMutation creates new mutation for the ActionItem entity.
func newActionItemMutation(c config, op Op, opts ...actionitemOption) *ActionItemMutation {
	m := &ActionItemMutation{
		config:        c,
		op:            op,
		typ:           TypeActionItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionItemID sets the ID field of the mutation.
func withActionItemID(id int) actionitemOption {
	return func(m *ActionItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ActionItem
		)
		m.oldValue = func(ctx context.Context) (*ActionItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActionItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActionItem sets the old ActionItem of the mutation.
func withActionItem(node *ActionItem) actionitemOption {
	return func(m *ActionItemMutation) {
		m.oldValue = func(context.Context) (*ActionItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActionItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *ActionItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ActionItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ActionItem entity.
// If the ActionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ActionItemMutation) ResetDescription() {
	m.description = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *ActionItemMutation) SetOwnerID(s string) {
	m.owner_id = &s
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ActionItemMutation) OwnerID() (r string, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the ActionItem entity.
// If the ActionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionItemMutation) OldOwnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ActionItemMutation) ResetOwnerID() {
	m.owner_id = nil
}

// SetDueDate sets the "due_date" field.
func (m *ActionItemMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *ActionItemMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the ActionItem entity.
// If the ActionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionItemMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *ActionItemMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[actionitem.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *ActionItemMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[actionitem.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *ActionItemMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, actionitem.FieldDueDate)
}

// SetStatus sets the "status" field.
func (m *ActionItemMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ActionItemMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ActionItem entity.
// If the ActionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionItemMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ActionItemMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ActionItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActionItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActionItem entity.
// If the ActionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActionItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *ActionItemMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *ActionItemMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the ActionItem entity.
// If the ActionItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionItemMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *ActionItemMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[actionitem.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *ActionItemMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[actionitem.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *ActionItemMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, actionitem.FieldCompletedAt)
}

// SetAgendaItemID sets the "agenda_item" edge to the AgendaItem entity by id.
func (m *ActionItemMutation) SetAgendaItemID(id int) {
	m.agenda_item = &id
}

// ClearAgendaItem clears the "agenda_item" edge to the AgendaItem entity.
func (m *ActionItemMutation) ClearAgendaItem() {
	m.clearedagenda_item = true
}

// AgendaItemCleared reports if the "agenda_item" edge to the AgendaItem entity was cleared.
func (m *ActionItemMutation) AgendaItemCleared() bool {
	return m.clearedagenda_item
}

// AgendaItemID returns the "agenda_item" edge ID in the mutation.
func (m *ActionItemMutation) AgendaItemID() (id int, exists bool) {
	if m.agenda_item != nil {
		return *m.agenda_item, true
	}
	return
}

// AgendaItemIDs returns the "agenda_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgendaItemID instead. It exists only for internal usage by the builders.
func (m *ActionItemMutation) AgendaItemIDs() (ids []int) {
	if id := m.agenda_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgendaItem resets all changes to the "agenda_item" edge.
func (m *ActionItemMutation) ResetAgendaItem() {
	m.agenda_item = nil
	m.clearedagenda_item = false
}

// Where appends a list predicates to the ActionItemMutation builder.
func (m *ActionItemMutation) Where(ps ...predicate.ActionItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActionItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActionItem).
func (m *ActionItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionItemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.description != nil {
		fields = append(fields, actionitem.FieldDescription)
	}
	if m.owner_id != nil {
		fields = append(fields, actionitem.FieldOwnerID)
	}
	if m.due_date != nil {
		fields = append(fields, actionitem.FieldDueDate)
	}
	if m.status != nil {
		fields = append(fields, actionitem.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, actionitem.FieldCreatedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, actionitem.FieldCompletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case actionitem.FieldDescription:
		return m.Description()
	case actionitem.FieldOwnerID:
		return m.OwnerID()
	case actionitem.FieldDueDate:
		return m.DueDate()
	case actionitem.FieldStatus:
		return m.Status()
	case actionitem.FieldCreatedAt:
		return m.CreatedAt()
	case actionitem.FieldCompletedAt:
		return m.CompletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case actionitem.FieldDescription:
		return m.OldDescription(ctx)
	case actionitem.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case actionitem.FieldDueDate:
		return m.OldDueDate(ctx)
	case actionitem.FieldStatus:
		return m.OldStatus(ctx)
	case actionitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case actionitem.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ActionItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case actionitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case actionitem.FieldOwnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case actionitem.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case actionitem.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case actionitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case actionitem.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ActionItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActionItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(actionitem.FieldDueDate) {
		fields = append(fields, actionitem.FieldDueDate)
	}
	if m.FieldCleared(actionitem.FieldCompletedAt) {
		fields = append(fields, actionitem.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionItemMutation) ClearField(name string) error {
	switch name {
	case actionitem.FieldDueDate:
		m.ClearDueDate()
		return nil
	case actionitem.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown ActionItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionItemMutation) ResetField(name string) error {
	switch name {
	case actionitem.FieldDescription:
		m.ResetDescription()
		return nil
	case actionitem.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case actionitem.FieldDueDate:
		m.ResetDueDate()
		return nil
	case actionitem.FieldStatus:
		m.ResetStatus()
		return nil
	case actionitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case actionitem.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown ActionItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.agenda_item != nil {
		edges = append(edges, actionitem.EdgeAgendaItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case actionitem.EdgeAgendaItem:
		if id := m.agenda_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedagenda_item {
		edges = append(edges, actionitem.EdgeAgendaItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionItemMutation) EdgeCleared(name string) bool {
	switch name {
	case actionitem.EdgeAgendaItem:
		return m.clearedagenda_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionItemMutation) ClearEdge(name string) error {
	switch name {
	case actionitem.EdgeAgendaItem:
		m.ClearAgendaItem()
		return nil
	}
	return fmt.Errorf("unknown ActionItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionItemMutation) ResetEdge(name string) error {
	switch name {
	case actionitem.EdgeAgendaItem:
		m.ResetAgendaItem()
		return nil
	}
	return fmt.Errorf("unknown ActionItem edge %s", name)
}

// ActivityLogMutation represents an operation that mutates the ActivityLog nodes in the graph.
type ActivityLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_type         *activitylog.Type
	title         *string
	description   *string
	link_href     *string
	entity_type   *string
	entity_id     *string
	metadata      *map[string]interface{}
	ip_address    *string
	user_agent    *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	actor         *int
	clearedactor  bool
	done          bool
	oldValue      func(context.Context) (*ActivityLog, error)
	predicates    []predicate.ActivityLog
}

var _ ent.Mutation = (*ActivityLogMutation)(nil)

// activitylogOption allows management of the mutation configuration using functional options.
type activitylogOption func(*ActivityLogMutation)

// newActivityLogMutation creates new mutation for the ActivityLog entity.
func newActivityLogMutation(c config, op Op, opts ...activitylogOption) *ActivityLogMutation {
	m := &ActivityLogMutation{
		config:        c,
		op:            op,
		typ:           TypeActivityLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityLogID sets the ID field of the mutation.
func withActivityLogID(id int) activitylogOption {
	return func(m *ActivityLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ActivityLog
		)
		m.oldValue = func(ctx context.Context) (*ActivityLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActivityLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivityLog sets the old ActivityLog of the mutation.
func withActivityLog(node *ActivityLog) activitylogOption {
	return func(m *ActivityLogMutation) {
		m.oldValue = func(context.Context) (*ActivityLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActivityLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ActivityLogMutation) SetType(a activitylog.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *ActivityLogMutation) GetType() (r activitylog.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldType(ctx context.Context) (v activitylog.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ActivityLogMutation) ResetType() {
	m._type = nil
}

// SetTitle sets the "title" field.
func (m *ActivityLogMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ActivityLogMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ActivityLogMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ActivityLogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ActivityLogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ActivityLogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[activitylog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ActivityLogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ActivityLogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, activitylog.FieldDescription)
}

// SetLinkHref sets the "link_href" field.
func (m *ActivityLogMutation) SetLinkHref(s string) {
	m.link_href = &s
}

// LinkHref returns the value of the "link_href" field in the mutation.
func (m *ActivityLogMutation) LinkHref() (r string, exists bool) {
	v := m.link_href
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkHref returns the old "link_href" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldLinkHref(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkHref is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkHref requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkHref: %w", err)
	}
	return oldValue.LinkHref, nil
}

// ClearLinkHref clears the value of the "link_href" field.
func (m *ActivityLogMutation) ClearLinkHref() {
	m.link_href = nil
	m.clearedFields[activitylog.FieldLinkHref] = struct{}{}
}

// LinkHrefCleared returns if the "link_href" field was cleared in this mutation.
func (m *ActivityLogMutation) LinkHrefCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldLinkHref]
	return ok
}

// ResetLinkHref resets all changes to the "link_href" field.
func (m *ActivityLogMutation) ResetLinkHref() {
	m.link_href = nil
	delete(m.clearedFields, activitylog.FieldLinkHref)
}

// SetEntityType sets the "entity_type" field.
func (m *ActivityLogMutation) SetEntityType(s string) {
	m.entity_type = &s
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *ActivityLogMutation) EntityType() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldEntityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ClearEntityType clears the value of the "entity_type" field.
func (m *ActivityLogMutation) ClearEntityType() {
	m.entity_type = nil
	m.clearedFields[activitylog.FieldEntityType] = struct{}{}
}

// EntityTypeCleared returns if the "entity_type" field was cleared in this mutation.
func (m *ActivityLogMutation) EntityTypeCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldEntityType]
	return ok
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *ActivityLogMutation) ResetEntityType() {
	m.entity_type = nil
	delete(m.clearedFields, activitylog.FieldEntityType)
}

// SetEntityID sets the "entity_id" field.
func (m *ActivityLogMutation) SetEntityID(s string) {
	m.entity_id = &s
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *ActivityLogMutation) EntityID() (r string, exists bool) {
	v := m.entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldEntityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ClearEntityID clears the value of the "entity_id" field.
func (m *ActivityLogMutation) ClearEntityID() {
	m.entity_id = nil
	m.clearedFields[activitylog.FieldEntityID] = struct{}{}
}

// EntityIDCleared returns if the "entity_id" field was cleared in this mutation.
func (m *ActivityLogMutation) EntityIDCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldEntityID]
	return ok
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *ActivityLogMutation) ResetEntityID() {
	m.entity_id = nil
	delete(m.clearedFields, activitylog.FieldEntityID)
}

// SetMetadata sets the "metadata" field.
func (m *ActivityLogMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ActivityLogMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ActivityLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[activitylog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ActivityLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ActivityLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, activitylog.FieldMetadata)
}

// SetIPAddress sets the "ip_address" field.
func (m *ActivityLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *ActivityLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *ActivityLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[activitylog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *ActivityLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *ActivityLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, activitylog.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *ActivityLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *ActivityLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *ActivityLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[activitylog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *ActivityLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[activitylog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *ActivityLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, activitylog.FieldUserAgent)
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ActivityLog entity.
// If the ActivityLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetActorID sets the "actor" edge to the User entity by id.
func (m *ActivityLogMutation) SetActorID(id int) {
	m.actor = &id
}

// ClearActor clears the "actor" edge to the User entity.
func (m *ActivityLogMutation) ClearActor() {
	m.clearedactor = true
}

// ActorCleared reports if the "actor" edge to the User entity was cleared.
func (m *ActivityLogMutation) ActorCleared() bool {
	return m.clearedactor
}

// ActorID returns the "actor" edge ID in the mutation.
func (m *ActivityLogMutation) ActorID() (id int, exists bool) {
	if m.actor != nil {
		return *m.actor, true
	}
	return
}

// ActorIDs returns the "actor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActorID instead. It exists only for internal usage by the builders.
func (m *ActivityLogMutation) ActorIDs() (ids []int) {
	if id := m.actor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActor resets all changes to the "actor" edge.
func (m *ActivityLogMutation) ResetActor() {
	m.actor = nil
	m.clearedactor = false
}

// Where appends a list predicates to the ActivityLogMutation builder.
func (m *ActivityLogMutation) Where(ps ...predicate.ActivityLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActivityLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActivityLog).
func (m *ActivityLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityLogMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m._type != nil {
		fields = append(fields, activitylog.FieldType)
	}
	if m.title != nil {
		fields = append(fields, activitylog.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, activitylog.FieldDescription)
	}
	if m.link_href != nil {
		fields = append(fields, activitylog.FieldLinkHref)
	}
	if m.entity_type != nil {
		fields = append(fields, activitylog.FieldEntityType)
	}
	if m.entity_id != nil {
		fields = append(fields, activitylog.FieldEntityID)
	}
	if m.metadata != nil {
		fields = append(fields, activitylog.FieldMetadata)
	}
	if m.ip_address != nil {
		fields = append(fields, activitylog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, activitylog.FieldUserAgent)
	}
	if m.created_at != nil {
		fields = append(fields, activitylog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activitylog.FieldType:
		return m.GetType()
	case activitylog.FieldTitle:
		return m.Title()
	case activitylog.FieldDescription:
		return m.Description()
	case activitylog.FieldLinkHref:
		return m.LinkHref()
	case activitylog.FieldEntityType:
		return m.EntityType()
	case activitylog.FieldEntityID:
		return m.EntityID()
	case activitylog.FieldMetadata:
		return m.Metadata()
	case activitylog.FieldIPAddress:
		return m.IPAddress()
	case activitylog.FieldUserAgent:
		return m.UserAgent()
	case activitylog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activitylog.FieldType:
		return m.OldType(ctx)
	case activitylog.FieldTitle:
		return m.OldTitle(ctx)
	case activitylog.FieldDescription:
		return m.OldDescription(ctx)
	case activitylog.FieldLinkHref:
		return m.OldLinkHref(ctx)
	case activitylog.FieldEntityType:
		return m.OldEntityType(ctx)
	case activitylog.FieldEntityID:
		return m.OldEntityID(ctx)
	case activitylog.FieldMetadata:
		return m.OldMetadata(ctx)
	case activitylog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case activitylog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case activitylog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ActivityLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activitylog.FieldType:
		v, ok := value.(activitylog.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case activitylog.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case activitylog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case activitylog.FieldLinkHref:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkHref(v)
		return nil
	case activitylog.FieldEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case activitylog.FieldEntityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case activitylog.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case activitylog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case activitylog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case activitylog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ActivityLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActivityLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activitylog.FieldDescription) {
		fields = append(fields, activitylog.FieldDescription)
	}
	if m.FieldCleared(activitylog.FieldLinkHref) {
		fields = append(fields, activitylog.FieldLinkHref)
	}
	if m.FieldCleared(activitylog.FieldEntityType) {
		fields = append(fields, activitylog.FieldEntityType)
	}
	if m.FieldCleared(activitylog.FieldEntityID) {
		fields = append(fields, activitylog.FieldEntityID)
	}
	if m.FieldCleared(activitylog.FieldMetadata) {
		fields = append(fields, activitylog.FieldMetadata)
	}
	if m.FieldCleared(activitylog.FieldIPAddress) {
		fields = append(fields, activitylog.FieldIPAddress)
	}
	if m.FieldCleared(activitylog.FieldUserAgent) {
		fields = append(fields, activitylog.FieldUserAgent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityLogMutation) ClearField(name string) error {
	switch name {
	case activitylog.FieldDescription:
		m.ClearDescription()
		return nil
	case activitylog.FieldLinkHref:
		m.ClearLinkHref()
		return nil
	case activitylog.FieldEntityType:
		m.ClearEntityType()
		return nil
	case activitylog.FieldEntityID:
		m.ClearEntityID()
		return nil
	case activitylog.FieldMetadata:
		m.ClearMetadata()
		return nil
	case activitylog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case activitylog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	}
	return fmt.Errorf("unknown ActivityLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityLogMutation) ResetField(name string) error {
	switch name {
	case activitylog.FieldType:
		m.ResetType()
		return nil
	case activitylog.FieldTitle:
		m.ResetTitle()
		return nil
	case activitylog.FieldDescription:
		m.ResetDescription()
		return nil
	case activitylog.FieldLinkHref:
		m.ResetLinkHref()
		return nil
	case activitylog.FieldEntityType:
		m.ResetEntityType()
		return nil
	case activitylog.FieldEntityID:
		m.ResetEntityID()
		return nil
	case activitylog.FieldMetadata:
		m.ResetMetadata()
		return nil
	case activitylog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case activitylog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case activitylog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ActivityLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.actor != nil {
		edges = append(edges, activitylog.EdgeActor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activitylog.EdgeActor:
		if id := m.actor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedactor {
		edges = append(edges, activitylog.EdgeActor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityLogMutation) EdgeCleared(name string) bool {
	switch name {
	case activitylog.EdgeActor:
		return m.clearedactor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityLogMutation) ClearEdge(name string) error {
	switch name {
	case activitylog.EdgeActor:
		m.ClearActor()
		return nil
	}
	return fmt.Errorf("unknown ActivityLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityLogMutation) ResetEdge(name string) error {
	switch name {
	case activitylog.EdgeActor:
		m.ResetActor()
		return nil
	}
	return fmt.Errorf("unknown ActivityLog edge %s", name)
}

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	street1              *string
	street2              *string
	city                 *string
	state                *string
	postal_code          *string
	country              *string
	clearedFields        map[string]struct{}
	user_profiles        map[int]struct{}
	removeduser_profiles map[int]struct{}
	cleareduser_profiles bool
	events               map[int]struct{}
	removedevents        map[int]struct{}
	clearedevents        bool
	done                 bool
	oldValue             func(context.Context) (*Address, error)
	predicates           []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id int) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStreet1 sets the "street1" field.
func (m *AddressMutation) SetStreet1(s string) {
	m.street1 = &s
}

// Street1 returns the value of the "street1" field in the mutation.
func (m *AddressMutation) Street1() (r string, exists bool) {
	v := m.street1
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet1 returns the old "street1" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldStreet1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet1: %w", err)
	}
	return oldValue.Street1, nil
}

// ResetStreet1 resets all changes to the "street1" field.
func (m *AddressMutation) ResetStreet1() {
	m.street1 = nil
}

// SetStreet2 sets the "street2" field.
func (m *AddressMutation) SetStreet2(s string) {
	m.street2 = &s
}

// Street2 returns the value of the "street2" field in the mutation.
func (m *AddressMutation) Street2() (r string, exists bool) {
	v := m.street2
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet2 returns the old "street2" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldStreet2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet2: %w", err)
	}
	return oldValue.Street2, nil
}

// ClearStreet2 clears the value of the "street2" field.
func (m *AddressMutation) ClearStreet2() {
	m.street2 = nil
	m.clearedFields[address.FieldStreet2] = struct{}{}
}

// Street2Cleared returns if the "street2" field was cleared in this mutation.
func (m *AddressMutation) Street2Cleared() bool {
	_, ok := m.clearedFields[address.FieldStreet2]
	return ok
}

// ResetStreet2 resets all changes to the "street2" field.
func (m *AddressMutation) ResetStreet2() {
	m.street2 = nil
	delete(m.clearedFields, address.FieldStreet2)
}

// SetCity sets the "city" field.
func (m *AddressMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AddressMutation) ResetCity() {
	m.city = nil
}

// SetState sets the "state" field.
func (m *AddressMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AddressMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *AddressMutation) ResetState() {
	m.state = nil
}

// SetPostalCode sets the "postal_code" field.
func (m *AddressMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *AddressMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *AddressMutation) ResetPostalCode() {
	m.postal_code = nil
}

// SetCountry sets the "country" field.
func (m *AddressMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *AddressMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *AddressMutation) ResetCountry() {
	m.country = nil
}

// AddUserProfileIDs adds the "user_profiles" edge to the UserProfile entity by ids.
func (m *AddressMutation) AddUserProfileIDs(ids ...int) {
	if m.user_profiles == nil {
		m.user_profiles = make(map[int]struct{})
	}
	for i := range ids {
		m.user_profiles[ids[i]] = struct{}{}
	}
}

// ClearUserProfiles clears the "user_profiles" edge to the UserProfile entity.
func (m *AddressMutation) ClearUserProfiles() {
	m.cleareduser_profiles = true
}

// UserProfilesCleared reports if the "user_profiles" edge to the UserProfile entity was cleared.
func (m *AddressMutation) UserProfilesCleared() bool {
	return m.cleareduser_profiles
}

// RemoveUserProfileIDs removes the "user_profiles" edge to the UserProfile entity by IDs.
func (m *AddressMutation) RemoveUserProfileIDs(ids ...int) {
	if m.removeduser_profiles == nil {
		m.removeduser_profiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_profiles, ids[i])
		m.removeduser_profiles[ids[i]] = struct{}{}
	}
}

// RemovedUserProfiles returns the removed IDs of the "user_profiles" edge to the UserProfile entity.
func (m *AddressMutation) RemovedUserProfilesIDs() (ids []int) {
	for id := range m.removeduser_profiles {
		ids = append(ids, id)
	}
	return
}

// UserProfilesIDs returns the "user_profiles" edge IDs in the mutation.
func (m *AddressMutation) UserProfilesIDs() (ids []int) {
	for id := range m.user_profiles {
		ids = append(ids, id)
	}
	return
}

// ResetUserProfiles resets all changes to the "user_profiles" edge.
func (m *AddressMutation) ResetUserProfiles() {
	m.user_profiles = nil
	m.cleareduser_profiles = false
	m.removeduser_profiles = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *AddressMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *AddressMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *AddressMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *AddressMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *AddressMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *AddressMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *AddressMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Address, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.street1 != nil {
		fields = append(fields, address.FieldStreet1)
	}
	if m.street2 != nil {
		fields = append(fields, address.FieldStreet2)
	}
	if m.city != nil {
		fields = append(fields, address.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, address.FieldState)
	}
	if m.postal_code != nil {
		fields = append(fields, address.FieldPostalCode)
	}
	if m.country != nil {
		fields = append(fields, address.FieldCountry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldStreet1:
		return m.Street1()
	case address.FieldStreet2:
		return m.Street2()
	case address.FieldCity:
		return m.City()
	case address.FieldState:
		return m.State()
	case address.FieldPostalCode:
		return m.PostalCode()
	case address.FieldCountry:
		return m.Country()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldStreet1:
		return m.OldStreet1(ctx)
	case address.FieldStreet2:
		return m.OldStreet2(ctx)
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldState:
		return m.OldState(ctx)
	case address.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case address.FieldCountry:
		return m.OldCountry(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldStreet1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet1(v)
		return nil
	case address.FieldStreet2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet2(v)
		return nil
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case address.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case address.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldStreet2) {
		fields = append(fields, address.FieldStreet2)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldStreet2:
		m.ClearStreet2()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldStreet1:
		m.ResetStreet1()
		return nil
	case address.FieldStreet2:
		m.ResetStreet2()
		return nil
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldState:
		m.ResetState()
		return nil
	case address.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case address.FieldCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_profiles != nil {
		edges = append(edges, address.EdgeUserProfiles)
	}
	if m.events != nil {
		edges = append(edges, address.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeUserProfiles:
		ids := make([]ent.Value, 0, len(m.user_profiles))
		for id := range m.user_profiles {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_profiles != nil {
		edges = append(edges, address.EdgeUserProfiles)
	}
	if m.removedevents != nil {
		edges = append(edges, address.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeUserProfiles:
		ids := make([]ent.Value, 0, len(m.removeduser_profiles))
		for id := range m.removeduser_profiles {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_profiles {
		edges = append(edges, address.EdgeUserProfiles)
	}
	if m.clearedevents {
		edges = append(edges, address.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeUserProfiles:
		return m.cleareduser_profiles
	case address.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeUserProfiles:
		m.ResetUserProfiles()
		return nil
	case address.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// AgendaMutation represents an operation that mutates the Agenda nodes in the graph.
type AgendaMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	status                    *string
	clearedFields             map[string]struct{}
	event                     *int
	clearedevent              bool
	items                     map[int]struct{}
	removeditems              map[int]struct{}
	cleareditems              bool
	mentorship_session        *int
	clearedmentorship_session bool
	done                      bool
	oldValue                  func(context.Context) (*Agenda, error)
	predicates                []predicate.Agenda
}

var _ ent.Mutation = (*AgendaMutation)(nil)

// agendaOption allows management of the mutation configuration using functional options.
type agendaOption func(*AgendaMutation)

// newAgendaMutation creates new mutation for the Agenda entity.
func newAgendaMutation(c config, op Op, opts ...agendaOption) *AgendaMutation {
	m := &AgendaMutation{
		config:        c,
		op:            op,
		typ:           TypeAgenda,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgendaID sets the ID field of the mutation.
func withAgendaID(id int) agendaOption {
	return func(m *AgendaMutation) {
		var (
			err   error
			once  sync.Once
			value *Agenda
		)
		m.oldValue = func(ctx context.Context) (*Agenda, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agenda.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgenda sets the old Agenda of the mutation.
func withAgenda(node *Agenda) agendaOption {
	return func(m *AgendaMutation) {
		m.oldValue = func(context.Context) (*Agenda, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgendaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgendaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgendaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgendaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agenda.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *AgendaMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AgendaMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Agenda entity.
// If the Agenda object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgendaMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AgendaMutation) ResetStatus() {
	m.status = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *AgendaMutation) SetEventID(id int) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *AgendaMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *AgendaMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *AgendaMutation) EventID() (id int, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *AgendaMutation) EventIDs() (ids []int) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *AgendaMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// AddItemIDs adds the "items" edge to the AgendaItem entity by ids.
func (m *AgendaMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the AgendaItem entity.
func (m *AgendaMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the AgendaItem entity was cleared.
func (m *AgendaMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the AgendaItem entity by IDs.
func (m *AgendaMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the AgendaItem entity.
func (m *AgendaMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *AgendaMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *AgendaMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// SetMentorshipSessionID sets the "mentorship_session" edge to the MentorshipSession entity by id.
func (m *AgendaMutation) SetMentorshipSessionID(id int) {
	m.mentorship_session = &id
}

// ClearMentorshipSession clears the "mentorship_session" edge to the MentorshipSession entity.
func (m *AgendaMutation) ClearMentorshipSession() {
	m.clearedmentorship_session = true
}

// MentorshipSessionCleared reports if the "mentorship_session" edge to the MentorshipSession entity was cleared.
func (m *AgendaMutation) MentorshipSessionCleared() bool {
	return m.clearedmentorship_session
}

// MentorshipSessionID returns the "mentorship_session" edge ID in the mutation.
func (m *AgendaMutation) MentorshipSessionID() (id int, exists bool) {
	if m.mentorship_session != nil {
		return *m.mentorship_session, true
	}
	return
}

// MentorshipSessionIDs returns the "mentorship_session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MentorshipSessionID instead. It exists only for internal usage by the builders.
func (m *AgendaMutation) MentorshipSessionIDs() (ids []int) {
	if id := m.mentorship_session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMentorshipSession resets all changes to the "mentorship_session" edge.
func (m *AgendaMutation) ResetMentorshipSession() {
	m.mentorship_session = nil
	m.clearedmentorship_session = false
}

// Where appends a list predicates to the AgendaMutation builder.
func (m *AgendaMutation) Where(ps ...predicate.Agenda) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgendaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgendaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Agenda, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgendaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgendaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Agenda).
func (m *AgendaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgendaMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.status != nil {
		fields = append(fields, agenda.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgendaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agenda.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgendaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agenda.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Agenda field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgendaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agenda.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Agenda field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgendaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgendaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgendaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agenda numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgendaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgendaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgendaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Agenda nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgendaMutation) ResetField(name string) error {
	switch name {
	case agenda.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Agenda field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgendaMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.event != nil {
		edges = append(edges, agenda.EdgeEvent)
	}
	if m.items != nil {
		edges = append(edges, agenda.EdgeItems)
	}
	if m.mentorship_session != nil {
		edges = append(edges, agenda.EdgeMentorshipSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgendaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agenda.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case agenda.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case agenda.EdgeMentorshipSession:
		if id := m.mentorship_session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgendaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeditems != nil {
		edges = append(edges, agenda.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgendaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agenda.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgendaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedevent {
		edges = append(edges, agenda.EdgeEvent)
	}
	if m.cleareditems {
		edges = append(edges, agenda.EdgeItems)
	}
	if m.clearedmentorship_session {
		edges = append(edges, agenda.EdgeMentorshipSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgendaMutation) EdgeCleared(name string) bool {
	switch name {
	case agenda.EdgeEvent:
		return m.clearedevent
	case agenda.EdgeItems:
		return m.cleareditems
	case agenda.EdgeMentorshipSession:
		return m.clearedmentorship_session
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgendaMutation) ClearEdge(name string) error {
	switch name {
	case agenda.EdgeEvent:
		m.ClearEvent()
		return nil
	case agenda.EdgeMentorshipSession:
		m.ClearMentorshipSession()
		return nil
	}
	return fmt.Errorf("unknown Agenda unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgendaMutation) ResetEdge(name string) error {
	switch name {
	case agenda.EdgeEvent:
		m.ResetEvent()
		return nil
	case agenda.EdgeItems:
		m.ResetItems()
		return nil
	case agenda.EdgeMentorshipSession:
		m.ResetMentorshipSession()
		return nil
	}
	return fmt.Errorf("unknown Agenda edge %s", name)
}

// AgendaItemMutation represents an operation that mutates the AgendaItem nodes in the graph.
type AgendaItemMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_order              *int
	add_order           *int
	title               *string
	presenter           *string
	notes               *string
	duration            *int
	addduration         *int
	clearedFields       map[string]struct{}
	agenda              *int
	clearedagenda       bool
	vote                *int
	clearedvote         bool
	action_items        map[int]struct{}
	removedaction_items map[int]struct{}
	clearedaction_items bool
	done                bool
	oldValue            func(context.Context) (*AgendaItem, error)
	predicates          []predicate.AgendaItem
}

var _ ent.Mutation = (*AgendaItemMutation)(nil)

// agendaitemOption allows management of the mutation configuration using functional options.
type agendaitemOption func(*AgendaItemMutation)

// newAgendaItemMutation creates new mutation for the AgendaItem entity.
func newAgendaItemMutation(c config, op Op, opts ...agendaitemOption) *AgendaItemMutation {
	m := &AgendaItemMutation{
		config:        c,
		op:            op,
		typ:           TypeAgendaItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgendaItemID sets the ID field of the mutation.
func withAgendaItemID(id int) agendaitemOption {
	return func(m *AgendaItemMutation) {
		var (
			err   error
			once  sync.Once
			value *AgendaItem
		)
		m.oldValue = func(ctx context.Context) (*AgendaItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgendaItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgendaItem sets the old AgendaItem of the mutation.
func withAgendaItem(node *AgendaItem) agendaitemOption {
	return func(m *AgendaItemMutation) {
		m.oldValue = func(context.Context) (*AgendaItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgendaItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgendaItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgendaItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgendaItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgendaItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *AgendaItemMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *AgendaItemMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the AgendaItem entity.
// If the AgendaItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgendaItemMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *AgendaItemMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *AgendaItemMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *AgendaItemMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetTitle sets the "title" field.
func (m *AgendaItemMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AgendaItemMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the AgendaItem entity.
// If the AgendaItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgendaItemMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AgendaItemMutation) ResetTitle() {
	m.title = nil
}

// SetPresenter sets the "presenter" field.
func (m *AgendaItemMutation) SetPresenter(s string) {
	m.presenter = &s
}

// Presenter returns the value of the "presenter" field in the mutation.
func (m *AgendaItemMutation) Presenter() (r string, exists bool) {
	v := m.presenter
	if v == nil {
		return
	}
	return *v, true
}

// OldPresenter returns the old "presenter" field's value of the AgendaItem entity.
// If the AgendaItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgendaItemMutation) OldPresenter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPresenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPresenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPresenter: %w", err)
	}
	return oldValue.Presenter, nil
}

// ClearPresenter clears the value of the "presenter" field.
func (m *AgendaItemMutation) ClearPresenter() {
	m.presenter = nil
	m.clearedFields[agendaitem.FieldPresenter] = struct{}{}
}

// PresenterCleared returns if the "presenter" field was cleared in this mutation.
func (m *AgendaItemMutation) PresenterCleared() bool {
	_, ok := m.clearedFields[agendaitem.FieldPresenter]
	return ok
}

// ResetPresenter resets all changes to the "presenter" field.
func (m *AgendaItemMutation) ResetPresenter() {
	m.presenter = nil
	delete(m.clearedFields, agendaitem.FieldPresenter)
}

// SetNotes sets the "notes" field.
func (m *AgendaItemMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *AgendaItemMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the AgendaItem entity.
// If the AgendaItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgendaItemMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *AgendaItemMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[agendaitem.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *AgendaItemMutation) NotesCleared() bool {
	_, ok := m.clearedFields[agendaitem.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *AgendaItemMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, agendaitem.FieldNotes)
}

// SetDuration sets the "duration" field.
func (m *AgendaItemMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *AgendaItemMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the AgendaItem entity.
// If the AgendaItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgendaItemMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *AgendaItemMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *AgendaItemMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *AgendaItemMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[agendaitem.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *AgendaItemMutation) DurationCleared() bool {
	_, ok := m.clearedFields[agendaitem.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *AgendaItemMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, agendaitem.FieldDuration)
}

// SetAgendaID sets the "agenda" edge to the Agenda entity by id.
func (m *AgendaItemMutation) SetAgendaID(id int) {
	m.agenda = &id
}

// ClearAgenda clears the "agenda" edge to the Agenda entity.
func (m *AgendaItemMutation) ClearAgenda() {
	m.clearedagenda = true
}

// AgendaCleared reports if the "agenda" edge to the Agenda entity was cleared.
func (m *AgendaItemMutation) AgendaCleared() bool {
	return m.clearedagenda
}

// AgendaID returns the "agenda" edge ID in the mutation.
func (m *AgendaItemMutation) AgendaID() (id int, exists bool) {
	if m.agenda != nil {
		return *m.agenda, true
	}
	return
}

// AgendaIDs returns the "agenda" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgendaID instead. It exists only for internal usage by the builders.
func (m *AgendaItemMutation) AgendaIDs() (ids []int) {
	if id := m.agenda; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgenda resets all changes to the "agenda" edge.
func (m *AgendaItemMutation) ResetAgenda() {
	m.agenda = nil
	m.clearedagenda = false
}

// SetVoteID sets the "vote" edge to the Vote entity by id.
func (m *AgendaItemMutation) SetVoteID(id int) {
	m.vote = &id
}

// ClearVote clears the "vote" edge to the Vote entity.
func (m *AgendaItemMutation) ClearVote() {
	m.clearedvote = true
}

// VoteCleared reports if the "vote" edge to the Vote entity was cleared.
func (m *AgendaItemMutation) VoteCleared() bool {
	return m.clearedvote
}

// VoteID returns the "vote" edge ID in the mutation.
func (m *AgendaItemMutation) VoteID() (id int, exists bool) {
	if m.vote != nil {
		return *m.vote, true
	}
	return
}

// VoteIDs returns the "vote" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VoteID instead. It exists only for internal usage by the builders.
func (m *AgendaItemMutation) VoteIDs() (ids []int) {
	if id := m.vote; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVote resets all changes to the "vote" edge.
func (m *AgendaItemMutation) ResetVote() {
	m.vote = nil
	m.clearedvote = false
}

// AddActionItemIDs adds the "action_items" edge to the ActionItem entity by ids.
func (m *AgendaItemMutation) AddActionItemIDs(ids ...int) {
	if m.action_items == nil {
		m.action_items = make(map[int]struct{})
	}
	for i := range ids {
		m.action_items[ids[i]] = struct{}{}
	}
}

// ClearActionItems clears the "action_items" edge to the ActionItem entity.
func (m *AgendaItemMutation) ClearActionItems() {
	m.clearedaction_items = true
}

// ActionItemsCleared reports if the "action_items" edge to the ActionItem entity was cleared.
func (m *AgendaItemMutation) ActionItemsCleared() bool {
	return m.clearedaction_items
}

// RemoveActionItemIDs removes the "action_items" edge to the ActionItem entity by IDs.
func (m *AgendaItemMutation) RemoveActionItemIDs(ids ...int) {
	if m.removedaction_items == nil {
		m.removedaction_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.action_items, ids[i])
		m.removedaction_items[ids[i]] = struct{}{}
	}
}

// RemovedActionItems returns the removed IDs of the "action_items" edge to the ActionItem entity.
func (m *AgendaItemMutation) RemovedActionItemsIDs() (ids []int) {
	for id := range m.removedaction_items {
		ids = append(ids, id)
	}
	return
}

// ActionItemsIDs returns the "action_items" edge IDs in the mutation.
func (m *AgendaItemMutation) ActionItemsIDs() (ids []int) {
	for id := range m.action_items {
		ids = append(ids, id)
	}
	return
}

// ResetActionItems resets all changes to the "action_items" edge.
func (m *AgendaItemMutation) ResetActionItems() {
	m.action_items = nil
	m.clearedaction_items = false
	m.removedaction_items = nil
}

// Where appends a list predicates to the AgendaItemMutation builder.
func (m *AgendaItemMutation) Where(ps ...predicate.AgendaItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgendaItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgendaItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AgendaItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgendaItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgendaItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AgendaItem).
func (m *AgendaItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgendaItemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._order != nil {
		fields = append(fields, agendaitem.FieldOrder)
	}
	if m.title != nil {
		fields = append(fields, agendaitem.FieldTitle)
	}
	if m.presenter != nil {
		fields = append(fields, agendaitem.FieldPresenter)
	}
	if m.notes != nil {
		fields = append(fields, agendaitem.FieldNotes)
	}
	if m.duration != nil {
		fields = append(fields, agendaitem.FieldDuration)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgendaItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agendaitem.FieldOrder:
		return m.Order()
	case agendaitem.FieldTitle:
		return m.Title()
	case agendaitem.FieldPresenter:
		return m.Presenter()
	case agendaitem.FieldNotes:
		return m.Notes()
	case agendaitem.FieldDuration:
		return m.Duration()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgendaItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agendaitem.FieldOrder:
		return m.OldOrder(ctx)
	case agendaitem.FieldTitle:
		return m.OldTitle(ctx)
	case agendaitem.FieldPresenter:
		return m.OldPresenter(ctx)
	case agendaitem.FieldNotes:
		return m.OldNotes(ctx)
	case agendaitem.FieldDuration:
		return m.OldDuration(ctx)
	}
	return nil, fmt.Errorf("unknown AgendaItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgendaItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agendaitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case agendaitem.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case agendaitem.FieldPresenter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPresenter(v)
		return nil
	case agendaitem.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case agendaitem.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	}
	return fmt.Errorf("unknown AgendaItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgendaItemMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, agendaitem.FieldOrder)
	}
	if m.addduration != nil {
		fields = append(fields, agendaitem.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgendaItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agendaitem.FieldOrder:
		return m.AddedOrder()
	case agendaitem.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgendaItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agendaitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case agendaitem.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown AgendaItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgendaItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agendaitem.FieldPresenter) {
		fields = append(fields, agendaitem.FieldPresenter)
	}
	if m.FieldCleared(agendaitem.FieldNotes) {
		fields = append(fields, agendaitem.FieldNotes)
	}
	if m.FieldCleared(agendaitem.FieldDuration) {
		fields = append(fields, agendaitem.FieldDuration)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgendaItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgendaItemMutation) ClearField(name string) error {
	switch name {
	case agendaitem.FieldPresenter:
		m.ClearPresenter()
		return nil
	case agendaitem.FieldNotes:
		m.ClearNotes()
		return nil
	case agendaitem.FieldDuration:
		m.ClearDuration()
		return nil
	}
	return fmt.Errorf("unknown AgendaItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgendaItemMutation) ResetField(name string) error {
	switch name {
	case agendaitem.FieldOrder:
		m.ResetOrder()
		return nil
	case agendaitem.FieldTitle:
		m.ResetTitle()
		return nil
	case agendaitem.FieldPresenter:
		m.ResetPresenter()
		return nil
	case agendaitem.FieldNotes:
		m.ResetNotes()
		return nil
	case agendaitem.FieldDuration:
		m.ResetDuration()
		return nil
	}
	return fmt.Errorf("unknown AgendaItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgendaItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.agenda != nil {
		edges = append(edges, agendaitem.EdgeAgenda)
	}
	if m.vote != nil {
		edges = append(edges, agendaitem.EdgeVote)
	}
	if m.action_items != nil {
		edges = append(edges, agendaitem.EdgeActionItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgendaItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agendaitem.EdgeAgenda:
		if id := m.agenda; id != nil {
			return []ent.Value{*id}
		}
	case agendaitem.EdgeVote:
		if id := m.vote; id != nil {
			return []ent.Value{*id}
		}
	case agendaitem.EdgeActionItems:
		ids := make([]ent.Value, 0, len(m.action_items))
		for id := range m.action_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgendaItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedaction_items != nil {
		edges = append(edges, agendaitem.EdgeActionItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgendaItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agendaitem.EdgeActionItems:
		ids := make([]ent.Value, 0, len(m.removedaction_items))
		for id := range m.removedaction_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgendaItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedagenda {
		edges = append(edges, agendaitem.EdgeAgenda)
	}
	if m.clearedvote {
		edges = append(edges, agendaitem.EdgeVote)
	}
	if m.clearedaction_items {
		edges = append(edges, agendaitem.EdgeActionItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgendaItemMutation) EdgeCleared(name string) bool {
	switch name {
	case agendaitem.EdgeAgenda:
		return m.clearedagenda
	case agendaitem.EdgeVote:
		return m.clearedvote
	case agendaitem.EdgeActionItems:
		return m.clearedaction_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgendaItemMutation) ClearEdge(name string) error {
	switch name {
	case agendaitem.EdgeAgenda:
		m.ClearAgenda()
		return nil
	case agendaitem.EdgeVote:
		m.ClearVote()
		return nil
	}
	return fmt.Errorf("unknown AgendaItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgendaItemMutation) ResetEdge(name string) error {
	switch name {
	case agendaitem.EdgeAgenda:
		m.ResetAgenda()
		return nil
	case agendaitem.EdgeVote:
		m.ResetVote()
		return nil
	case agendaitem.EdgeActionItems:
		m.ResetActionItems()
		return nil
	}
	return fmt.Errorf("unknown AgendaItem edge %s", name)
}

// AnalyticsDashboardMutation represents an operation that mutates the AnalyticsDashboard nodes in the graph.
type AnalyticsDashboardMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *map[string]string
	description         *map[string]string
	slug                *string
	layout              *map[string]interface{}
	is_default          *bool
	is_public           *bool
	shared_with         *[]string
	appendshared_with   []string
	allowed_roles       *[]string
	appendallowed_roles []string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	owner               *int
	clearedowner        bool
	widgets             map[int]struct{}
	removedwidgets      map[int]struct{}
	clearedwidgets      bool
	done                bool
	oldValue            func(context.Context) (*AnalyticsDashboard, error)
	predicates          []predicate.AnalyticsDashboard
}

var _ ent.Mutation = (*AnalyticsDashboardMutation)(nil)

// analyticsdashboardOption allows management of the mutation configuration using functional options.
type analyticsdashboardOption func(*AnalyticsDashboardMutation)

// newAnalyticsDashboardMutation creates new mutation for the AnalyticsDashboard entity.
func newAnalyticsDashboardMutation(c config, op Op, opts ...analyticsdashboardOption) *AnalyticsDashboardMutation {
	m := &AnalyticsDashboardMutation{
		config:        c,
		op:            op,
		typ:           TypeAnalyticsDashboard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnalyticsDashboardID sets the ID field of the mutation.
func withAnalyticsDashboardID(id int) analyticsdashboardOption {
	return func(m *AnalyticsDashboardMutation) {
		var (
			err   error
			once  sync.Once
			value *AnalyticsDashboard
		)
		m.oldValue = func(ctx context.Context) (*AnalyticsDashboard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AnalyticsDashboard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnalyticsDashboard sets the old AnalyticsDashboard of the mutation.
func withAnalyticsDashboard(node *AnalyticsDashboard) analyticsdashboardOption {
	return func(m *AnalyticsDashboardMutation) {
		m.oldValue = func(context.Context) (*AnalyticsDashboard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnalyticsDashboardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnalyticsDashboardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnalyticsDashboardMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnalyticsDashboardMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AnalyticsDashboard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AnalyticsDashboardMutation) SetName(value map[string]string) {
	m.name = &value
}

// Name returns the value of the "name" field in the mutation.
func (m *AnalyticsDashboardMutation) Name() (r map[string]string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AnalyticsDashboard entity.
// If the AnalyticsDashboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsDashboardMutation) OldName(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AnalyticsDashboardMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AnalyticsDashboardMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *AnalyticsDashboardMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AnalyticsDashboard entity.
// If the AnalyticsDashboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsDashboardMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AnalyticsDashboardMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[analyticsdashboard.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AnalyticsDashboardMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[analyticsdashboard.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AnalyticsDashboardMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, analyticsdashboard.FieldDescription)
}

// SetSlug sets the "slug" field.
func (m *AnalyticsDashboardMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *AnalyticsDashboardMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the AnalyticsDashboard entity.
// If the AnalyticsDashboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsDashboardMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *AnalyticsDashboardMutation) ResetSlug() {
	m.slug = nil
}

// SetLayout sets the "layout" field.
func (m *AnalyticsDashboardMutation) SetLayout(value map[string]interface{}) {
	m.layout = &value
}

// Layout returns the value of the "layout" field in the mutation.
func (m *AnalyticsDashboardMutation) Layout() (r map[string]interface{}, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the AnalyticsDashboard entity.
// If the AnalyticsDashboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsDashboardMutation) OldLayout(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ResetLayout resets all changes to the "layout" field.
func (m *AnalyticsDashboardMutation) ResetLayout() {
	m.layout = nil
}

// SetIsDefault sets the "is_default" field.
func (m *AnalyticsDashboardMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *AnalyticsDashboardMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the AnalyticsDashboard entity.
// If the AnalyticsDashboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsDashboardMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *AnalyticsDashboardMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetIsPublic sets the "is_public" field.
func (m *AnalyticsDashboardMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *AnalyticsDashboardMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the AnalyticsDashboard entity.
// If the AnalyticsDashboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsDashboardMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *AnalyticsDashboardMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetSharedWith sets the "shared_with" field.
func (m *AnalyticsDashboardMutation) SetSharedWith(s []string) {
	m.shared_with = &s
	m.appendshared_with = nil
}

// SharedWith returns the value of the "shared_with" field in the mutation.
func (m *AnalyticsDashboardMutation) SharedWith() (r []string, exists bool) {
	v := m.shared_with
	if v == nil {
		return
	}
	return *v, true
}

// OldSharedWith returns the old "shared_with" field's value of the AnalyticsDashboard entity.
// If the AnalyticsDashboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsDashboardMutation) OldSharedWith(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSharedWith is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSharedWith requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSharedWith: %w", err)
	}
	return oldValue.SharedWith, nil
}

// AppendSharedWith adds s to the "shared_with" field.
func (m *AnalyticsDashboardMutation) AppendSharedWith(s []string) {
	m.appendshared_with = append(m.appendshared_with, s...)
}

// AppendedSharedWith returns the list of values that were appended to the "shared_with" field in this mutation.
func (m *AnalyticsDashboardMutation) AppendedSharedWith() ([]string, bool) {
	if len(m.appendshared_with) == 0 {
		return nil, false
	}
	return m.appendshared_with, true
}

// ClearSharedWith clears the value of the "shared_with" field.
func (m *AnalyticsDashboardMutation) ClearSharedWith() {
	m.shared_with = nil
	m.appendshared_with = nil
	m.clearedFields[analyticsdashboard.FieldSharedWith] = struct{}{}
}

// SharedWithCleared returns if the "shared_with" field was cleared in this mutation.
func (m *AnalyticsDashboardMutation) SharedWithCleared() bool {
	_, ok := m.clearedFields[analyticsdashboard.FieldSharedWith]
	return ok
}

// ResetSharedWith resets all changes to the "shared_with" field.
func (m *AnalyticsDashboardMutation) ResetSharedWith() {
	m.shared_with = nil
	m.appendshared_with = nil
	delete(m.clearedFields, analyticsdashboard.FieldSharedWith)
}

// SetAllowedRoles sets the "allowed_roles" field.
func (m *AnalyticsDashboardMutation) SetAllowedRoles(s []string) {
	m.allowed_roles = &s
	m.appendallowed_roles = nil
}

// AllowedRoles returns the value of the "allowed_roles" field in the mutation.
func (m *AnalyticsDashboardMutation) AllowedRoles() (r []string, exists bool) {
	v := m.allowed_roles
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedRoles returns the old "allowed_roles" field's value of the AnalyticsDashboard entity.
// If the AnalyticsDashboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsDashboardMutation) OldAllowedRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedRoles: %w", err)
	}
	return oldValue.AllowedRoles, nil
}

// AppendAllowedRoles adds s to the "allowed_roles" field.
func (m *AnalyticsDashboardMutation) AppendAllowedRoles(s []string) {
	m.appendallowed_roles = append(m.appendallowed_roles, s...)
}

// AppendedAllowedRoles returns the list of values that were appended to the "allowed_roles" field in this mutation.
func (m *AnalyticsDashboardMutation) AppendedAllowedRoles() ([]string, bool) {
	if len(m.appendallowed_roles) == 0 {
		return nil, false
	}
	return m.appendallowed_roles, true
}

// ResetAllowedRoles resets all changes to the "allowed_roles" field.
func (m *AnalyticsDashboardMutation) ResetAllowedRoles() {
	m.allowed_roles = nil
	m.appendallowed_roles = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AnalyticsDashboardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AnalyticsDashboardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AnalyticsDashboard entity.
// If the AnalyticsDashboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsDashboardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AnalyticsDashboardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AnalyticsDashboardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AnalyticsDashboardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AnalyticsDashboard entity.
// If the AnalyticsDashboard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsDashboardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AnalyticsDashboardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *AnalyticsDashboardMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AnalyticsDashboardMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AnalyticsDashboardMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AnalyticsDashboardMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AnalyticsDashboardMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AnalyticsDashboardMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddWidgetIDs adds the "widgets" edge to the DashboardWidget entity by ids.
func (m *AnalyticsDashboardMutation) AddWidgetIDs(ids ...int) {
	if m.widgets == nil {
		m.widgets = make(map[int]struct{})
	}
	for i := range ids {
		m.widgets[ids[i]] = struct{}{}
	}
}

// ClearWidgets clears the "widgets" edge to the DashboardWidget entity.
func (m *AnalyticsDashboardMutation) ClearWidgets() {
	m.clearedwidgets = true
}

// WidgetsCleared reports if the "widgets" edge to the DashboardWidget entity was cleared.
func (m *AnalyticsDashboardMutation) WidgetsCleared() bool {
	return m.clearedwidgets
}

// RemoveWidgetIDs removes the "widgets" edge to the DashboardWidget entity by IDs.
func (m *AnalyticsDashboardMutation) RemoveWidgetIDs(ids ...int) {
	if m.removedwidgets == nil {
		m.removedwidgets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.widgets, ids[i])
		m.removedwidgets[ids[i]] = struct{}{}
	}
}

// RemovedWidgets returns the removed IDs of the "widgets" edge to the DashboardWidget entity.
func (m *AnalyticsDashboardMutation) RemovedWidgetsIDs() (ids []int) {
	for id := range m.removedwidgets {
		ids = append(ids, id)
	}
	return
}

// WidgetsIDs returns the "widgets" edge IDs in the mutation.
func (m *AnalyticsDashboardMutation) WidgetsIDs() (ids []int) {
	for id := range m.widgets {
		ids = append(ids, id)
	}
	return
}

// ResetWidgets resets all changes to the "widgets" edge.
func (m *AnalyticsDashboardMutation) ResetWidgets() {
	m.widgets = nil
	m.clearedwidgets = false
	m.removedwidgets = nil
}

// Where appends a list predicates to the AnalyticsDashboardMutation builder.
func (m *AnalyticsDashboardMutation) Where(ps ...predicate.AnalyticsDashboard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnalyticsDashboardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnalyticsDashboardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AnalyticsDashboard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnalyticsDashboardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnalyticsDashboardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AnalyticsDashboard).
func (m *AnalyticsDashboardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnalyticsDashboardMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, analyticsdashboard.FieldName)
	}
	if m.description != nil {
		fields = append(fields, analyticsdashboard.FieldDescription)
	}
	if m.slug != nil {
		fields = append(fields, analyticsdashboard.FieldSlug)
	}
	if m.layout != nil {
		fields = append(fields, analyticsdashboard.FieldLayout)
	}
	if m.is_default != nil {
		fields = append(fields, analyticsdashboard.FieldIsDefault)
	}
	if m.is_public != nil {
		fields = append(fields, analyticsdashboard.FieldIsPublic)
	}
	if m.shared_with != nil {
		fields = append(fields, analyticsdashboard.FieldSharedWith)
	}
	if m.allowed_roles != nil {
		fields = append(fields, analyticsdashboard.FieldAllowedRoles)
	}
	if m.created_at != nil {
		fields = append(fields, analyticsdashboard.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, analyticsdashboard.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnalyticsDashboardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case analyticsdashboard.FieldName:
		return m.Name()
	case analyticsdashboard.FieldDescription:
		return m.Description()
	case analyticsdashboard.FieldSlug:
		return m.Slug()
	case analyticsdashboard.FieldLayout:
		return m.Layout()
	case analyticsdashboard.FieldIsDefault:
		return m.IsDefault()
	case analyticsdashboard.FieldIsPublic:
		return m.IsPublic()
	case analyticsdashboard.FieldSharedWith:
		return m.SharedWith()
	case analyticsdashboard.FieldAllowedRoles:
		return m.AllowedRoles()
	case analyticsdashboard.FieldCreatedAt:
		return m.CreatedAt()
	case analyticsdashboard.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnalyticsDashboardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case analyticsdashboard.FieldName:
		return m.OldName(ctx)
	case analyticsdashboard.FieldDescription:
		return m.OldDescription(ctx)
	case analyticsdashboard.FieldSlug:
		return m.OldSlug(ctx)
	case analyticsdashboard.FieldLayout:
		return m.OldLayout(ctx)
	case analyticsdashboard.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case analyticsdashboard.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case analyticsdashboard.FieldSharedWith:
		return m.OldSharedWith(ctx)
	case analyticsdashboard.FieldAllowedRoles:
		return m.OldAllowedRoles(ctx)
	case analyticsdashboard.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case analyticsdashboard.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AnalyticsDashboard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnalyticsDashboardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case analyticsdashboard.FieldName:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case analyticsdashboard.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case analyticsdashboard.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case analyticsdashboard.FieldLayout:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case analyticsdashboard.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case analyticsdashboard.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case analyticsdashboard.FieldSharedWith:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSharedWith(v)
		return nil
	case analyticsdashboard.FieldAllowedRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedRoles(v)
		return nil
	case analyticsdashboard.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case analyticsdashboard.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AnalyticsDashboard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnalyticsDashboardMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnalyticsDashboardMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnalyticsDashboardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AnalyticsDashboard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnalyticsDashboardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(analyticsdashboard.FieldDescription) {
		fields = append(fields, analyticsdashboard.FieldDescription)
	}
	if m.FieldCleared(analyticsdashboard.FieldSharedWith) {
		fields = append(fields, analyticsdashboard.FieldSharedWith)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnalyticsDashboardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnalyticsDashboardMutation) ClearField(name string) error {
	switch name {
	case analyticsdashboard.FieldDescription:
		m.ClearDescription()
		return nil
	case analyticsdashboard.FieldSharedWith:
		m.ClearSharedWith()
		return nil
	}
	return fmt.Errorf("unknown AnalyticsDashboard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnalyticsDashboardMutation) ResetField(name string) error {
	switch name {
	case analyticsdashboard.FieldName:
		m.ResetName()
		return nil
	case analyticsdashboard.FieldDescription:
		m.ResetDescription()
		return nil
	case analyticsdashboard.FieldSlug:
		m.ResetSlug()
		return nil
	case analyticsdashboard.FieldLayout:
		m.ResetLayout()
		return nil
	case analyticsdashboard.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case analyticsdashboard.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case analyticsdashboard.FieldSharedWith:
		m.ResetSharedWith()
		return nil
	case analyticsdashboard.FieldAllowedRoles:
		m.ResetAllowedRoles()
		return nil
	case analyticsdashboard.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case analyticsdashboard.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AnalyticsDashboard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnalyticsDashboardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, analyticsdashboard.EdgeOwner)
	}
	if m.widgets != nil {
		edges = append(edges, analyticsdashboard.EdgeWidgets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnalyticsDashboardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case analyticsdashboard.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case analyticsdashboard.EdgeWidgets:
		ids := make([]ent.Value, 0, len(m.widgets))
		for id := range m.widgets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnalyticsDashboardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedwidgets != nil {
		edges = append(edges, analyticsdashboard.EdgeWidgets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnalyticsDashboardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case analyticsdashboard.EdgeWidgets:
		ids := make([]ent.Value, 0, len(m.removedwidgets))
		for id := range m.removedwidgets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnalyticsDashboardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, analyticsdashboard.EdgeOwner)
	}
	if m.clearedwidgets {
		edges = append(edges, analyticsdashboard.EdgeWidgets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnalyticsDashboardMutation) EdgeCleared(name string) bool {
	switch name {
	case analyticsdashboard.EdgeOwner:
		return m.clearedowner
	case analyticsdashboard.EdgeWidgets:
		return m.clearedwidgets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnalyticsDashboardMutation) ClearEdge(name string) error {
	switch name {
	case analyticsdashboard.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown AnalyticsDashboard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnalyticsDashboardMutation) ResetEdge(name string) error {
	switch name {
	case analyticsdashboard.EdgeOwner:
		m.ResetOwner()
		return nil
	case analyticsdashboard.EdgeWidgets:
		m.ResetWidgets()
		return nil
	}
	return fmt.Errorf("unknown AnalyticsDashboard edge %s", name)
}

// AnalyticsEventMutation represents an operation that mutates the AnalyticsEvent nodes in the graph.
type AnalyticsEventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	event_name    *string
	properties    *map[string]interface{}
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*AnalyticsEvent, error)
	predicates    []predicate.AnalyticsEvent
}

var _ ent.Mutation = (*AnalyticsEventMutation)(nil)

// analyticseventOption allows management of the mutation configuration using functional options.
type analyticseventOption func(*AnalyticsEventMutation)

// newAnalyticsEventMutation creates new mutation for the AnalyticsEvent entity.
func newAnalyticsEventMutation(c config, op Op, opts ...analyticseventOption) *AnalyticsEventMutation {
	m := &AnalyticsEventMutation{
		config:        c,
		op:            op,
		typ:           TypeAnalyticsEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnalyticsEventID sets the ID field of the mutation.
func withAnalyticsEventID(id int) analyticseventOption {
	return func(m *AnalyticsEventMutation) {
		var (
			err   error
			once  sync.Once
			value *AnalyticsEvent
		)
		m.oldValue = func(ctx context.Context) (*AnalyticsEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AnalyticsEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnalyticsEvent sets the old AnalyticsEvent of the mutation.
func withAnalyticsEvent(node *AnalyticsEvent) analyticseventOption {
	return func(m *AnalyticsEventMutation) {
		m.oldValue = func(context.Context) (*AnalyticsEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnalyticsEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnalyticsEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnalyticsEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnalyticsEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AnalyticsEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventName sets the "event_name" field.
func (m *AnalyticsEventMutation) SetEventName(s string) {
	m.event_name = &s
}

// EventName returns the value of the "event_name" field in the mutation.
func (m *AnalyticsEventMutation) EventName() (r string, exists bool) {
	v := m.event_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEventName returns the old "event_name" field's value of the AnalyticsEvent entity.
// If the AnalyticsEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsEventMutation) OldEventName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventName: %w", err)
	}
	return oldValue.EventName, nil
}

// ResetEventName resets all changes to the "event_name" field.
func (m *AnalyticsEventMutation) ResetEventName() {
	m.event_name = nil
}

// SetProperties sets the "properties" field.
func (m *AnalyticsEventMutation) SetProperties(value map[string]interface{}) {
	m.properties = &value
}

// Properties returns the value of the "properties" field in the mutation.
func (m *AnalyticsEventMutation) Properties() (r map[string]interface{}, exists bool) {
	v := m.properties
	if v == nil {
		return
	}
	return *v, true
}

// OldProperties returns the old "properties" field's value of the AnalyticsEvent entity.
// If the AnalyticsEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsEventMutation) OldProperties(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProperties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProperties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProperties: %w", err)
	}
	return oldValue.Properties, nil
}

// ResetProperties resets all changes to the "properties" field.
func (m *AnalyticsEventMutation) ResetProperties() {
	m.properties = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AnalyticsEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AnalyticsEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AnalyticsEvent entity.
// If the AnalyticsEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnalyticsEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AnalyticsEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AnalyticsEventMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AnalyticsEventMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AnalyticsEventMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AnalyticsEventMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AnalyticsEventMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AnalyticsEventMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AnalyticsEventMutation builder.
func (m *AnalyticsEventMutation) Where(ps ...predicate.AnalyticsEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnalyticsEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnalyticsEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AnalyticsEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnalyticsEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnalyticsEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AnalyticsEvent).
func (m *AnalyticsEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnalyticsEventMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.event_name != nil {
		fields = append(fields, analyticsevent.FieldEventName)
	}
	if m.properties != nil {
		fields = append(fields, analyticsevent.FieldProperties)
	}
	if m.created_at != nil {
		fields = append(fields, analyticsevent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnalyticsEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case analyticsevent.FieldEventName:
		return m.EventName()
	case analyticsevent.FieldProperties:
		return m.Properties()
	case analyticsevent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnalyticsEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case analyticsevent.FieldEventName:
		return m.OldEventName(ctx)
	case analyticsevent.FieldProperties:
		return m.OldProperties(ctx)
	case analyticsevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AnalyticsEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnalyticsEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case analyticsevent.FieldEventName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventName(v)
		return nil
	case analyticsevent.FieldProperties:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProperties(v)
		return nil
	case analyticsevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AnalyticsEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnalyticsEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnalyticsEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnalyticsEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AnalyticsEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnalyticsEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnalyticsEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnalyticsEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AnalyticsEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnalyticsEventMutation) ResetField(name string) error {
	switch name {
	case analyticsevent.FieldEventName:
		m.ResetEventName()
		return nil
	case analyticsevent.FieldProperties:
		m.ResetProperties()
		return nil
	case analyticsevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AnalyticsEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnalyticsEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, analyticsevent.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnalyticsEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case analyticsevent.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnalyticsEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnalyticsEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnalyticsEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, analyticsevent.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnalyticsEventMutation) EdgeCleared(name string) bool {
	switch name {
	case analyticsevent.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnalyticsEventMutation) ClearEdge(name string) error {
	switch name {
	case analyticsevent.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AnalyticsEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnalyticsEventMutation) ResetEdge(name string) error {
	switch name {
	case analyticsevent.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AnalyticsEvent edge %s", name)
}

// AppSettingMutation represents an operation that mutates the AppSetting nodes in the graph.
type AppSettingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	value         *map[string]interface{}
	group         *string
	description   *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppSetting, error)
	predicates    []predicate.AppSetting
}

var _ ent.Mutation = (*AppSettingMutation)(nil)

// appsettingOption allows management of the mutation configuration using functional options.
type appsettingOption func(*AppSettingMutation)

// newAppSettingMutation creates new mutation for the AppSetting entity.
func newAppSettingMutation(c config, op Op, opts ...appsettingOption) *AppSettingMutation {
	m := &AppSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeAppSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppSettingID sets the ID field of the mutation.
func withAppSettingID(id string) appsettingOption {
	return func(m *AppSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *AppSetting
		)
		m.oldValue = func(ctx context.Context) (*AppSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppSetting sets the old AppSetting of the mutation.
func withAppSetting(node *AppSetting) appsettingOption {
	return func(m *AppSettingMutation) {
		m.oldValue = func(context.Context) (*AppSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppSetting entities.
func (m *AppSettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppSettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppSettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *AppSettingMutation) SetValue(value map[string]interface{}) {
	m.value = &value
}

// Value returns the value of the "value" field in the mutation.
func (m *AppSettingMutation) Value() (r map[string]interface{}, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the AppSetting entity.
// If the AppSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSettingMutation) OldValue(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AppSettingMutation) ResetValue() {
	m.value = nil
}

// SetGroup sets the "group" field.
func (m *AppSettingMutation) SetGroup(s string) {
	m.group = &s
}

// Group returns the value of the "group" field in the mutation.
func (m *AppSettingMutation) Group() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the AppSetting entity.
// If the AppSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSettingMutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "group" field.
func (m *AppSettingMutation) ResetGroup() {
	m.group = nil
}

// SetDescription sets the "description" field.
func (m *AppSettingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppSettingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AppSetting entity.
// If the AppSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSettingMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppSettingMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[appsetting.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppSettingMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[appsetting.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppSettingMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, appsetting.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *AppSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppSetting entity.
// If the AppSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppSettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppSetting entity.
// If the AppSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the AppSettingMutation builder.
func (m *AppSettingMutation) Where(ps ...predicate.AppSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppSetting).
func (m *AppSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppSettingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.value != nil {
		fields = append(fields, appsetting.FieldValue)
	}
	if m.group != nil {
		fields = append(fields, appsetting.FieldGroup)
	}
	if m.description != nil {
		fields = append(fields, appsetting.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, appsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appsetting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appsetting.FieldValue:
		return m.Value()
	case appsetting.FieldGroup:
		return m.Group()
	case appsetting.FieldDescription:
		return m.Description()
	case appsetting.FieldCreatedAt:
		return m.CreatedAt()
	case appsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appsetting.FieldValue:
		return m.OldValue(ctx)
	case appsetting.FieldGroup:
		return m.OldGroup(ctx)
	case appsetting.FieldDescription:
		return m.OldDescription(ctx)
	case appsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appsetting.FieldValue:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case appsetting.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case appsetting.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case appsetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appsetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppSettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppSettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appsetting.FieldDescription) {
		fields = append(fields, appsetting.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppSettingMutation) ClearField(name string) error {
	switch name {
	case appsetting.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AppSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppSettingMutation) ResetField(name string) error {
	switch name {
	case appsetting.FieldValue:
		m.ResetValue()
		return nil
	case appsetting.FieldGroup:
		m.ResetGroup()
		return nil
	case appsetting.FieldDescription:
		m.ResetDescription()
		return nil
	case appsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppSettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppSettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppSettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppSettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppSetting edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	action        *string
	meta          *map[string]interface{}
	created_at    *time.Time
	entity_id     *string
	entity_type   *string
	clearedFields map[string]struct{}
	actor         *int
	clearedactor  bool
	done          bool
	oldValue      func(context.Context) (*AuditLog, error)
	predicates    []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id int) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetMeta sets the "meta" field.
func (m *AuditLogMutation) SetMeta(value map[string]interface{}) {
	m.meta = &value
}

// Meta returns the value of the "meta" field in the mutation.
func (m *AuditLogMutation) Meta() (r map[string]interface{}, exists bool) {
	v := m.meta
	if v == nil {
		return
	}
	return *v, true
}

// OldMeta returns the old "meta" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMeta(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeta: %w", err)
	}
	return oldValue.Meta, nil
}

// ClearMeta clears the value of the "meta" field.
func (m *AuditLogMutation) ClearMeta() {
	m.meta = nil
	m.clearedFields[auditlog.FieldMeta] = struct{}{}
}

// MetaCleared returns if the "meta" field was cleared in this mutation.
func (m *AuditLogMutation) MetaCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldMeta]
	return ok
}

// ResetMeta resets all changes to the "meta" field.
func (m *AuditLogMutation) ResetMeta() {
	m.meta = nil
	delete(m.clearedFields, auditlog.FieldMeta)
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEntityID sets the "entity_id" field.
func (m *AuditLogMutation) SetEntityID(s string) {
	m.entity_id = &s
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *AuditLogMutation) EntityID() (r string, exists bool) {
	v := m.entity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldEntityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ClearEntityID clears the value of the "entity_id" field.
func (m *AuditLogMutation) ClearEntityID() {
	m.entity_id = nil
	m.clearedFields[auditlog.FieldEntityID] = struct{}{}
}

// EntityIDCleared returns if the "entity_id" field was cleared in this mutation.
func (m *AuditLogMutation) EntityIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldEntityID]
	return ok
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *AuditLogMutation) ResetEntityID() {
	m.entity_id = nil
	delete(m.clearedFields, auditlog.FieldEntityID)
}

// SetEntityType sets the "entity_type" field.
func (m *AuditLogMutation) SetEntityType(s string) {
	m.entity_type = &s
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *AuditLogMutation) EntityType() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldEntityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ClearEntityType clears the value of the "entity_type" field.
func (m *AuditLogMutation) ClearEntityType() {
	m.entity_type = nil
	m.clearedFields[auditlog.FieldEntityType] = struct{}{}
}

// EntityTypeCleared returns if the "entity_type" field was cleared in this mutation.
func (m *AuditLogMutation) EntityTypeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldEntityType]
	return ok
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *AuditLogMutation) ResetEntityType() {
	m.entity_type = nil
	delete(m.clearedFields, auditlog.FieldEntityType)
}

// SetActorID sets the "actor" edge to the User entity by id.
func (m *AuditLogMutation) SetActorID(id int) {
	m.actor = &id
}

// ClearActor clears the "actor" edge to the User entity.
func (m *AuditLogMutation) ClearActor() {
	m.clearedactor = true
}

// ActorCleared reports if the "actor" edge to the User entity was cleared.
func (m *AuditLogMutation) ActorCleared() bool {
	return m.clearedactor
}

// ActorID returns the "actor" edge ID in the mutation.
func (m *AuditLogMutation) ActorID() (id int, exists bool) {
	if m.actor != nil {
		return *m.actor, true
	}
	return
}

// ActorIDs returns the "actor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActorID instead. It exists only for internal usage by the builders.
func (m *AuditLogMutation) ActorIDs() (ids []int) {
	if id := m.actor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActor resets all changes to the "actor" edge.
func (m *AuditLogMutation) ResetActor() {
	m.actor = nil
	m.clearedactor = false
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m.meta != nil {
		fields = append(fields, auditlog.FieldMeta)
	}
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	if m.entity_id != nil {
		fields = append(fields, auditlog.FieldEntityID)
	}
	if m.entity_type != nil {
		fields = append(fields, auditlog.FieldEntityType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldMeta:
		return m.Meta()
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	case auditlog.FieldEntityID:
		return m.EntityID()
	case auditlog.FieldEntityType:
		return m.EntityType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldMeta:
		return m.OldMeta(ctx)
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auditlog.FieldEntityID:
		return m.OldEntityID(ctx)
	case auditlog.FieldEntityType:
		return m.OldEntityType(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldMeta:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeta(v)
		return nil
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auditlog.FieldEntityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case auditlog.FieldEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldMeta) {
		fields = append(fields, auditlog.FieldMeta)
	}
	if m.FieldCleared(auditlog.FieldEntityID) {
		fields = append(fields, auditlog.FieldEntityID)
	}
	if m.FieldCleared(auditlog.FieldEntityType) {
		fields = append(fields, auditlog.FieldEntityType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldMeta:
		m.ClearMeta()
		return nil
	case auditlog.FieldEntityID:
		m.ClearEntityID()
		return nil
	case auditlog.FieldEntityType:
		m.ClearEntityType()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldMeta:
		m.ResetMeta()
		return nil
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auditlog.FieldEntityID:
		m.ResetEntityID()
		return nil
	case auditlog.FieldEntityType:
		m.ResetEntityType()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.actor != nil {
		edges = append(edges, auditlog.EdgeActor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auditlog.EdgeActor:
		if id := m.actor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedactor {
		edges = append(edges, auditlog.EdgeActor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	switch name {
	case auditlog.EdgeActor:
		return m.clearedactor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	switch name {
	case auditlog.EdgeActor:
		m.ClearActor()
		return nil
	}
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	switch name {
	case auditlog.EdgeActor:
		m.ResetActor()
		return nil
	}
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// BadgeMutation represents an operation that mutates the Badge nodes in the graph.
type BadgeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *map[string]string
	description              *map[string]string
	image_url                *string
	criteria                 *string
	clearedFields            map[string]struct{}
	user_achievements        map[int]struct{}
	removeduser_achievements map[int]struct{}
	cleareduser_achievements bool
	done                     bool
	oldValue                 func(context.Context) (*Badge, error)
	predicates               []predicate.Badge
}

var _ ent.Mutation = (*BadgeMutation)(nil)

// badgeOption allows management of the mutation configuration using functional options.
type badgeOption func(*BadgeMutation)

// newBadgeMutation creates new mutation for the Badge entity.
func newBadgeMutation(c config, op Op, opts ...badgeOption) *BadgeMutation {
	m := &BadgeMutation{
		config:        c,
		op:            op,
		typ:           TypeBadge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBadgeID sets the ID field of the mutation.
func withBadgeID(id int) badgeOption {
	return func(m *BadgeMutation) {
		var (
			err   error
			once  sync.Once
			value *Badge
		)
		m.oldValue = func(ctx context.Context) (*Badge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Badge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBadge sets the old Badge of the mutation.
func withBadge(node *Badge) badgeOption {
	return func(m *BadgeMutation) {
		m.oldValue = func(context.Context) (*Badge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BadgeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BadgeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BadgeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BadgeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Badge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BadgeMutation) SetName(value map[string]string) {
	m.name = &value
}

// Name returns the value of the "name" field in the mutation.
func (m *BadgeMutation) Name() (r map[string]string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldName(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BadgeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BadgeMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BadgeMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BadgeMutation) ResetDescription() {
	m.description = nil
}

// SetImageURL sets the "image_url" field.
func (m *BadgeMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *BadgeMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *BadgeMutation) ResetImageURL() {
	m.image_url = nil
}

// SetCriteria sets the "criteria" field.
func (m *BadgeMutation) SetCriteria(s string) {
	m.criteria = &s
}

// Criteria returns the value of the "criteria" field in the mutation.
func (m *BadgeMutation) Criteria() (r string, exists bool) {
	v := m.criteria
	if v == nil {
		return
	}
	return *v, true
}

// OldCriteria returns the old "criteria" field's value of the Badge entity.
// If the Badge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BadgeMutation) OldCriteria(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCriteria: %w", err)
	}
	return oldValue.Criteria, nil
}

// ResetCriteria resets all changes to the "criteria" field.
func (m *BadgeMutation) ResetCriteria() {
	m.criteria = nil
}

// AddUserAchievementIDs adds the "user_achievements" edge to the UserAchievement entity by ids.
func (m *BadgeMutation) AddUserAchievementIDs(ids ...int) {
	if m.user_achievements == nil {
		m.user_achievements = make(map[int]struct{})
	}
	for i := range ids {
		m.user_achievements[ids[i]] = struct{}{}
	}
}

// ClearUserAchievements clears the "user_achievements" edge to the UserAchievement entity.
func (m *BadgeMutation) ClearUserAchievements() {
	m.cleareduser_achievements = true
}

// UserAchievementsCleared reports if the "user_achievements" edge to the UserAchievement entity was cleared.
func (m *BadgeMutation) UserAchievementsCleared() bool {
	return m.cleareduser_achievements
}

// RemoveUserAchievementIDs removes the "user_achievements" edge to the UserAchievement entity by IDs.
func (m *BadgeMutation) RemoveUserAchievementIDs(ids ...int) {
	if m.removeduser_achievements == nil {
		m.removeduser_achievements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_achievements, ids[i])
		m.removeduser_achievements[ids[i]] = struct{}{}
	}
}

// RemovedUserAchievements returns the removed IDs of the "user_achievements" edge to the UserAchievement entity.
func (m *BadgeMutation) RemovedUserAchievementsIDs() (ids []int) {
	for id := range m.removeduser_achievements {
		ids = append(ids, id)
	}
	return
}

// UserAchievementsIDs returns the "user_achievements" edge IDs in the mutation.
func (m *BadgeMutation) UserAchievementsIDs() (ids []int) {
	for id := range m.user_achievements {
		ids = append(ids, id)
	}
	return
}

// ResetUserAchievements resets all changes to the "user_achievements" edge.
func (m *BadgeMutation) ResetUserAchievements() {
	m.user_achievements = nil
	m.cleareduser_achievements = false
	m.removeduser_achievements = nil
}

// Where appends a list predicates to the BadgeMutation builder.
func (m *BadgeMutation) Where(ps ...predicate.Badge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BadgeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BadgeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Badge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BadgeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BadgeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Badge).
func (m *BadgeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BadgeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, badge.FieldName)
	}
	if m.description != nil {
		fields = append(fields, badge.FieldDescription)
	}
	if m.image_url != nil {
		fields = append(fields, badge.FieldImageURL)
	}
	if m.criteria != nil {
		fields = append(fields, badge.FieldCriteria)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BadgeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case badge.FieldName:
		return m.Name()
	case badge.FieldDescription:
		return m.Description()
	case badge.FieldImageURL:
		return m.ImageURL()
	case badge.FieldCriteria:
		return m.Criteria()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BadgeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case badge.FieldName:
		return m.OldName(ctx)
	case badge.FieldDescription:
		return m.OldDescription(ctx)
	case badge.FieldImageURL:
		return m.OldImageURL(ctx)
	case badge.FieldCriteria:
		return m.OldCriteria(ctx)
	}
	return nil, fmt.Errorf("unknown Badge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BadgeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case badge.FieldName:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case badge.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case badge.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case badge.FieldCriteria:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCriteria(v)
		return nil
	}
	return fmt.Errorf("unknown Badge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BadgeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BadgeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BadgeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Badge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BadgeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BadgeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BadgeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Badge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BadgeMutation) ResetField(name string) error {
	switch name {
	case badge.FieldName:
		m.ResetName()
		return nil
	case badge.FieldDescription:
		m.ResetDescription()
		return nil
	case badge.FieldImageURL:
		m.ResetImageURL()
		return nil
	case badge.FieldCriteria:
		m.ResetCriteria()
		return nil
	}
	return fmt.Errorf("unknown Badge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BadgeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_achievements != nil {
		edges = append(edges, badge.EdgeUserAchievements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BadgeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case badge.EdgeUserAchievements:
		ids := make([]ent.Value, 0, len(m.user_achievements))
		for id := range m.user_achievements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BadgeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_achievements != nil {
		edges = append(edges, badge.EdgeUserAchievements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BadgeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case badge.EdgeUserAchievements:
		ids := make([]ent.Value, 0, len(m.removeduser_achievements))
		for id := range m.removeduser_achievements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BadgeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_achievements {
		edges = append(edges, badge.EdgeUserAchievements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BadgeMutation) EdgeCleared(name string) bool {
	switch name {
	case badge.EdgeUserAchievements:
		return m.cleareduser_achievements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BadgeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Badge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BadgeMutation) ResetEdge(name string) error {
	switch name {
	case badge.EdgeUserAchievements:
		m.ResetUserAchievements()
		return nil
	}
	return fmt.Errorf("unknown Badge edge %s", name)
}

// BallotMutation represents an operation that mutates the Ballot nodes in the graph.
type BallotMutation struct {
	config
	op            Op
	typ           string
	id            *int
	voter_id      *string
	choice        *string
	cast_at       *time.Time
	clearedFields map[string]struct{}
	vote          *int
	clearedvote   bool
	done          bool
	oldValue      func(context.Context) (*Ballot, error)
	predicates    []predicate.Ballot
}

var _ ent.Mutation = (*BallotMutation)(nil)

// ballotOption allows management of the mutation configuration using functional options.
type ballotOption func(*BallotMutation)

// newBallotMutation creates new mutation for the Ballot entity.
func newBallotMutation(c config, op Op, opts ...ballotOption) *BallotMutation {
	m := &BallotMutation{
		config:        c,
		op:            op,
		typ:           TypeBallot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBallotID sets the ID field of the mutation.
func withBallotID(id int) ballotOption {
	return func(m *BallotMutation) {
		var (
			err   error
			once  sync.Once
			value *Ballot
		)
		m.oldValue = func(ctx context.Context) (*Ballot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ballot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBallot sets the old Ballot of the mutation.
func withBallot(node *Ballot) ballotOption {
	return func(m *BallotMutation) {
		m.oldValue = func(context.Context) (*Ballot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BallotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BallotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BallotMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BallotMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ballot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVoterID sets the "voter_id" field.
func (m *BallotMutation) SetVoterID(s string) {
	m.voter_id = &s
}

// VoterID returns the value of the "voter_id" field in the mutation.
func (m *BallotMutation) VoterID() (r string, exists bool) {
	v := m.voter_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVoterID returns the old "voter_id" field's value of the Ballot entity.
// If the Ballot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BallotMutation) OldVoterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoterID: %w", err)
	}
	return oldValue.VoterID, nil
}

// ResetVoterID resets all changes to the "voter_id" field.
func (m *BallotMutation) ResetVoterID() {
	m.voter_id = nil
}

// SetChoice sets the "choice" field.
func (m *BallotMutation) SetChoice(s string) {
	m.choice = &s
}

// Choice returns the value of the "choice" field in the mutation.
func (m *BallotMutation) Choice() (r string, exists bool) {
	v := m.choice
	if v == nil {
		return
	}
	return *v, true
}

// OldChoice returns the old "choice" field's value of the Ballot entity.
// If the Ballot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BallotMutation) OldChoice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChoice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChoice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChoice: %w", err)
	}
	return oldValue.Choice, nil
}

// ResetChoice resets all changes to the "choice" field.
func (m *BallotMutation) ResetChoice() {
	m.choice = nil
}

// SetCastAt sets the "cast_at" field.
func (m *BallotMutation) SetCastAt(t time.Time) {
	m.cast_at = &t
}

// CastAt returns the value of the "cast_at" field in the mutation.
func (m *BallotMutation) CastAt() (r time.Time, exists bool) {
	v := m.cast_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCastAt returns the old "cast_at" field's value of the Ballot entity.
// If the Ballot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BallotMutation) OldCastAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCastAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCastAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCastAt: %w", err)
	}
	return oldValue.CastAt, nil
}

// ResetCastAt resets all changes to the "cast_at" field.
func (m *BallotMutation) ResetCastAt() {
	m.cast_at = nil
}

// SetVoteID sets the "vote" edge to the Vote entity by id.
func (m *BallotMutation) SetVoteID(id int) {
	m.vote = &id
}

// ClearVote clears the "vote" edge to the Vote entity.
func (m *BallotMutation) ClearVote() {
	m.clearedvote = true
}

// VoteCleared reports if the "vote" edge to the Vote entity was cleared.
func (m *BallotMutation) VoteCleared() bool {
	return m.clearedvote
}

// VoteID returns the "vote" edge ID in the mutation.
func (m *BallotMutation) VoteID() (id int, exists bool) {
	if m.vote != nil {
		return *m.vote, true
	}
	return
}

// VoteIDs returns the "vote" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VoteID instead. It exists only for internal usage by the builders.
func (m *BallotMutation) VoteIDs() (ids []int) {
	if id := m.vote; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVote resets all changes to the "vote" edge.
func (m *BallotMutation) ResetVote() {
	m.vote = nil
	m.clearedvote = false
}

// Where appends a list predicates to the BallotMutation builder.
func (m *BallotMutation) Where(ps ...predicate.Ballot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BallotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BallotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ballot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BallotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BallotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ballot).
func (m *BallotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BallotMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.voter_id != nil {
		fields = append(fields, ballot.FieldVoterID)
	}
	if m.choice != nil {
		fields = append(fields, ballot.FieldChoice)
	}
	if m.cast_at != nil {
		fields = append(fields, ballot.FieldCastAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BallotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ballot.FieldVoterID:
		return m.VoterID()
	case ballot.FieldChoice:
		return m.Choice()
	case ballot.FieldCastAt:
		return m.CastAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BallotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ballot.FieldVoterID:
		return m.OldVoterID(ctx)
	case ballot.FieldChoice:
		return m.OldChoice(ctx)
	case ballot.FieldCastAt:
		return m.OldCastAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ballot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BallotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ballot.FieldVoterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoterID(v)
		return nil
	case ballot.FieldChoice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChoice(v)
		return nil
	case ballot.FieldCastAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCastAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ballot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BallotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BallotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BallotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ballot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BallotMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BallotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BallotMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ballot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BallotMutation) ResetField(name string) error {
	switch name {
	case ballot.FieldVoterID:
		m.ResetVoterID()
		return nil
	case ballot.FieldChoice:
		m.ResetChoice()
		return nil
	case ballot.FieldCastAt:
		m.ResetCastAt()
		return nil
	}
	return fmt.Errorf("unknown Ballot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BallotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vote != nil {
		edges = append(edges, ballot.EdgeVote)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BallotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ballot.EdgeVote:
		if id := m.vote; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BallotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BallotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BallotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvote {
		edges = append(edges, ballot.EdgeVote)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BallotMutation) EdgeCleared(name string) bool {
	switch name {
	case ballot.EdgeVote:
		return m.clearedvote
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BallotMutation) ClearEdge(name string) error {
	switch name {
	case ballot.EdgeVote:
		m.ClearVote()
		return nil
	}
	return fmt.Errorf("unknown Ballot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BallotMutation) ResetEdge(name string) error {
	switch name {
	case ballot.EdgeVote:
		m.ResetVote()
		return nil
	}
	return fmt.Errorf("unknown Ballot edge %s", name)
}

// BlockAccordionMutation represents an operation that mutates the BlockAccordion nodes in the graph.
type BlockAccordionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	items                map[int]struct{}
	removeditems         map[int]struct{}
	cleareditems         bool
	done                 bool
	oldValue             func(context.Context) (*BlockAccordion, error)
	predicates           []predicate.BlockAccordion
}

var _ ent.Mutation = (*BlockAccordionMutation)(nil)

// blockaccordionOption allows management of the mutation configuration using functional options.
type blockaccordionOption func(*BlockAccordionMutation)

// newBlockAccordionMutation creates new mutation for the BlockAccordion entity.
func newBlockAccordionMutation(c config, op Op, opts ...blockaccordionOption) *BlockAccordionMutation {
	m := &BlockAccordionMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockAccordion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockAccordionID sets the ID field of the mutation.
func withBlockAccordionID(id int) blockaccordionOption {
	return func(m *BlockAccordionMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockAccordion
		)
		m.oldValue = func(ctx context.Context) (*BlockAccordion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockAccordion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockAccordion sets the old BlockAccordion of the mutation.
func withBlockAccordion(node *BlockAccordion) blockaccordionOption {
	return func(m *BlockAccordionMutation) {
		m.oldValue = func(context.Context) (*BlockAccordion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockAccordionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockAccordionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockAccordionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockAccordionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockAccordion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockAccordionMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockAccordionMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockAccordion entity.
// If the BlockAccordion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockAccordionMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockAccordionMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockAccordionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockAccordionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockAccordion entity.
// If the BlockAccordion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockAccordionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockAccordionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockAccordionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockAccordionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockAccordion entity.
// If the BlockAccordion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockAccordionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockAccordionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockAccordionMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockAccordionMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockAccordionMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockAccordionMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockAccordionMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockAccordionMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// AddItemIDs adds the "items" edge to the AccordionItem entity by ids.
func (m *BlockAccordionMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the AccordionItem entity.
func (m *BlockAccordionMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the AccordionItem entity was cleared.
func (m *BlockAccordionMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the AccordionItem entity by IDs.
func (m *BlockAccordionMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the AccordionItem entity.
func (m *BlockAccordionMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *BlockAccordionMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *BlockAccordionMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the BlockAccordionMutation builder.
func (m *BlockAccordionMutation) Where(ps ...predicate.BlockAccordion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockAccordionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockAccordionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockAccordion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockAccordionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockAccordionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockAccordion).
func (m *BlockAccordionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockAccordionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.internal_name != nil {
		fields = append(fields, blockaccordion.FieldInternalName)
	}
	if m.created_at != nil {
		fields = append(fields, blockaccordion.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockaccordion.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockAccordionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockaccordion.FieldInternalName:
		return m.InternalName()
	case blockaccordion.FieldCreatedAt:
		return m.CreatedAt()
	case blockaccordion.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockAccordionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockaccordion.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockaccordion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockaccordion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockAccordion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockAccordionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockaccordion.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockaccordion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockaccordion.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockAccordion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockAccordionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockAccordionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockAccordionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockAccordion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockAccordionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockAccordionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockAccordionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlockAccordion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockAccordionMutation) ResetField(name string) error {
	switch name {
	case blockaccordion.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockaccordion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockaccordion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockAccordion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockAccordionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.content_block != nil {
		edges = append(edges, blockaccordion.EdgeContentBlock)
	}
	if m.items != nil {
		edges = append(edges, blockaccordion.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockAccordionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockaccordion.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	case blockaccordion.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockAccordionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, blockaccordion.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockAccordionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blockaccordion.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockAccordionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontent_block {
		edges = append(edges, blockaccordion.EdgeContentBlock)
	}
	if m.cleareditems {
		edges = append(edges, blockaccordion.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockAccordionMutation) EdgeCleared(name string) bool {
	switch name {
	case blockaccordion.EdgeContentBlock:
		return m.clearedcontent_block
	case blockaccordion.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockAccordionMutation) ClearEdge(name string) error {
	switch name {
	case blockaccordion.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockAccordion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockAccordionMutation) ResetEdge(name string) error {
	switch name {
	case blockaccordion.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	case blockaccordion.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown BlockAccordion edge %s", name)
}

// BlockContactFormMutation represents an operation that mutates the BlockContactForm nodes in the graph.
type BlockContactFormMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	internal_name           *string
	title                   *map[string]string
	description             *map[string]string
	show_name_field         *bool
	show_phone_field        *bool
	show_subject_field      *bool
	show_organization_field *bool
	recipient_email         *string
	success_message         *map[string]string
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	content_block           *int
	clearedcontent_block    bool
	done                    bool
	oldValue                func(context.Context) (*BlockContactForm, error)
	predicates              []predicate.BlockContactForm
}

var _ ent.Mutation = (*BlockContactFormMutation)(nil)

// blockcontactformOption allows management of the mutation configuration using functional options.
type blockcontactformOption func(*BlockContactFormMutation)

// newBlockContactFormMutation creates new mutation for the BlockContactForm entity.
func newBlockContactFormMutation(c config, op Op, opts ...blockcontactformOption) *BlockContactFormMutation {
	m := &BlockContactFormMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockContactForm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockContactFormID sets the ID field of the mutation.
func withBlockContactFormID(id int) blockcontactformOption {
	return func(m *BlockContactFormMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockContactForm
		)
		m.oldValue = func(ctx context.Context) (*BlockContactForm, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockContactForm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockContactForm sets the old BlockContactForm of the mutation.
func withBlockContactForm(node *BlockContactForm) blockcontactformOption {
	return func(m *BlockContactFormMutation) {
		m.oldValue = func(context.Context) (*BlockContactForm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockContactFormMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockContactFormMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockContactFormMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockContactFormMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockContactForm.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockContactFormMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockContactFormMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockContactForm entity.
// If the BlockContactForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockContactFormMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockContactFormMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetTitle sets the "title" field.
func (m *BlockContactFormMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockContactFormMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockContactForm entity.
// If the BlockContactForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockContactFormMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockContactFormMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BlockContactFormMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockContactFormMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockContactForm entity.
// If the BlockContactForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockContactFormMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockContactFormMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockcontactform.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockContactFormMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockcontactform.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockContactFormMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockcontactform.FieldDescription)
}

// SetShowNameField sets the "show_name_field" field.
func (m *BlockContactFormMutation) SetShowNameField(b bool) {
	m.show_name_field = &b
}

// ShowNameField returns the value of the "show_name_field" field in the mutation.
func (m *BlockContactFormMutation) ShowNameField() (r bool, exists bool) {
	v := m.show_name_field
	if v == nil {
		return
	}
	return *v, true
}

// OldShowNameField returns the old "show_name_field" field's value of the BlockContactForm entity.
// If the BlockContactForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockContactFormMutation) OldShowNameField(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowNameField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowNameField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowNameField: %w", err)
	}
	return oldValue.ShowNameField, nil
}

// ResetShowNameField resets all changes to the "show_name_field" field.
func (m *BlockContactFormMutation) ResetShowNameField() {
	m.show_name_field = nil
}

// SetShowPhoneField sets the "show_phone_field" field.
func (m *BlockContactFormMutation) SetShowPhoneField(b bool) {
	m.show_phone_field = &b
}

// ShowPhoneField returns the value of the "show_phone_field" field in the mutation.
func (m *BlockContactFormMutation) ShowPhoneField() (r bool, exists bool) {
	v := m.show_phone_field
	if v == nil {
		return
	}
	return *v, true
}

// OldShowPhoneField returns the old "show_phone_field" field's value of the BlockContactForm entity.
// If the BlockContactForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockContactFormMutation) OldShowPhoneField(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowPhoneField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowPhoneField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowPhoneField: %w", err)
	}
	return oldValue.ShowPhoneField, nil
}

// ResetShowPhoneField resets all changes to the "show_phone_field" field.
func (m *BlockContactFormMutation) ResetShowPhoneField() {
	m.show_phone_field = nil
}

// SetShowSubjectField sets the "show_subject_field" field.
func (m *BlockContactFormMutation) SetShowSubjectField(b bool) {
	m.show_subject_field = &b
}

// ShowSubjectField returns the value of the "show_subject_field" field in the mutation.
func (m *BlockContactFormMutation) ShowSubjectField() (r bool, exists bool) {
	v := m.show_subject_field
	if v == nil {
		return
	}
	return *v, true
}

// OldShowSubjectField returns the old "show_subject_field" field's value of the BlockContactForm entity.
// If the BlockContactForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockContactFormMutation) OldShowSubjectField(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowSubjectField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowSubjectField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowSubjectField: %w", err)
	}
	return oldValue.ShowSubjectField, nil
}

// ResetShowSubjectField resets all changes to the "show_subject_field" field.
func (m *BlockContactFormMutation) ResetShowSubjectField() {
	m.show_subject_field = nil
}

// SetShowOrganizationField sets the "show_organization_field" field.
func (m *BlockContactFormMutation) SetShowOrganizationField(b bool) {
	m.show_organization_field = &b
}

// ShowOrganizationField returns the value of the "show_organization_field" field in the mutation.
func (m *BlockContactFormMutation) ShowOrganizationField() (r bool, exists bool) {
	v := m.show_organization_field
	if v == nil {
		return
	}
	return *v, true
}

// OldShowOrganizationField returns the old "show_organization_field" field's value of the BlockContactForm entity.
// If the BlockContactForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockContactFormMutation) OldShowOrganizationField(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowOrganizationField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowOrganizationField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowOrganizationField: %w", err)
	}
	return oldValue.ShowOrganizationField, nil
}

// ResetShowOrganizationField resets all changes to the "show_organization_field" field.
func (m *BlockContactFormMutation) ResetShowOrganizationField() {
	m.show_organization_field = nil
}

// SetRecipientEmail sets the "recipient_email" field.
func (m *BlockContactFormMutation) SetRecipientEmail(s string) {
	m.recipient_email = &s
}

// RecipientEmail returns the value of the "recipient_email" field in the mutation.
func (m *BlockContactFormMutation) RecipientEmail() (r string, exists bool) {
	v := m.recipient_email
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipientEmail returns the old "recipient_email" field's value of the BlockContactForm entity.
// If the BlockContactForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockContactFormMutation) OldRecipientEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipientEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipientEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipientEmail: %w", err)
	}
	return oldValue.RecipientEmail, nil
}

// ResetRecipientEmail resets all changes to the "recipient_email" field.
func (m *BlockContactFormMutation) ResetRecipientEmail() {
	m.recipient_email = nil
}

// SetSuccessMessage sets the "success_message" field.
func (m *BlockContactFormMutation) SetSuccessMessage(value map[string]string) {
	m.success_message = &value
}

// SuccessMessage returns the value of the "success_message" field in the mutation.
func (m *BlockContactFormMutation) SuccessMessage() (r map[string]string, exists bool) {
	v := m.success_message
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessMessage returns the old "success_message" field's value of the BlockContactForm entity.
// If the BlockContactForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockContactFormMutation) OldSuccessMessage(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessMessage: %w", err)
	}
	return oldValue.SuccessMessage, nil
}

// ResetSuccessMessage resets all changes to the "success_message" field.
func (m *BlockContactFormMutation) ResetSuccessMessage() {
	m.success_message = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockContactFormMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockContactFormMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockContactForm entity.
// If the BlockContactForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockContactFormMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockContactFormMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockContactFormMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockContactFormMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockContactForm entity.
// If the BlockContactForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockContactFormMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockContactFormMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockContactFormMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockContactFormMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockContactFormMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockContactFormMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockContactFormMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockContactFormMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// Where appends a list predicates to the BlockContactFormMutation builder.
func (m *BlockContactFormMutation) Where(ps ...predicate.BlockContactForm) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockContactFormMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockContactFormMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockContactForm, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockContactFormMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockContactFormMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockContactForm).
func (m *BlockContactFormMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockContactFormMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.internal_name != nil {
		fields = append(fields, blockcontactform.FieldInternalName)
	}
	if m.title != nil {
		fields = append(fields, blockcontactform.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blockcontactform.FieldDescription)
	}
	if m.show_name_field != nil {
		fields = append(fields, blockcontactform.FieldShowNameField)
	}
	if m.show_phone_field != nil {
		fields = append(fields, blockcontactform.FieldShowPhoneField)
	}
	if m.show_subject_field != nil {
		fields = append(fields, blockcontactform.FieldShowSubjectField)
	}
	if m.show_organization_field != nil {
		fields = append(fields, blockcontactform.FieldShowOrganizationField)
	}
	if m.recipient_email != nil {
		fields = append(fields, blockcontactform.FieldRecipientEmail)
	}
	if m.success_message != nil {
		fields = append(fields, blockcontactform.FieldSuccessMessage)
	}
	if m.created_at != nil {
		fields = append(fields, blockcontactform.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockcontactform.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockContactFormMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockcontactform.FieldInternalName:
		return m.InternalName()
	case blockcontactform.FieldTitle:
		return m.Title()
	case blockcontactform.FieldDescription:
		return m.Description()
	case blockcontactform.FieldShowNameField:
		return m.ShowNameField()
	case blockcontactform.FieldShowPhoneField:
		return m.ShowPhoneField()
	case blockcontactform.FieldShowSubjectField:
		return m.ShowSubjectField()
	case blockcontactform.FieldShowOrganizationField:
		return m.ShowOrganizationField()
	case blockcontactform.FieldRecipientEmail:
		return m.RecipientEmail()
	case blockcontactform.FieldSuccessMessage:
		return m.SuccessMessage()
	case blockcontactform.FieldCreatedAt:
		return m.CreatedAt()
	case blockcontactform.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockContactFormMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockcontactform.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockcontactform.FieldTitle:
		return m.OldTitle(ctx)
	case blockcontactform.FieldDescription:
		return m.OldDescription(ctx)
	case blockcontactform.FieldShowNameField:
		return m.OldShowNameField(ctx)
	case blockcontactform.FieldShowPhoneField:
		return m.OldShowPhoneField(ctx)
	case blockcontactform.FieldShowSubjectField:
		return m.OldShowSubjectField(ctx)
	case blockcontactform.FieldShowOrganizationField:
		return m.OldShowOrganizationField(ctx)
	case blockcontactform.FieldRecipientEmail:
		return m.OldRecipientEmail(ctx)
	case blockcontactform.FieldSuccessMessage:
		return m.OldSuccessMessage(ctx)
	case blockcontactform.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockcontactform.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockContactForm field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockContactFormMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockcontactform.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockcontactform.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockcontactform.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockcontactform.FieldShowNameField:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowNameField(v)
		return nil
	case blockcontactform.FieldShowPhoneField:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowPhoneField(v)
		return nil
	case blockcontactform.FieldShowSubjectField:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowSubjectField(v)
		return nil
	case blockcontactform.FieldShowOrganizationField:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowOrganizationField(v)
		return nil
	case blockcontactform.FieldRecipientEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipientEmail(v)
		return nil
	case blockcontactform.FieldSuccessMessage:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessMessage(v)
		return nil
	case blockcontactform.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockcontactform.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockContactForm field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockContactFormMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockContactFormMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockContactFormMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockContactForm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockContactFormMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockcontactform.FieldDescription) {
		fields = append(fields, blockcontactform.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockContactFormMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockContactFormMutation) ClearField(name string) error {
	switch name {
	case blockcontactform.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlockContactForm nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockContactFormMutation) ResetField(name string) error {
	switch name {
	case blockcontactform.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockcontactform.FieldTitle:
		m.ResetTitle()
		return nil
	case blockcontactform.FieldDescription:
		m.ResetDescription()
		return nil
	case blockcontactform.FieldShowNameField:
		m.ResetShowNameField()
		return nil
	case blockcontactform.FieldShowPhoneField:
		m.ResetShowPhoneField()
		return nil
	case blockcontactform.FieldShowSubjectField:
		m.ResetShowSubjectField()
		return nil
	case blockcontactform.FieldShowOrganizationField:
		m.ResetShowOrganizationField()
		return nil
	case blockcontactform.FieldRecipientEmail:
		m.ResetRecipientEmail()
		return nil
	case blockcontactform.FieldSuccessMessage:
		m.ResetSuccessMessage()
		return nil
	case blockcontactform.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockcontactform.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockContactForm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockContactFormMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content_block != nil {
		edges = append(edges, blockcontactform.EdgeContentBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockContactFormMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockcontactform.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockContactFormMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockContactFormMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockContactFormMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent_block {
		edges = append(edges, blockcontactform.EdgeContentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockContactFormMutation) EdgeCleared(name string) bool {
	switch name {
	case blockcontactform.EdgeContentBlock:
		return m.clearedcontent_block
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockContactFormMutation) ClearEdge(name string) error {
	switch name {
	case blockcontactform.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockContactForm unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockContactFormMutation) ResetEdge(name string) error {
	switch name {
	case blockcontactform.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockContactForm edge %s", name)
}

// BlockCtaMutation represents an operation that mutates the BlockCta nodes in the graph.
type BlockCtaMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	internal_name          *string
	badge                  *map[string]string
	title                  *map[string]string
	description            *map[string]string
	primary_button_text    *map[string]string
	primary_button_href    *string
	primary_button_style   *blockcta.PrimaryButtonStyle
	secondary_button_text  *map[string]string
	secondary_button_href  *string
	secondary_button_style *blockcta.SecondaryButtonStyle
	text_align             *blockcta.TextAlign
	color_scheme           *blockcta.ColorScheme
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	content_block          *int
	clearedcontent_block   bool
	done                   bool
	oldValue               func(context.Context) (*BlockCta, error)
	predicates             []predicate.BlockCta
}

var _ ent.Mutation = (*BlockCtaMutation)(nil)

// blockctaOption allows management of the mutation configuration using functional options.
type blockctaOption func(*BlockCtaMutation)

// newBlockCtaMutation creates new mutation for the BlockCta entity.
func newBlockCtaMutation(c config, op Op, opts ...blockctaOption) *BlockCtaMutation {
	m := &BlockCtaMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockCta,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockCtaID sets the ID field of the mutation.
func withBlockCtaID(id int) blockctaOption {
	return func(m *BlockCtaMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockCta
		)
		m.oldValue = func(ctx context.Context) (*BlockCta, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockCta.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockCta sets the old BlockCta of the mutation.
func withBlockCta(node *BlockCta) blockctaOption {
	return func(m *BlockCtaMutation) {
		m.oldValue = func(context.Context) (*BlockCta, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockCtaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockCtaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockCtaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockCtaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockCta.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockCtaMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockCtaMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockCtaMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetBadge sets the "badge" field.
func (m *BlockCtaMutation) SetBadge(value map[string]string) {
	m.badge = &value
}

// Badge returns the value of the "badge" field in the mutation.
func (m *BlockCtaMutation) Badge() (r map[string]string, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldBadge(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *BlockCtaMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[blockcta.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *BlockCtaMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[blockcta.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *BlockCtaMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, blockcta.FieldBadge)
}

// SetTitle sets the "title" field.
func (m *BlockCtaMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockCtaMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockCtaMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BlockCtaMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockCtaMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockCtaMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockcta.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockCtaMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockcta.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockCtaMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockcta.FieldDescription)
}

// SetPrimaryButtonText sets the "primary_button_text" field.
func (m *BlockCtaMutation) SetPrimaryButtonText(value map[string]string) {
	m.primary_button_text = &value
}

// PrimaryButtonText returns the value of the "primary_button_text" field in the mutation.
func (m *BlockCtaMutation) PrimaryButtonText() (r map[string]string, exists bool) {
	v := m.primary_button_text
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryButtonText returns the old "primary_button_text" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldPrimaryButtonText(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryButtonText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryButtonText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryButtonText: %w", err)
	}
	return oldValue.PrimaryButtonText, nil
}

// ResetPrimaryButtonText resets all changes to the "primary_button_text" field.
func (m *BlockCtaMutation) ResetPrimaryButtonText() {
	m.primary_button_text = nil
}

// SetPrimaryButtonHref sets the "primary_button_href" field.
func (m *BlockCtaMutation) SetPrimaryButtonHref(s string) {
	m.primary_button_href = &s
}

// PrimaryButtonHref returns the value of the "primary_button_href" field in the mutation.
func (m *BlockCtaMutation) PrimaryButtonHref() (r string, exists bool) {
	v := m.primary_button_href
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryButtonHref returns the old "primary_button_href" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldPrimaryButtonHref(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryButtonHref is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryButtonHref requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryButtonHref: %w", err)
	}
	return oldValue.PrimaryButtonHref, nil
}

// ResetPrimaryButtonHref resets all changes to the "primary_button_href" field.
func (m *BlockCtaMutation) ResetPrimaryButtonHref() {
	m.primary_button_href = nil
}

// SetPrimaryButtonStyle sets the "primary_button_style" field.
func (m *BlockCtaMutation) SetPrimaryButtonStyle(bbs blockcta.PrimaryButtonStyle) {
	m.primary_button_style = &bbs
}

// PrimaryButtonStyle returns the value of the "primary_button_style" field in the mutation.
func (m *BlockCtaMutation) PrimaryButtonStyle() (r blockcta.PrimaryButtonStyle, exists bool) {
	v := m.primary_button_style
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryButtonStyle returns the old "primary_button_style" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldPrimaryButtonStyle(ctx context.Context) (v blockcta.PrimaryButtonStyle, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryButtonStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryButtonStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryButtonStyle: %w", err)
	}
	return oldValue.PrimaryButtonStyle, nil
}

// ResetPrimaryButtonStyle resets all changes to the "primary_button_style" field.
func (m *BlockCtaMutation) ResetPrimaryButtonStyle() {
	m.primary_button_style = nil
}

// SetSecondaryButtonText sets the "secondary_button_text" field.
func (m *BlockCtaMutation) SetSecondaryButtonText(value map[string]string) {
	m.secondary_button_text = &value
}

// SecondaryButtonText returns the value of the "secondary_button_text" field in the mutation.
func (m *BlockCtaMutation) SecondaryButtonText() (r map[string]string, exists bool) {
	v := m.secondary_button_text
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondaryButtonText returns the old "secondary_button_text" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldSecondaryButtonText(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondaryButtonText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondaryButtonText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondaryButtonText: %w", err)
	}
	return oldValue.SecondaryButtonText, nil
}

// ClearSecondaryButtonText clears the value of the "secondary_button_text" field.
func (m *BlockCtaMutation) ClearSecondaryButtonText() {
	m.secondary_button_text = nil
	m.clearedFields[blockcta.FieldSecondaryButtonText] = struct{}{}
}

// SecondaryButtonTextCleared returns if the "secondary_button_text" field was cleared in this mutation.
func (m *BlockCtaMutation) SecondaryButtonTextCleared() bool {
	_, ok := m.clearedFields[blockcta.FieldSecondaryButtonText]
	return ok
}

// ResetSecondaryButtonText resets all changes to the "secondary_button_text" field.
func (m *BlockCtaMutation) ResetSecondaryButtonText() {
	m.secondary_button_text = nil
	delete(m.clearedFields, blockcta.FieldSecondaryButtonText)
}

// SetSecondaryButtonHref sets the "secondary_button_href" field.
func (m *BlockCtaMutation) SetSecondaryButtonHref(s string) {
	m.secondary_button_href = &s
}

// SecondaryButtonHref returns the value of the "secondary_button_href" field in the mutation.
func (m *BlockCtaMutation) SecondaryButtonHref() (r string, exists bool) {
	v := m.secondary_button_href
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondaryButtonHref returns the old "secondary_button_href" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldSecondaryButtonHref(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondaryButtonHref is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondaryButtonHref requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondaryButtonHref: %w", err)
	}
	return oldValue.SecondaryButtonHref, nil
}

// ClearSecondaryButtonHref clears the value of the "secondary_button_href" field.
func (m *BlockCtaMutation) ClearSecondaryButtonHref() {
	m.secondary_button_href = nil
	m.clearedFields[blockcta.FieldSecondaryButtonHref] = struct{}{}
}

// SecondaryButtonHrefCleared returns if the "secondary_button_href" field was cleared in this mutation.
func (m *BlockCtaMutation) SecondaryButtonHrefCleared() bool {
	_, ok := m.clearedFields[blockcta.FieldSecondaryButtonHref]
	return ok
}

// ResetSecondaryButtonHref resets all changes to the "secondary_button_href" field.
func (m *BlockCtaMutation) ResetSecondaryButtonHref() {
	m.secondary_button_href = nil
	delete(m.clearedFields, blockcta.FieldSecondaryButtonHref)
}

// SetSecondaryButtonStyle sets the "secondary_button_style" field.
func (m *BlockCtaMutation) SetSecondaryButtonStyle(bbs blockcta.SecondaryButtonStyle) {
	m.secondary_button_style = &bbs
}

// SecondaryButtonStyle returns the value of the "secondary_button_style" field in the mutation.
func (m *BlockCtaMutation) SecondaryButtonStyle() (r blockcta.SecondaryButtonStyle, exists bool) {
	v := m.secondary_button_style
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondaryButtonStyle returns the old "secondary_button_style" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldSecondaryButtonStyle(ctx context.Context) (v blockcta.SecondaryButtonStyle, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondaryButtonStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondaryButtonStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondaryButtonStyle: %w", err)
	}
	return oldValue.SecondaryButtonStyle, nil
}

// ResetSecondaryButtonStyle resets all changes to the "secondary_button_style" field.
func (m *BlockCtaMutation) ResetSecondaryButtonStyle() {
	m.secondary_button_style = nil
}

// SetTextAlign sets the "text_align" field.
func (m *BlockCtaMutation) SetTextAlign(ba blockcta.TextAlign) {
	m.text_align = &ba
}

// TextAlign returns the value of the "text_align" field in the mutation.
func (m *BlockCtaMutation) TextAlign() (r blockcta.TextAlign, exists bool) {
	v := m.text_align
	if v == nil {
		return
	}
	return *v, true
}

// OldTextAlign returns the old "text_align" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldTextAlign(ctx context.Context) (v blockcta.TextAlign, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextAlign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextAlign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextAlign: %w", err)
	}
	return oldValue.TextAlign, nil
}

// ResetTextAlign resets all changes to the "text_align" field.
func (m *BlockCtaMutation) ResetTextAlign() {
	m.text_align = nil
}

// SetColorScheme sets the "color_scheme" field.
func (m *BlockCtaMutation) SetColorScheme(bs blockcta.ColorScheme) {
	m.color_scheme = &bs
}

// ColorScheme returns the value of the "color_scheme" field in the mutation.
func (m *BlockCtaMutation) ColorScheme() (r blockcta.ColorScheme, exists bool) {
	v := m.color_scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldColorScheme returns the old "color_scheme" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldColorScheme(ctx context.Context) (v blockcta.ColorScheme, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorScheme: %w", err)
	}
	return oldValue.ColorScheme, nil
}

// ResetColorScheme resets all changes to the "color_scheme" field.
func (m *BlockCtaMutation) ResetColorScheme() {
	m.color_scheme = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockCtaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockCtaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockCtaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockCtaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockCtaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockCta entity.
// If the BlockCta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockCtaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockCtaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockCtaMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockCtaMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockCtaMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockCtaMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockCtaMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockCtaMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// Where appends a list predicates to the BlockCtaMutation builder.
func (m *BlockCtaMutation) Where(ps ...predicate.BlockCta) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockCtaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockCtaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockCta, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockCtaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockCtaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockCta).
func (m *BlockCtaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockCtaMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.internal_name != nil {
		fields = append(fields, blockcta.FieldInternalName)
	}
	if m.badge != nil {
		fields = append(fields, blockcta.FieldBadge)
	}
	if m.title != nil {
		fields = append(fields, blockcta.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blockcta.FieldDescription)
	}
	if m.primary_button_text != nil {
		fields = append(fields, blockcta.FieldPrimaryButtonText)
	}
	if m.primary_button_href != nil {
		fields = append(fields, blockcta.FieldPrimaryButtonHref)
	}
	if m.primary_button_style != nil {
		fields = append(fields, blockcta.FieldPrimaryButtonStyle)
	}
	if m.secondary_button_text != nil {
		fields = append(fields, blockcta.FieldSecondaryButtonText)
	}
	if m.secondary_button_href != nil {
		fields = append(fields, blockcta.FieldSecondaryButtonHref)
	}
	if m.secondary_button_style != nil {
		fields = append(fields, blockcta.FieldSecondaryButtonStyle)
	}
	if m.text_align != nil {
		fields = append(fields, blockcta.FieldTextAlign)
	}
	if m.color_scheme != nil {
		fields = append(fields, blockcta.FieldColorScheme)
	}
	if m.created_at != nil {
		fields = append(fields, blockcta.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockcta.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockCtaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockcta.FieldInternalName:
		return m.InternalName()
	case blockcta.FieldBadge:
		return m.Badge()
	case blockcta.FieldTitle:
		return m.Title()
	case blockcta.FieldDescription:
		return m.Description()
	case blockcta.FieldPrimaryButtonText:
		return m.PrimaryButtonText()
	case blockcta.FieldPrimaryButtonHref:
		return m.PrimaryButtonHref()
	case blockcta.FieldPrimaryButtonStyle:
		return m.PrimaryButtonStyle()
	case blockcta.FieldSecondaryButtonText:
		return m.SecondaryButtonText()
	case blockcta.FieldSecondaryButtonHref:
		return m.SecondaryButtonHref()
	case blockcta.FieldSecondaryButtonStyle:
		return m.SecondaryButtonStyle()
	case blockcta.FieldTextAlign:
		return m.TextAlign()
	case blockcta.FieldColorScheme:
		return m.ColorScheme()
	case blockcta.FieldCreatedAt:
		return m.CreatedAt()
	case blockcta.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockCtaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockcta.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockcta.FieldBadge:
		return m.OldBadge(ctx)
	case blockcta.FieldTitle:
		return m.OldTitle(ctx)
	case blockcta.FieldDescription:
		return m.OldDescription(ctx)
	case blockcta.FieldPrimaryButtonText:
		return m.OldPrimaryButtonText(ctx)
	case blockcta.FieldPrimaryButtonHref:
		return m.OldPrimaryButtonHref(ctx)
	case blockcta.FieldPrimaryButtonStyle:
		return m.OldPrimaryButtonStyle(ctx)
	case blockcta.FieldSecondaryButtonText:
		return m.OldSecondaryButtonText(ctx)
	case blockcta.FieldSecondaryButtonHref:
		return m.OldSecondaryButtonHref(ctx)
	case blockcta.FieldSecondaryButtonStyle:
		return m.OldSecondaryButtonStyle(ctx)
	case blockcta.FieldTextAlign:
		return m.OldTextAlign(ctx)
	case blockcta.FieldColorScheme:
		return m.OldColorScheme(ctx)
	case blockcta.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockcta.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockCta field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockCtaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockcta.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockcta.FieldBadge:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	case blockcta.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockcta.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockcta.FieldPrimaryButtonText:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryButtonText(v)
		return nil
	case blockcta.FieldPrimaryButtonHref:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryButtonHref(v)
		return nil
	case blockcta.FieldPrimaryButtonStyle:
		v, ok := value.(blockcta.PrimaryButtonStyle)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryButtonStyle(v)
		return nil
	case blockcta.FieldSecondaryButtonText:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondaryButtonText(v)
		return nil
	case blockcta.FieldSecondaryButtonHref:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondaryButtonHref(v)
		return nil
	case blockcta.FieldSecondaryButtonStyle:
		v, ok := value.(blockcta.SecondaryButtonStyle)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondaryButtonStyle(v)
		return nil
	case blockcta.FieldTextAlign:
		v, ok := value.(blockcta.TextAlign)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextAlign(v)
		return nil
	case blockcta.FieldColorScheme:
		v, ok := value.(blockcta.ColorScheme)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorScheme(v)
		return nil
	case blockcta.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockcta.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockCta field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockCtaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockCtaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockCtaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockCta numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockCtaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockcta.FieldBadge) {
		fields = append(fields, blockcta.FieldBadge)
	}
	if m.FieldCleared(blockcta.FieldDescription) {
		fields = append(fields, blockcta.FieldDescription)
	}
	if m.FieldCleared(blockcta.FieldSecondaryButtonText) {
		fields = append(fields, blockcta.FieldSecondaryButtonText)
	}
	if m.FieldCleared(blockcta.FieldSecondaryButtonHref) {
		fields = append(fields, blockcta.FieldSecondaryButtonHref)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockCtaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockCtaMutation) ClearField(name string) error {
	switch name {
	case blockcta.FieldBadge:
		m.ClearBadge()
		return nil
	case blockcta.FieldDescription:
		m.ClearDescription()
		return nil
	case blockcta.FieldSecondaryButtonText:
		m.ClearSecondaryButtonText()
		return nil
	case blockcta.FieldSecondaryButtonHref:
		m.ClearSecondaryButtonHref()
		return nil
	}
	return fmt.Errorf("unknown BlockCta nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockCtaMutation) ResetField(name string) error {
	switch name {
	case blockcta.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockcta.FieldBadge:
		m.ResetBadge()
		return nil
	case blockcta.FieldTitle:
		m.ResetTitle()
		return nil
	case blockcta.FieldDescription:
		m.ResetDescription()
		return nil
	case blockcta.FieldPrimaryButtonText:
		m.ResetPrimaryButtonText()
		return nil
	case blockcta.FieldPrimaryButtonHref:
		m.ResetPrimaryButtonHref()
		return nil
	case blockcta.FieldPrimaryButtonStyle:
		m.ResetPrimaryButtonStyle()
		return nil
	case blockcta.FieldSecondaryButtonText:
		m.ResetSecondaryButtonText()
		return nil
	case blockcta.FieldSecondaryButtonHref:
		m.ResetSecondaryButtonHref()
		return nil
	case blockcta.FieldSecondaryButtonStyle:
		m.ResetSecondaryButtonStyle()
		return nil
	case blockcta.FieldTextAlign:
		m.ResetTextAlign()
		return nil
	case blockcta.FieldColorScheme:
		m.ResetColorScheme()
		return nil
	case blockcta.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockcta.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockCta field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockCtaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content_block != nil {
		edges = append(edges, blockcta.EdgeContentBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockCtaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockcta.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockCtaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockCtaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockCtaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent_block {
		edges = append(edges, blockcta.EdgeContentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockCtaMutation) EdgeCleared(name string) bool {
	switch name {
	case blockcta.EdgeContentBlock:
		return m.clearedcontent_block
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockCtaMutation) ClearEdge(name string) error {
	switch name {
	case blockcta.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockCta unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockCtaMutation) ResetEdge(name string) error {
	switch name {
	case blockcta.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockCta edge %s", name)
}

// BlockDividerMutation represents an operation that mutates the BlockDivider nodes in the graph.
type BlockDividerMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	height               *int
	addheight            *int
	color                *string
	style                *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	done                 bool
	oldValue             func(context.Context) (*BlockDivider, error)
	predicates           []predicate.BlockDivider
}

var _ ent.Mutation = (*BlockDividerMutation)(nil)

// blockdividerOption allows management of the mutation configuration using functional options.
type blockdividerOption func(*BlockDividerMutation)

// newBlockDividerMutation creates new mutation for the BlockDivider entity.
func newBlockDividerMutation(c config, op Op, opts ...blockdividerOption) *BlockDividerMutation {
	m := &BlockDividerMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockDivider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockDividerID sets the ID field of the mutation.
func withBlockDividerID(id int) blockdividerOption {
	return func(m *BlockDividerMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockDivider
		)
		m.oldValue = func(ctx context.Context) (*BlockDivider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockDivider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockDivider sets the old BlockDivider of the mutation.
func withBlockDivider(node *BlockDivider) blockdividerOption {
	return func(m *BlockDividerMutation) {
		m.oldValue = func(context.Context) (*BlockDivider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockDividerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockDividerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockDividerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockDividerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockDivider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockDividerMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockDividerMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockDivider entity.
// If the BlockDivider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDividerMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockDividerMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetHeight sets the "height" field.
func (m *BlockDividerMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *BlockDividerMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the BlockDivider entity.
// If the BlockDivider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDividerMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *BlockDividerMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *BlockDividerMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *BlockDividerMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[blockdivider.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *BlockDividerMutation) HeightCleared() bool {
	_, ok := m.clearedFields[blockdivider.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *BlockDividerMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, blockdivider.FieldHeight)
}

// SetColor sets the "color" field.
func (m *BlockDividerMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *BlockDividerMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the BlockDivider entity.
// If the BlockDivider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDividerMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *BlockDividerMutation) ClearColor() {
	m.color = nil
	m.clearedFields[blockdivider.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *BlockDividerMutation) ColorCleared() bool {
	_, ok := m.clearedFields[blockdivider.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *BlockDividerMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, blockdivider.FieldColor)
}

// SetStyle sets the "style" field.
func (m *BlockDividerMutation) SetStyle(s string) {
	m.style = &s
}

// Style returns the value of the "style" field in the mutation.
func (m *BlockDividerMutation) Style() (r string, exists bool) {
	v := m.style
	if v == nil {
		return
	}
	return *v, true
}

// OldStyle returns the old "style" field's value of the BlockDivider entity.
// If the BlockDivider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDividerMutation) OldStyle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStyle: %w", err)
	}
	return oldValue.Style, nil
}

// ClearStyle clears the value of the "style" field.
func (m *BlockDividerMutation) ClearStyle() {
	m.style = nil
	m.clearedFields[blockdivider.FieldStyle] = struct{}{}
}

// StyleCleared returns if the "style" field was cleared in this mutation.
func (m *BlockDividerMutation) StyleCleared() bool {
	_, ok := m.clearedFields[blockdivider.FieldStyle]
	return ok
}

// ResetStyle resets all changes to the "style" field.
func (m *BlockDividerMutation) ResetStyle() {
	m.style = nil
	delete(m.clearedFields, blockdivider.FieldStyle)
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockDividerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockDividerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockDivider entity.
// If the BlockDivider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDividerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockDividerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockDividerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockDividerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockDivider entity.
// If the BlockDivider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDividerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockDividerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockDividerMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockDividerMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockDividerMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockDividerMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockDividerMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockDividerMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// Where appends a list predicates to the BlockDividerMutation builder.
func (m *BlockDividerMutation) Where(ps ...predicate.BlockDivider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockDividerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockDividerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockDivider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockDividerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockDividerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockDivider).
func (m *BlockDividerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockDividerMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.internal_name != nil {
		fields = append(fields, blockdivider.FieldInternalName)
	}
	if m.height != nil {
		fields = append(fields, blockdivider.FieldHeight)
	}
	if m.color != nil {
		fields = append(fields, blockdivider.FieldColor)
	}
	if m.style != nil {
		fields = append(fields, blockdivider.FieldStyle)
	}
	if m.created_at != nil {
		fields = append(fields, blockdivider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockdivider.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockDividerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockdivider.FieldInternalName:
		return m.InternalName()
	case blockdivider.FieldHeight:
		return m.Height()
	case blockdivider.FieldColor:
		return m.Color()
	case blockdivider.FieldStyle:
		return m.Style()
	case blockdivider.FieldCreatedAt:
		return m.CreatedAt()
	case blockdivider.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockDividerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockdivider.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockdivider.FieldHeight:
		return m.OldHeight(ctx)
	case blockdivider.FieldColor:
		return m.OldColor(ctx)
	case blockdivider.FieldStyle:
		return m.OldStyle(ctx)
	case blockdivider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockdivider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockDivider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockDividerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockdivider.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockdivider.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case blockdivider.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case blockdivider.FieldStyle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStyle(v)
		return nil
	case blockdivider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockdivider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockDivider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockDividerMutation) AddedFields() []string {
	var fields []string
	if m.addheight != nil {
		fields = append(fields, blockdivider.FieldHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockDividerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockdivider.FieldHeight:
		return m.AddedHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockDividerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockdivider.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	}
	return fmt.Errorf("unknown BlockDivider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockDividerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockdivider.FieldHeight) {
		fields = append(fields, blockdivider.FieldHeight)
	}
	if m.FieldCleared(blockdivider.FieldColor) {
		fields = append(fields, blockdivider.FieldColor)
	}
	if m.FieldCleared(blockdivider.FieldStyle) {
		fields = append(fields, blockdivider.FieldStyle)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockDividerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockDividerMutation) ClearField(name string) error {
	switch name {
	case blockdivider.FieldHeight:
		m.ClearHeight()
		return nil
	case blockdivider.FieldColor:
		m.ClearColor()
		return nil
	case blockdivider.FieldStyle:
		m.ClearStyle()
		return nil
	}
	return fmt.Errorf("unknown BlockDivider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockDividerMutation) ResetField(name string) error {
	switch name {
	case blockdivider.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockdivider.FieldHeight:
		m.ResetHeight()
		return nil
	case blockdivider.FieldColor:
		m.ResetColor()
		return nil
	case blockdivider.FieldStyle:
		m.ResetStyle()
		return nil
	case blockdivider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockdivider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockDivider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockDividerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content_block != nil {
		edges = append(edges, blockdivider.EdgeContentBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockDividerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockdivider.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockDividerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockDividerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockDividerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent_block {
		edges = append(edges, blockdivider.EdgeContentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockDividerMutation) EdgeCleared(name string) bool {
	switch name {
	case blockdivider.EdgeContentBlock:
		return m.clearedcontent_block
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockDividerMutation) ClearEdge(name string) error {
	switch name {
	case blockdivider.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockDivider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockDividerMutation) ResetEdge(name string) error {
	switch name {
	case blockdivider.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockDivider edge %s", name)
}

// BlockDonationFormMutation represents an operation that mutates the BlockDonationForm nodes in the graph.
type BlockDonationFormMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	internal_name         *string
	title                 *map[string]string
	description           *map[string]string
	show_amount_buttons   *bool
	default_amounts       *[]int
	appenddefault_amounts []int
	allow_custom_amount   *bool
	show_recurring        *bool
	color_scheme          *blockdonationform.ColorScheme
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	content_block         *int
	clearedcontent_block  bool
	done                  bool
	oldValue              func(context.Context) (*BlockDonationForm, error)
	predicates            []predicate.BlockDonationForm
}

var _ ent.Mutation = (*BlockDonationFormMutation)(nil)

// blockdonationformOption allows management of the mutation configuration using functional options.
type blockdonationformOption func(*BlockDonationFormMutation)

// newBlockDonationFormMutation creates new mutation for the BlockDonationForm entity.
func newBlockDonationFormMutation(c config, op Op, opts ...blockdonationformOption) *BlockDonationFormMutation {
	m := &BlockDonationFormMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockDonationForm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockDonationFormID sets the ID field of the mutation.
func withBlockDonationFormID(id int) blockdonationformOption {
	return func(m *BlockDonationFormMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockDonationForm
		)
		m.oldValue = func(ctx context.Context) (*BlockDonationForm, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockDonationForm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockDonationForm sets the old BlockDonationForm of the mutation.
func withBlockDonationForm(node *BlockDonationForm) blockdonationformOption {
	return func(m *BlockDonationFormMutation) {
		m.oldValue = func(context.Context) (*BlockDonationForm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockDonationFormMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockDonationFormMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockDonationFormMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockDonationFormMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockDonationForm.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockDonationFormMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockDonationFormMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockDonationForm entity.
// If the BlockDonationForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDonationFormMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockDonationFormMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetTitle sets the "title" field.
func (m *BlockDonationFormMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockDonationFormMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockDonationForm entity.
// If the BlockDonationForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDonationFormMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockDonationFormMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BlockDonationFormMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockDonationFormMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockDonationForm entity.
// If the BlockDonationForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDonationFormMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockDonationFormMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockdonationform.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockDonationFormMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockdonationform.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockDonationFormMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockdonationform.FieldDescription)
}

// SetShowAmountButtons sets the "show_amount_buttons" field.
func (m *BlockDonationFormMutation) SetShowAmountButtons(b bool) {
	m.show_amount_buttons = &b
}

// ShowAmountButtons returns the value of the "show_amount_buttons" field in the mutation.
func (m *BlockDonationFormMutation) ShowAmountButtons() (r bool, exists bool) {
	v := m.show_amount_buttons
	if v == nil {
		return
	}
	return *v, true
}

// OldShowAmountButtons returns the old "show_amount_buttons" field's value of the BlockDonationForm entity.
// If the BlockDonationForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDonationFormMutation) OldShowAmountButtons(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowAmountButtons is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowAmountButtons requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowAmountButtons: %w", err)
	}
	return oldValue.ShowAmountButtons, nil
}

// ResetShowAmountButtons resets all changes to the "show_amount_buttons" field.
func (m *BlockDonationFormMutation) ResetShowAmountButtons() {
	m.show_amount_buttons = nil
}

// SetDefaultAmounts sets the "default_amounts" field.
func (m *BlockDonationFormMutation) SetDefaultAmounts(i []int) {
	m.default_amounts = &i
	m.appenddefault_amounts = nil
}

// DefaultAmounts returns the value of the "default_amounts" field in the mutation.
func (m *BlockDonationFormMutation) DefaultAmounts() (r []int, exists bool) {
	v := m.default_amounts
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultAmounts returns the old "default_amounts" field's value of the BlockDonationForm entity.
// If the BlockDonationForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDonationFormMutation) OldDefaultAmounts(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultAmounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultAmounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultAmounts: %w", err)
	}
	return oldValue.DefaultAmounts, nil
}

// AppendDefaultAmounts adds i to the "default_amounts" field.
func (m *BlockDonationFormMutation) AppendDefaultAmounts(i []int) {
	m.appenddefault_amounts = append(m.appenddefault_amounts, i...)
}

// AppendedDefaultAmounts returns the list of values that were appended to the "default_amounts" field in this mutation.
func (m *BlockDonationFormMutation) AppendedDefaultAmounts() ([]int, bool) {
	if len(m.appenddefault_amounts) == 0 {
		return nil, false
	}
	return m.appenddefault_amounts, true
}

// ResetDefaultAmounts resets all changes to the "default_amounts" field.
func (m *BlockDonationFormMutation) ResetDefaultAmounts() {
	m.default_amounts = nil
	m.appenddefault_amounts = nil
}

// SetAllowCustomAmount sets the "allow_custom_amount" field.
func (m *BlockDonationFormMutation) SetAllowCustomAmount(b bool) {
	m.allow_custom_amount = &b
}

// AllowCustomAmount returns the value of the "allow_custom_amount" field in the mutation.
func (m *BlockDonationFormMutation) AllowCustomAmount() (r bool, exists bool) {
	v := m.allow_custom_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowCustomAmount returns the old "allow_custom_amount" field's value of the BlockDonationForm entity.
// If the BlockDonationForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDonationFormMutation) OldAllowCustomAmount(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowCustomAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowCustomAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowCustomAmount: %w", err)
	}
	return oldValue.AllowCustomAmount, nil
}

// ResetAllowCustomAmount resets all changes to the "allow_custom_amount" field.
func (m *BlockDonationFormMutation) ResetAllowCustomAmount() {
	m.allow_custom_amount = nil
}

// SetShowRecurring sets the "show_recurring" field.
func (m *BlockDonationFormMutation) SetShowRecurring(b bool) {
	m.show_recurring = &b
}

// ShowRecurring returns the value of the "show_recurring" field in the mutation.
func (m *BlockDonationFormMutation) ShowRecurring() (r bool, exists bool) {
	v := m.show_recurring
	if v == nil {
		return
	}
	return *v, true
}

// OldShowRecurring returns the old "show_recurring" field's value of the BlockDonationForm entity.
// If the BlockDonationForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDonationFormMutation) OldShowRecurring(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowRecurring is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowRecurring requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowRecurring: %w", err)
	}
	return oldValue.ShowRecurring, nil
}

// ResetShowRecurring resets all changes to the "show_recurring" field.
func (m *BlockDonationFormMutation) ResetShowRecurring() {
	m.show_recurring = nil
}

// SetColorScheme sets the "color_scheme" field.
func (m *BlockDonationFormMutation) SetColorScheme(bs blockdonationform.ColorScheme) {
	m.color_scheme = &bs
}

// ColorScheme returns the value of the "color_scheme" field in the mutation.
func (m *BlockDonationFormMutation) ColorScheme() (r blockdonationform.ColorScheme, exists bool) {
	v := m.color_scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldColorScheme returns the old "color_scheme" field's value of the BlockDonationForm entity.
// If the BlockDonationForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDonationFormMutation) OldColorScheme(ctx context.Context) (v blockdonationform.ColorScheme, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorScheme: %w", err)
	}
	return oldValue.ColorScheme, nil
}

// ResetColorScheme resets all changes to the "color_scheme" field.
func (m *BlockDonationFormMutation) ResetColorScheme() {
	m.color_scheme = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockDonationFormMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockDonationFormMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockDonationForm entity.
// If the BlockDonationForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDonationFormMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockDonationFormMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockDonationFormMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockDonationFormMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockDonationForm entity.
// If the BlockDonationForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockDonationFormMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockDonationFormMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockDonationFormMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockDonationFormMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockDonationFormMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockDonationFormMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockDonationFormMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockDonationFormMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// Where appends a list predicates to the BlockDonationFormMutation builder.
func (m *BlockDonationFormMutation) Where(ps ...predicate.BlockDonationForm) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockDonationFormMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockDonationFormMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockDonationForm, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockDonationFormMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockDonationFormMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockDonationForm).
func (m *BlockDonationFormMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockDonationFormMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.internal_name != nil {
		fields = append(fields, blockdonationform.FieldInternalName)
	}
	if m.title != nil {
		fields = append(fields, blockdonationform.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blockdonationform.FieldDescription)
	}
	if m.show_amount_buttons != nil {
		fields = append(fields, blockdonationform.FieldShowAmountButtons)
	}
	if m.default_amounts != nil {
		fields = append(fields, blockdonationform.FieldDefaultAmounts)
	}
	if m.allow_custom_amount != nil {
		fields = append(fields, blockdonationform.FieldAllowCustomAmount)
	}
	if m.show_recurring != nil {
		fields = append(fields, blockdonationform.FieldShowRecurring)
	}
	if m.color_scheme != nil {
		fields = append(fields, blockdonationform.FieldColorScheme)
	}
	if m.created_at != nil {
		fields = append(fields, blockdonationform.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockdonationform.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockDonationFormMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockdonationform.FieldInternalName:
		return m.InternalName()
	case blockdonationform.FieldTitle:
		return m.Title()
	case blockdonationform.FieldDescription:
		return m.Description()
	case blockdonationform.FieldShowAmountButtons:
		return m.ShowAmountButtons()
	case blockdonationform.FieldDefaultAmounts:
		return m.DefaultAmounts()
	case blockdonationform.FieldAllowCustomAmount:
		return m.AllowCustomAmount()
	case blockdonationform.FieldShowRecurring:
		return m.ShowRecurring()
	case blockdonationform.FieldColorScheme:
		return m.ColorScheme()
	case blockdonationform.FieldCreatedAt:
		return m.CreatedAt()
	case blockdonationform.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockDonationFormMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockdonationform.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockdonationform.FieldTitle:
		return m.OldTitle(ctx)
	case blockdonationform.FieldDescription:
		return m.OldDescription(ctx)
	case blockdonationform.FieldShowAmountButtons:
		return m.OldShowAmountButtons(ctx)
	case blockdonationform.FieldDefaultAmounts:
		return m.OldDefaultAmounts(ctx)
	case blockdonationform.FieldAllowCustomAmount:
		return m.OldAllowCustomAmount(ctx)
	case blockdonationform.FieldShowRecurring:
		return m.OldShowRecurring(ctx)
	case blockdonationform.FieldColorScheme:
		return m.OldColorScheme(ctx)
	case blockdonationform.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockdonationform.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockDonationForm field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockDonationFormMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockdonationform.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockdonationform.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockdonationform.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockdonationform.FieldShowAmountButtons:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowAmountButtons(v)
		return nil
	case blockdonationform.FieldDefaultAmounts:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultAmounts(v)
		return nil
	case blockdonationform.FieldAllowCustomAmount:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowCustomAmount(v)
		return nil
	case blockdonationform.FieldShowRecurring:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowRecurring(v)
		return nil
	case blockdonationform.FieldColorScheme:
		v, ok := value.(blockdonationform.ColorScheme)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorScheme(v)
		return nil
	case blockdonationform.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockdonationform.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockDonationForm field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockDonationFormMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockDonationFormMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockDonationFormMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockDonationForm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockDonationFormMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockdonationform.FieldDescription) {
		fields = append(fields, blockdonationform.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockDonationFormMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockDonationFormMutation) ClearField(name string) error {
	switch name {
	case blockdonationform.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlockDonationForm nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockDonationFormMutation) ResetField(name string) error {
	switch name {
	case blockdonationform.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockdonationform.FieldTitle:
		m.ResetTitle()
		return nil
	case blockdonationform.FieldDescription:
		m.ResetDescription()
		return nil
	case blockdonationform.FieldShowAmountButtons:
		m.ResetShowAmountButtons()
		return nil
	case blockdonationform.FieldDefaultAmounts:
		m.ResetDefaultAmounts()
		return nil
	case blockdonationform.FieldAllowCustomAmount:
		m.ResetAllowCustomAmount()
		return nil
	case blockdonationform.FieldShowRecurring:
		m.ResetShowRecurring()
		return nil
	case blockdonationform.FieldColorScheme:
		m.ResetColorScheme()
		return nil
	case blockdonationform.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockdonationform.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockDonationForm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockDonationFormMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content_block != nil {
		edges = append(edges, blockdonationform.EdgeContentBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockDonationFormMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockdonationform.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockDonationFormMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockDonationFormMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockDonationFormMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent_block {
		edges = append(edges, blockdonationform.EdgeContentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockDonationFormMutation) EdgeCleared(name string) bool {
	switch name {
	case blockdonationform.EdgeContentBlock:
		return m.clearedcontent_block
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockDonationFormMutation) ClearEdge(name string) error {
	switch name {
	case blockdonationform.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockDonationForm unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockDonationFormMutation) ResetEdge(name string) error {
	switch name {
	case blockdonationform.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockDonationForm edge %s", name)
}

// BlockFaqMutation represents an operation that mutates the BlockFaq nodes in the graph.
type BlockFaqMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	badge                *map[string]string
	title                *map[string]string
	description          *map[string]string
	allow_multiple_open  *bool
	default_open_first   *bool
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	items                map[int]struct{}
	removeditems         map[int]struct{}
	cleareditems         bool
	done                 bool
	oldValue             func(context.Context) (*BlockFaq, error)
	predicates           []predicate.BlockFaq
}

var _ ent.Mutation = (*BlockFaqMutation)(nil)

// blockfaqOption allows management of the mutation configuration using functional options.
type blockfaqOption func(*BlockFaqMutation)

// newBlockFaqMutation creates new mutation for the BlockFaq entity.
func newBlockFaqMutation(c config, op Op, opts ...blockfaqOption) *BlockFaqMutation {
	m := &BlockFaqMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockFaq,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockFaqID sets the ID field of the mutation.
func withBlockFaqID(id int) blockfaqOption {
	return func(m *BlockFaqMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockFaq
		)
		m.oldValue = func(ctx context.Context) (*BlockFaq, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockFaq.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockFaq sets the old BlockFaq of the mutation.
func withBlockFaq(node *BlockFaq) blockfaqOption {
	return func(m *BlockFaqMutation) {
		m.oldValue = func(context.Context) (*BlockFaq, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockFaqMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockFaqMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockFaqMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockFaqMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockFaq.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockFaqMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockFaqMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockFaq entity.
// If the BlockFaq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockFaqMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockFaqMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetBadge sets the "badge" field.
func (m *BlockFaqMutation) SetBadge(value map[string]string) {
	m.badge = &value
}

// Badge returns the value of the "badge" field in the mutation.
func (m *BlockFaqMutation) Badge() (r map[string]string, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the BlockFaq entity.
// If the BlockFaq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockFaqMutation) OldBadge(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *BlockFaqMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[blockfaq.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *BlockFaqMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[blockfaq.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *BlockFaqMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, blockfaq.FieldBadge)
}

// SetTitle sets the "title" field.
func (m *BlockFaqMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockFaqMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockFaq entity.
// If the BlockFaq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockFaqMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockFaqMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BlockFaqMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockFaqMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockFaq entity.
// If the BlockFaq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockFaqMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockFaqMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockfaq.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockFaqMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockfaq.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockFaqMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockfaq.FieldDescription)
}

// SetAllowMultipleOpen sets the "allow_multiple_open" field.
func (m *BlockFaqMutation) SetAllowMultipleOpen(b bool) {
	m.allow_multiple_open = &b
}

// AllowMultipleOpen returns the value of the "allow_multiple_open" field in the mutation.
func (m *BlockFaqMutation) AllowMultipleOpen() (r bool, exists bool) {
	v := m.allow_multiple_open
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowMultipleOpen returns the old "allow_multiple_open" field's value of the BlockFaq entity.
// If the BlockFaq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockFaqMutation) OldAllowMultipleOpen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowMultipleOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowMultipleOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowMultipleOpen: %w", err)
	}
	return oldValue.AllowMultipleOpen, nil
}

// ResetAllowMultipleOpen resets all changes to the "allow_multiple_open" field.
func (m *BlockFaqMutation) ResetAllowMultipleOpen() {
	m.allow_multiple_open = nil
}

// SetDefaultOpenFirst sets the "default_open_first" field.
func (m *BlockFaqMutation) SetDefaultOpenFirst(b bool) {
	m.default_open_first = &b
}

// DefaultOpenFirst returns the value of the "default_open_first" field in the mutation.
func (m *BlockFaqMutation) DefaultOpenFirst() (r bool, exists bool) {
	v := m.default_open_first
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultOpenFirst returns the old "default_open_first" field's value of the BlockFaq entity.
// If the BlockFaq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockFaqMutation) OldDefaultOpenFirst(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultOpenFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultOpenFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultOpenFirst: %w", err)
	}
	return oldValue.DefaultOpenFirst, nil
}

// ResetDefaultOpenFirst resets all changes to the "default_open_first" field.
func (m *BlockFaqMutation) ResetDefaultOpenFirst() {
	m.default_open_first = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockFaqMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockFaqMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockFaq entity.
// If the BlockFaq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockFaqMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockFaqMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockFaqMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockFaqMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockFaq entity.
// If the BlockFaq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockFaqMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockFaqMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockFaqMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockFaqMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockFaqMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockFaqMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockFaqMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockFaqMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// AddItemIDs adds the "items" edge to the FaqItem entity by ids.
func (m *BlockFaqMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the FaqItem entity.
func (m *BlockFaqMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the FaqItem entity was cleared.
func (m *BlockFaqMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the FaqItem entity by IDs.
func (m *BlockFaqMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the FaqItem entity.
func (m *BlockFaqMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *BlockFaqMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *BlockFaqMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the BlockFaqMutation builder.
func (m *BlockFaqMutation) Where(ps ...predicate.BlockFaq) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockFaqMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockFaqMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockFaq, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockFaqMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockFaqMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockFaq).
func (m *BlockFaqMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockFaqMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.internal_name != nil {
		fields = append(fields, blockfaq.FieldInternalName)
	}
	if m.badge != nil {
		fields = append(fields, blockfaq.FieldBadge)
	}
	if m.title != nil {
		fields = append(fields, blockfaq.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blockfaq.FieldDescription)
	}
	if m.allow_multiple_open != nil {
		fields = append(fields, blockfaq.FieldAllowMultipleOpen)
	}
	if m.default_open_first != nil {
		fields = append(fields, blockfaq.FieldDefaultOpenFirst)
	}
	if m.created_at != nil {
		fields = append(fields, blockfaq.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockfaq.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockFaqMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockfaq.FieldInternalName:
		return m.InternalName()
	case blockfaq.FieldBadge:
		return m.Badge()
	case blockfaq.FieldTitle:
		return m.Title()
	case blockfaq.FieldDescription:
		return m.Description()
	case blockfaq.FieldAllowMultipleOpen:
		return m.AllowMultipleOpen()
	case blockfaq.FieldDefaultOpenFirst:
		return m.DefaultOpenFirst()
	case blockfaq.FieldCreatedAt:
		return m.CreatedAt()
	case blockfaq.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockFaqMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockfaq.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockfaq.FieldBadge:
		return m.OldBadge(ctx)
	case blockfaq.FieldTitle:
		return m.OldTitle(ctx)
	case blockfaq.FieldDescription:
		return m.OldDescription(ctx)
	case blockfaq.FieldAllowMultipleOpen:
		return m.OldAllowMultipleOpen(ctx)
	case blockfaq.FieldDefaultOpenFirst:
		return m.OldDefaultOpenFirst(ctx)
	case blockfaq.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockfaq.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockFaq field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockFaqMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockfaq.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockfaq.FieldBadge:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	case blockfaq.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockfaq.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockfaq.FieldAllowMultipleOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowMultipleOpen(v)
		return nil
	case blockfaq.FieldDefaultOpenFirst:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultOpenFirst(v)
		return nil
	case blockfaq.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockfaq.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockFaq field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockFaqMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockFaqMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockFaqMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockFaq numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockFaqMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockfaq.FieldBadge) {
		fields = append(fields, blockfaq.FieldBadge)
	}
	if m.FieldCleared(blockfaq.FieldDescription) {
		fields = append(fields, blockfaq.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockFaqMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockFaqMutation) ClearField(name string) error {
	switch name {
	case blockfaq.FieldBadge:
		m.ClearBadge()
		return nil
	case blockfaq.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlockFaq nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockFaqMutation) ResetField(name string) error {
	switch name {
	case blockfaq.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockfaq.FieldBadge:
		m.ResetBadge()
		return nil
	case blockfaq.FieldTitle:
		m.ResetTitle()
		return nil
	case blockfaq.FieldDescription:
		m.ResetDescription()
		return nil
	case blockfaq.FieldAllowMultipleOpen:
		m.ResetAllowMultipleOpen()
		return nil
	case blockfaq.FieldDefaultOpenFirst:
		m.ResetDefaultOpenFirst()
		return nil
	case blockfaq.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockfaq.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockFaq field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockFaqMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.content_block != nil {
		edges = append(edges, blockfaq.EdgeContentBlock)
	}
	if m.items != nil {
		edges = append(edges, blockfaq.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockFaqMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockfaq.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	case blockfaq.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockFaqMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, blockfaq.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockFaqMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blockfaq.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockFaqMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontent_block {
		edges = append(edges, blockfaq.EdgeContentBlock)
	}
	if m.cleareditems {
		edges = append(edges, blockfaq.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockFaqMutation) EdgeCleared(name string) bool {
	switch name {
	case blockfaq.EdgeContentBlock:
		return m.clearedcontent_block
	case blockfaq.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockFaqMutation) ClearEdge(name string) error {
	switch name {
	case blockfaq.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockFaq unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockFaqMutation) ResetEdge(name string) error {
	switch name {
	case blockfaq.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	case blockfaq.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown BlockFaq edge %s", name)
}

// BlockGalleryMutation represents an operation that mutates the BlockGallery nodes in the graph.
type BlockGalleryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	title                *map[string]string
	description          *map[string]string
	layout               *blockgallery.Layout
	columns              *int
	addcolumns           *int
	spacing              *string
	aspect_ratio         *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	images               map[int]struct{}
	removedimages        map[int]struct{}
	clearedimages        bool
	done                 bool
	oldValue             func(context.Context) (*BlockGallery, error)
	predicates           []predicate.BlockGallery
}

var _ ent.Mutation = (*BlockGalleryMutation)(nil)

// blockgalleryOption allows management of the mutation configuration using functional options.
type blockgalleryOption func(*BlockGalleryMutation)

// newBlockGalleryMutation creates new mutation for the BlockGallery entity.
func newBlockGalleryMutation(c config, op Op, opts ...blockgalleryOption) *BlockGalleryMutation {
	m := &BlockGalleryMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockGallery,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockGalleryID sets the ID field of the mutation.
func withBlockGalleryID(id int) blockgalleryOption {
	return func(m *BlockGalleryMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockGallery
		)
		m.oldValue = func(ctx context.Context) (*BlockGallery, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockGallery.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockGallery sets the old BlockGallery of the mutation.
func withBlockGallery(node *BlockGallery) blockgalleryOption {
	return func(m *BlockGalleryMutation) {
		m.oldValue = func(context.Context) (*BlockGallery, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockGalleryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockGalleryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockGalleryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockGalleryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockGallery.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockGalleryMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockGalleryMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockGallery entity.
// If the BlockGallery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockGalleryMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockGalleryMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetTitle sets the "title" field.
func (m *BlockGalleryMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockGalleryMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockGallery entity.
// If the BlockGallery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockGalleryMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *BlockGalleryMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[blockgallery.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *BlockGalleryMutation) TitleCleared() bool {
	_, ok := m.clearedFields[blockgallery.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockGalleryMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, blockgallery.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *BlockGalleryMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockGalleryMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockGallery entity.
// If the BlockGallery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockGalleryMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockGalleryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockgallery.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockGalleryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockgallery.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockGalleryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockgallery.FieldDescription)
}

// SetLayout sets the "layout" field.
func (m *BlockGalleryMutation) SetLayout(b blockgallery.Layout) {
	m.layout = &b
}

// Layout returns the value of the "layout" field in the mutation.
func (m *BlockGalleryMutation) Layout() (r blockgallery.Layout, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the BlockGallery entity.
// If the BlockGallery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockGalleryMutation) OldLayout(ctx context.Context) (v blockgallery.Layout, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ResetLayout resets all changes to the "layout" field.
func (m *BlockGalleryMutation) ResetLayout() {
	m.layout = nil
}

// SetColumns sets the "columns" field.
func (m *BlockGalleryMutation) SetColumns(i int) {
	m.columns = &i
	m.addcolumns = nil
}

// Columns returns the value of the "columns" field in the mutation.
func (m *BlockGalleryMutation) Columns() (r int, exists bool) {
	v := m.columns
	if v == nil {
		return
	}
	return *v, true
}

// OldColumns returns the old "columns" field's value of the BlockGallery entity.
// If the BlockGallery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockGalleryMutation) OldColumns(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColumns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColumns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColumns: %w", err)
	}
	return oldValue.Columns, nil
}

// AddColumns adds i to the "columns" field.
func (m *BlockGalleryMutation) AddColumns(i int) {
	if m.addcolumns != nil {
		*m.addcolumns += i
	} else {
		m.addcolumns = &i
	}
}

// AddedColumns returns the value that was added to the "columns" field in this mutation.
func (m *BlockGalleryMutation) AddedColumns() (r int, exists bool) {
	v := m.addcolumns
	if v == nil {
		return
	}
	return *v, true
}

// ResetColumns resets all changes to the "columns" field.
func (m *BlockGalleryMutation) ResetColumns() {
	m.columns = nil
	m.addcolumns = nil
}

// SetSpacing sets the "spacing" field.
func (m *BlockGalleryMutation) SetSpacing(s string) {
	m.spacing = &s
}

// Spacing returns the value of the "spacing" field in the mutation.
func (m *BlockGalleryMutation) Spacing() (r string, exists bool) {
	v := m.spacing
	if v == nil {
		return
	}
	return *v, true
}

// OldSpacing returns the old "spacing" field's value of the BlockGallery entity.
// If the BlockGallery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockGalleryMutation) OldSpacing(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpacing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpacing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpacing: %w", err)
	}
	return oldValue.Spacing, nil
}

// ResetSpacing resets all changes to the "spacing" field.
func (m *BlockGalleryMutation) ResetSpacing() {
	m.spacing = nil
}

// SetAspectRatio sets the "aspect_ratio" field.
func (m *BlockGalleryMutation) SetAspectRatio(s string) {
	m.aspect_ratio = &s
}

// AspectRatio returns the value of the "aspect_ratio" field in the mutation.
func (m *BlockGalleryMutation) AspectRatio() (r string, exists bool) {
	v := m.aspect_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldAspectRatio returns the old "aspect_ratio" field's value of the BlockGallery entity.
// If the BlockGallery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockGalleryMutation) OldAspectRatio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAspectRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAspectRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAspectRatio: %w", err)
	}
	return oldValue.AspectRatio, nil
}

// ClearAspectRatio clears the value of the "aspect_ratio" field.
func (m *BlockGalleryMutation) ClearAspectRatio() {
	m.aspect_ratio = nil
	m.clearedFields[blockgallery.FieldAspectRatio] = struct{}{}
}

// AspectRatioCleared returns if the "aspect_ratio" field was cleared in this mutation.
func (m *BlockGalleryMutation) AspectRatioCleared() bool {
	_, ok := m.clearedFields[blockgallery.FieldAspectRatio]
	return ok
}

// ResetAspectRatio resets all changes to the "aspect_ratio" field.
func (m *BlockGalleryMutation) ResetAspectRatio() {
	m.aspect_ratio = nil
	delete(m.clearedFields, blockgallery.FieldAspectRatio)
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockGalleryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockGalleryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockGallery entity.
// If the BlockGallery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockGalleryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockGalleryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockGalleryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockGalleryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockGallery entity.
// If the BlockGallery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockGalleryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockGalleryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockGalleryMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockGalleryMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockGalleryMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockGalleryMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockGalleryMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockGalleryMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// AddImageIDs adds the "images" edge to the GalleryImage entity by ids.
func (m *BlockGalleryMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the GalleryImage entity.
func (m *BlockGalleryMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the GalleryImage entity was cleared.
func (m *BlockGalleryMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the GalleryImage entity by IDs.
func (m *BlockGalleryMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the GalleryImage entity.
func (m *BlockGalleryMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *BlockGalleryMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *BlockGalleryMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// Where appends a list predicates to the BlockGalleryMutation builder.
func (m *BlockGalleryMutation) Where(ps ...predicate.BlockGallery) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockGalleryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockGalleryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockGallery, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockGalleryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockGalleryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockGallery).
func (m *BlockGalleryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockGalleryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.internal_name != nil {
		fields = append(fields, blockgallery.FieldInternalName)
	}
	if m.title != nil {
		fields = append(fields, blockgallery.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blockgallery.FieldDescription)
	}
	if m.layout != nil {
		fields = append(fields, blockgallery.FieldLayout)
	}
	if m.columns != nil {
		fields = append(fields, blockgallery.FieldColumns)
	}
	if m.spacing != nil {
		fields = append(fields, blockgallery.FieldSpacing)
	}
	if m.aspect_ratio != nil {
		fields = append(fields, blockgallery.FieldAspectRatio)
	}
	if m.created_at != nil {
		fields = append(fields, blockgallery.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockgallery.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockGalleryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockgallery.FieldInternalName:
		return m.InternalName()
	case blockgallery.FieldTitle:
		return m.Title()
	case blockgallery.FieldDescription:
		return m.Description()
	case blockgallery.FieldLayout:
		return m.Layout()
	case blockgallery.FieldColumns:
		return m.Columns()
	case blockgallery.FieldSpacing:
		return m.Spacing()
	case blockgallery.FieldAspectRatio:
		return m.AspectRatio()
	case blockgallery.FieldCreatedAt:
		return m.CreatedAt()
	case blockgallery.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockGalleryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockgallery.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockgallery.FieldTitle:
		return m.OldTitle(ctx)
	case blockgallery.FieldDescription:
		return m.OldDescription(ctx)
	case blockgallery.FieldLayout:
		return m.OldLayout(ctx)
	case blockgallery.FieldColumns:
		return m.OldColumns(ctx)
	case blockgallery.FieldSpacing:
		return m.OldSpacing(ctx)
	case blockgallery.FieldAspectRatio:
		return m.OldAspectRatio(ctx)
	case blockgallery.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockgallery.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockGallery field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockGalleryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockgallery.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockgallery.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockgallery.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockgallery.FieldLayout:
		v, ok := value.(blockgallery.Layout)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case blockgallery.FieldColumns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColumns(v)
		return nil
	case blockgallery.FieldSpacing:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpacing(v)
		return nil
	case blockgallery.FieldAspectRatio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAspectRatio(v)
		return nil
	case blockgallery.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockgallery.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockGallery field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockGalleryMutation) AddedFields() []string {
	var fields []string
	if m.addcolumns != nil {
		fields = append(fields, blockgallery.FieldColumns)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockGalleryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockgallery.FieldColumns:
		return m.AddedColumns()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockGalleryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockgallery.FieldColumns:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddColumns(v)
		return nil
	}
	return fmt.Errorf("unknown BlockGallery numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockGalleryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockgallery.FieldTitle) {
		fields = append(fields, blockgallery.FieldTitle)
	}
	if m.FieldCleared(blockgallery.FieldDescription) {
		fields = append(fields, blockgallery.FieldDescription)
	}
	if m.FieldCleared(blockgallery.FieldAspectRatio) {
		fields = append(fields, blockgallery.FieldAspectRatio)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockGalleryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockGalleryMutation) ClearField(name string) error {
	switch name {
	case blockgallery.FieldTitle:
		m.ClearTitle()
		return nil
	case blockgallery.FieldDescription:
		m.ClearDescription()
		return nil
	case blockgallery.FieldAspectRatio:
		m.ClearAspectRatio()
		return nil
	}
	return fmt.Errorf("unknown BlockGallery nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockGalleryMutation) ResetField(name string) error {
	switch name {
	case blockgallery.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockgallery.FieldTitle:
		m.ResetTitle()
		return nil
	case blockgallery.FieldDescription:
		m.ResetDescription()
		return nil
	case blockgallery.FieldLayout:
		m.ResetLayout()
		return nil
	case blockgallery.FieldColumns:
		m.ResetColumns()
		return nil
	case blockgallery.FieldSpacing:
		m.ResetSpacing()
		return nil
	case blockgallery.FieldAspectRatio:
		m.ResetAspectRatio()
		return nil
	case blockgallery.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockgallery.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockGallery field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockGalleryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.content_block != nil {
		edges = append(edges, blockgallery.EdgeContentBlock)
	}
	if m.images != nil {
		edges = append(edges, blockgallery.EdgeImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockGalleryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockgallery.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	case blockgallery.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockGalleryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedimages != nil {
		edges = append(edges, blockgallery.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockGalleryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blockgallery.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockGalleryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontent_block {
		edges = append(edges, blockgallery.EdgeContentBlock)
	}
	if m.clearedimages {
		edges = append(edges, blockgallery.EdgeImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockGalleryMutation) EdgeCleared(name string) bool {
	switch name {
	case blockgallery.EdgeContentBlock:
		return m.clearedcontent_block
	case blockgallery.EdgeImages:
		return m.clearedimages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockGalleryMutation) ClearEdge(name string) error {
	switch name {
	case blockgallery.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockGallery unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockGalleryMutation) ResetEdge(name string) error {
	switch name {
	case blockgallery.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	case blockgallery.EdgeImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown BlockGallery edge %s", name)
}

// BlockHeroMutation represents an operation that mutates the BlockHero nodes in the graph.
type BlockHeroMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	title                *map[string]string
	subtitle             *map[string]string
	cta_buttons          *[]map[string]interface{}
	appendcta_buttons    []map[string]interface{}
	background_image_url *string
	badge                *map[string]string
	description          *map[string]string
	text_align           *blockhero.TextAlign
	color_scheme         *blockhero.ColorScheme
	min_height           *string
	background_video_url *string
	overlay_color        *string
	overlay_opacity      *float64
	addoverlay_opacity   *float64
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	done                 bool
	oldValue             func(context.Context) (*BlockHero, error)
	predicates           []predicate.BlockHero
}

var _ ent.Mutation = (*BlockHeroMutation)(nil)

// blockheroOption allows management of the mutation configuration using functional options.
type blockheroOption func(*BlockHeroMutation)

// newBlockHeroMutation creates new mutation for the BlockHero entity.
func newBlockHeroMutation(c config, op Op, opts ...blockheroOption) *BlockHeroMutation {
	m := &BlockHeroMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockHero,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockHeroID sets the ID field of the mutation.
func withBlockHeroID(id int) blockheroOption {
	return func(m *BlockHeroMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockHero
		)
		m.oldValue = func(ctx context.Context) (*BlockHero, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockHero.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockHero sets the old BlockHero of the mutation.
func withBlockHero(node *BlockHero) blockheroOption {
	return func(m *BlockHeroMutation) {
		m.oldValue = func(context.Context) (*BlockHero, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockHeroMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockHeroMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockHeroMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockHeroMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockHero.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockHeroMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockHeroMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockHeroMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetTitle sets the "title" field.
func (m *BlockHeroMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockHeroMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockHeroMutation) ResetTitle() {
	m.title = nil
}

// SetSubtitle sets the "subtitle" field.
func (m *BlockHeroMutation) SetSubtitle(value map[string]string) {
	m.subtitle = &value
}

// Subtitle returns the value of the "subtitle" field in the mutation.
func (m *BlockHeroMutation) Subtitle() (r map[string]string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old "subtitle" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldSubtitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ClearSubtitle clears the value of the "subtitle" field.
func (m *BlockHeroMutation) ClearSubtitle() {
	m.subtitle = nil
	m.clearedFields[blockhero.FieldSubtitle] = struct{}{}
}

// SubtitleCleared returns if the "subtitle" field was cleared in this mutation.
func (m *BlockHeroMutation) SubtitleCleared() bool {
	_, ok := m.clearedFields[blockhero.FieldSubtitle]
	return ok
}

// ResetSubtitle resets all changes to the "subtitle" field.
func (m *BlockHeroMutation) ResetSubtitle() {
	m.subtitle = nil
	delete(m.clearedFields, blockhero.FieldSubtitle)
}

// SetCtaButtons sets the "cta_buttons" field.
func (m *BlockHeroMutation) SetCtaButtons(value []map[string]interface{}) {
	m.cta_buttons = &value
	m.appendcta_buttons = nil
}

// CtaButtons returns the value of the "cta_buttons" field in the mutation.
func (m *BlockHeroMutation) CtaButtons() (r []map[string]interface{}, exists bool) {
	v := m.cta_buttons
	if v == nil {
		return
	}
	return *v, true
}

// OldCtaButtons returns the old "cta_buttons" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldCtaButtons(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCtaButtons is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCtaButtons requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCtaButtons: %w", err)
	}
	return oldValue.CtaButtons, nil
}

// AppendCtaButtons adds value to the "cta_buttons" field.
func (m *BlockHeroMutation) AppendCtaButtons(value []map[string]interface{}) {
	m.appendcta_buttons = append(m.appendcta_buttons, value...)
}

// AppendedCtaButtons returns the list of values that were appended to the "cta_buttons" field in this mutation.
func (m *BlockHeroMutation) AppendedCtaButtons() ([]map[string]interface{}, bool) {
	if len(m.appendcta_buttons) == 0 {
		return nil, false
	}
	return m.appendcta_buttons, true
}

// ClearCtaButtons clears the value of the "cta_buttons" field.
func (m *BlockHeroMutation) ClearCtaButtons() {
	m.cta_buttons = nil
	m.appendcta_buttons = nil
	m.clearedFields[blockhero.FieldCtaButtons] = struct{}{}
}

// CtaButtonsCleared returns if the "cta_buttons" field was cleared in this mutation.
func (m *BlockHeroMutation) CtaButtonsCleared() bool {
	_, ok := m.clearedFields[blockhero.FieldCtaButtons]
	return ok
}

// ResetCtaButtons resets all changes to the "cta_buttons" field.
func (m *BlockHeroMutation) ResetCtaButtons() {
	m.cta_buttons = nil
	m.appendcta_buttons = nil
	delete(m.clearedFields, blockhero.FieldCtaButtons)
}

// SetBackgroundImageURL sets the "background_image_url" field.
func (m *BlockHeroMutation) SetBackgroundImageURL(s string) {
	m.background_image_url = &s
}

// BackgroundImageURL returns the value of the "background_image_url" field in the mutation.
func (m *BlockHeroMutation) BackgroundImageURL() (r string, exists bool) {
	v := m.background_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundImageURL returns the old "background_image_url" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldBackgroundImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundImageURL: %w", err)
	}
	return oldValue.BackgroundImageURL, nil
}

// ClearBackgroundImageURL clears the value of the "background_image_url" field.
func (m *BlockHeroMutation) ClearBackgroundImageURL() {
	m.background_image_url = nil
	m.clearedFields[blockhero.FieldBackgroundImageURL] = struct{}{}
}

// BackgroundImageURLCleared returns if the "background_image_url" field was cleared in this mutation.
func (m *BlockHeroMutation) BackgroundImageURLCleared() bool {
	_, ok := m.clearedFields[blockhero.FieldBackgroundImageURL]
	return ok
}

// ResetBackgroundImageURL resets all changes to the "background_image_url" field.
func (m *BlockHeroMutation) ResetBackgroundImageURL() {
	m.background_image_url = nil
	delete(m.clearedFields, blockhero.FieldBackgroundImageURL)
}

// SetBadge sets the "badge" field.
func (m *BlockHeroMutation) SetBadge(value map[string]string) {
	m.badge = &value
}

// Badge returns the value of the "badge" field in the mutation.
func (m *BlockHeroMutation) Badge() (r map[string]string, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldBadge(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *BlockHeroMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[blockhero.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *BlockHeroMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[blockhero.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *BlockHeroMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, blockhero.FieldBadge)
}

// SetDescription sets the "description" field.
func (m *BlockHeroMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockHeroMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockHeroMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockhero.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockHeroMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockhero.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockHeroMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockhero.FieldDescription)
}

// SetTextAlign sets the "text_align" field.
func (m *BlockHeroMutation) SetTextAlign(ba blockhero.TextAlign) {
	m.text_align = &ba
}

// TextAlign returns the value of the "text_align" field in the mutation.
func (m *BlockHeroMutation) TextAlign() (r blockhero.TextAlign, exists bool) {
	v := m.text_align
	if v == nil {
		return
	}
	return *v, true
}

// OldTextAlign returns the old "text_align" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldTextAlign(ctx context.Context) (v blockhero.TextAlign, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextAlign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextAlign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextAlign: %w", err)
	}
	return oldValue.TextAlign, nil
}

// ResetTextAlign resets all changes to the "text_align" field.
func (m *BlockHeroMutation) ResetTextAlign() {
	m.text_align = nil
}

// SetColorScheme sets the "color_scheme" field.
func (m *BlockHeroMutation) SetColorScheme(bs blockhero.ColorScheme) {
	m.color_scheme = &bs
}

// ColorScheme returns the value of the "color_scheme" field in the mutation.
func (m *BlockHeroMutation) ColorScheme() (r blockhero.ColorScheme, exists bool) {
	v := m.color_scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldColorScheme returns the old "color_scheme" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldColorScheme(ctx context.Context) (v blockhero.ColorScheme, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorScheme: %w", err)
	}
	return oldValue.ColorScheme, nil
}

// ResetColorScheme resets all changes to the "color_scheme" field.
func (m *BlockHeroMutation) ResetColorScheme() {
	m.color_scheme = nil
}

// SetMinHeight sets the "min_height" field.
func (m *BlockHeroMutation) SetMinHeight(s string) {
	m.min_height = &s
}

// MinHeight returns the value of the "min_height" field in the mutation.
func (m *BlockHeroMutation) MinHeight() (r string, exists bool) {
	v := m.min_height
	if v == nil {
		return
	}
	return *v, true
}

// OldMinHeight returns the old "min_height" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldMinHeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinHeight: %w", err)
	}
	return oldValue.MinHeight, nil
}

// ClearMinHeight clears the value of the "min_height" field.
func (m *BlockHeroMutation) ClearMinHeight() {
	m.min_height = nil
	m.clearedFields[blockhero.FieldMinHeight] = struct{}{}
}

// MinHeightCleared returns if the "min_height" field was cleared in this mutation.
func (m *BlockHeroMutation) MinHeightCleared() bool {
	_, ok := m.clearedFields[blockhero.FieldMinHeight]
	return ok
}

// ResetMinHeight resets all changes to the "min_height" field.
func (m *BlockHeroMutation) ResetMinHeight() {
	m.min_height = nil
	delete(m.clearedFields, blockhero.FieldMinHeight)
}

// SetBackgroundVideoURL sets the "background_video_url" field.
func (m *BlockHeroMutation) SetBackgroundVideoURL(s string) {
	m.background_video_url = &s
}

// BackgroundVideoURL returns the value of the "background_video_url" field in the mutation.
func (m *BlockHeroMutation) BackgroundVideoURL() (r string, exists bool) {
	v := m.background_video_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundVideoURL returns the old "background_video_url" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldBackgroundVideoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundVideoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundVideoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundVideoURL: %w", err)
	}
	return oldValue.BackgroundVideoURL, nil
}

// ClearBackgroundVideoURL clears the value of the "background_video_url" field.
func (m *BlockHeroMutation) ClearBackgroundVideoURL() {
	m.background_video_url = nil
	m.clearedFields[blockhero.FieldBackgroundVideoURL] = struct{}{}
}

// BackgroundVideoURLCleared returns if the "background_video_url" field was cleared in this mutation.
func (m *BlockHeroMutation) BackgroundVideoURLCleared() bool {
	_, ok := m.clearedFields[blockhero.FieldBackgroundVideoURL]
	return ok
}

// ResetBackgroundVideoURL resets all changes to the "background_video_url" field.
func (m *BlockHeroMutation) ResetBackgroundVideoURL() {
	m.background_video_url = nil
	delete(m.clearedFields, blockhero.FieldBackgroundVideoURL)
}

// SetOverlayColor sets the "overlay_color" field.
func (m *BlockHeroMutation) SetOverlayColor(s string) {
	m.overlay_color = &s
}

// OverlayColor returns the value of the "overlay_color" field in the mutation.
func (m *BlockHeroMutation) OverlayColor() (r string, exists bool) {
	v := m.overlay_color
	if v == nil {
		return
	}
	return *v, true
}

// OldOverlayColor returns the old "overlay_color" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldOverlayColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverlayColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverlayColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverlayColor: %w", err)
	}
	return oldValue.OverlayColor, nil
}

// ClearOverlayColor clears the value of the "overlay_color" field.
func (m *BlockHeroMutation) ClearOverlayColor() {
	m.overlay_color = nil
	m.clearedFields[blockhero.FieldOverlayColor] = struct{}{}
}

// OverlayColorCleared returns if the "overlay_color" field was cleared in this mutation.
func (m *BlockHeroMutation) OverlayColorCleared() bool {
	_, ok := m.clearedFields[blockhero.FieldOverlayColor]
	return ok
}

// ResetOverlayColor resets all changes to the "overlay_color" field.
func (m *BlockHeroMutation) ResetOverlayColor() {
	m.overlay_color = nil
	delete(m.clearedFields, blockhero.FieldOverlayColor)
}

// SetOverlayOpacity sets the "overlay_opacity" field.
func (m *BlockHeroMutation) SetOverlayOpacity(f float64) {
	m.overlay_opacity = &f
	m.addoverlay_opacity = nil
}

// OverlayOpacity returns the value of the "overlay_opacity" field in the mutation.
func (m *BlockHeroMutation) OverlayOpacity() (r float64, exists bool) {
	v := m.overlay_opacity
	if v == nil {
		return
	}
	return *v, true
}

// OldOverlayOpacity returns the old "overlay_opacity" field's value of the BlockHero entity.
// If the BlockHero object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeroMutation) OldOverlayOpacity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverlayOpacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverlayOpacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverlayOpacity: %w", err)
	}
	return oldValue.OverlayOpacity, nil
}

// AddOverlayOpacity adds f to the "overlay_opacity" field.
func (m *BlockHeroMutation) AddOverlayOpacity(f float64) {
	if m.addoverlay_opacity != nil {
		*m.addoverlay_opacity += f
	} else {
		m.addoverlay_opacity = &f
	}
}

// AddedOverlayOpacity returns the value that was added to the "overlay_opacity" field in this mutation.
func (m *BlockHeroMutation) AddedOverlayOpacity() (r float64, exists bool) {
	v := m.addoverlay_opacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearOverlayOpacity clears the value of the "overlay_opacity" field.
func (m *BlockHeroMutation) ClearOverlayOpacity() {
	m.overlay_opacity = nil
	m.addoverlay_opacity = nil
	m.clearedFields[blockhero.FieldOverlayOpacity] = struct{}{}
}

// OverlayOpacityCleared returns if the "overlay_opacity" field was cleared in this mutation.
func (m *BlockHeroMutation) OverlayOpacityCleared() bool {
	_, ok := m.clearedFields[blockhero.FieldOverlayOpacity]
	return ok
}

// ResetOverlayOpacity resets all changes to the "overlay_opacity" field.
func (m *BlockHeroMutation) ResetOverlayOpacity() {
	m.overlay_opacity = nil
	m.addoverlay_opacity = nil
	delete(m.clearedFields, blockhero.FieldOverlayOpacity)
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockHeroMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockHeroMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockHeroMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockHeroMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockHeroMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockHeroMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// Where appends a list predicates to the BlockHeroMutation builder.
func (m *BlockHeroMutation) Where(ps ...predicate.BlockHero) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockHeroMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockHeroMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockHero, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockHeroMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockHeroMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockHero).
func (m *BlockHeroMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockHeroMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.internal_name != nil {
		fields = append(fields, blockhero.FieldInternalName)
	}
	if m.title != nil {
		fields = append(fields, blockhero.FieldTitle)
	}
	if m.subtitle != nil {
		fields = append(fields, blockhero.FieldSubtitle)
	}
	if m.cta_buttons != nil {
		fields = append(fields, blockhero.FieldCtaButtons)
	}
	if m.background_image_url != nil {
		fields = append(fields, blockhero.FieldBackgroundImageURL)
	}
	if m.badge != nil {
		fields = append(fields, blockhero.FieldBadge)
	}
	if m.description != nil {
		fields = append(fields, blockhero.FieldDescription)
	}
	if m.text_align != nil {
		fields = append(fields, blockhero.FieldTextAlign)
	}
	if m.color_scheme != nil {
		fields = append(fields, blockhero.FieldColorScheme)
	}
	if m.min_height != nil {
		fields = append(fields, blockhero.FieldMinHeight)
	}
	if m.background_video_url != nil {
		fields = append(fields, blockhero.FieldBackgroundVideoURL)
	}
	if m.overlay_color != nil {
		fields = append(fields, blockhero.FieldOverlayColor)
	}
	if m.overlay_opacity != nil {
		fields = append(fields, blockhero.FieldOverlayOpacity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockHeroMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockhero.FieldInternalName:
		return m.InternalName()
	case blockhero.FieldTitle:
		return m.Title()
	case blockhero.FieldSubtitle:
		return m.Subtitle()
	case blockhero.FieldCtaButtons:
		return m.CtaButtons()
	case blockhero.FieldBackgroundImageURL:
		return m.BackgroundImageURL()
	case blockhero.FieldBadge:
		return m.Badge()
	case blockhero.FieldDescription:
		return m.Description()
	case blockhero.FieldTextAlign:
		return m.TextAlign()
	case blockhero.FieldColorScheme:
		return m.ColorScheme()
	case blockhero.FieldMinHeight:
		return m.MinHeight()
	case blockhero.FieldBackgroundVideoURL:
		return m.BackgroundVideoURL()
	case blockhero.FieldOverlayColor:
		return m.OverlayColor()
	case blockhero.FieldOverlayOpacity:
		return m.OverlayOpacity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockHeroMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockhero.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockhero.FieldTitle:
		return m.OldTitle(ctx)
	case blockhero.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case blockhero.FieldCtaButtons:
		return m.OldCtaButtons(ctx)
	case blockhero.FieldBackgroundImageURL:
		return m.OldBackgroundImageURL(ctx)
	case blockhero.FieldBadge:
		return m.OldBadge(ctx)
	case blockhero.FieldDescription:
		return m.OldDescription(ctx)
	case blockhero.FieldTextAlign:
		return m.OldTextAlign(ctx)
	case blockhero.FieldColorScheme:
		return m.OldColorScheme(ctx)
	case blockhero.FieldMinHeight:
		return m.OldMinHeight(ctx)
	case blockhero.FieldBackgroundVideoURL:
		return m.OldBackgroundVideoURL(ctx)
	case blockhero.FieldOverlayColor:
		return m.OldOverlayColor(ctx)
	case blockhero.FieldOverlayOpacity:
		return m.OldOverlayOpacity(ctx)
	}
	return nil, fmt.Errorf("unknown BlockHero field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockHeroMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockhero.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockhero.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockhero.FieldSubtitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case blockhero.FieldCtaButtons:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCtaButtons(v)
		return nil
	case blockhero.FieldBackgroundImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundImageURL(v)
		return nil
	case blockhero.FieldBadge:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	case blockhero.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockhero.FieldTextAlign:
		v, ok := value.(blockhero.TextAlign)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextAlign(v)
		return nil
	case blockhero.FieldColorScheme:
		v, ok := value.(blockhero.ColorScheme)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorScheme(v)
		return nil
	case blockhero.FieldMinHeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinHeight(v)
		return nil
	case blockhero.FieldBackgroundVideoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundVideoURL(v)
		return nil
	case blockhero.FieldOverlayColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverlayColor(v)
		return nil
	case blockhero.FieldOverlayOpacity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverlayOpacity(v)
		return nil
	}
	return fmt.Errorf("unknown BlockHero field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockHeroMutation) AddedFields() []string {
	var fields []string
	if m.addoverlay_opacity != nil {
		fields = append(fields, blockhero.FieldOverlayOpacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockHeroMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockhero.FieldOverlayOpacity:
		return m.AddedOverlayOpacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockHeroMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockhero.FieldOverlayOpacity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverlayOpacity(v)
		return nil
	}
	return fmt.Errorf("unknown BlockHero numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockHeroMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockhero.FieldSubtitle) {
		fields = append(fields, blockhero.FieldSubtitle)
	}
	if m.FieldCleared(blockhero.FieldCtaButtons) {
		fields = append(fields, blockhero.FieldCtaButtons)
	}
	if m.FieldCleared(blockhero.FieldBackgroundImageURL) {
		fields = append(fields, blockhero.FieldBackgroundImageURL)
	}
	if m.FieldCleared(blockhero.FieldBadge) {
		fields = append(fields, blockhero.FieldBadge)
	}
	if m.FieldCleared(blockhero.FieldDescription) {
		fields = append(fields, blockhero.FieldDescription)
	}
	if m.FieldCleared(blockhero.FieldMinHeight) {
		fields = append(fields, blockhero.FieldMinHeight)
	}
	if m.FieldCleared(blockhero.FieldBackgroundVideoURL) {
		fields = append(fields, blockhero.FieldBackgroundVideoURL)
	}
	if m.FieldCleared(blockhero.FieldOverlayColor) {
		fields = append(fields, blockhero.FieldOverlayColor)
	}
	if m.FieldCleared(blockhero.FieldOverlayOpacity) {
		fields = append(fields, blockhero.FieldOverlayOpacity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockHeroMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockHeroMutation) ClearField(name string) error {
	switch name {
	case blockhero.FieldSubtitle:
		m.ClearSubtitle()
		return nil
	case blockhero.FieldCtaButtons:
		m.ClearCtaButtons()
		return nil
	case blockhero.FieldBackgroundImageURL:
		m.ClearBackgroundImageURL()
		return nil
	case blockhero.FieldBadge:
		m.ClearBadge()
		return nil
	case blockhero.FieldDescription:
		m.ClearDescription()
		return nil
	case blockhero.FieldMinHeight:
		m.ClearMinHeight()
		return nil
	case blockhero.FieldBackgroundVideoURL:
		m.ClearBackgroundVideoURL()
		return nil
	case blockhero.FieldOverlayColor:
		m.ClearOverlayColor()
		return nil
	case blockhero.FieldOverlayOpacity:
		m.ClearOverlayOpacity()
		return nil
	}
	return fmt.Errorf("unknown BlockHero nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockHeroMutation) ResetField(name string) error {
	switch name {
	case blockhero.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockhero.FieldTitle:
		m.ResetTitle()
		return nil
	case blockhero.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case blockhero.FieldCtaButtons:
		m.ResetCtaButtons()
		return nil
	case blockhero.FieldBackgroundImageURL:
		m.ResetBackgroundImageURL()
		return nil
	case blockhero.FieldBadge:
		m.ResetBadge()
		return nil
	case blockhero.FieldDescription:
		m.ResetDescription()
		return nil
	case blockhero.FieldTextAlign:
		m.ResetTextAlign()
		return nil
	case blockhero.FieldColorScheme:
		m.ResetColorScheme()
		return nil
	case blockhero.FieldMinHeight:
		m.ResetMinHeight()
		return nil
	case blockhero.FieldBackgroundVideoURL:
		m.ResetBackgroundVideoURL()
		return nil
	case blockhero.FieldOverlayColor:
		m.ResetOverlayColor()
		return nil
	case blockhero.FieldOverlayOpacity:
		m.ResetOverlayOpacity()
		return nil
	}
	return fmt.Errorf("unknown BlockHero field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockHeroMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content_block != nil {
		edges = append(edges, blockhero.EdgeContentBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockHeroMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockhero.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockHeroMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockHeroMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockHeroMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent_block {
		edges = append(edges, blockhero.EdgeContentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockHeroMutation) EdgeCleared(name string) bool {
	switch name {
	case blockhero.EdgeContentBlock:
		return m.clearedcontent_block
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockHeroMutation) ClearEdge(name string) error {
	switch name {
	case blockhero.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockHero unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockHeroMutation) ResetEdge(name string) error {
	switch name {
	case blockhero.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockHero edge %s", name)
}

// BlockMapMutation represents an operation that mutates the BlockMap nodes in the graph.
type BlockMapMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	latitude             *float64
	addlatitude          *float64
	longitude            *float64
	addlongitude         *float64
	zoom                 *int
	addzoom              *int
	markers              *[]map[string]interface{}
	appendmarkers        []map[string]interface{}
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	done                 bool
	oldValue             func(context.Context) (*BlockMap, error)
	predicates           []predicate.BlockMap
}

var _ ent.Mutation = (*BlockMapMutation)(nil)

// blockmapOption allows management of the mutation configuration using functional options.
type blockmapOption func(*BlockMapMutation)

// newBlockMapMutation creates new mutation for the BlockMap entity.
func newBlockMapMutation(c config, op Op, opts ...blockmapOption) *BlockMapMutation {
	m := &BlockMapMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockMap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockMapID sets the ID field of the mutation.
func withBlockMapID(id int) blockmapOption {
	return func(m *BlockMapMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockMap
		)
		m.oldValue = func(ctx context.Context) (*BlockMap, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockMap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockMap sets the old BlockMap of the mutation.
func withBlockMap(node *BlockMap) blockmapOption {
	return func(m *BlockMapMutation) {
		m.oldValue = func(context.Context) (*BlockMap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockMapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockMapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockMapMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockMapMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockMap.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockMapMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockMapMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockMap entity.
// If the BlockMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMapMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockMapMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetLatitude sets the "latitude" field.
func (m *BlockMapMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *BlockMapMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the BlockMap entity.
// If the BlockMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMapMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *BlockMapMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *BlockMapMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *BlockMapMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLongitude sets the "longitude" field.
func (m *BlockMapMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *BlockMapMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the BlockMap entity.
// If the BlockMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMapMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *BlockMapMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *BlockMapMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *BlockMapMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetZoom sets the "zoom" field.
func (m *BlockMapMutation) SetZoom(i int) {
	m.zoom = &i
	m.addzoom = nil
}

// Zoom returns the value of the "zoom" field in the mutation.
func (m *BlockMapMutation) Zoom() (r int, exists bool) {
	v := m.zoom
	if v == nil {
		return
	}
	return *v, true
}

// OldZoom returns the old "zoom" field's value of the BlockMap entity.
// If the BlockMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMapMutation) OldZoom(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZoom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZoom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZoom: %w", err)
	}
	return oldValue.Zoom, nil
}

// AddZoom adds i to the "zoom" field.
func (m *BlockMapMutation) AddZoom(i int) {
	if m.addzoom != nil {
		*m.addzoom += i
	} else {
		m.addzoom = &i
	}
}

// AddedZoom returns the value that was added to the "zoom" field in this mutation.
func (m *BlockMapMutation) AddedZoom() (r int, exists bool) {
	v := m.addzoom
	if v == nil {
		return
	}
	return *v, true
}

// ResetZoom resets all changes to the "zoom" field.
func (m *BlockMapMutation) ResetZoom() {
	m.zoom = nil
	m.addzoom = nil
}

// SetMarkers sets the "markers" field.
func (m *BlockMapMutation) SetMarkers(value []map[string]interface{}) {
	m.markers = &value
	m.appendmarkers = nil
}

// Markers returns the value of the "markers" field in the mutation.
func (m *BlockMapMutation) Markers() (r []map[string]interface{}, exists bool) {
	v := m.markers
	if v == nil {
		return
	}
	return *v, true
}

// OldMarkers returns the old "markers" field's value of the BlockMap entity.
// If the BlockMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMapMutation) OldMarkers(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarkers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarkers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarkers: %w", err)
	}
	return oldValue.Markers, nil
}

// AppendMarkers adds value to the "markers" field.
func (m *BlockMapMutation) AppendMarkers(value []map[string]interface{}) {
	m.appendmarkers = append(m.appendmarkers, value...)
}

// AppendedMarkers returns the list of values that were appended to the "markers" field in this mutation.
func (m *BlockMapMutation) AppendedMarkers() ([]map[string]interface{}, bool) {
	if len(m.appendmarkers) == 0 {
		return nil, false
	}
	return m.appendmarkers, true
}

// ClearMarkers clears the value of the "markers" field.
func (m *BlockMapMutation) ClearMarkers() {
	m.markers = nil
	m.appendmarkers = nil
	m.clearedFields[blockmap.FieldMarkers] = struct{}{}
}

// MarkersCleared returns if the "markers" field was cleared in this mutation.
func (m *BlockMapMutation) MarkersCleared() bool {
	_, ok := m.clearedFields[blockmap.FieldMarkers]
	return ok
}

// ResetMarkers resets all changes to the "markers" field.
func (m *BlockMapMutation) ResetMarkers() {
	m.markers = nil
	m.appendmarkers = nil
	delete(m.clearedFields, blockmap.FieldMarkers)
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockMapMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockMapMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockMap entity.
// If the BlockMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMapMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockMapMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockMapMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockMapMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockMap entity.
// If the BlockMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMapMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockMapMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockMapMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockMapMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockMapMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockMapMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockMapMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockMapMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// Where appends a list predicates to the BlockMapMutation builder.
func (m *BlockMapMutation) Where(ps ...predicate.BlockMap) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockMapMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockMapMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockMap, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockMapMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockMapMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockMap).
func (m *BlockMapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockMapMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.internal_name != nil {
		fields = append(fields, blockmap.FieldInternalName)
	}
	if m.latitude != nil {
		fields = append(fields, blockmap.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, blockmap.FieldLongitude)
	}
	if m.zoom != nil {
		fields = append(fields, blockmap.FieldZoom)
	}
	if m.markers != nil {
		fields = append(fields, blockmap.FieldMarkers)
	}
	if m.created_at != nil {
		fields = append(fields, blockmap.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockmap.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockMapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockmap.FieldInternalName:
		return m.InternalName()
	case blockmap.FieldLatitude:
		return m.Latitude()
	case blockmap.FieldLongitude:
		return m.Longitude()
	case blockmap.FieldZoom:
		return m.Zoom()
	case blockmap.FieldMarkers:
		return m.Markers()
	case blockmap.FieldCreatedAt:
		return m.CreatedAt()
	case blockmap.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockMapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockmap.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockmap.FieldLatitude:
		return m.OldLatitude(ctx)
	case blockmap.FieldLongitude:
		return m.OldLongitude(ctx)
	case blockmap.FieldZoom:
		return m.OldZoom(ctx)
	case blockmap.FieldMarkers:
		return m.OldMarkers(ctx)
	case blockmap.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockmap.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockMap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockMapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockmap.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockmap.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case blockmap.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case blockmap.FieldZoom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZoom(v)
		return nil
	case blockmap.FieldMarkers:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarkers(v)
		return nil
	case blockmap.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockmap.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockMap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockMapMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, blockmap.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, blockmap.FieldLongitude)
	}
	if m.addzoom != nil {
		fields = append(fields, blockmap.FieldZoom)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockMapMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockmap.FieldLatitude:
		return m.AddedLatitude()
	case blockmap.FieldLongitude:
		return m.AddedLongitude()
	case blockmap.FieldZoom:
		return m.AddedZoom()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockMapMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockmap.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case blockmap.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case blockmap.FieldZoom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddZoom(v)
		return nil
	}
	return fmt.Errorf("unknown BlockMap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockMapMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockmap.FieldMarkers) {
		fields = append(fields, blockmap.FieldMarkers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockMapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockMapMutation) ClearField(name string) error {
	switch name {
	case blockmap.FieldMarkers:
		m.ClearMarkers()
		return nil
	}
	return fmt.Errorf("unknown BlockMap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockMapMutation) ResetField(name string) error {
	switch name {
	case blockmap.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockmap.FieldLatitude:
		m.ResetLatitude()
		return nil
	case blockmap.FieldLongitude:
		m.ResetLongitude()
		return nil
	case blockmap.FieldZoom:
		m.ResetZoom()
		return nil
	case blockmap.FieldMarkers:
		m.ResetMarkers()
		return nil
	case blockmap.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockmap.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockMap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockMapMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content_block != nil {
		edges = append(edges, blockmap.EdgeContentBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockMapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockmap.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockMapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockMapMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockMapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent_block {
		edges = append(edges, blockmap.EdgeContentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockMapMutation) EdgeCleared(name string) bool {
	switch name {
	case blockmap.EdgeContentBlock:
		return m.clearedcontent_block
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockMapMutation) ClearEdge(name string) error {
	switch name {
	case blockmap.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockMap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockMapMutation) ResetEdge(name string) error {
	switch name {
	case blockmap.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockMap edge %s", name)
}

// BlockNewsletterSignupMutation represents an operation that mutates the BlockNewsletterSignup nodes in the graph.
type BlockNewsletterSignupMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	title                *map[string]string
	description          *map[string]string
	button_text          *map[string]string
	show_name_field      *bool
	placeholder          *map[string]string
	layout               *string
	color_scheme         *blocknewslettersignup.ColorScheme
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	done                 bool
	oldValue             func(context.Context) (*BlockNewsletterSignup, error)
	predicates           []predicate.BlockNewsletterSignup
}

var _ ent.Mutation = (*BlockNewsletterSignupMutation)(nil)

// blocknewslettersignupOption allows management of the mutation configuration using functional options.
type blocknewslettersignupOption func(*BlockNewsletterSignupMutation)

// newBlockNewsletterSignupMutation creates new mutation for the BlockNewsletterSignup entity.
func newBlockNewsletterSignupMutation(c config, op Op, opts ...blocknewslettersignupOption) *BlockNewsletterSignupMutation {
	m := &BlockNewsletterSignupMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockNewsletterSignup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockNewsletterSignupID sets the ID field of the mutation.
func withBlockNewsletterSignupID(id int) blocknewslettersignupOption {
	return func(m *BlockNewsletterSignupMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockNewsletterSignup
		)
		m.oldValue = func(ctx context.Context) (*BlockNewsletterSignup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockNewsletterSignup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockNewsletterSignup sets the old BlockNewsletterSignup of the mutation.
func withBlockNewsletterSignup(node *BlockNewsletterSignup) blocknewslettersignupOption {
	return func(m *BlockNewsletterSignupMutation) {
		m.oldValue = func(context.Context) (*BlockNewsletterSignup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockNewsletterSignupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockNewsletterSignupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockNewsletterSignupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockNewsletterSignupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockNewsletterSignup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockNewsletterSignupMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockNewsletterSignupMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockNewsletterSignup entity.
// If the BlockNewsletterSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockNewsletterSignupMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockNewsletterSignupMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetTitle sets the "title" field.
func (m *BlockNewsletterSignupMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockNewsletterSignupMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockNewsletterSignup entity.
// If the BlockNewsletterSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockNewsletterSignupMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockNewsletterSignupMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BlockNewsletterSignupMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockNewsletterSignupMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockNewsletterSignup entity.
// If the BlockNewsletterSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockNewsletterSignupMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockNewsletterSignupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blocknewslettersignup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockNewsletterSignupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blocknewslettersignup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockNewsletterSignupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blocknewslettersignup.FieldDescription)
}

// SetButtonText sets the "button_text" field.
func (m *BlockNewsletterSignupMutation) SetButtonText(value map[string]string) {
	m.button_text = &value
}

// ButtonText returns the value of the "button_text" field in the mutation.
func (m *BlockNewsletterSignupMutation) ButtonText() (r map[string]string, exists bool) {
	v := m.button_text
	if v == nil {
		return
	}
	return *v, true
}

// OldButtonText returns the old "button_text" field's value of the BlockNewsletterSignup entity.
// If the BlockNewsletterSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockNewsletterSignupMutation) OldButtonText(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldButtonText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldButtonText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldButtonText: %w", err)
	}
	return oldValue.ButtonText, nil
}

// ResetButtonText resets all changes to the "button_text" field.
func (m *BlockNewsletterSignupMutation) ResetButtonText() {
	m.button_text = nil
}

// SetShowNameField sets the "show_name_field" field.
func (m *BlockNewsletterSignupMutation) SetShowNameField(b bool) {
	m.show_name_field = &b
}

// ShowNameField returns the value of the "show_name_field" field in the mutation.
func (m *BlockNewsletterSignupMutation) ShowNameField() (r bool, exists bool) {
	v := m.show_name_field
	if v == nil {
		return
	}
	return *v, true
}

// OldShowNameField returns the old "show_name_field" field's value of the BlockNewsletterSignup entity.
// If the BlockNewsletterSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockNewsletterSignupMutation) OldShowNameField(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowNameField is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowNameField requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowNameField: %w", err)
	}
	return oldValue.ShowNameField, nil
}

// ResetShowNameField resets all changes to the "show_name_field" field.
func (m *BlockNewsletterSignupMutation) ResetShowNameField() {
	m.show_name_field = nil
}

// SetPlaceholder sets the "placeholder" field.
func (m *BlockNewsletterSignupMutation) SetPlaceholder(value map[string]string) {
	m.placeholder = &value
}

// Placeholder returns the value of the "placeholder" field in the mutation.
func (m *BlockNewsletterSignupMutation) Placeholder() (r map[string]string, exists bool) {
	v := m.placeholder
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceholder returns the old "placeholder" field's value of the BlockNewsletterSignup entity.
// If the BlockNewsletterSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockNewsletterSignupMutation) OldPlaceholder(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceholder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceholder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceholder: %w", err)
	}
	return oldValue.Placeholder, nil
}

// ResetPlaceholder resets all changes to the "placeholder" field.
func (m *BlockNewsletterSignupMutation) ResetPlaceholder() {
	m.placeholder = nil
}

// SetLayout sets the "layout" field.
func (m *BlockNewsletterSignupMutation) SetLayout(s string) {
	m.layout = &s
}

// Layout returns the value of the "layout" field in the mutation.
func (m *BlockNewsletterSignupMutation) Layout() (r string, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the BlockNewsletterSignup entity.
// If the BlockNewsletterSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockNewsletterSignupMutation) OldLayout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ResetLayout resets all changes to the "layout" field.
func (m *BlockNewsletterSignupMutation) ResetLayout() {
	m.layout = nil
}

// SetColorScheme sets the "color_scheme" field.
func (m *BlockNewsletterSignupMutation) SetColorScheme(bs blocknewslettersignup.ColorScheme) {
	m.color_scheme = &bs
}

// ColorScheme returns the value of the "color_scheme" field in the mutation.
func (m *BlockNewsletterSignupMutation) ColorScheme() (r blocknewslettersignup.ColorScheme, exists bool) {
	v := m.color_scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldColorScheme returns the old "color_scheme" field's value of the BlockNewsletterSignup entity.
// If the BlockNewsletterSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockNewsletterSignupMutation) OldColorScheme(ctx context.Context) (v blocknewslettersignup.ColorScheme, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorScheme: %w", err)
	}
	return oldValue.ColorScheme, nil
}

// ResetColorScheme resets all changes to the "color_scheme" field.
func (m *BlockNewsletterSignupMutation) ResetColorScheme() {
	m.color_scheme = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockNewsletterSignupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockNewsletterSignupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockNewsletterSignup entity.
// If the BlockNewsletterSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockNewsletterSignupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockNewsletterSignupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockNewsletterSignupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockNewsletterSignupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockNewsletterSignup entity.
// If the BlockNewsletterSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockNewsletterSignupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockNewsletterSignupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockNewsletterSignupMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockNewsletterSignupMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockNewsletterSignupMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockNewsletterSignupMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockNewsletterSignupMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockNewsletterSignupMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// Where appends a list predicates to the BlockNewsletterSignupMutation builder.
func (m *BlockNewsletterSignupMutation) Where(ps ...predicate.BlockNewsletterSignup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockNewsletterSignupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockNewsletterSignupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockNewsletterSignup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockNewsletterSignupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockNewsletterSignupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockNewsletterSignup).
func (m *BlockNewsletterSignupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockNewsletterSignupMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.internal_name != nil {
		fields = append(fields, blocknewslettersignup.FieldInternalName)
	}
	if m.title != nil {
		fields = append(fields, blocknewslettersignup.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blocknewslettersignup.FieldDescription)
	}
	if m.button_text != nil {
		fields = append(fields, blocknewslettersignup.FieldButtonText)
	}
	if m.show_name_field != nil {
		fields = append(fields, blocknewslettersignup.FieldShowNameField)
	}
	if m.placeholder != nil {
		fields = append(fields, blocknewslettersignup.FieldPlaceholder)
	}
	if m.layout != nil {
		fields = append(fields, blocknewslettersignup.FieldLayout)
	}
	if m.color_scheme != nil {
		fields = append(fields, blocknewslettersignup.FieldColorScheme)
	}
	if m.created_at != nil {
		fields = append(fields, blocknewslettersignup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blocknewslettersignup.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockNewsletterSignupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blocknewslettersignup.FieldInternalName:
		return m.InternalName()
	case blocknewslettersignup.FieldTitle:
		return m.Title()
	case blocknewslettersignup.FieldDescription:
		return m.Description()
	case blocknewslettersignup.FieldButtonText:
		return m.ButtonText()
	case blocknewslettersignup.FieldShowNameField:
		return m.ShowNameField()
	case blocknewslettersignup.FieldPlaceholder:
		return m.Placeholder()
	case blocknewslettersignup.FieldLayout:
		return m.Layout()
	case blocknewslettersignup.FieldColorScheme:
		return m.ColorScheme()
	case blocknewslettersignup.FieldCreatedAt:
		return m.CreatedAt()
	case blocknewslettersignup.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockNewsletterSignupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blocknewslettersignup.FieldInternalName:
		return m.OldInternalName(ctx)
	case blocknewslettersignup.FieldTitle:
		return m.OldTitle(ctx)
	case blocknewslettersignup.FieldDescription:
		return m.OldDescription(ctx)
	case blocknewslettersignup.FieldButtonText:
		return m.OldButtonText(ctx)
	case blocknewslettersignup.FieldShowNameField:
		return m.OldShowNameField(ctx)
	case blocknewslettersignup.FieldPlaceholder:
		return m.OldPlaceholder(ctx)
	case blocknewslettersignup.FieldLayout:
		return m.OldLayout(ctx)
	case blocknewslettersignup.FieldColorScheme:
		return m.OldColorScheme(ctx)
	case blocknewslettersignup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blocknewslettersignup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockNewsletterSignup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockNewsletterSignupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blocknewslettersignup.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blocknewslettersignup.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blocknewslettersignup.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blocknewslettersignup.FieldButtonText:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetButtonText(v)
		return nil
	case blocknewslettersignup.FieldShowNameField:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowNameField(v)
		return nil
	case blocknewslettersignup.FieldPlaceholder:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceholder(v)
		return nil
	case blocknewslettersignup.FieldLayout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case blocknewslettersignup.FieldColorScheme:
		v, ok := value.(blocknewslettersignup.ColorScheme)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorScheme(v)
		return nil
	case blocknewslettersignup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blocknewslettersignup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockNewsletterSignup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockNewsletterSignupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockNewsletterSignupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockNewsletterSignupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockNewsletterSignup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockNewsletterSignupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blocknewslettersignup.FieldDescription) {
		fields = append(fields, blocknewslettersignup.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockNewsletterSignupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockNewsletterSignupMutation) ClearField(name string) error {
	switch name {
	case blocknewslettersignup.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlockNewsletterSignup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockNewsletterSignupMutation) ResetField(name string) error {
	switch name {
	case blocknewslettersignup.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blocknewslettersignup.FieldTitle:
		m.ResetTitle()
		return nil
	case blocknewslettersignup.FieldDescription:
		m.ResetDescription()
		return nil
	case blocknewslettersignup.FieldButtonText:
		m.ResetButtonText()
		return nil
	case blocknewslettersignup.FieldShowNameField:
		m.ResetShowNameField()
		return nil
	case blocknewslettersignup.FieldPlaceholder:
		m.ResetPlaceholder()
		return nil
	case blocknewslettersignup.FieldLayout:
		m.ResetLayout()
		return nil
	case blocknewslettersignup.FieldColorScheme:
		m.ResetColorScheme()
		return nil
	case blocknewslettersignup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blocknewslettersignup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockNewsletterSignup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockNewsletterSignupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content_block != nil {
		edges = append(edges, blocknewslettersignup.EdgeContentBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockNewsletterSignupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blocknewslettersignup.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockNewsletterSignupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockNewsletterSignupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockNewsletterSignupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent_block {
		edges = append(edges, blocknewslettersignup.EdgeContentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockNewsletterSignupMutation) EdgeCleared(name string) bool {
	switch name {
	case blocknewslettersignup.EdgeContentBlock:
		return m.clearedcontent_block
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockNewsletterSignupMutation) ClearEdge(name string) error {
	switch name {
	case blocknewslettersignup.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockNewsletterSignup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockNewsletterSignupMutation) ResetEdge(name string) error {
	switch name {
	case blocknewslettersignup.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockNewsletterSignup edge %s", name)
}

// BlockPartnerLogosMutation represents an operation that mutates the BlockPartnerLogos nodes in the graph.
type BlockPartnerLogosMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	title                *map[string]string
	description          *map[string]string
	layout               *string
	items_per_row        *int
	additems_per_row     *int
	grayscale            *bool
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	partners             map[int]struct{}
	removedpartners      map[int]struct{}
	clearedpartners      bool
	done                 bool
	oldValue             func(context.Context) (*BlockPartnerLogos, error)
	predicates           []predicate.BlockPartnerLogos
}

var _ ent.Mutation = (*BlockPartnerLogosMutation)(nil)

// blockpartnerlogosOption allows management of the mutation configuration using functional options.
type blockpartnerlogosOption func(*BlockPartnerLogosMutation)

// newBlockPartnerLogosMutation creates new mutation for the BlockPartnerLogos entity.
func newBlockPartnerLogosMutation(c config, op Op, opts ...blockpartnerlogosOption) *BlockPartnerLogosMutation {
	m := &BlockPartnerLogosMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockPartnerLogos,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockPartnerLogosID sets the ID field of the mutation.
func withBlockPartnerLogosID(id int) blockpartnerlogosOption {
	return func(m *BlockPartnerLogosMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockPartnerLogos
		)
		m.oldValue = func(ctx context.Context) (*BlockPartnerLogos, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockPartnerLogos.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockPartnerLogos sets the old BlockPartnerLogos of the mutation.
func withBlockPartnerLogos(node *BlockPartnerLogos) blockpartnerlogosOption {
	return func(m *BlockPartnerLogosMutation) {
		m.oldValue = func(context.Context) (*BlockPartnerLogos, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockPartnerLogosMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockPartnerLogosMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockPartnerLogosMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockPartnerLogosMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockPartnerLogos.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockPartnerLogosMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockPartnerLogosMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockPartnerLogos entity.
// If the BlockPartnerLogos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockPartnerLogosMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockPartnerLogosMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetTitle sets the "title" field.
func (m *BlockPartnerLogosMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockPartnerLogosMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockPartnerLogos entity.
// If the BlockPartnerLogos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockPartnerLogosMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *BlockPartnerLogosMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[blockpartnerlogos.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *BlockPartnerLogosMutation) TitleCleared() bool {
	_, ok := m.clearedFields[blockpartnerlogos.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockPartnerLogosMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, blockpartnerlogos.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *BlockPartnerLogosMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockPartnerLogosMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockPartnerLogos entity.
// If the BlockPartnerLogos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockPartnerLogosMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockPartnerLogosMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockpartnerlogos.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockPartnerLogosMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockpartnerlogos.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockPartnerLogosMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockpartnerlogos.FieldDescription)
}

// SetLayout sets the "layout" field.
func (m *BlockPartnerLogosMutation) SetLayout(s string) {
	m.layout = &s
}

// Layout returns the value of the "layout" field in the mutation.
func (m *BlockPartnerLogosMutation) Layout() (r string, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the BlockPartnerLogos entity.
// If the BlockPartnerLogos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockPartnerLogosMutation) OldLayout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ResetLayout resets all changes to the "layout" field.
func (m *BlockPartnerLogosMutation) ResetLayout() {
	m.layout = nil
}

// SetItemsPerRow sets the "items_per_row" field.
func (m *BlockPartnerLogosMutation) SetItemsPerRow(i int) {
	m.items_per_row = &i
	m.additems_per_row = nil
}

// ItemsPerRow returns the value of the "items_per_row" field in the mutation.
func (m *BlockPartnerLogosMutation) ItemsPerRow() (r int, exists bool) {
	v := m.items_per_row
	if v == nil {
		return
	}
	return *v, true
}

// OldItemsPerRow returns the old "items_per_row" field's value of the BlockPartnerLogos entity.
// If the BlockPartnerLogos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockPartnerLogosMutation) OldItemsPerRow(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemsPerRow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemsPerRow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemsPerRow: %w", err)
	}
	return oldValue.ItemsPerRow, nil
}

// AddItemsPerRow adds i to the "items_per_row" field.
func (m *BlockPartnerLogosMutation) AddItemsPerRow(i int) {
	if m.additems_per_row != nil {
		*m.additems_per_row += i
	} else {
		m.additems_per_row = &i
	}
}

// AddedItemsPerRow returns the value that was added to the "items_per_row" field in this mutation.
func (m *BlockPartnerLogosMutation) AddedItemsPerRow() (r int, exists bool) {
	v := m.additems_per_row
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemsPerRow resets all changes to the "items_per_row" field.
func (m *BlockPartnerLogosMutation) ResetItemsPerRow() {
	m.items_per_row = nil
	m.additems_per_row = nil
}

// SetGrayscale sets the "grayscale" field.
func (m *BlockPartnerLogosMutation) SetGrayscale(b bool) {
	m.grayscale = &b
}

// Grayscale returns the value of the "grayscale" field in the mutation.
func (m *BlockPartnerLogosMutation) Grayscale() (r bool, exists bool) {
	v := m.grayscale
	if v == nil {
		return
	}
	return *v, true
}

// OldGrayscale returns the old "grayscale" field's value of the BlockPartnerLogos entity.
// If the BlockPartnerLogos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockPartnerLogosMutation) OldGrayscale(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrayscale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrayscale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrayscale: %w", err)
	}
	return oldValue.Grayscale, nil
}

// ResetGrayscale resets all changes to the "grayscale" field.
func (m *BlockPartnerLogosMutation) ResetGrayscale() {
	m.grayscale = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockPartnerLogosMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockPartnerLogosMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockPartnerLogos entity.
// If the BlockPartnerLogos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockPartnerLogosMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockPartnerLogosMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockPartnerLogosMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockPartnerLogosMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockPartnerLogos entity.
// If the BlockPartnerLogos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockPartnerLogosMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockPartnerLogosMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockPartnerLogosMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockPartnerLogosMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockPartnerLogosMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockPartnerLogosMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockPartnerLogosMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockPartnerLogosMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// AddPartnerIDs adds the "partners" edge to the PartnerLogoItem entity by ids.
func (m *BlockPartnerLogosMutation) AddPartnerIDs(ids ...int) {
	if m.partners == nil {
		m.partners = make(map[int]struct{})
	}
	for i := range ids {
		m.partners[ids[i]] = struct{}{}
	}
}

// ClearPartners clears the "partners" edge to the PartnerLogoItem entity.
func (m *BlockPartnerLogosMutation) ClearPartners() {
	m.clearedpartners = true
}

// PartnersCleared reports if the "partners" edge to the PartnerLogoItem entity was cleared.
func (m *BlockPartnerLogosMutation) PartnersCleared() bool {
	return m.clearedpartners
}

// RemovePartnerIDs removes the "partners" edge to the PartnerLogoItem entity by IDs.
func (m *BlockPartnerLogosMutation) RemovePartnerIDs(ids ...int) {
	if m.removedpartners == nil {
		m.removedpartners = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.partners, ids[i])
		m.removedpartners[ids[i]] = struct{}{}
	}
}

// RemovedPartners returns the removed IDs of the "partners" edge to the PartnerLogoItem entity.
func (m *BlockPartnerLogosMutation) RemovedPartnersIDs() (ids []int) {
	for id := range m.removedpartners {
		ids = append(ids, id)
	}
	return
}

// PartnersIDs returns the "partners" edge IDs in the mutation.
func (m *BlockPartnerLogosMutation) PartnersIDs() (ids []int) {
	for id := range m.partners {
		ids = append(ids, id)
	}
	return
}

// ResetPartners resets all changes to the "partners" edge.
func (m *BlockPartnerLogosMutation) ResetPartners() {
	m.partners = nil
	m.clearedpartners = false
	m.removedpartners = nil
}

// Where appends a list predicates to the BlockPartnerLogosMutation builder.
func (m *BlockPartnerLogosMutation) Where(ps ...predicate.BlockPartnerLogos) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockPartnerLogosMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockPartnerLogosMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockPartnerLogos, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockPartnerLogosMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockPartnerLogosMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockPartnerLogos).
func (m *BlockPartnerLogosMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockPartnerLogosMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.internal_name != nil {
		fields = append(fields, blockpartnerlogos.FieldInternalName)
	}
	if m.title != nil {
		fields = append(fields, blockpartnerlogos.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blockpartnerlogos.FieldDescription)
	}
	if m.layout != nil {
		fields = append(fields, blockpartnerlogos.FieldLayout)
	}
	if m.items_per_row != nil {
		fields = append(fields, blockpartnerlogos.FieldItemsPerRow)
	}
	if m.grayscale != nil {
		fields = append(fields, blockpartnerlogos.FieldGrayscale)
	}
	if m.created_at != nil {
		fields = append(fields, blockpartnerlogos.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockpartnerlogos.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockPartnerLogosMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockpartnerlogos.FieldInternalName:
		return m.InternalName()
	case blockpartnerlogos.FieldTitle:
		return m.Title()
	case blockpartnerlogos.FieldDescription:
		return m.Description()
	case blockpartnerlogos.FieldLayout:
		return m.Layout()
	case blockpartnerlogos.FieldItemsPerRow:
		return m.ItemsPerRow()
	case blockpartnerlogos.FieldGrayscale:
		return m.Grayscale()
	case blockpartnerlogos.FieldCreatedAt:
		return m.CreatedAt()
	case blockpartnerlogos.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockPartnerLogosMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockpartnerlogos.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockpartnerlogos.FieldTitle:
		return m.OldTitle(ctx)
	case blockpartnerlogos.FieldDescription:
		return m.OldDescription(ctx)
	case blockpartnerlogos.FieldLayout:
		return m.OldLayout(ctx)
	case blockpartnerlogos.FieldItemsPerRow:
		return m.OldItemsPerRow(ctx)
	case blockpartnerlogos.FieldGrayscale:
		return m.OldGrayscale(ctx)
	case blockpartnerlogos.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockpartnerlogos.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockPartnerLogos field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockPartnerLogosMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockpartnerlogos.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockpartnerlogos.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockpartnerlogos.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockpartnerlogos.FieldLayout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case blockpartnerlogos.FieldItemsPerRow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemsPerRow(v)
		return nil
	case blockpartnerlogos.FieldGrayscale:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrayscale(v)
		return nil
	case blockpartnerlogos.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockpartnerlogos.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockPartnerLogos field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockPartnerLogosMutation) AddedFields() []string {
	var fields []string
	if m.additems_per_row != nil {
		fields = append(fields, blockpartnerlogos.FieldItemsPerRow)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockPartnerLogosMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockpartnerlogos.FieldItemsPerRow:
		return m.AddedItemsPerRow()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockPartnerLogosMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockpartnerlogos.FieldItemsPerRow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemsPerRow(v)
		return nil
	}
	return fmt.Errorf("unknown BlockPartnerLogos numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockPartnerLogosMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockpartnerlogos.FieldTitle) {
		fields = append(fields, blockpartnerlogos.FieldTitle)
	}
	if m.FieldCleared(blockpartnerlogos.FieldDescription) {
		fields = append(fields, blockpartnerlogos.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockPartnerLogosMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockPartnerLogosMutation) ClearField(name string) error {
	switch name {
	case blockpartnerlogos.FieldTitle:
		m.ClearTitle()
		return nil
	case blockpartnerlogos.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlockPartnerLogos nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockPartnerLogosMutation) ResetField(name string) error {
	switch name {
	case blockpartnerlogos.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockpartnerlogos.FieldTitle:
		m.ResetTitle()
		return nil
	case blockpartnerlogos.FieldDescription:
		m.ResetDescription()
		return nil
	case blockpartnerlogos.FieldLayout:
		m.ResetLayout()
		return nil
	case blockpartnerlogos.FieldItemsPerRow:
		m.ResetItemsPerRow()
		return nil
	case blockpartnerlogos.FieldGrayscale:
		m.ResetGrayscale()
		return nil
	case blockpartnerlogos.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockpartnerlogos.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockPartnerLogos field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockPartnerLogosMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.content_block != nil {
		edges = append(edges, blockpartnerlogos.EdgeContentBlock)
	}
	if m.partners != nil {
		edges = append(edges, blockpartnerlogos.EdgePartners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockPartnerLogosMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockpartnerlogos.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	case blockpartnerlogos.EdgePartners:
		ids := make([]ent.Value, 0, len(m.partners))
		for id := range m.partners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockPartnerLogosMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpartners != nil {
		edges = append(edges, blockpartnerlogos.EdgePartners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockPartnerLogosMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blockpartnerlogos.EdgePartners:
		ids := make([]ent.Value, 0, len(m.removedpartners))
		for id := range m.removedpartners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockPartnerLogosMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontent_block {
		edges = append(edges, blockpartnerlogos.EdgeContentBlock)
	}
	if m.clearedpartners {
		edges = append(edges, blockpartnerlogos.EdgePartners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockPartnerLogosMutation) EdgeCleared(name string) bool {
	switch name {
	case blockpartnerlogos.EdgeContentBlock:
		return m.clearedcontent_block
	case blockpartnerlogos.EdgePartners:
		return m.clearedpartners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockPartnerLogosMutation) ClearEdge(name string) error {
	switch name {
	case blockpartnerlogos.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockPartnerLogos unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockPartnerLogosMutation) ResetEdge(name string) error {
	switch name {
	case blockpartnerlogos.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	case blockpartnerlogos.EdgePartners:
		m.ResetPartners()
		return nil
	}
	return fmt.Errorf("unknown BlockPartnerLogos edge %s", name)
}

// BlockProgramCardsMutation represents an operation that mutates the BlockProgramCards nodes in the graph.
type BlockProgramCardsMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	internal_name            *string
	badge                    *map[string]string
	title                    *map[string]string
	description              *map[string]string
	layout                   *string
	items_per_row            *int
	additems_per_row         *int
	show_all_programs        *bool
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	content_block            *int
	clearedcontent_block     bool
	selected_programs        map[int]struct{}
	removedselected_programs map[int]struct{}
	clearedselected_programs bool
	done                     bool
	oldValue                 func(context.Context) (*BlockProgramCards, error)
	predicates               []predicate.BlockProgramCards
}

var _ ent.Mutation = (*BlockProgramCardsMutation)(nil)

// blockprogramcardsOption allows management of the mutation configuration using functional options.
type blockprogramcardsOption func(*BlockProgramCardsMutation)

// newBlockProgramCardsMutation creates new mutation for the BlockProgramCards entity.
func newBlockProgramCardsMutation(c config, op Op, opts ...blockprogramcardsOption) *BlockProgramCardsMutation {
	m := &BlockProgramCardsMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockProgramCards,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockProgramCardsID sets the ID field of the mutation.
func withBlockProgramCardsID(id int) blockprogramcardsOption {
	return func(m *BlockProgramCardsMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockProgramCards
		)
		m.oldValue = func(ctx context.Context) (*BlockProgramCards, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockProgramCards.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockProgramCards sets the old BlockProgramCards of the mutation.
func withBlockProgramCards(node *BlockProgramCards) blockprogramcardsOption {
	return func(m *BlockProgramCardsMutation) {
		m.oldValue = func(context.Context) (*BlockProgramCards, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockProgramCardsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockProgramCardsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockProgramCardsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockProgramCardsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockProgramCards.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockProgramCardsMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockProgramCardsMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockProgramCards entity.
// If the BlockProgramCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockProgramCardsMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockProgramCardsMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetBadge sets the "badge" field.
func (m *BlockProgramCardsMutation) SetBadge(value map[string]string) {
	m.badge = &value
}

// Badge returns the value of the "badge" field in the mutation.
func (m *BlockProgramCardsMutation) Badge() (r map[string]string, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the BlockProgramCards entity.
// If the BlockProgramCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockProgramCardsMutation) OldBadge(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *BlockProgramCardsMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[blockprogramcards.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *BlockProgramCardsMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[blockprogramcards.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *BlockProgramCardsMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, blockprogramcards.FieldBadge)
}

// SetTitle sets the "title" field.
func (m *BlockProgramCardsMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockProgramCardsMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockProgramCards entity.
// If the BlockProgramCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockProgramCardsMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *BlockProgramCardsMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[blockprogramcards.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *BlockProgramCardsMutation) TitleCleared() bool {
	_, ok := m.clearedFields[blockprogramcards.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockProgramCardsMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, blockprogramcards.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *BlockProgramCardsMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockProgramCardsMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockProgramCards entity.
// If the BlockProgramCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockProgramCardsMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockProgramCardsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockprogramcards.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockProgramCardsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockprogramcards.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockProgramCardsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockprogramcards.FieldDescription)
}

// SetLayout sets the "layout" field.
func (m *BlockProgramCardsMutation) SetLayout(s string) {
	m.layout = &s
}

// Layout returns the value of the "layout" field in the mutation.
func (m *BlockProgramCardsMutation) Layout() (r string, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the BlockProgramCards entity.
// If the BlockProgramCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockProgramCardsMutation) OldLayout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ResetLayout resets all changes to the "layout" field.
func (m *BlockProgramCardsMutation) ResetLayout() {
	m.layout = nil
}

// SetItemsPerRow sets the "items_per_row" field.
func (m *BlockProgramCardsMutation) SetItemsPerRow(i int) {
	m.items_per_row = &i
	m.additems_per_row = nil
}

// ItemsPerRow returns the value of the "items_per_row" field in the mutation.
func (m *BlockProgramCardsMutation) ItemsPerRow() (r int, exists bool) {
	v := m.items_per_row
	if v == nil {
		return
	}
	return *v, true
}

// OldItemsPerRow returns the old "items_per_row" field's value of the BlockProgramCards entity.
// If the BlockProgramCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockProgramCardsMutation) OldItemsPerRow(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemsPerRow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemsPerRow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemsPerRow: %w", err)
	}
	return oldValue.ItemsPerRow, nil
}

// AddItemsPerRow adds i to the "items_per_row" field.
func (m *BlockProgramCardsMutation) AddItemsPerRow(i int) {
	if m.additems_per_row != nil {
		*m.additems_per_row += i
	} else {
		m.additems_per_row = &i
	}
}

// AddedItemsPerRow returns the value that was added to the "items_per_row" field in this mutation.
func (m *BlockProgramCardsMutation) AddedItemsPerRow() (r int, exists bool) {
	v := m.additems_per_row
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemsPerRow resets all changes to the "items_per_row" field.
func (m *BlockProgramCardsMutation) ResetItemsPerRow() {
	m.items_per_row = nil
	m.additems_per_row = nil
}

// SetShowAllPrograms sets the "show_all_programs" field.
func (m *BlockProgramCardsMutation) SetShowAllPrograms(b bool) {
	m.show_all_programs = &b
}

// ShowAllPrograms returns the value of the "show_all_programs" field in the mutation.
func (m *BlockProgramCardsMutation) ShowAllPrograms() (r bool, exists bool) {
	v := m.show_all_programs
	if v == nil {
		return
	}
	return *v, true
}

// OldShowAllPrograms returns the old "show_all_programs" field's value of the BlockProgramCards entity.
// If the BlockProgramCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockProgramCardsMutation) OldShowAllPrograms(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowAllPrograms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowAllPrograms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowAllPrograms: %w", err)
	}
	return oldValue.ShowAllPrograms, nil
}

// ResetShowAllPrograms resets all changes to the "show_all_programs" field.
func (m *BlockProgramCardsMutation) ResetShowAllPrograms() {
	m.show_all_programs = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockProgramCardsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockProgramCardsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockProgramCards entity.
// If the BlockProgramCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockProgramCardsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockProgramCardsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockProgramCardsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockProgramCardsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockProgramCards entity.
// If the BlockProgramCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockProgramCardsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockProgramCardsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockProgramCardsMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockProgramCardsMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockProgramCardsMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockProgramCardsMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockProgramCardsMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockProgramCardsMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// AddSelectedProgramIDs adds the "selected_programs" edge to the ProgramCardItem entity by ids.
func (m *BlockProgramCardsMutation) AddSelectedProgramIDs(ids ...int) {
	if m.selected_programs == nil {
		m.selected_programs = make(map[int]struct{})
	}
	for i := range ids {
		m.selected_programs[ids[i]] = struct{}{}
	}
}

// ClearSelectedPrograms clears the "selected_programs" edge to the ProgramCardItem entity.
func (m *BlockProgramCardsMutation) ClearSelectedPrograms() {
	m.clearedselected_programs = true
}

// SelectedProgramsCleared reports if the "selected_programs" edge to the ProgramCardItem entity was cleared.
func (m *BlockProgramCardsMutation) SelectedProgramsCleared() bool {
	return m.clearedselected_programs
}

// RemoveSelectedProgramIDs removes the "selected_programs" edge to the ProgramCardItem entity by IDs.
func (m *BlockProgramCardsMutation) RemoveSelectedProgramIDs(ids ...int) {
	if m.removedselected_programs == nil {
		m.removedselected_programs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.selected_programs, ids[i])
		m.removedselected_programs[ids[i]] = struct{}{}
	}
}

// RemovedSelectedPrograms returns the removed IDs of the "selected_programs" edge to the ProgramCardItem entity.
func (m *BlockProgramCardsMutation) RemovedSelectedProgramsIDs() (ids []int) {
	for id := range m.removedselected_programs {
		ids = append(ids, id)
	}
	return
}

// SelectedProgramsIDs returns the "selected_programs" edge IDs in the mutation.
func (m *BlockProgramCardsMutation) SelectedProgramsIDs() (ids []int) {
	for id := range m.selected_programs {
		ids = append(ids, id)
	}
	return
}

// ResetSelectedPrograms resets all changes to the "selected_programs" edge.
func (m *BlockProgramCardsMutation) ResetSelectedPrograms() {
	m.selected_programs = nil
	m.clearedselected_programs = false
	m.removedselected_programs = nil
}

// Where appends a list predicates to the BlockProgramCardsMutation builder.
func (m *BlockProgramCardsMutation) Where(ps ...predicate.BlockProgramCards) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockProgramCardsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockProgramCardsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockProgramCards, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockProgramCardsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockProgramCardsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockProgramCards).
func (m *BlockProgramCardsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockProgramCardsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.internal_name != nil {
		fields = append(fields, blockprogramcards.FieldInternalName)
	}
	if m.badge != nil {
		fields = append(fields, blockprogramcards.FieldBadge)
	}
	if m.title != nil {
		fields = append(fields, blockprogramcards.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blockprogramcards.FieldDescription)
	}
	if m.layout != nil {
		fields = append(fields, blockprogramcards.FieldLayout)
	}
	if m.items_per_row != nil {
		fields = append(fields, blockprogramcards.FieldItemsPerRow)
	}
	if m.show_all_programs != nil {
		fields = append(fields, blockprogramcards.FieldShowAllPrograms)
	}
	if m.created_at != nil {
		fields = append(fields, blockprogramcards.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockprogramcards.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockProgramCardsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockprogramcards.FieldInternalName:
		return m.InternalName()
	case blockprogramcards.FieldBadge:
		return m.Badge()
	case blockprogramcards.FieldTitle:
		return m.Title()
	case blockprogramcards.FieldDescription:
		return m.Description()
	case blockprogramcards.FieldLayout:
		return m.Layout()
	case blockprogramcards.FieldItemsPerRow:
		return m.ItemsPerRow()
	case blockprogramcards.FieldShowAllPrograms:
		return m.ShowAllPrograms()
	case blockprogramcards.FieldCreatedAt:
		return m.CreatedAt()
	case blockprogramcards.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockProgramCardsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockprogramcards.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockprogramcards.FieldBadge:
		return m.OldBadge(ctx)
	case blockprogramcards.FieldTitle:
		return m.OldTitle(ctx)
	case blockprogramcards.FieldDescription:
		return m.OldDescription(ctx)
	case blockprogramcards.FieldLayout:
		return m.OldLayout(ctx)
	case blockprogramcards.FieldItemsPerRow:
		return m.OldItemsPerRow(ctx)
	case blockprogramcards.FieldShowAllPrograms:
		return m.OldShowAllPrograms(ctx)
	case blockprogramcards.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockprogramcards.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockProgramCards field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockProgramCardsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockprogramcards.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockprogramcards.FieldBadge:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	case blockprogramcards.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockprogramcards.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockprogramcards.FieldLayout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case blockprogramcards.FieldItemsPerRow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemsPerRow(v)
		return nil
	case blockprogramcards.FieldShowAllPrograms:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowAllPrograms(v)
		return nil
	case blockprogramcards.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockprogramcards.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockProgramCards field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockProgramCardsMutation) AddedFields() []string {
	var fields []string
	if m.additems_per_row != nil {
		fields = append(fields, blockprogramcards.FieldItemsPerRow)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockProgramCardsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockprogramcards.FieldItemsPerRow:
		return m.AddedItemsPerRow()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockProgramCardsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockprogramcards.FieldItemsPerRow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemsPerRow(v)
		return nil
	}
	return fmt.Errorf("unknown BlockProgramCards numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockProgramCardsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockprogramcards.FieldBadge) {
		fields = append(fields, blockprogramcards.FieldBadge)
	}
	if m.FieldCleared(blockprogramcards.FieldTitle) {
		fields = append(fields, blockprogramcards.FieldTitle)
	}
	if m.FieldCleared(blockprogramcards.FieldDescription) {
		fields = append(fields, blockprogramcards.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockProgramCardsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockProgramCardsMutation) ClearField(name string) error {
	switch name {
	case blockprogramcards.FieldBadge:
		m.ClearBadge()
		return nil
	case blockprogramcards.FieldTitle:
		m.ClearTitle()
		return nil
	case blockprogramcards.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlockProgramCards nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockProgramCardsMutation) ResetField(name string) error {
	switch name {
	case blockprogramcards.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockprogramcards.FieldBadge:
		m.ResetBadge()
		return nil
	case blockprogramcards.FieldTitle:
		m.ResetTitle()
		return nil
	case blockprogramcards.FieldDescription:
		m.ResetDescription()
		return nil
	case blockprogramcards.FieldLayout:
		m.ResetLayout()
		return nil
	case blockprogramcards.FieldItemsPerRow:
		m.ResetItemsPerRow()
		return nil
	case blockprogramcards.FieldShowAllPrograms:
		m.ResetShowAllPrograms()
		return nil
	case blockprogramcards.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockprogramcards.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockProgramCards field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockProgramCardsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.content_block != nil {
		edges = append(edges, blockprogramcards.EdgeContentBlock)
	}
	if m.selected_programs != nil {
		edges = append(edges, blockprogramcards.EdgeSelectedPrograms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockProgramCardsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockprogramcards.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	case blockprogramcards.EdgeSelectedPrograms:
		ids := make([]ent.Value, 0, len(m.selected_programs))
		for id := range m.selected_programs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockProgramCardsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedselected_programs != nil {
		edges = append(edges, blockprogramcards.EdgeSelectedPrograms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockProgramCardsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blockprogramcards.EdgeSelectedPrograms:
		ids := make([]ent.Value, 0, len(m.removedselected_programs))
		for id := range m.removedselected_programs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockProgramCardsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontent_block {
		edges = append(edges, blockprogramcards.EdgeContentBlock)
	}
	if m.clearedselected_programs {
		edges = append(edges, blockprogramcards.EdgeSelectedPrograms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockProgramCardsMutation) EdgeCleared(name string) bool {
	switch name {
	case blockprogramcards.EdgeContentBlock:
		return m.clearedcontent_block
	case blockprogramcards.EdgeSelectedPrograms:
		return m.clearedselected_programs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockProgramCardsMutation) ClearEdge(name string) error {
	switch name {
	case blockprogramcards.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockProgramCards unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockProgramCardsMutation) ResetEdge(name string) error {
	switch name {
	case blockprogramcards.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	case blockprogramcards.EdgeSelectedPrograms:
		m.ResetSelectedPrograms()
		return nil
	}
	return fmt.Errorf("unknown BlockProgramCards edge %s", name)
}

// BlockStatsMutation represents an operation that mutates the BlockStats nodes in the graph.
type BlockStatsMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	badge                *map[string]string
	title                *map[string]string
	description          *map[string]string
	layout               *string
	items_per_row        *int
	additems_per_row     *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	stats                map[int]struct{}
	removedstats         map[int]struct{}
	clearedstats         bool
	done                 bool
	oldValue             func(context.Context) (*BlockStats, error)
	predicates           []predicate.BlockStats
}

var _ ent.Mutation = (*BlockStatsMutation)(nil)

// blockstatsOption allows management of the mutation configuration using functional options.
type blockstatsOption func(*BlockStatsMutation)

// newBlockStatsMutation creates new mutation for the BlockStats entity.
func newBlockStatsMutation(c config, op Op, opts ...blockstatsOption) *BlockStatsMutation {
	m := &BlockStatsMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockStats,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockStatsID sets the ID field of the mutation.
func withBlockStatsID(id int) blockstatsOption {
	return func(m *BlockStatsMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockStats
		)
		m.oldValue = func(ctx context.Context) (*BlockStats, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockStats.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockStats sets the old BlockStats of the mutation.
func withBlockStats(node *BlockStats) blockstatsOption {
	return func(m *BlockStatsMutation) {
		m.oldValue = func(context.Context) (*BlockStats, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockStatsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockStatsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockStatsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockStatsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockStats.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockStatsMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockStatsMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockStats entity.
// If the BlockStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStatsMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockStatsMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetBadge sets the "badge" field.
func (m *BlockStatsMutation) SetBadge(value map[string]string) {
	m.badge = &value
}

// Badge returns the value of the "badge" field in the mutation.
func (m *BlockStatsMutation) Badge() (r map[string]string, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the BlockStats entity.
// If the BlockStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStatsMutation) OldBadge(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *BlockStatsMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[blockstats.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *BlockStatsMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[blockstats.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *BlockStatsMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, blockstats.FieldBadge)
}

// SetTitle sets the "title" field.
func (m *BlockStatsMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockStatsMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockStats entity.
// If the BlockStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStatsMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *BlockStatsMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[blockstats.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *BlockStatsMutation) TitleCleared() bool {
	_, ok := m.clearedFields[blockstats.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockStatsMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, blockstats.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *BlockStatsMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockStatsMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockStats entity.
// If the BlockStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStatsMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockStatsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockstats.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockStatsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockstats.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockStatsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockstats.FieldDescription)
}

// SetLayout sets the "layout" field.
func (m *BlockStatsMutation) SetLayout(s string) {
	m.layout = &s
}

// Layout returns the value of the "layout" field in the mutation.
func (m *BlockStatsMutation) Layout() (r string, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the BlockStats entity.
// If the BlockStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStatsMutation) OldLayout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ResetLayout resets all changes to the "layout" field.
func (m *BlockStatsMutation) ResetLayout() {
	m.layout = nil
}

// SetItemsPerRow sets the "items_per_row" field.
func (m *BlockStatsMutation) SetItemsPerRow(i int) {
	m.items_per_row = &i
	m.additems_per_row = nil
}

// ItemsPerRow returns the value of the "items_per_row" field in the mutation.
func (m *BlockStatsMutation) ItemsPerRow() (r int, exists bool) {
	v := m.items_per_row
	if v == nil {
		return
	}
	return *v, true
}

// OldItemsPerRow returns the old "items_per_row" field's value of the BlockStats entity.
// If the BlockStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStatsMutation) OldItemsPerRow(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemsPerRow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemsPerRow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemsPerRow: %w", err)
	}
	return oldValue.ItemsPerRow, nil
}

// AddItemsPerRow adds i to the "items_per_row" field.
func (m *BlockStatsMutation) AddItemsPerRow(i int) {
	if m.additems_per_row != nil {
		*m.additems_per_row += i
	} else {
		m.additems_per_row = &i
	}
}

// AddedItemsPerRow returns the value that was added to the "items_per_row" field in this mutation.
func (m *BlockStatsMutation) AddedItemsPerRow() (r int, exists bool) {
	v := m.additems_per_row
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemsPerRow resets all changes to the "items_per_row" field.
func (m *BlockStatsMutation) ResetItemsPerRow() {
	m.items_per_row = nil
	m.additems_per_row = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockStatsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockStatsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockStats entity.
// If the BlockStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStatsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockStatsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockStatsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockStatsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockStats entity.
// If the BlockStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStatsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockStatsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockStatsMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockStatsMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockStatsMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockStatsMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockStatsMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockStatsMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// AddStatIDs adds the "stats" edge to the StatItem entity by ids.
func (m *BlockStatsMutation) AddStatIDs(ids ...int) {
	if m.stats == nil {
		m.stats = make(map[int]struct{})
	}
	for i := range ids {
		m.stats[ids[i]] = struct{}{}
	}
}

// ClearStats clears the "stats" edge to the StatItem entity.
func (m *BlockStatsMutation) ClearStats() {
	m.clearedstats = true
}

// StatsCleared reports if the "stats" edge to the StatItem entity was cleared.
func (m *BlockStatsMutation) StatsCleared() bool {
	return m.clearedstats
}

// RemoveStatIDs removes the "stats" edge to the StatItem entity by IDs.
func (m *BlockStatsMutation) RemoveStatIDs(ids ...int) {
	if m.removedstats == nil {
		m.removedstats = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stats, ids[i])
		m.removedstats[ids[i]] = struct{}{}
	}
}

// RemovedStats returns the removed IDs of the "stats" edge to the StatItem entity.
func (m *BlockStatsMutation) RemovedStatsIDs() (ids []int) {
	for id := range m.removedstats {
		ids = append(ids, id)
	}
	return
}

// StatsIDs returns the "stats" edge IDs in the mutation.
func (m *BlockStatsMutation) StatsIDs() (ids []int) {
	for id := range m.stats {
		ids = append(ids, id)
	}
	return
}

// ResetStats resets all changes to the "stats" edge.
func (m *BlockStatsMutation) ResetStats() {
	m.stats = nil
	m.clearedstats = false
	m.removedstats = nil
}

// Where appends a list predicates to the BlockStatsMutation builder.
func (m *BlockStatsMutation) Where(ps ...predicate.BlockStats) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockStatsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockStatsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockStats, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockStatsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockStatsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockStats).
func (m *BlockStatsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockStatsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.internal_name != nil {
		fields = append(fields, blockstats.FieldInternalName)
	}
	if m.badge != nil {
		fields = append(fields, blockstats.FieldBadge)
	}
	if m.title != nil {
		fields = append(fields, blockstats.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blockstats.FieldDescription)
	}
	if m.layout != nil {
		fields = append(fields, blockstats.FieldLayout)
	}
	if m.items_per_row != nil {
		fields = append(fields, blockstats.FieldItemsPerRow)
	}
	if m.created_at != nil {
		fields = append(fields, blockstats.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockstats.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockStatsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockstats.FieldInternalName:
		return m.InternalName()
	case blockstats.FieldBadge:
		return m.Badge()
	case blockstats.FieldTitle:
		return m.Title()
	case blockstats.FieldDescription:
		return m.Description()
	case blockstats.FieldLayout:
		return m.Layout()
	case blockstats.FieldItemsPerRow:
		return m.ItemsPerRow()
	case blockstats.FieldCreatedAt:
		return m.CreatedAt()
	case blockstats.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockStatsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockstats.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockstats.FieldBadge:
		return m.OldBadge(ctx)
	case blockstats.FieldTitle:
		return m.OldTitle(ctx)
	case blockstats.FieldDescription:
		return m.OldDescription(ctx)
	case blockstats.FieldLayout:
		return m.OldLayout(ctx)
	case blockstats.FieldItemsPerRow:
		return m.OldItemsPerRow(ctx)
	case blockstats.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockstats.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockStats field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockStatsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockstats.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockstats.FieldBadge:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	case blockstats.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockstats.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockstats.FieldLayout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case blockstats.FieldItemsPerRow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemsPerRow(v)
		return nil
	case blockstats.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockstats.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockStats field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockStatsMutation) AddedFields() []string {
	var fields []string
	if m.additems_per_row != nil {
		fields = append(fields, blockstats.FieldItemsPerRow)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockStatsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockstats.FieldItemsPerRow:
		return m.AddedItemsPerRow()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockStatsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockstats.FieldItemsPerRow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemsPerRow(v)
		return nil
	}
	return fmt.Errorf("unknown BlockStats numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockStatsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockstats.FieldBadge) {
		fields = append(fields, blockstats.FieldBadge)
	}
	if m.FieldCleared(blockstats.FieldTitle) {
		fields = append(fields, blockstats.FieldTitle)
	}
	if m.FieldCleared(blockstats.FieldDescription) {
		fields = append(fields, blockstats.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockStatsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockStatsMutation) ClearField(name string) error {
	switch name {
	case blockstats.FieldBadge:
		m.ClearBadge()
		return nil
	case blockstats.FieldTitle:
		m.ClearTitle()
		return nil
	case blockstats.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlockStats nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockStatsMutation) ResetField(name string) error {
	switch name {
	case blockstats.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockstats.FieldBadge:
		m.ResetBadge()
		return nil
	case blockstats.FieldTitle:
		m.ResetTitle()
		return nil
	case blockstats.FieldDescription:
		m.ResetDescription()
		return nil
	case blockstats.FieldLayout:
		m.ResetLayout()
		return nil
	case blockstats.FieldItemsPerRow:
		m.ResetItemsPerRow()
		return nil
	case blockstats.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockstats.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockStats field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockStatsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.content_block != nil {
		edges = append(edges, blockstats.EdgeContentBlock)
	}
	if m.stats != nil {
		edges = append(edges, blockstats.EdgeStats)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockStatsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockstats.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	case blockstats.EdgeStats:
		ids := make([]ent.Value, 0, len(m.stats))
		for id := range m.stats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockStatsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedstats != nil {
		edges = append(edges, blockstats.EdgeStats)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockStatsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blockstats.EdgeStats:
		ids := make([]ent.Value, 0, len(m.removedstats))
		for id := range m.removedstats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockStatsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontent_block {
		edges = append(edges, blockstats.EdgeContentBlock)
	}
	if m.clearedstats {
		edges = append(edges, blockstats.EdgeStats)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockStatsMutation) EdgeCleared(name string) bool {
	switch name {
	case blockstats.EdgeContentBlock:
		return m.clearedcontent_block
	case blockstats.EdgeStats:
		return m.clearedstats
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockStatsMutation) ClearEdge(name string) error {
	switch name {
	case blockstats.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockStats unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockStatsMutation) ResetEdge(name string) error {
	switch name {
	case blockstats.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	case blockstats.EdgeStats:
		m.ResetStats()
		return nil
	}
	return fmt.Errorf("unknown BlockStats edge %s", name)
}

// BlockSuccessStoriesMutation represents an operation that mutates the BlockSuccessStories nodes in the graph.
type BlockSuccessStoriesMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	badge                *map[string]string
	title                *map[string]string
	description          *map[string]string
	layout               *string
	max_items            *int
	addmax_items         *int
	autoplay             *bool
	program_filter       *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	done                 bool
	oldValue             func(context.Context) (*BlockSuccessStories, error)
	predicates           []predicate.BlockSuccessStories
}

var _ ent.Mutation = (*BlockSuccessStoriesMutation)(nil)

// blocksuccessstoriesOption allows management of the mutation configuration using functional options.
type blocksuccessstoriesOption func(*BlockSuccessStoriesMutation)

// newBlockSuccessStoriesMutation creates new mutation for the BlockSuccessStories entity.
func newBlockSuccessStoriesMutation(c config, op Op, opts ...blocksuccessstoriesOption) *BlockSuccessStoriesMutation {
	m := &BlockSuccessStoriesMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockSuccessStories,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockSuccessStoriesID sets the ID field of the mutation.
func withBlockSuccessStoriesID(id int) blocksuccessstoriesOption {
	return func(m *BlockSuccessStoriesMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockSuccessStories
		)
		m.oldValue = func(ctx context.Context) (*BlockSuccessStories, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockSuccessStories.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockSuccessStories sets the old BlockSuccessStories of the mutation.
func withBlockSuccessStories(node *BlockSuccessStories) blocksuccessstoriesOption {
	return func(m *BlockSuccessStoriesMutation) {
		m.oldValue = func(context.Context) (*BlockSuccessStories, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockSuccessStoriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockSuccessStoriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockSuccessStoriesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockSuccessStoriesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockSuccessStories.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockSuccessStoriesMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockSuccessStoriesMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockSuccessStories entity.
// If the BlockSuccessStories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockSuccessStoriesMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockSuccessStoriesMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetBadge sets the "badge" field.
func (m *BlockSuccessStoriesMutation) SetBadge(value map[string]string) {
	m.badge = &value
}

// Badge returns the value of the "badge" field in the mutation.
func (m *BlockSuccessStoriesMutation) Badge() (r map[string]string, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the BlockSuccessStories entity.
// If the BlockSuccessStories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockSuccessStoriesMutation) OldBadge(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *BlockSuccessStoriesMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[blocksuccessstories.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *BlockSuccessStoriesMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[blocksuccessstories.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *BlockSuccessStoriesMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, blocksuccessstories.FieldBadge)
}

// SetTitle sets the "title" field.
func (m *BlockSuccessStoriesMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockSuccessStoriesMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockSuccessStories entity.
// If the BlockSuccessStories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockSuccessStoriesMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *BlockSuccessStoriesMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[blocksuccessstories.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *BlockSuccessStoriesMutation) TitleCleared() bool {
	_, ok := m.clearedFields[blocksuccessstories.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockSuccessStoriesMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, blocksuccessstories.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *BlockSuccessStoriesMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockSuccessStoriesMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockSuccessStories entity.
// If the BlockSuccessStories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockSuccessStoriesMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockSuccessStoriesMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blocksuccessstories.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockSuccessStoriesMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blocksuccessstories.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockSuccessStoriesMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blocksuccessstories.FieldDescription)
}

// SetLayout sets the "layout" field.
func (m *BlockSuccessStoriesMutation) SetLayout(s string) {
	m.layout = &s
}

// Layout returns the value of the "layout" field in the mutation.
func (m *BlockSuccessStoriesMutation) Layout() (r string, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the BlockSuccessStories entity.
// If the BlockSuccessStories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockSuccessStoriesMutation) OldLayout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ResetLayout resets all changes to the "layout" field.
func (m *BlockSuccessStoriesMutation) ResetLayout() {
	m.layout = nil
}

// SetMaxItems sets the "max_items" field.
func (m *BlockSuccessStoriesMutation) SetMaxItems(i int) {
	m.max_items = &i
	m.addmax_items = nil
}

// MaxItems returns the value of the "max_items" field in the mutation.
func (m *BlockSuccessStoriesMutation) MaxItems() (r int, exists bool) {
	v := m.max_items
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxItems returns the old "max_items" field's value of the BlockSuccessStories entity.
// If the BlockSuccessStories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockSuccessStoriesMutation) OldMaxItems(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxItems: %w", err)
	}
	return oldValue.MaxItems, nil
}

// AddMaxItems adds i to the "max_items" field.
func (m *BlockSuccessStoriesMutation) AddMaxItems(i int) {
	if m.addmax_items != nil {
		*m.addmax_items += i
	} else {
		m.addmax_items = &i
	}
}

// AddedMaxItems returns the value that was added to the "max_items" field in this mutation.
func (m *BlockSuccessStoriesMutation) AddedMaxItems() (r int, exists bool) {
	v := m.addmax_items
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxItems resets all changes to the "max_items" field.
func (m *BlockSuccessStoriesMutation) ResetMaxItems() {
	m.max_items = nil
	m.addmax_items = nil
}

// SetAutoplay sets the "autoplay" field.
func (m *BlockSuccessStoriesMutation) SetAutoplay(b bool) {
	m.autoplay = &b
}

// Autoplay returns the value of the "autoplay" field in the mutation.
func (m *BlockSuccessStoriesMutation) Autoplay() (r bool, exists bool) {
	v := m.autoplay
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoplay returns the old "autoplay" field's value of the BlockSuccessStories entity.
// If the BlockSuccessStories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockSuccessStoriesMutation) OldAutoplay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoplay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoplay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoplay: %w", err)
	}
	return oldValue.Autoplay, nil
}

// ResetAutoplay resets all changes to the "autoplay" field.
func (m *BlockSuccessStoriesMutation) ResetAutoplay() {
	m.autoplay = nil
}

// SetProgramFilter sets the "program_filter" field.
func (m *BlockSuccessStoriesMutation) SetProgramFilter(s string) {
	m.program_filter = &s
}

// ProgramFilter returns the value of the "program_filter" field in the mutation.
func (m *BlockSuccessStoriesMutation) ProgramFilter() (r string, exists bool) {
	v := m.program_filter
	if v == nil {
		return
	}
	return *v, true
}

// OldProgramFilter returns the old "program_filter" field's value of the BlockSuccessStories entity.
// If the BlockSuccessStories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockSuccessStoriesMutation) OldProgramFilter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgramFilter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgramFilter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgramFilter: %w", err)
	}
	return oldValue.ProgramFilter, nil
}

// ClearProgramFilter clears the value of the "program_filter" field.
func (m *BlockSuccessStoriesMutation) ClearProgramFilter() {
	m.program_filter = nil
	m.clearedFields[blocksuccessstories.FieldProgramFilter] = struct{}{}
}

// ProgramFilterCleared returns if the "program_filter" field was cleared in this mutation.
func (m *BlockSuccessStoriesMutation) ProgramFilterCleared() bool {
	_, ok := m.clearedFields[blocksuccessstories.FieldProgramFilter]
	return ok
}

// ResetProgramFilter resets all changes to the "program_filter" field.
func (m *BlockSuccessStoriesMutation) ResetProgramFilter() {
	m.program_filter = nil
	delete(m.clearedFields, blocksuccessstories.FieldProgramFilter)
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockSuccessStoriesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockSuccessStoriesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockSuccessStories entity.
// If the BlockSuccessStories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockSuccessStoriesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockSuccessStoriesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockSuccessStoriesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockSuccessStoriesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockSuccessStories entity.
// If the BlockSuccessStories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockSuccessStoriesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockSuccessStoriesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockSuccessStoriesMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockSuccessStoriesMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockSuccessStoriesMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockSuccessStoriesMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockSuccessStoriesMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockSuccessStoriesMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// Where appends a list predicates to the BlockSuccessStoriesMutation builder.
func (m *BlockSuccessStoriesMutation) Where(ps ...predicate.BlockSuccessStories) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockSuccessStoriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockSuccessStoriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockSuccessStories, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockSuccessStoriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockSuccessStoriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockSuccessStories).
func (m *BlockSuccessStoriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockSuccessStoriesMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.internal_name != nil {
		fields = append(fields, blocksuccessstories.FieldInternalName)
	}
	if m.badge != nil {
		fields = append(fields, blocksuccessstories.FieldBadge)
	}
	if m.title != nil {
		fields = append(fields, blocksuccessstories.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blocksuccessstories.FieldDescription)
	}
	if m.layout != nil {
		fields = append(fields, blocksuccessstories.FieldLayout)
	}
	if m.max_items != nil {
		fields = append(fields, blocksuccessstories.FieldMaxItems)
	}
	if m.autoplay != nil {
		fields = append(fields, blocksuccessstories.FieldAutoplay)
	}
	if m.program_filter != nil {
		fields = append(fields, blocksuccessstories.FieldProgramFilter)
	}
	if m.created_at != nil {
		fields = append(fields, blocksuccessstories.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blocksuccessstories.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockSuccessStoriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blocksuccessstories.FieldInternalName:
		return m.InternalName()
	case blocksuccessstories.FieldBadge:
		return m.Badge()
	case blocksuccessstories.FieldTitle:
		return m.Title()
	case blocksuccessstories.FieldDescription:
		return m.Description()
	case blocksuccessstories.FieldLayout:
		return m.Layout()
	case blocksuccessstories.FieldMaxItems:
		return m.MaxItems()
	case blocksuccessstories.FieldAutoplay:
		return m.Autoplay()
	case blocksuccessstories.FieldProgramFilter:
		return m.ProgramFilter()
	case blocksuccessstories.FieldCreatedAt:
		return m.CreatedAt()
	case blocksuccessstories.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockSuccessStoriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blocksuccessstories.FieldInternalName:
		return m.OldInternalName(ctx)
	case blocksuccessstories.FieldBadge:
		return m.OldBadge(ctx)
	case blocksuccessstories.FieldTitle:
		return m.OldTitle(ctx)
	case blocksuccessstories.FieldDescription:
		return m.OldDescription(ctx)
	case blocksuccessstories.FieldLayout:
		return m.OldLayout(ctx)
	case blocksuccessstories.FieldMaxItems:
		return m.OldMaxItems(ctx)
	case blocksuccessstories.FieldAutoplay:
		return m.OldAutoplay(ctx)
	case blocksuccessstories.FieldProgramFilter:
		return m.OldProgramFilter(ctx)
	case blocksuccessstories.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blocksuccessstories.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockSuccessStories field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockSuccessStoriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blocksuccessstories.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blocksuccessstories.FieldBadge:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	case blocksuccessstories.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blocksuccessstories.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blocksuccessstories.FieldLayout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case blocksuccessstories.FieldMaxItems:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxItems(v)
		return nil
	case blocksuccessstories.FieldAutoplay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoplay(v)
		return nil
	case blocksuccessstories.FieldProgramFilter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgramFilter(v)
		return nil
	case blocksuccessstories.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blocksuccessstories.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockSuccessStories field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockSuccessStoriesMutation) AddedFields() []string {
	var fields []string
	if m.addmax_items != nil {
		fields = append(fields, blocksuccessstories.FieldMaxItems)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockSuccessStoriesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blocksuccessstories.FieldMaxItems:
		return m.AddedMaxItems()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockSuccessStoriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blocksuccessstories.FieldMaxItems:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxItems(v)
		return nil
	}
	return fmt.Errorf("unknown BlockSuccessStories numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockSuccessStoriesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blocksuccessstories.FieldBadge) {
		fields = append(fields, blocksuccessstories.FieldBadge)
	}
	if m.FieldCleared(blocksuccessstories.FieldTitle) {
		fields = append(fields, blocksuccessstories.FieldTitle)
	}
	if m.FieldCleared(blocksuccessstories.FieldDescription) {
		fields = append(fields, blocksuccessstories.FieldDescription)
	}
	if m.FieldCleared(blocksuccessstories.FieldProgramFilter) {
		fields = append(fields, blocksuccessstories.FieldProgramFilter)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockSuccessStoriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockSuccessStoriesMutation) ClearField(name string) error {
	switch name {
	case blocksuccessstories.FieldBadge:
		m.ClearBadge()
		return nil
	case blocksuccessstories.FieldTitle:
		m.ClearTitle()
		return nil
	case blocksuccessstories.FieldDescription:
		m.ClearDescription()
		return nil
	case blocksuccessstories.FieldProgramFilter:
		m.ClearProgramFilter()
		return nil
	}
	return fmt.Errorf("unknown BlockSuccessStories nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockSuccessStoriesMutation) ResetField(name string) error {
	switch name {
	case blocksuccessstories.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blocksuccessstories.FieldBadge:
		m.ResetBadge()
		return nil
	case blocksuccessstories.FieldTitle:
		m.ResetTitle()
		return nil
	case blocksuccessstories.FieldDescription:
		m.ResetDescription()
		return nil
	case blocksuccessstories.FieldLayout:
		m.ResetLayout()
		return nil
	case blocksuccessstories.FieldMaxItems:
		m.ResetMaxItems()
		return nil
	case blocksuccessstories.FieldAutoplay:
		m.ResetAutoplay()
		return nil
	case blocksuccessstories.FieldProgramFilter:
		m.ResetProgramFilter()
		return nil
	case blocksuccessstories.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blocksuccessstories.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockSuccessStories field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockSuccessStoriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content_block != nil {
		edges = append(edges, blocksuccessstories.EdgeContentBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockSuccessStoriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blocksuccessstories.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockSuccessStoriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockSuccessStoriesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockSuccessStoriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent_block {
		edges = append(edges, blocksuccessstories.EdgeContentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockSuccessStoriesMutation) EdgeCleared(name string) bool {
	switch name {
	case blocksuccessstories.EdgeContentBlock:
		return m.clearedcontent_block
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockSuccessStoriesMutation) ClearEdge(name string) error {
	switch name {
	case blocksuccessstories.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockSuccessStories unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockSuccessStoriesMutation) ResetEdge(name string) error {
	switch name {
	case blocksuccessstories.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockSuccessStories edge %s", name)
}

// BlockTabsMutation represents an operation that mutates the BlockTabs nodes in the graph.
type BlockTabsMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	items                map[int]struct{}
	removeditems         map[int]struct{}
	cleareditems         bool
	done                 bool
	oldValue             func(context.Context) (*BlockTabs, error)
	predicates           []predicate.BlockTabs
}

var _ ent.Mutation = (*BlockTabsMutation)(nil)

// blocktabsOption allows management of the mutation configuration using functional options.
type blocktabsOption func(*BlockTabsMutation)

// newBlockTabsMutation creates new mutation for the BlockTabs entity.
func newBlockTabsMutation(c config, op Op, opts ...blocktabsOption) *BlockTabsMutation {
	m := &BlockTabsMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockTabs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockTabsID sets the ID field of the mutation.
func withBlockTabsID(id int) blocktabsOption {
	return func(m *BlockTabsMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockTabs
		)
		m.oldValue = func(ctx context.Context) (*BlockTabs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockTabs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockTabs sets the old BlockTabs of the mutation.
func withBlockTabs(node *BlockTabs) blocktabsOption {
	return func(m *BlockTabsMutation) {
		m.oldValue = func(context.Context) (*BlockTabs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockTabsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockTabsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockTabsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockTabsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockTabs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockTabsMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockTabsMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockTabs entity.
// If the BlockTabs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTabsMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockTabsMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockTabsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockTabsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockTabs entity.
// If the BlockTabs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTabsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockTabsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockTabsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockTabsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockTabs entity.
// If the BlockTabs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTabsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockTabsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockTabsMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockTabsMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockTabsMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockTabsMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockTabsMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockTabsMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// AddItemIDs adds the "items" edge to the TabItem entity by ids.
func (m *BlockTabsMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the TabItem entity.
func (m *BlockTabsMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the TabItem entity was cleared.
func (m *BlockTabsMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the TabItem entity by IDs.
func (m *BlockTabsMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the TabItem entity.
func (m *BlockTabsMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *BlockTabsMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *BlockTabsMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the BlockTabsMutation builder.
func (m *BlockTabsMutation) Where(ps ...predicate.BlockTabs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockTabsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockTabsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockTabs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockTabsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockTabsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockTabs).
func (m *BlockTabsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockTabsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.internal_name != nil {
		fields = append(fields, blocktabs.FieldInternalName)
	}
	if m.created_at != nil {
		fields = append(fields, blocktabs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blocktabs.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockTabsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blocktabs.FieldInternalName:
		return m.InternalName()
	case blocktabs.FieldCreatedAt:
		return m.CreatedAt()
	case blocktabs.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockTabsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blocktabs.FieldInternalName:
		return m.OldInternalName(ctx)
	case blocktabs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blocktabs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockTabs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockTabsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blocktabs.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blocktabs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blocktabs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockTabs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockTabsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockTabsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockTabsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockTabs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockTabsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockTabsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockTabsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlockTabs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockTabsMutation) ResetField(name string) error {
	switch name {
	case blocktabs.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blocktabs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blocktabs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockTabs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockTabsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.content_block != nil {
		edges = append(edges, blocktabs.EdgeContentBlock)
	}
	if m.items != nil {
		edges = append(edges, blocktabs.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockTabsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blocktabs.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	case blocktabs.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockTabsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, blocktabs.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockTabsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blocktabs.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockTabsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontent_block {
		edges = append(edges, blocktabs.EdgeContentBlock)
	}
	if m.cleareditems {
		edges = append(edges, blocktabs.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockTabsMutation) EdgeCleared(name string) bool {
	switch name {
	case blocktabs.EdgeContentBlock:
		return m.clearedcontent_block
	case blocktabs.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockTabsMutation) ClearEdge(name string) error {
	switch name {
	case blocktabs.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockTabs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockTabsMutation) ResetEdge(name string) error {
	switch name {
	case blocktabs.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	case blocktabs.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown BlockTabs edge %s", name)
}

// BlockTeamGridMutation represents an operation that mutates the BlockTeamGrid nodes in the graph.
type BlockTeamGridMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	badge                *map[string]string
	title                *map[string]string
	description          *map[string]string
	items_per_row        *int
	additems_per_row     *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	members              map[int]struct{}
	removedmembers       map[int]struct{}
	clearedmembers       bool
	done                 bool
	oldValue             func(context.Context) (*BlockTeamGrid, error)
	predicates           []predicate.BlockTeamGrid
}

var _ ent.Mutation = (*BlockTeamGridMutation)(nil)

// blockteamgridOption allows management of the mutation configuration using functional options.
type blockteamgridOption func(*BlockTeamGridMutation)

// newBlockTeamGridMutation creates new mutation for the BlockTeamGrid entity.
func newBlockTeamGridMutation(c config, op Op, opts ...blockteamgridOption) *BlockTeamGridMutation {
	m := &BlockTeamGridMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockTeamGrid,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockTeamGridID sets the ID field of the mutation.
func withBlockTeamGridID(id int) blockteamgridOption {
	return func(m *BlockTeamGridMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockTeamGrid
		)
		m.oldValue = func(ctx context.Context) (*BlockTeamGrid, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockTeamGrid.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockTeamGrid sets the old BlockTeamGrid of the mutation.
func withBlockTeamGrid(node *BlockTeamGrid) blockteamgridOption {
	return func(m *BlockTeamGridMutation) {
		m.oldValue = func(context.Context) (*BlockTeamGrid, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockTeamGridMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockTeamGridMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockTeamGridMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockTeamGridMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockTeamGrid.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockTeamGridMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockTeamGridMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockTeamGrid entity.
// If the BlockTeamGrid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTeamGridMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockTeamGridMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetBadge sets the "badge" field.
func (m *BlockTeamGridMutation) SetBadge(value map[string]string) {
	m.badge = &value
}

// Badge returns the value of the "badge" field in the mutation.
func (m *BlockTeamGridMutation) Badge() (r map[string]string, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the BlockTeamGrid entity.
// If the BlockTeamGrid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTeamGridMutation) OldBadge(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *BlockTeamGridMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[blockteamgrid.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *BlockTeamGridMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[blockteamgrid.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *BlockTeamGridMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, blockteamgrid.FieldBadge)
}

// SetTitle sets the "title" field.
func (m *BlockTeamGridMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockTeamGridMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockTeamGrid entity.
// If the BlockTeamGrid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTeamGridMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *BlockTeamGridMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[blockteamgrid.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *BlockTeamGridMutation) TitleCleared() bool {
	_, ok := m.clearedFields[blockteamgrid.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockTeamGridMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, blockteamgrid.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *BlockTeamGridMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockTeamGridMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockTeamGrid entity.
// If the BlockTeamGrid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTeamGridMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockTeamGridMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockteamgrid.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockTeamGridMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockteamgrid.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockTeamGridMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockteamgrid.FieldDescription)
}

// SetItemsPerRow sets the "items_per_row" field.
func (m *BlockTeamGridMutation) SetItemsPerRow(i int) {
	m.items_per_row = &i
	m.additems_per_row = nil
}

// ItemsPerRow returns the value of the "items_per_row" field in the mutation.
func (m *BlockTeamGridMutation) ItemsPerRow() (r int, exists bool) {
	v := m.items_per_row
	if v == nil {
		return
	}
	return *v, true
}

// OldItemsPerRow returns the old "items_per_row" field's value of the BlockTeamGrid entity.
// If the BlockTeamGrid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTeamGridMutation) OldItemsPerRow(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemsPerRow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemsPerRow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemsPerRow: %w", err)
	}
	return oldValue.ItemsPerRow, nil
}

// AddItemsPerRow adds i to the "items_per_row" field.
func (m *BlockTeamGridMutation) AddItemsPerRow(i int) {
	if m.additems_per_row != nil {
		*m.additems_per_row += i
	} else {
		m.additems_per_row = &i
	}
}

// AddedItemsPerRow returns the value that was added to the "items_per_row" field in this mutation.
func (m *BlockTeamGridMutation) AddedItemsPerRow() (r int, exists bool) {
	v := m.additems_per_row
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemsPerRow resets all changes to the "items_per_row" field.
func (m *BlockTeamGridMutation) ResetItemsPerRow() {
	m.items_per_row = nil
	m.additems_per_row = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockTeamGridMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockTeamGridMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockTeamGrid entity.
// If the BlockTeamGrid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTeamGridMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockTeamGridMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockTeamGridMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockTeamGridMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockTeamGrid entity.
// If the BlockTeamGrid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTeamGridMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockTeamGridMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockTeamGridMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockTeamGridMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockTeamGridMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockTeamGridMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockTeamGridMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockTeamGridMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// AddMemberIDs adds the "members" edge to the TeamMemberItem entity by ids.
func (m *BlockTeamGridMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the TeamMemberItem entity.
func (m *BlockTeamGridMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the TeamMemberItem entity was cleared.
func (m *BlockTeamGridMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the TeamMemberItem entity by IDs.
func (m *BlockTeamGridMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the TeamMemberItem entity.
func (m *BlockTeamGridMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *BlockTeamGridMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *BlockTeamGridMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the BlockTeamGridMutation builder.
func (m *BlockTeamGridMutation) Where(ps ...predicate.BlockTeamGrid) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockTeamGridMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockTeamGridMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockTeamGrid, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockTeamGridMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockTeamGridMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockTeamGrid).
func (m *BlockTeamGridMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockTeamGridMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.internal_name != nil {
		fields = append(fields, blockteamgrid.FieldInternalName)
	}
	if m.badge != nil {
		fields = append(fields, blockteamgrid.FieldBadge)
	}
	if m.title != nil {
		fields = append(fields, blockteamgrid.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blockteamgrid.FieldDescription)
	}
	if m.items_per_row != nil {
		fields = append(fields, blockteamgrid.FieldItemsPerRow)
	}
	if m.created_at != nil {
		fields = append(fields, blockteamgrid.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockteamgrid.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockTeamGridMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockteamgrid.FieldInternalName:
		return m.InternalName()
	case blockteamgrid.FieldBadge:
		return m.Badge()
	case blockteamgrid.FieldTitle:
		return m.Title()
	case blockteamgrid.FieldDescription:
		return m.Description()
	case blockteamgrid.FieldItemsPerRow:
		return m.ItemsPerRow()
	case blockteamgrid.FieldCreatedAt:
		return m.CreatedAt()
	case blockteamgrid.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockTeamGridMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockteamgrid.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockteamgrid.FieldBadge:
		return m.OldBadge(ctx)
	case blockteamgrid.FieldTitle:
		return m.OldTitle(ctx)
	case blockteamgrid.FieldDescription:
		return m.OldDescription(ctx)
	case blockteamgrid.FieldItemsPerRow:
		return m.OldItemsPerRow(ctx)
	case blockteamgrid.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockteamgrid.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockTeamGrid field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockTeamGridMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockteamgrid.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockteamgrid.FieldBadge:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	case blockteamgrid.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockteamgrid.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockteamgrid.FieldItemsPerRow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemsPerRow(v)
		return nil
	case blockteamgrid.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockteamgrid.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockTeamGrid field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockTeamGridMutation) AddedFields() []string {
	var fields []string
	if m.additems_per_row != nil {
		fields = append(fields, blockteamgrid.FieldItemsPerRow)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockTeamGridMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockteamgrid.FieldItemsPerRow:
		return m.AddedItemsPerRow()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockTeamGridMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockteamgrid.FieldItemsPerRow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemsPerRow(v)
		return nil
	}
	return fmt.Errorf("unknown BlockTeamGrid numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockTeamGridMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockteamgrid.FieldBadge) {
		fields = append(fields, blockteamgrid.FieldBadge)
	}
	if m.FieldCleared(blockteamgrid.FieldTitle) {
		fields = append(fields, blockteamgrid.FieldTitle)
	}
	if m.FieldCleared(blockteamgrid.FieldDescription) {
		fields = append(fields, blockteamgrid.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockTeamGridMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockTeamGridMutation) ClearField(name string) error {
	switch name {
	case blockteamgrid.FieldBadge:
		m.ClearBadge()
		return nil
	case blockteamgrid.FieldTitle:
		m.ClearTitle()
		return nil
	case blockteamgrid.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlockTeamGrid nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockTeamGridMutation) ResetField(name string) error {
	switch name {
	case blockteamgrid.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockteamgrid.FieldBadge:
		m.ResetBadge()
		return nil
	case blockteamgrid.FieldTitle:
		m.ResetTitle()
		return nil
	case blockteamgrid.FieldDescription:
		m.ResetDescription()
		return nil
	case blockteamgrid.FieldItemsPerRow:
		m.ResetItemsPerRow()
		return nil
	case blockteamgrid.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockteamgrid.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockTeamGrid field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockTeamGridMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.content_block != nil {
		edges = append(edges, blockteamgrid.EdgeContentBlock)
	}
	if m.members != nil {
		edges = append(edges, blockteamgrid.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockTeamGridMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockteamgrid.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	case blockteamgrid.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockTeamGridMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmembers != nil {
		edges = append(edges, blockteamgrid.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockTeamGridMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blockteamgrid.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockTeamGridMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontent_block {
		edges = append(edges, blockteamgrid.EdgeContentBlock)
	}
	if m.clearedmembers {
		edges = append(edges, blockteamgrid.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockTeamGridMutation) EdgeCleared(name string) bool {
	switch name {
	case blockteamgrid.EdgeContentBlock:
		return m.clearedcontent_block
	case blockteamgrid.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockTeamGridMutation) ClearEdge(name string) error {
	switch name {
	case blockteamgrid.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockTeamGrid unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockTeamGridMutation) ResetEdge(name string) error {
	switch name {
	case blockteamgrid.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	case blockteamgrid.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown BlockTeamGrid edge %s", name)
}

// BlockTestimonialsMutation represents an operation that mutates the BlockTestimonials nodes in the graph.
type BlockTestimonialsMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	badge                *map[string]string
	title                *map[string]string
	description          *map[string]string
	layout               *string
	items_per_row        *int
	additems_per_row     *int
	autoplay             *bool
	autoplay_speed       *int
	addautoplay_speed    *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	testimonials         map[int]struct{}
	removedtestimonials  map[int]struct{}
	clearedtestimonials  bool
	done                 bool
	oldValue             func(context.Context) (*BlockTestimonials, error)
	predicates           []predicate.BlockTestimonials
}

var _ ent.Mutation = (*BlockTestimonialsMutation)(nil)

// blocktestimonialsOption allows management of the mutation configuration using functional options.
type blocktestimonialsOption func(*BlockTestimonialsMutation)

// newBlockTestimonialsMutation creates new mutation for the BlockTestimonials entity.
func newBlockTestimonialsMutation(c config, op Op, opts ...blocktestimonialsOption) *BlockTestimonialsMutation {
	m := &BlockTestimonialsMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockTestimonials,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockTestimonialsID sets the ID field of the mutation.
func withBlockTestimonialsID(id int) blocktestimonialsOption {
	return func(m *BlockTestimonialsMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockTestimonials
		)
		m.oldValue = func(ctx context.Context) (*BlockTestimonials, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockTestimonials.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockTestimonials sets the old BlockTestimonials of the mutation.
func withBlockTestimonials(node *BlockTestimonials) blocktestimonialsOption {
	return func(m *BlockTestimonialsMutation) {
		m.oldValue = func(context.Context) (*BlockTestimonials, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockTestimonialsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockTestimonialsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockTestimonialsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockTestimonialsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockTestimonials.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockTestimonialsMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockTestimonialsMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockTestimonials entity.
// If the BlockTestimonials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTestimonialsMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockTestimonialsMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetBadge sets the "badge" field.
func (m *BlockTestimonialsMutation) SetBadge(value map[string]string) {
	m.badge = &value
}

// Badge returns the value of the "badge" field in the mutation.
func (m *BlockTestimonialsMutation) Badge() (r map[string]string, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the BlockTestimonials entity.
// If the BlockTestimonials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTestimonialsMutation) OldBadge(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *BlockTestimonialsMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[blocktestimonials.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *BlockTestimonialsMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[blocktestimonials.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *BlockTestimonialsMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, blocktestimonials.FieldBadge)
}

// SetTitle sets the "title" field.
func (m *BlockTestimonialsMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockTestimonialsMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockTestimonials entity.
// If the BlockTestimonials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTestimonialsMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockTestimonialsMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BlockTestimonialsMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockTestimonialsMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockTestimonials entity.
// If the BlockTestimonials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTestimonialsMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockTestimonialsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blocktestimonials.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockTestimonialsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blocktestimonials.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockTestimonialsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blocktestimonials.FieldDescription)
}

// SetLayout sets the "layout" field.
func (m *BlockTestimonialsMutation) SetLayout(s string) {
	m.layout = &s
}

// Layout returns the value of the "layout" field in the mutation.
func (m *BlockTestimonialsMutation) Layout() (r string, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the BlockTestimonials entity.
// If the BlockTestimonials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTestimonialsMutation) OldLayout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ResetLayout resets all changes to the "layout" field.
func (m *BlockTestimonialsMutation) ResetLayout() {
	m.layout = nil
}

// SetItemsPerRow sets the "items_per_row" field.
func (m *BlockTestimonialsMutation) SetItemsPerRow(i int) {
	m.items_per_row = &i
	m.additems_per_row = nil
}

// ItemsPerRow returns the value of the "items_per_row" field in the mutation.
func (m *BlockTestimonialsMutation) ItemsPerRow() (r int, exists bool) {
	v := m.items_per_row
	if v == nil {
		return
	}
	return *v, true
}

// OldItemsPerRow returns the old "items_per_row" field's value of the BlockTestimonials entity.
// If the BlockTestimonials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTestimonialsMutation) OldItemsPerRow(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemsPerRow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemsPerRow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemsPerRow: %w", err)
	}
	return oldValue.ItemsPerRow, nil
}

// AddItemsPerRow adds i to the "items_per_row" field.
func (m *BlockTestimonialsMutation) AddItemsPerRow(i int) {
	if m.additems_per_row != nil {
		*m.additems_per_row += i
	} else {
		m.additems_per_row = &i
	}
}

// AddedItemsPerRow returns the value that was added to the "items_per_row" field in this mutation.
func (m *BlockTestimonialsMutation) AddedItemsPerRow() (r int, exists bool) {
	v := m.additems_per_row
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemsPerRow resets all changes to the "items_per_row" field.
func (m *BlockTestimonialsMutation) ResetItemsPerRow() {
	m.items_per_row = nil
	m.additems_per_row = nil
}

// SetAutoplay sets the "autoplay" field.
func (m *BlockTestimonialsMutation) SetAutoplay(b bool) {
	m.autoplay = &b
}

// Autoplay returns the value of the "autoplay" field in the mutation.
func (m *BlockTestimonialsMutation) Autoplay() (r bool, exists bool) {
	v := m.autoplay
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoplay returns the old "autoplay" field's value of the BlockTestimonials entity.
// If the BlockTestimonials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTestimonialsMutation) OldAutoplay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoplay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoplay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoplay: %w", err)
	}
	return oldValue.Autoplay, nil
}

// ResetAutoplay resets all changes to the "autoplay" field.
func (m *BlockTestimonialsMutation) ResetAutoplay() {
	m.autoplay = nil
}

// SetAutoplaySpeed sets the "autoplay_speed" field.
func (m *BlockTestimonialsMutation) SetAutoplaySpeed(i int) {
	m.autoplay_speed = &i
	m.addautoplay_speed = nil
}

// AutoplaySpeed returns the value of the "autoplay_speed" field in the mutation.
func (m *BlockTestimonialsMutation) AutoplaySpeed() (r int, exists bool) {
	v := m.autoplay_speed
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoplaySpeed returns the old "autoplay_speed" field's value of the BlockTestimonials entity.
// If the BlockTestimonials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTestimonialsMutation) OldAutoplaySpeed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoplaySpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoplaySpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoplaySpeed: %w", err)
	}
	return oldValue.AutoplaySpeed, nil
}

// AddAutoplaySpeed adds i to the "autoplay_speed" field.
func (m *BlockTestimonialsMutation) AddAutoplaySpeed(i int) {
	if m.addautoplay_speed != nil {
		*m.addautoplay_speed += i
	} else {
		m.addautoplay_speed = &i
	}
}

// AddedAutoplaySpeed returns the value that was added to the "autoplay_speed" field in this mutation.
func (m *BlockTestimonialsMutation) AddedAutoplaySpeed() (r int, exists bool) {
	v := m.addautoplay_speed
	if v == nil {
		return
	}
	return *v, true
}

// ResetAutoplaySpeed resets all changes to the "autoplay_speed" field.
func (m *BlockTestimonialsMutation) ResetAutoplaySpeed() {
	m.autoplay_speed = nil
	m.addautoplay_speed = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockTestimonialsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockTestimonialsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockTestimonials entity.
// If the BlockTestimonials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTestimonialsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockTestimonialsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockTestimonialsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockTestimonialsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockTestimonials entity.
// If the BlockTestimonials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTestimonialsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockTestimonialsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockTestimonialsMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockTestimonialsMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockTestimonialsMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockTestimonialsMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockTestimonialsMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockTestimonialsMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// AddTestimonialIDs adds the "testimonials" edge to the TestimonialItem entity by ids.
func (m *BlockTestimonialsMutation) AddTestimonialIDs(ids ...int) {
	if m.testimonials == nil {
		m.testimonials = make(map[int]struct{})
	}
	for i := range ids {
		m.testimonials[ids[i]] = struct{}{}
	}
}

// ClearTestimonials clears the "testimonials" edge to the TestimonialItem entity.
func (m *BlockTestimonialsMutation) ClearTestimonials() {
	m.clearedtestimonials = true
}

// TestimonialsCleared reports if the "testimonials" edge to the TestimonialItem entity was cleared.
func (m *BlockTestimonialsMutation) TestimonialsCleared() bool {
	return m.clearedtestimonials
}

// RemoveTestimonialIDs removes the "testimonials" edge to the TestimonialItem entity by IDs.
func (m *BlockTestimonialsMutation) RemoveTestimonialIDs(ids ...int) {
	if m.removedtestimonials == nil {
		m.removedtestimonials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.testimonials, ids[i])
		m.removedtestimonials[ids[i]] = struct{}{}
	}
}

// RemovedTestimonials returns the removed IDs of the "testimonials" edge to the TestimonialItem entity.
func (m *BlockTestimonialsMutation) RemovedTestimonialsIDs() (ids []int) {
	for id := range m.removedtestimonials {
		ids = append(ids, id)
	}
	return
}

// TestimonialsIDs returns the "testimonials" edge IDs in the mutation.
func (m *BlockTestimonialsMutation) TestimonialsIDs() (ids []int) {
	for id := range m.testimonials {
		ids = append(ids, id)
	}
	return
}

// ResetTestimonials resets all changes to the "testimonials" edge.
func (m *BlockTestimonialsMutation) ResetTestimonials() {
	m.testimonials = nil
	m.clearedtestimonials = false
	m.removedtestimonials = nil
}

// Where appends a list predicates to the BlockTestimonialsMutation builder.
func (m *BlockTestimonialsMutation) Where(ps ...predicate.BlockTestimonials) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockTestimonialsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockTestimonialsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockTestimonials, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockTestimonialsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockTestimonialsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockTestimonials).
func (m *BlockTestimonialsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockTestimonialsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.internal_name != nil {
		fields = append(fields, blocktestimonials.FieldInternalName)
	}
	if m.badge != nil {
		fields = append(fields, blocktestimonials.FieldBadge)
	}
	if m.title != nil {
		fields = append(fields, blocktestimonials.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blocktestimonials.FieldDescription)
	}
	if m.layout != nil {
		fields = append(fields, blocktestimonials.FieldLayout)
	}
	if m.items_per_row != nil {
		fields = append(fields, blocktestimonials.FieldItemsPerRow)
	}
	if m.autoplay != nil {
		fields = append(fields, blocktestimonials.FieldAutoplay)
	}
	if m.autoplay_speed != nil {
		fields = append(fields, blocktestimonials.FieldAutoplaySpeed)
	}
	if m.created_at != nil {
		fields = append(fields, blocktestimonials.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blocktestimonials.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockTestimonialsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blocktestimonials.FieldInternalName:
		return m.InternalName()
	case blocktestimonials.FieldBadge:
		return m.Badge()
	case blocktestimonials.FieldTitle:
		return m.Title()
	case blocktestimonials.FieldDescription:
		return m.Description()
	case blocktestimonials.FieldLayout:
		return m.Layout()
	case blocktestimonials.FieldItemsPerRow:
		return m.ItemsPerRow()
	case blocktestimonials.FieldAutoplay:
		return m.Autoplay()
	case blocktestimonials.FieldAutoplaySpeed:
		return m.AutoplaySpeed()
	case blocktestimonials.FieldCreatedAt:
		return m.CreatedAt()
	case blocktestimonials.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockTestimonialsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blocktestimonials.FieldInternalName:
		return m.OldInternalName(ctx)
	case blocktestimonials.FieldBadge:
		return m.OldBadge(ctx)
	case blocktestimonials.FieldTitle:
		return m.OldTitle(ctx)
	case blocktestimonials.FieldDescription:
		return m.OldDescription(ctx)
	case blocktestimonials.FieldLayout:
		return m.OldLayout(ctx)
	case blocktestimonials.FieldItemsPerRow:
		return m.OldItemsPerRow(ctx)
	case blocktestimonials.FieldAutoplay:
		return m.OldAutoplay(ctx)
	case blocktestimonials.FieldAutoplaySpeed:
		return m.OldAutoplaySpeed(ctx)
	case blocktestimonials.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blocktestimonials.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockTestimonials field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockTestimonialsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blocktestimonials.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blocktestimonials.FieldBadge:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	case blocktestimonials.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blocktestimonials.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blocktestimonials.FieldLayout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case blocktestimonials.FieldItemsPerRow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemsPerRow(v)
		return nil
	case blocktestimonials.FieldAutoplay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoplay(v)
		return nil
	case blocktestimonials.FieldAutoplaySpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoplaySpeed(v)
		return nil
	case blocktestimonials.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blocktestimonials.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockTestimonials field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockTestimonialsMutation) AddedFields() []string {
	var fields []string
	if m.additems_per_row != nil {
		fields = append(fields, blocktestimonials.FieldItemsPerRow)
	}
	if m.addautoplay_speed != nil {
		fields = append(fields, blocktestimonials.FieldAutoplaySpeed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockTestimonialsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blocktestimonials.FieldItemsPerRow:
		return m.AddedItemsPerRow()
	case blocktestimonials.FieldAutoplaySpeed:
		return m.AddedAutoplaySpeed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockTestimonialsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blocktestimonials.FieldItemsPerRow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemsPerRow(v)
		return nil
	case blocktestimonials.FieldAutoplaySpeed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAutoplaySpeed(v)
		return nil
	}
	return fmt.Errorf("unknown BlockTestimonials numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockTestimonialsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blocktestimonials.FieldBadge) {
		fields = append(fields, blocktestimonials.FieldBadge)
	}
	if m.FieldCleared(blocktestimonials.FieldDescription) {
		fields = append(fields, blocktestimonials.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockTestimonialsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockTestimonialsMutation) ClearField(name string) error {
	switch name {
	case blocktestimonials.FieldBadge:
		m.ClearBadge()
		return nil
	case blocktestimonials.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlockTestimonials nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockTestimonialsMutation) ResetField(name string) error {
	switch name {
	case blocktestimonials.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blocktestimonials.FieldBadge:
		m.ResetBadge()
		return nil
	case blocktestimonials.FieldTitle:
		m.ResetTitle()
		return nil
	case blocktestimonials.FieldDescription:
		m.ResetDescription()
		return nil
	case blocktestimonials.FieldLayout:
		m.ResetLayout()
		return nil
	case blocktestimonials.FieldItemsPerRow:
		m.ResetItemsPerRow()
		return nil
	case blocktestimonials.FieldAutoplay:
		m.ResetAutoplay()
		return nil
	case blocktestimonials.FieldAutoplaySpeed:
		m.ResetAutoplaySpeed()
		return nil
	case blocktestimonials.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blocktestimonials.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockTestimonials field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockTestimonialsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.content_block != nil {
		edges = append(edges, blocktestimonials.EdgeContentBlock)
	}
	if m.testimonials != nil {
		edges = append(edges, blocktestimonials.EdgeTestimonials)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockTestimonialsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blocktestimonials.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	case blocktestimonials.EdgeTestimonials:
		ids := make([]ent.Value, 0, len(m.testimonials))
		for id := range m.testimonials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockTestimonialsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtestimonials != nil {
		edges = append(edges, blocktestimonials.EdgeTestimonials)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockTestimonialsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blocktestimonials.EdgeTestimonials:
		ids := make([]ent.Value, 0, len(m.removedtestimonials))
		for id := range m.removedtestimonials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockTestimonialsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontent_block {
		edges = append(edges, blocktestimonials.EdgeContentBlock)
	}
	if m.clearedtestimonials {
		edges = append(edges, blocktestimonials.EdgeTestimonials)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockTestimonialsMutation) EdgeCleared(name string) bool {
	switch name {
	case blocktestimonials.EdgeContentBlock:
		return m.clearedcontent_block
	case blocktestimonials.EdgeTestimonials:
		return m.clearedtestimonials
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockTestimonialsMutation) ClearEdge(name string) error {
	switch name {
	case blocktestimonials.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockTestimonials unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockTestimonialsMutation) ResetEdge(name string) error {
	switch name {
	case blocktestimonials.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	case blocktestimonials.EdgeTestimonials:
		m.ResetTestimonials()
		return nil
	}
	return fmt.Errorf("unknown BlockTestimonials edge %s", name)
}

// BlockTextContentMutation represents an operation that mutates the BlockTextContent nodes in the graph.
type BlockTextContentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	content              *map[string]string
	text_align           *blocktextcontent.TextAlign
	color_scheme         *blocktextcontent.ColorScheme
	max_width            *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	done                 bool
	oldValue             func(context.Context) (*BlockTextContent, error)
	predicates           []predicate.BlockTextContent
}

var _ ent.Mutation = (*BlockTextContentMutation)(nil)

// blocktextcontentOption allows management of the mutation configuration using functional options.
type blocktextcontentOption func(*BlockTextContentMutation)

// newBlockTextContentMutation creates new mutation for the BlockTextContent entity.
func newBlockTextContentMutation(c config, op Op, opts ...blocktextcontentOption) *BlockTextContentMutation {
	m := &BlockTextContentMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockTextContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockTextContentID sets the ID field of the mutation.
func withBlockTextContentID(id int) blocktextcontentOption {
	return func(m *BlockTextContentMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockTextContent
		)
		m.oldValue = func(ctx context.Context) (*BlockTextContent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockTextContent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockTextContent sets the old BlockTextContent of the mutation.
func withBlockTextContent(node *BlockTextContent) blocktextcontentOption {
	return func(m *BlockTextContentMutation) {
		m.oldValue = func(context.Context) (*BlockTextContent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockTextContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockTextContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockTextContentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockTextContentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockTextContent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockTextContentMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockTextContentMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockTextContent entity.
// If the BlockTextContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTextContentMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockTextContentMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetContent sets the "content" field.
func (m *BlockTextContentMutation) SetContent(value map[string]string) {
	m.content = &value
}

// Content returns the value of the "content" field in the mutation.
func (m *BlockTextContentMutation) Content() (r map[string]string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlockTextContent entity.
// If the BlockTextContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTextContentMutation) OldContent(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlockTextContentMutation) ResetContent() {
	m.content = nil
}

// SetTextAlign sets the "text_align" field.
func (m *BlockTextContentMutation) SetTextAlign(ba blocktextcontent.TextAlign) {
	m.text_align = &ba
}

// TextAlign returns the value of the "text_align" field in the mutation.
func (m *BlockTextContentMutation) TextAlign() (r blocktextcontent.TextAlign, exists bool) {
	v := m.text_align
	if v == nil {
		return
	}
	return *v, true
}

// OldTextAlign returns the old "text_align" field's value of the BlockTextContent entity.
// If the BlockTextContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTextContentMutation) OldTextAlign(ctx context.Context) (v blocktextcontent.TextAlign, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextAlign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextAlign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextAlign: %w", err)
	}
	return oldValue.TextAlign, nil
}

// ResetTextAlign resets all changes to the "text_align" field.
func (m *BlockTextContentMutation) ResetTextAlign() {
	m.text_align = nil
}

// SetColorScheme sets the "color_scheme" field.
func (m *BlockTextContentMutation) SetColorScheme(bs blocktextcontent.ColorScheme) {
	m.color_scheme = &bs
}

// ColorScheme returns the value of the "color_scheme" field in the mutation.
func (m *BlockTextContentMutation) ColorScheme() (r blocktextcontent.ColorScheme, exists bool) {
	v := m.color_scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldColorScheme returns the old "color_scheme" field's value of the BlockTextContent entity.
// If the BlockTextContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTextContentMutation) OldColorScheme(ctx context.Context) (v blocktextcontent.ColorScheme, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorScheme: %w", err)
	}
	return oldValue.ColorScheme, nil
}

// ResetColorScheme resets all changes to the "color_scheme" field.
func (m *BlockTextContentMutation) ResetColorScheme() {
	m.color_scheme = nil
}

// SetMaxWidth sets the "max_width" field.
func (m *BlockTextContentMutation) SetMaxWidth(s string) {
	m.max_width = &s
}

// MaxWidth returns the value of the "max_width" field in the mutation.
func (m *BlockTextContentMutation) MaxWidth() (r string, exists bool) {
	v := m.max_width
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxWidth returns the old "max_width" field's value of the BlockTextContent entity.
// If the BlockTextContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTextContentMutation) OldMaxWidth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxWidth: %w", err)
	}
	return oldValue.MaxWidth, nil
}

// ClearMaxWidth clears the value of the "max_width" field.
func (m *BlockTextContentMutation) ClearMaxWidth() {
	m.max_width = nil
	m.clearedFields[blocktextcontent.FieldMaxWidth] = struct{}{}
}

// MaxWidthCleared returns if the "max_width" field was cleared in this mutation.
func (m *BlockTextContentMutation) MaxWidthCleared() bool {
	_, ok := m.clearedFields[blocktextcontent.FieldMaxWidth]
	return ok
}

// ResetMaxWidth resets all changes to the "max_width" field.
func (m *BlockTextContentMutation) ResetMaxWidth() {
	m.max_width = nil
	delete(m.clearedFields, blocktextcontent.FieldMaxWidth)
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockTextContentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockTextContentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockTextContent entity.
// If the BlockTextContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTextContentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockTextContentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockTextContentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockTextContentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockTextContent entity.
// If the BlockTextContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTextContentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockTextContentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockTextContentMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockTextContentMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockTextContentMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockTextContentMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockTextContentMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockTextContentMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// Where appends a list predicates to the BlockTextContentMutation builder.
func (m *BlockTextContentMutation) Where(ps ...predicate.BlockTextContent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockTextContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockTextContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockTextContent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockTextContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockTextContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockTextContent).
func (m *BlockTextContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockTextContentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.internal_name != nil {
		fields = append(fields, blocktextcontent.FieldInternalName)
	}
	if m.content != nil {
		fields = append(fields, blocktextcontent.FieldContent)
	}
	if m.text_align != nil {
		fields = append(fields, blocktextcontent.FieldTextAlign)
	}
	if m.color_scheme != nil {
		fields = append(fields, blocktextcontent.FieldColorScheme)
	}
	if m.max_width != nil {
		fields = append(fields, blocktextcontent.FieldMaxWidth)
	}
	if m.created_at != nil {
		fields = append(fields, blocktextcontent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blocktextcontent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockTextContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blocktextcontent.FieldInternalName:
		return m.InternalName()
	case blocktextcontent.FieldContent:
		return m.Content()
	case blocktextcontent.FieldTextAlign:
		return m.TextAlign()
	case blocktextcontent.FieldColorScheme:
		return m.ColorScheme()
	case blocktextcontent.FieldMaxWidth:
		return m.MaxWidth()
	case blocktextcontent.FieldCreatedAt:
		return m.CreatedAt()
	case blocktextcontent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockTextContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blocktextcontent.FieldInternalName:
		return m.OldInternalName(ctx)
	case blocktextcontent.FieldContent:
		return m.OldContent(ctx)
	case blocktextcontent.FieldTextAlign:
		return m.OldTextAlign(ctx)
	case blocktextcontent.FieldColorScheme:
		return m.OldColorScheme(ctx)
	case blocktextcontent.FieldMaxWidth:
		return m.OldMaxWidth(ctx)
	case blocktextcontent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blocktextcontent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockTextContent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockTextContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blocktextcontent.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blocktextcontent.FieldContent:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case blocktextcontent.FieldTextAlign:
		v, ok := value.(blocktextcontent.TextAlign)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextAlign(v)
		return nil
	case blocktextcontent.FieldColorScheme:
		v, ok := value.(blocktextcontent.ColorScheme)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorScheme(v)
		return nil
	case blocktextcontent.FieldMaxWidth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxWidth(v)
		return nil
	case blocktextcontent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blocktextcontent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockTextContent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockTextContentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockTextContentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockTextContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockTextContent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockTextContentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blocktextcontent.FieldMaxWidth) {
		fields = append(fields, blocktextcontent.FieldMaxWidth)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockTextContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockTextContentMutation) ClearField(name string) error {
	switch name {
	case blocktextcontent.FieldMaxWidth:
		m.ClearMaxWidth()
		return nil
	}
	return fmt.Errorf("unknown BlockTextContent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockTextContentMutation) ResetField(name string) error {
	switch name {
	case blocktextcontent.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blocktextcontent.FieldContent:
		m.ResetContent()
		return nil
	case blocktextcontent.FieldTextAlign:
		m.ResetTextAlign()
		return nil
	case blocktextcontent.FieldColorScheme:
		m.ResetColorScheme()
		return nil
	case blocktextcontent.FieldMaxWidth:
		m.ResetMaxWidth()
		return nil
	case blocktextcontent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blocktextcontent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockTextContent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockTextContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content_block != nil {
		edges = append(edges, blocktextcontent.EdgeContentBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockTextContentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blocktextcontent.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockTextContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockTextContentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockTextContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent_block {
		edges = append(edges, blocktextcontent.EdgeContentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockTextContentMutation) EdgeCleared(name string) bool {
	switch name {
	case blocktextcontent.EdgeContentBlock:
		return m.clearedcontent_block
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockTextContentMutation) ClearEdge(name string) error {
	switch name {
	case blocktextcontent.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockTextContent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockTextContentMutation) ResetEdge(name string) error {
	switch name {
	case blocktextcontent.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockTextContent edge %s", name)
}

// BlockTimelineMutation represents an operation that mutates the BlockTimeline nodes in the graph.
type BlockTimelineMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	badge                *map[string]string
	title                *map[string]string
	description          *map[string]string
	layout               *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	events               map[int]struct{}
	removedevents        map[int]struct{}
	clearedevents        bool
	done                 bool
	oldValue             func(context.Context) (*BlockTimeline, error)
	predicates           []predicate.BlockTimeline
}

var _ ent.Mutation = (*BlockTimelineMutation)(nil)

// blocktimelineOption allows management of the mutation configuration using functional options.
type blocktimelineOption func(*BlockTimelineMutation)

// newBlockTimelineMutation creates new mutation for the BlockTimeline entity.
func newBlockTimelineMutation(c config, op Op, opts ...blocktimelineOption) *BlockTimelineMutation {
	m := &BlockTimelineMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockTimeline,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockTimelineID sets the ID field of the mutation.
func withBlockTimelineID(id int) blocktimelineOption {
	return func(m *BlockTimelineMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockTimeline
		)
		m.oldValue = func(ctx context.Context) (*BlockTimeline, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockTimeline.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockTimeline sets the old BlockTimeline of the mutation.
func withBlockTimeline(node *BlockTimeline) blocktimelineOption {
	return func(m *BlockTimelineMutation) {
		m.oldValue = func(context.Context) (*BlockTimeline, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockTimelineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockTimelineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockTimelineMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockTimelineMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockTimeline.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockTimelineMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockTimelineMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockTimeline entity.
// If the BlockTimeline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTimelineMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockTimelineMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetBadge sets the "badge" field.
func (m *BlockTimelineMutation) SetBadge(value map[string]string) {
	m.badge = &value
}

// Badge returns the value of the "badge" field in the mutation.
func (m *BlockTimelineMutation) Badge() (r map[string]string, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the BlockTimeline entity.
// If the BlockTimeline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTimelineMutation) OldBadge(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *BlockTimelineMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[blocktimeline.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *BlockTimelineMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[blocktimeline.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *BlockTimelineMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, blocktimeline.FieldBadge)
}

// SetTitle sets the "title" field.
func (m *BlockTimelineMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockTimelineMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockTimeline entity.
// If the BlockTimeline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTimelineMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *BlockTimelineMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[blocktimeline.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *BlockTimelineMutation) TitleCleared() bool {
	_, ok := m.clearedFields[blocktimeline.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockTimelineMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, blocktimeline.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *BlockTimelineMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockTimelineMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockTimeline entity.
// If the BlockTimeline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTimelineMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockTimelineMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blocktimeline.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockTimelineMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blocktimeline.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockTimelineMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blocktimeline.FieldDescription)
}

// SetLayout sets the "layout" field.
func (m *BlockTimelineMutation) SetLayout(s string) {
	m.layout = &s
}

// Layout returns the value of the "layout" field in the mutation.
func (m *BlockTimelineMutation) Layout() (r string, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the BlockTimeline entity.
// If the BlockTimeline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTimelineMutation) OldLayout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ResetLayout resets all changes to the "layout" field.
func (m *BlockTimelineMutation) ResetLayout() {
	m.layout = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockTimelineMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockTimelineMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockTimeline entity.
// If the BlockTimeline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTimelineMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockTimelineMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockTimelineMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockTimelineMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockTimeline entity.
// If the BlockTimeline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockTimelineMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockTimelineMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockTimelineMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockTimelineMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockTimelineMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockTimelineMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockTimelineMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockTimelineMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// AddEventIDs adds the "events" edge to the TimelineEvent entity by ids.
func (m *BlockTimelineMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the TimelineEvent entity.
func (m *BlockTimelineMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the TimelineEvent entity was cleared.
func (m *BlockTimelineMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the TimelineEvent entity by IDs.
func (m *BlockTimelineMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the TimelineEvent entity.
func (m *BlockTimelineMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *BlockTimelineMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *BlockTimelineMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the BlockTimelineMutation builder.
func (m *BlockTimelineMutation) Where(ps ...predicate.BlockTimeline) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockTimelineMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockTimelineMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockTimeline, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockTimelineMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockTimelineMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockTimeline).
func (m *BlockTimelineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockTimelineMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.internal_name != nil {
		fields = append(fields, blocktimeline.FieldInternalName)
	}
	if m.badge != nil {
		fields = append(fields, blocktimeline.FieldBadge)
	}
	if m.title != nil {
		fields = append(fields, blocktimeline.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blocktimeline.FieldDescription)
	}
	if m.layout != nil {
		fields = append(fields, blocktimeline.FieldLayout)
	}
	if m.created_at != nil {
		fields = append(fields, blocktimeline.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blocktimeline.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockTimelineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blocktimeline.FieldInternalName:
		return m.InternalName()
	case blocktimeline.FieldBadge:
		return m.Badge()
	case blocktimeline.FieldTitle:
		return m.Title()
	case blocktimeline.FieldDescription:
		return m.Description()
	case blocktimeline.FieldLayout:
		return m.Layout()
	case blocktimeline.FieldCreatedAt:
		return m.CreatedAt()
	case blocktimeline.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockTimelineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blocktimeline.FieldInternalName:
		return m.OldInternalName(ctx)
	case blocktimeline.FieldBadge:
		return m.OldBadge(ctx)
	case blocktimeline.FieldTitle:
		return m.OldTitle(ctx)
	case blocktimeline.FieldDescription:
		return m.OldDescription(ctx)
	case blocktimeline.FieldLayout:
		return m.OldLayout(ctx)
	case blocktimeline.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blocktimeline.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockTimeline field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockTimelineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blocktimeline.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blocktimeline.FieldBadge:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	case blocktimeline.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blocktimeline.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blocktimeline.FieldLayout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case blocktimeline.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blocktimeline.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockTimeline field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockTimelineMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockTimelineMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockTimelineMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockTimeline numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockTimelineMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blocktimeline.FieldBadge) {
		fields = append(fields, blocktimeline.FieldBadge)
	}
	if m.FieldCleared(blocktimeline.FieldTitle) {
		fields = append(fields, blocktimeline.FieldTitle)
	}
	if m.FieldCleared(blocktimeline.FieldDescription) {
		fields = append(fields, blocktimeline.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockTimelineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockTimelineMutation) ClearField(name string) error {
	switch name {
	case blocktimeline.FieldBadge:
		m.ClearBadge()
		return nil
	case blocktimeline.FieldTitle:
		m.ClearTitle()
		return nil
	case blocktimeline.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlockTimeline nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockTimelineMutation) ResetField(name string) error {
	switch name {
	case blocktimeline.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blocktimeline.FieldBadge:
		m.ResetBadge()
		return nil
	case blocktimeline.FieldTitle:
		m.ResetTitle()
		return nil
	case blocktimeline.FieldDescription:
		m.ResetDescription()
		return nil
	case blocktimeline.FieldLayout:
		m.ResetLayout()
		return nil
	case blocktimeline.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blocktimeline.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockTimeline field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockTimelineMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.content_block != nil {
		edges = append(edges, blocktimeline.EdgeContentBlock)
	}
	if m.events != nil {
		edges = append(edges, blocktimeline.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockTimelineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blocktimeline.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	case blocktimeline.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockTimelineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedevents != nil {
		edges = append(edges, blocktimeline.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockTimelineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blocktimeline.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockTimelineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcontent_block {
		edges = append(edges, blocktimeline.EdgeContentBlock)
	}
	if m.clearedevents {
		edges = append(edges, blocktimeline.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockTimelineMutation) EdgeCleared(name string) bool {
	switch name {
	case blocktimeline.EdgeContentBlock:
		return m.clearedcontent_block
	case blocktimeline.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockTimelineMutation) ClearEdge(name string) error {
	switch name {
	case blocktimeline.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockTimeline unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockTimelineMutation) ResetEdge(name string) error {
	switch name {
	case blocktimeline.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	case blocktimeline.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown BlockTimeline edge %s", name)
}

// BlockVideoEmbedMutation represents an operation that mutates the BlockVideoEmbed nodes in the graph.
type BlockVideoEmbedMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	badge                *map[string]string
	title                *map[string]string
	description          *map[string]string
	video_url            *string
	thumbnail_url        *string
	aspect_ratio         *string
	autoplay             *bool
	show_controls        *bool
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	done                 bool
	oldValue             func(context.Context) (*BlockVideoEmbed, error)
	predicates           []predicate.BlockVideoEmbed
}

var _ ent.Mutation = (*BlockVideoEmbedMutation)(nil)

// blockvideoembedOption allows management of the mutation configuration using functional options.
type blockvideoembedOption func(*BlockVideoEmbedMutation)

// newBlockVideoEmbedMutation creates new mutation for the BlockVideoEmbed entity.
func newBlockVideoEmbedMutation(c config, op Op, opts ...blockvideoembedOption) *BlockVideoEmbedMutation {
	m := &BlockVideoEmbedMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockVideoEmbed,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockVideoEmbedID sets the ID field of the mutation.
func withBlockVideoEmbedID(id int) blockvideoembedOption {
	return func(m *BlockVideoEmbedMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockVideoEmbed
		)
		m.oldValue = func(ctx context.Context) (*BlockVideoEmbed, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockVideoEmbed.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockVideoEmbed sets the old BlockVideoEmbed of the mutation.
func withBlockVideoEmbed(node *BlockVideoEmbed) blockvideoembedOption {
	return func(m *BlockVideoEmbedMutation) {
		m.oldValue = func(context.Context) (*BlockVideoEmbed, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockVideoEmbedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockVideoEmbedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockVideoEmbedMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockVideoEmbedMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockVideoEmbed.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockVideoEmbedMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockVideoEmbedMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockVideoEmbed entity.
// If the BlockVideoEmbed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVideoEmbedMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockVideoEmbedMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetBadge sets the "badge" field.
func (m *BlockVideoEmbedMutation) SetBadge(value map[string]string) {
	m.badge = &value
}

// Badge returns the value of the "badge" field in the mutation.
func (m *BlockVideoEmbedMutation) Badge() (r map[string]string, exists bool) {
	v := m.badge
	if v == nil {
		return
	}
	return *v, true
}

// OldBadge returns the old "badge" field's value of the BlockVideoEmbed entity.
// If the BlockVideoEmbed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVideoEmbedMutation) OldBadge(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadge: %w", err)
	}
	return oldValue.Badge, nil
}

// ClearBadge clears the value of the "badge" field.
func (m *BlockVideoEmbedMutation) ClearBadge() {
	m.badge = nil
	m.clearedFields[blockvideoembed.FieldBadge] = struct{}{}
}

// BadgeCleared returns if the "badge" field was cleared in this mutation.
func (m *BlockVideoEmbedMutation) BadgeCleared() bool {
	_, ok := m.clearedFields[blockvideoembed.FieldBadge]
	return ok
}

// ResetBadge resets all changes to the "badge" field.
func (m *BlockVideoEmbedMutation) ResetBadge() {
	m.badge = nil
	delete(m.clearedFields, blockvideoembed.FieldBadge)
}

// SetTitle sets the "title" field.
func (m *BlockVideoEmbedMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockVideoEmbedMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockVideoEmbed entity.
// If the BlockVideoEmbed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVideoEmbedMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *BlockVideoEmbedMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[blockvideoembed.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *BlockVideoEmbedMutation) TitleCleared() bool {
	_, ok := m.clearedFields[blockvideoembed.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockVideoEmbedMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, blockvideoembed.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *BlockVideoEmbedMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockVideoEmbedMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockVideoEmbed entity.
// If the BlockVideoEmbed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVideoEmbedMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockVideoEmbedMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockvideoembed.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockVideoEmbedMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockvideoembed.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockVideoEmbedMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockvideoembed.FieldDescription)
}

// SetVideoURL sets the "video_url" field.
func (m *BlockVideoEmbedMutation) SetVideoURL(s string) {
	m.video_url = &s
}

// VideoURL returns the value of the "video_url" field in the mutation.
func (m *BlockVideoEmbedMutation) VideoURL() (r string, exists bool) {
	v := m.video_url
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoURL returns the old "video_url" field's value of the BlockVideoEmbed entity.
// If the BlockVideoEmbed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVideoEmbedMutation) OldVideoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoURL: %w", err)
	}
	return oldValue.VideoURL, nil
}

// ResetVideoURL resets all changes to the "video_url" field.
func (m *BlockVideoEmbedMutation) ResetVideoURL() {
	m.video_url = nil
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *BlockVideoEmbedMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *BlockVideoEmbedMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the BlockVideoEmbed entity.
// If the BlockVideoEmbed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVideoEmbedMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *BlockVideoEmbedMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[blockvideoembed.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *BlockVideoEmbedMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[blockvideoembed.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *BlockVideoEmbedMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, blockvideoembed.FieldThumbnailURL)
}

// SetAspectRatio sets the "aspect_ratio" field.
func (m *BlockVideoEmbedMutation) SetAspectRatio(s string) {
	m.aspect_ratio = &s
}

// AspectRatio returns the value of the "aspect_ratio" field in the mutation.
func (m *BlockVideoEmbedMutation) AspectRatio() (r string, exists bool) {
	v := m.aspect_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldAspectRatio returns the old "aspect_ratio" field's value of the BlockVideoEmbed entity.
// If the BlockVideoEmbed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVideoEmbedMutation) OldAspectRatio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAspectRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAspectRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAspectRatio: %w", err)
	}
	return oldValue.AspectRatio, nil
}

// ResetAspectRatio resets all changes to the "aspect_ratio" field.
func (m *BlockVideoEmbedMutation) ResetAspectRatio() {
	m.aspect_ratio = nil
}

// SetAutoplay sets the "autoplay" field.
func (m *BlockVideoEmbedMutation) SetAutoplay(b bool) {
	m.autoplay = &b
}

// Autoplay returns the value of the "autoplay" field in the mutation.
func (m *BlockVideoEmbedMutation) Autoplay() (r bool, exists bool) {
	v := m.autoplay
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoplay returns the old "autoplay" field's value of the BlockVideoEmbed entity.
// If the BlockVideoEmbed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVideoEmbedMutation) OldAutoplay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoplay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoplay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoplay: %w", err)
	}
	return oldValue.Autoplay, nil
}

// ResetAutoplay resets all changes to the "autoplay" field.
func (m *BlockVideoEmbedMutation) ResetAutoplay() {
	m.autoplay = nil
}

// SetShowControls sets the "show_controls" field.
func (m *BlockVideoEmbedMutation) SetShowControls(b bool) {
	m.show_controls = &b
}

// ShowControls returns the value of the "show_controls" field in the mutation.
func (m *BlockVideoEmbedMutation) ShowControls() (r bool, exists bool) {
	v := m.show_controls
	if v == nil {
		return
	}
	return *v, true
}

// OldShowControls returns the old "show_controls" field's value of the BlockVideoEmbed entity.
// If the BlockVideoEmbed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVideoEmbedMutation) OldShowControls(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowControls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowControls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowControls: %w", err)
	}
	return oldValue.ShowControls, nil
}

// ResetShowControls resets all changes to the "show_controls" field.
func (m *BlockVideoEmbedMutation) ResetShowControls() {
	m.show_controls = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockVideoEmbedMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockVideoEmbedMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockVideoEmbed entity.
// If the BlockVideoEmbed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVideoEmbedMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockVideoEmbedMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockVideoEmbedMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockVideoEmbedMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockVideoEmbed entity.
// If the BlockVideoEmbed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVideoEmbedMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockVideoEmbedMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockVideoEmbedMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockVideoEmbedMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockVideoEmbedMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockVideoEmbedMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockVideoEmbedMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockVideoEmbedMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// Where appends a list predicates to the BlockVideoEmbedMutation builder.
func (m *BlockVideoEmbedMutation) Where(ps ...predicate.BlockVideoEmbed) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockVideoEmbedMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockVideoEmbedMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockVideoEmbed, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockVideoEmbedMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockVideoEmbedMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockVideoEmbed).
func (m *BlockVideoEmbedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockVideoEmbedMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.internal_name != nil {
		fields = append(fields, blockvideoembed.FieldInternalName)
	}
	if m.badge != nil {
		fields = append(fields, blockvideoembed.FieldBadge)
	}
	if m.title != nil {
		fields = append(fields, blockvideoembed.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blockvideoembed.FieldDescription)
	}
	if m.video_url != nil {
		fields = append(fields, blockvideoembed.FieldVideoURL)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, blockvideoembed.FieldThumbnailURL)
	}
	if m.aspect_ratio != nil {
		fields = append(fields, blockvideoembed.FieldAspectRatio)
	}
	if m.autoplay != nil {
		fields = append(fields, blockvideoembed.FieldAutoplay)
	}
	if m.show_controls != nil {
		fields = append(fields, blockvideoembed.FieldShowControls)
	}
	if m.created_at != nil {
		fields = append(fields, blockvideoembed.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockvideoembed.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockVideoEmbedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockvideoembed.FieldInternalName:
		return m.InternalName()
	case blockvideoembed.FieldBadge:
		return m.Badge()
	case blockvideoembed.FieldTitle:
		return m.Title()
	case blockvideoembed.FieldDescription:
		return m.Description()
	case blockvideoembed.FieldVideoURL:
		return m.VideoURL()
	case blockvideoembed.FieldThumbnailURL:
		return m.ThumbnailURL()
	case blockvideoembed.FieldAspectRatio:
		return m.AspectRatio()
	case blockvideoembed.FieldAutoplay:
		return m.Autoplay()
	case blockvideoembed.FieldShowControls:
		return m.ShowControls()
	case blockvideoembed.FieldCreatedAt:
		return m.CreatedAt()
	case blockvideoembed.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockVideoEmbedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockvideoembed.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockvideoembed.FieldBadge:
		return m.OldBadge(ctx)
	case blockvideoembed.FieldTitle:
		return m.OldTitle(ctx)
	case blockvideoembed.FieldDescription:
		return m.OldDescription(ctx)
	case blockvideoembed.FieldVideoURL:
		return m.OldVideoURL(ctx)
	case blockvideoembed.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case blockvideoembed.FieldAspectRatio:
		return m.OldAspectRatio(ctx)
	case blockvideoembed.FieldAutoplay:
		return m.OldAutoplay(ctx)
	case blockvideoembed.FieldShowControls:
		return m.OldShowControls(ctx)
	case blockvideoembed.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockvideoembed.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockVideoEmbed field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockVideoEmbedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockvideoembed.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockvideoembed.FieldBadge:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadge(v)
		return nil
	case blockvideoembed.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockvideoembed.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockvideoembed.FieldVideoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoURL(v)
		return nil
	case blockvideoembed.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case blockvideoembed.FieldAspectRatio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAspectRatio(v)
		return nil
	case blockvideoembed.FieldAutoplay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoplay(v)
		return nil
	case blockvideoembed.FieldShowControls:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowControls(v)
		return nil
	case blockvideoembed.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockvideoembed.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockVideoEmbed field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockVideoEmbedMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockVideoEmbedMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockVideoEmbedMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockVideoEmbed numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockVideoEmbedMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockvideoembed.FieldBadge) {
		fields = append(fields, blockvideoembed.FieldBadge)
	}
	if m.FieldCleared(blockvideoembed.FieldTitle) {
		fields = append(fields, blockvideoembed.FieldTitle)
	}
	if m.FieldCleared(blockvideoembed.FieldDescription) {
		fields = append(fields, blockvideoembed.FieldDescription)
	}
	if m.FieldCleared(blockvideoembed.FieldThumbnailURL) {
		fields = append(fields, blockvideoembed.FieldThumbnailURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockVideoEmbedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockVideoEmbedMutation) ClearField(name string) error {
	switch name {
	case blockvideoembed.FieldBadge:
		m.ClearBadge()
		return nil
	case blockvideoembed.FieldTitle:
		m.ClearTitle()
		return nil
	case blockvideoembed.FieldDescription:
		m.ClearDescription()
		return nil
	case blockvideoembed.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	}
	return fmt.Errorf("unknown BlockVideoEmbed nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockVideoEmbedMutation) ResetField(name string) error {
	switch name {
	case blockvideoembed.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockvideoembed.FieldBadge:
		m.ResetBadge()
		return nil
	case blockvideoembed.FieldTitle:
		m.ResetTitle()
		return nil
	case blockvideoembed.FieldDescription:
		m.ResetDescription()
		return nil
	case blockvideoembed.FieldVideoURL:
		m.ResetVideoURL()
		return nil
	case blockvideoembed.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case blockvideoembed.FieldAspectRatio:
		m.ResetAspectRatio()
		return nil
	case blockvideoembed.FieldAutoplay:
		m.ResetAutoplay()
		return nil
	case blockvideoembed.FieldShowControls:
		m.ResetShowControls()
		return nil
	case blockvideoembed.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockvideoembed.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockVideoEmbed field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockVideoEmbedMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content_block != nil {
		edges = append(edges, blockvideoembed.EdgeContentBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockVideoEmbedMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockvideoembed.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockVideoEmbedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockVideoEmbedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockVideoEmbedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent_block {
		edges = append(edges, blockvideoembed.EdgeContentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockVideoEmbedMutation) EdgeCleared(name string) bool {
	switch name {
	case blockvideoembed.EdgeContentBlock:
		return m.clearedcontent_block
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockVideoEmbedMutation) ClearEdge(name string) error {
	switch name {
	case blockvideoembed.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockVideoEmbed unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockVideoEmbedMutation) ResetEdge(name string) error {
	switch name {
	case blockvideoembed.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockVideoEmbed edge %s", name)
}

// BlockVolunteerSignupMutation represents an operation that mutates the BlockVolunteerSignup nodes in the graph.
type BlockVolunteerSignupMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	internal_name        *string
	title                *map[string]string
	description          *map[string]string
	show_skills_input    *bool
	show_availability    *bool
	require_background   *bool
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	content_block        *int
	clearedcontent_block bool
	done                 bool
	oldValue             func(context.Context) (*BlockVolunteerSignup, error)
	predicates           []predicate.BlockVolunteerSignup
}

var _ ent.Mutation = (*BlockVolunteerSignupMutation)(nil)

// blockvolunteersignupOption allows management of the mutation configuration using functional options.
type blockvolunteersignupOption func(*BlockVolunteerSignupMutation)

// newBlockVolunteerSignupMutation creates new mutation for the BlockVolunteerSignup entity.
func newBlockVolunteerSignupMutation(c config, op Op, opts ...blockvolunteersignupOption) *BlockVolunteerSignupMutation {
	m := &BlockVolunteerSignupMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockVolunteerSignup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockVolunteerSignupID sets the ID field of the mutation.
func withBlockVolunteerSignupID(id int) blockvolunteersignupOption {
	return func(m *BlockVolunteerSignupMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockVolunteerSignup
		)
		m.oldValue = func(ctx context.Context) (*BlockVolunteerSignup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockVolunteerSignup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockVolunteerSignup sets the old BlockVolunteerSignup of the mutation.
func withBlockVolunteerSignup(node *BlockVolunteerSignup) blockvolunteersignupOption {
	return func(m *BlockVolunteerSignupMutation) {
		m.oldValue = func(context.Context) (*BlockVolunteerSignup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockVolunteerSignupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockVolunteerSignupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockVolunteerSignupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockVolunteerSignupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockVolunteerSignup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternalName sets the "internal_name" field.
func (m *BlockVolunteerSignupMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *BlockVolunteerSignupMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the BlockVolunteerSignup entity.
// If the BlockVolunteerSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVolunteerSignupMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *BlockVolunteerSignupMutation) ResetInternalName() {
	m.internal_name = nil
}

// SetTitle sets the "title" field.
func (m *BlockVolunteerSignupMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *BlockVolunteerSignupMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlockVolunteerSignup entity.
// If the BlockVolunteerSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVolunteerSignupMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlockVolunteerSignupMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BlockVolunteerSignupMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *BlockVolunteerSignupMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlockVolunteerSignup entity.
// If the BlockVolunteerSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVolunteerSignupMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlockVolunteerSignupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blockvolunteersignup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlockVolunteerSignupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blockvolunteersignup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlockVolunteerSignupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blockvolunteersignup.FieldDescription)
}

// SetShowSkillsInput sets the "show_skills_input" field.
func (m *BlockVolunteerSignupMutation) SetShowSkillsInput(b bool) {
	m.show_skills_input = &b
}

// ShowSkillsInput returns the value of the "show_skills_input" field in the mutation.
func (m *BlockVolunteerSignupMutation) ShowSkillsInput() (r bool, exists bool) {
	v := m.show_skills_input
	if v == nil {
		return
	}
	return *v, true
}

// OldShowSkillsInput returns the old "show_skills_input" field's value of the BlockVolunteerSignup entity.
// If the BlockVolunteerSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVolunteerSignupMutation) OldShowSkillsInput(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowSkillsInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowSkillsInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowSkillsInput: %w", err)
	}
	return oldValue.ShowSkillsInput, nil
}

// ResetShowSkillsInput resets all changes to the "show_skills_input" field.
func (m *BlockVolunteerSignupMutation) ResetShowSkillsInput() {
	m.show_skills_input = nil
}

// SetShowAvailability sets the "show_availability" field.
func (m *BlockVolunteerSignupMutation) SetShowAvailability(b bool) {
	m.show_availability = &b
}

// ShowAvailability returns the value of the "show_availability" field in the mutation.
func (m *BlockVolunteerSignupMutation) ShowAvailability() (r bool, exists bool) {
	v := m.show_availability
	if v == nil {
		return
	}
	return *v, true
}

// OldShowAvailability returns the old "show_availability" field's value of the BlockVolunteerSignup entity.
// If the BlockVolunteerSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVolunteerSignupMutation) OldShowAvailability(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowAvailability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowAvailability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowAvailability: %w", err)
	}
	return oldValue.ShowAvailability, nil
}

// ResetShowAvailability resets all changes to the "show_availability" field.
func (m *BlockVolunteerSignupMutation) ResetShowAvailability() {
	m.show_availability = nil
}

// SetRequireBackground sets the "require_background" field.
func (m *BlockVolunteerSignupMutation) SetRequireBackground(b bool) {
	m.require_background = &b
}

// RequireBackground returns the value of the "require_background" field in the mutation.
func (m *BlockVolunteerSignupMutation) RequireBackground() (r bool, exists bool) {
	v := m.require_background
	if v == nil {
		return
	}
	return *v, true
}

// OldRequireBackground returns the old "require_background" field's value of the BlockVolunteerSignup entity.
// If the BlockVolunteerSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVolunteerSignupMutation) OldRequireBackground(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequireBackground is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequireBackground requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequireBackground: %w", err)
	}
	return oldValue.RequireBackground, nil
}

// ResetRequireBackground resets all changes to the "require_background" field.
func (m *BlockVolunteerSignupMutation) ResetRequireBackground() {
	m.require_background = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockVolunteerSignupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockVolunteerSignupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockVolunteerSignup entity.
// If the BlockVolunteerSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVolunteerSignupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockVolunteerSignupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockVolunteerSignupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockVolunteerSignupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockVolunteerSignup entity.
// If the BlockVolunteerSignup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockVolunteerSignupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockVolunteerSignupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContentBlockID sets the "content_block" edge to the ContentBlock entity by id.
func (m *BlockVolunteerSignupMutation) SetContentBlockID(id int) {
	m.content_block = &id
}

// ClearContentBlock clears the "content_block" edge to the ContentBlock entity.
func (m *BlockVolunteerSignupMutation) ClearContentBlock() {
	m.clearedcontent_block = true
}

// ContentBlockCleared reports if the "content_block" edge to the ContentBlock entity was cleared.
func (m *BlockVolunteerSignupMutation) ContentBlockCleared() bool {
	return m.clearedcontent_block
}

// ContentBlockID returns the "content_block" edge ID in the mutation.
func (m *BlockVolunteerSignupMutation) ContentBlockID() (id int, exists bool) {
	if m.content_block != nil {
		return *m.content_block, true
	}
	return
}

// ContentBlockIDs returns the "content_block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentBlockID instead. It exists only for internal usage by the builders.
func (m *BlockVolunteerSignupMutation) ContentBlockIDs() (ids []int) {
	if id := m.content_block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContentBlock resets all changes to the "content_block" edge.
func (m *BlockVolunteerSignupMutation) ResetContentBlock() {
	m.content_block = nil
	m.clearedcontent_block = false
}

// Where appends a list predicates to the BlockVolunteerSignupMutation builder.
func (m *BlockVolunteerSignupMutation) Where(ps ...predicate.BlockVolunteerSignup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockVolunteerSignupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockVolunteerSignupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockVolunteerSignup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockVolunteerSignupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockVolunteerSignupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockVolunteerSignup).
func (m *BlockVolunteerSignupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockVolunteerSignupMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.internal_name != nil {
		fields = append(fields, blockvolunteersignup.FieldInternalName)
	}
	if m.title != nil {
		fields = append(fields, blockvolunteersignup.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blockvolunteersignup.FieldDescription)
	}
	if m.show_skills_input != nil {
		fields = append(fields, blockvolunteersignup.FieldShowSkillsInput)
	}
	if m.show_availability != nil {
		fields = append(fields, blockvolunteersignup.FieldShowAvailability)
	}
	if m.require_background != nil {
		fields = append(fields, blockvolunteersignup.FieldRequireBackground)
	}
	if m.created_at != nil {
		fields = append(fields, blockvolunteersignup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockvolunteersignup.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockVolunteerSignupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockvolunteersignup.FieldInternalName:
		return m.InternalName()
	case blockvolunteersignup.FieldTitle:
		return m.Title()
	case blockvolunteersignup.FieldDescription:
		return m.Description()
	case blockvolunteersignup.FieldShowSkillsInput:
		return m.ShowSkillsInput()
	case blockvolunteersignup.FieldShowAvailability:
		return m.ShowAvailability()
	case blockvolunteersignup.FieldRequireBackground:
		return m.RequireBackground()
	case blockvolunteersignup.FieldCreatedAt:
		return m.CreatedAt()
	case blockvolunteersignup.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockVolunteerSignupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockvolunteersignup.FieldInternalName:
		return m.OldInternalName(ctx)
	case blockvolunteersignup.FieldTitle:
		return m.OldTitle(ctx)
	case blockvolunteersignup.FieldDescription:
		return m.OldDescription(ctx)
	case blockvolunteersignup.FieldShowSkillsInput:
		return m.OldShowSkillsInput(ctx)
	case blockvolunteersignup.FieldShowAvailability:
		return m.OldShowAvailability(ctx)
	case blockvolunteersignup.FieldRequireBackground:
		return m.OldRequireBackground(ctx)
	case blockvolunteersignup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockvolunteersignup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlockVolunteerSignup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockVolunteerSignupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockvolunteersignup.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case blockvolunteersignup.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blockvolunteersignup.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blockvolunteersignup.FieldShowSkillsInput:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowSkillsInput(v)
		return nil
	case blockvolunteersignup.FieldShowAvailability:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowAvailability(v)
		return nil
	case blockvolunteersignup.FieldRequireBackground:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequireBackground(v)
		return nil
	case blockvolunteersignup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockvolunteersignup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlockVolunteerSignup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockVolunteerSignupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockVolunteerSignupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockVolunteerSignupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockVolunteerSignup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockVolunteerSignupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockvolunteersignup.FieldDescription) {
		fields = append(fields, blockvolunteersignup.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockVolunteerSignupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockVolunteerSignupMutation) ClearField(name string) error {
	switch name {
	case blockvolunteersignup.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlockVolunteerSignup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockVolunteerSignupMutation) ResetField(name string) error {
	switch name {
	case blockvolunteersignup.FieldInternalName:
		m.ResetInternalName()
		return nil
	case blockvolunteersignup.FieldTitle:
		m.ResetTitle()
		return nil
	case blockvolunteersignup.FieldDescription:
		m.ResetDescription()
		return nil
	case blockvolunteersignup.FieldShowSkillsInput:
		m.ResetShowSkillsInput()
		return nil
	case blockvolunteersignup.FieldShowAvailability:
		m.ResetShowAvailability()
		return nil
	case blockvolunteersignup.FieldRequireBackground:
		m.ResetRequireBackground()
		return nil
	case blockvolunteersignup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockvolunteersignup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockVolunteerSignup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockVolunteerSignupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.content_block != nil {
		edges = append(edges, blockvolunteersignup.EdgeContentBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockVolunteerSignupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockvolunteersignup.EdgeContentBlock:
		if id := m.content_block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockVolunteerSignupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockVolunteerSignupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockVolunteerSignupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontent_block {
		edges = append(edges, blockvolunteersignup.EdgeContentBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockVolunteerSignupMutation) EdgeCleared(name string) bool {
	switch name {
	case blockvolunteersignup.EdgeContentBlock:
		return m.clearedcontent_block
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockVolunteerSignupMutation) ClearEdge(name string) error {
	switch name {
	case blockvolunteersignup.EdgeContentBlock:
		m.ClearContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockVolunteerSignup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockVolunteerSignupMutation) ResetEdge(name string) error {
	switch name {
	case blockvolunteersignup.EdgeContentBlock:
		m.ResetContentBlock()
		return nil
	}
	return fmt.Errorf("unknown BlockVolunteerSignup edge %s", name)
}

// BrandBenefitMutation represents an operation that mutates the BrandBenefit nodes in the graph.
type BrandBenefitMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_type              *string
	description        *string
	url                *string
	date               *time.Time
	value              *float64
	addvalue           *float64
	clearedFields      map[string]struct{}
	partnership        *int
	clearedpartnership bool
	done               bool
	oldValue           func(context.Context) (*BrandBenefit, error)
	predicates         []predicate.BrandBenefit
}

var _ ent.Mutation = (*BrandBenefitMutation)(nil)

// brandbenefitOption allows management of the mutation configuration using functional options.
type brandbenefitOption func(*BrandBenefitMutation)

// newBrandBenefitMutation creates new mutation for the BrandBenefit entity.
func newBrandBenefitMutation(c config, op Op, opts ...brandbenefitOption) *BrandBenefitMutation {
	m := &BrandBenefitMutation{
		config:        c,
		op:            op,
		typ:           TypeBrandBenefit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBrandBenefitID sets the ID field of the mutation.
func withBrandBenefitID(id int) brandbenefitOption {
	return func(m *BrandBenefitMutation) {
		var (
			err   error
			once  sync.Once
			value *BrandBenefit
		)
		m.oldValue = func(ctx context.Context) (*BrandBenefit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BrandBenefit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBrandBenefit sets the old BrandBenefit of the mutation.
func withBrandBenefit(node *BrandBenefit) brandbenefitOption {
	return func(m *BrandBenefitMutation) {
		m.oldValue = func(context.Context) (*BrandBenefit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BrandBenefitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BrandBenefitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BrandBenefitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BrandBenefitMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BrandBenefit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *BrandBenefitMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *BrandBenefitMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BrandBenefit entity.
// If the BrandBenefit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandBenefitMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BrandBenefitMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *BrandBenefitMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BrandBenefitMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BrandBenefit entity.
// If the BrandBenefit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandBenefitMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BrandBenefitMutation) ResetDescription() {
	m.description = nil
}

// SetURL sets the "url" field.
func (m *BrandBenefitMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *BrandBenefitMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the BrandBenefit entity.
// If the BrandBenefit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandBenefitMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *BrandBenefitMutation) ClearURL() {
	m.url = nil
	m.clearedFields[brandbenefit.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *BrandBenefitMutation) URLCleared() bool {
	_, ok := m.clearedFields[brandbenefit.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *BrandBenefitMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, brandbenefit.FieldURL)
}

// SetDate sets the "date" field.
func (m *BrandBenefitMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *BrandBenefitMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the BrandBenefit entity.
// If the BrandBenefit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandBenefitMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *BrandBenefitMutation) ResetDate() {
	m.date = nil
}

// SetValue sets the "value" field.
func (m *BrandBenefitMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *BrandBenefitMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the BrandBenefit entity.
// If the BrandBenefit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandBenefitMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *BrandBenefitMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *BrandBenefitMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ClearValue clears the value of the "value" field.
func (m *BrandBenefitMutation) ClearValue() {
	m.value = nil
	m.addvalue = nil
	m.clearedFields[brandbenefit.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *BrandBenefitMutation) ValueCleared() bool {
	_, ok := m.clearedFields[brandbenefit.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *BrandBenefitMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
	delete(m.clearedFields, brandbenefit.FieldValue)
}

// SetPartnershipID sets the "partnership" edge to the Partnership entity by id.
func (m *BrandBenefitMutation) SetPartnershipID(id int) {
	m.partnership = &id
}

// ClearPartnership clears the "partnership" edge to the Partnership entity.
func (m *BrandBenefitMutation) ClearPartnership() {
	m.clearedpartnership = true
}

// PartnershipCleared reports if the "partnership" edge to the Partnership entity was cleared.
func (m *BrandBenefitMutation) PartnershipCleared() bool {
	return m.clearedpartnership
}

// PartnershipID returns the "partnership" edge ID in the mutation.
func (m *BrandBenefitMutation) PartnershipID() (id int, exists bool) {
	if m.partnership != nil {
		return *m.partnership, true
	}
	return
}

// PartnershipIDs returns the "partnership" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnershipID instead. It exists only for internal usage by the builders.
func (m *BrandBenefitMutation) PartnershipIDs() (ids []int) {
	if id := m.partnership; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartnership resets all changes to the "partnership" edge.
func (m *BrandBenefitMutation) ResetPartnership() {
	m.partnership = nil
	m.clearedpartnership = false
}

// Where appends a list predicates to the BrandBenefitMutation builder.
func (m *BrandBenefitMutation) Where(ps ...predicate.BrandBenefit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BrandBenefitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BrandBenefitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BrandBenefit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BrandBenefitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BrandBenefitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BrandBenefit).
func (m *BrandBenefitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BrandBenefitMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, brandbenefit.FieldType)
	}
	if m.description != nil {
		fields = append(fields, brandbenefit.FieldDescription)
	}
	if m.url != nil {
		fields = append(fields, brandbenefit.FieldURL)
	}
	if m.date != nil {
		fields = append(fields, brandbenefit.FieldDate)
	}
	if m.value != nil {
		fields = append(fields, brandbenefit.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BrandBenefitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case brandbenefit.FieldType:
		return m.GetType()
	case brandbenefit.FieldDescription:
		return m.Description()
	case brandbenefit.FieldURL:
		return m.URL()
	case brandbenefit.FieldDate:
		return m.Date()
	case brandbenefit.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BrandBenefitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case brandbenefit.FieldType:
		return m.OldType(ctx)
	case brandbenefit.FieldDescription:
		return m.OldDescription(ctx)
	case brandbenefit.FieldURL:
		return m.OldURL(ctx)
	case brandbenefit.FieldDate:
		return m.OldDate(ctx)
	case brandbenefit.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown BrandBenefit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandBenefitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case brandbenefit.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case brandbenefit.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case brandbenefit.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case brandbenefit.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case brandbenefit.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown BrandBenefit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BrandBenefitMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, brandbenefit.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BrandBenefitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case brandbenefit.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandBenefitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case brandbenefit.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown BrandBenefit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BrandBenefitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(brandbenefit.FieldURL) {
		fields = append(fields, brandbenefit.FieldURL)
	}
	if m.FieldCleared(brandbenefit.FieldValue) {
		fields = append(fields, brandbenefit.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BrandBenefitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BrandBenefitMutation) ClearField(name string) error {
	switch name {
	case brandbenefit.FieldURL:
		m.ClearURL()
		return nil
	case brandbenefit.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown BrandBenefit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BrandBenefitMutation) ResetField(name string) error {
	switch name {
	case brandbenefit.FieldType:
		m.ResetType()
		return nil
	case brandbenefit.FieldDescription:
		m.ResetDescription()
		return nil
	case brandbenefit.FieldURL:
		m.ResetURL()
		return nil
	case brandbenefit.FieldDate:
		m.ResetDate()
		return nil
	case brandbenefit.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown BrandBenefit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BrandBenefitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.partnership != nil {
		edges = append(edges, brandbenefit.EdgePartnership)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BrandBenefitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case brandbenefit.EdgePartnership:
		if id := m.partnership; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BrandBenefitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BrandBenefitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BrandBenefitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpartnership {
		edges = append(edges, brandbenefit.EdgePartnership)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BrandBenefitMutation) EdgeCleared(name string) bool {
	switch name {
	case brandbenefit.EdgePartnership:
		return m.clearedpartnership
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BrandBenefitMutation) ClearEdge(name string) error {
	switch name {
	case brandbenefit.EdgePartnership:
		m.ClearPartnership()
		return nil
	}
	return fmt.Errorf("unknown BrandBenefit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BrandBenefitMutation) ResetEdge(name string) error {
	switch name {
	case brandbenefit.EdgePartnership:
		m.ResetPartnership()
		return nil
	}
	return fmt.Errorf("unknown BrandBenefit edge %s", name)
}

// BrandConfigMutation represents an operation that mutates the BrandConfig nodes in the graph.
type BrandConfigMutation struct {
	config
	op            Op
	typ           string
	id            *int
	singleton     *string
	name          *string
	logo_url      *string
	colors        *map[string]string
	contact       *map[string]string
	social        *map[string]string
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BrandConfig, error)
	predicates    []predicate.BrandConfig
}

var _ ent.Mutation = (*BrandConfigMutation)(nil)

// brandconfigOption allows management of the mutation configuration using functional options.
type brandconfigOption func(*BrandConfigMutation)

// newBrandConfigMutation creates new mutation for the BrandConfig entity.
func newBrandConfigMutation(c config, op Op, opts ...brandconfigOption) *BrandConfigMutation {
	m := &BrandConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeBrandConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBrandConfigID sets the ID field of the mutation.
func withBrandConfigID(id int) brandconfigOption {
	return func(m *BrandConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *BrandConfig
		)
		m.oldValue = func(ctx context.Context) (*BrandConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BrandConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBrandConfig sets the old BrandConfig of the mutation.
func withBrandConfig(node *BrandConfig) brandconfigOption {
	return func(m *BrandConfigMutation) {
		m.oldValue = func(context.Context) (*BrandConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BrandConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BrandConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BrandConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BrandConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BrandConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSingleton sets the "singleton" field.
func (m *BrandConfigMutation) SetSingleton(s string) {
	m.singleton = &s
}

// Singleton returns the value of the "singleton" field in the mutation.
func (m *BrandConfigMutation) Singleton() (r string, exists bool) {
	v := m.singleton
	if v == nil {
		return
	}
	return *v, true
}

// OldSingleton returns the old "singleton" field's value of the BrandConfig entity.
// If the BrandConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandConfigMutation) OldSingleton(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSingleton is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSingleton requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSingleton: %w", err)
	}
	return oldValue.Singleton, nil
}

// ResetSingleton resets all changes to the "singleton" field.
func (m *BrandConfigMutation) ResetSingleton() {
	m.singleton = nil
}

// SetName sets the "name" field.
func (m *BrandConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BrandConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BrandConfig entity.
// If the BrandConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BrandConfigMutation) ResetName() {
	m.name = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *BrandConfigMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *BrandConfigMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the BrandConfig entity.
// If the BrandConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandConfigMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *BrandConfigMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[brandconfig.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *BrandConfigMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[brandconfig.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *BrandConfigMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, brandconfig.FieldLogoURL)
}

// SetColors sets the "colors" field.
func (m *BrandConfigMutation) SetColors(value map[string]string) {
	m.colors = &value
}

// Colors returns the value of the "colors" field in the mutation.
func (m *BrandConfigMutation) Colors() (r map[string]string, exists bool) {
	v := m.colors
	if v == nil {
		return
	}
	return *v, true
}

// OldColors returns the old "colors" field's value of the BrandConfig entity.
// If the BrandConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandConfigMutation) OldColors(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColors: %w", err)
	}
	return oldValue.Colors, nil
}

// ResetColors resets all changes to the "colors" field.
func (m *BrandConfigMutation) ResetColors() {
	m.colors = nil
}

// SetContact sets the "contact" field.
func (m *BrandConfigMutation) SetContact(value map[string]string) {
	m.contact = &value
}

// Contact returns the value of the "contact" field in the mutation.
func (m *BrandConfigMutation) Contact() (r map[string]string, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the BrandConfig entity.
// If the BrandConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandConfigMutation) OldContact(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ResetContact resets all changes to the "contact" field.
func (m *BrandConfigMutation) ResetContact() {
	m.contact = nil
}

// SetSocial sets the "social" field.
func (m *BrandConfigMutation) SetSocial(value map[string]string) {
	m.social = &value
}

// Social returns the value of the "social" field in the mutation.
func (m *BrandConfigMutation) Social() (r map[string]string, exists bool) {
	v := m.social
	if v == nil {
		return
	}
	return *v, true
}

// OldSocial returns the old "social" field's value of the BrandConfig entity.
// If the BrandConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandConfigMutation) OldSocial(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocial: %w", err)
	}
	return oldValue.Social, nil
}

// ResetSocial resets all changes to the "social" field.
func (m *BrandConfigMutation) ResetSocial() {
	m.social = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BrandConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BrandConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BrandConfig entity.
// If the BrandConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BrandConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the BrandConfigMutation builder.
func (m *BrandConfigMutation) Where(ps ...predicate.BrandConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BrandConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BrandConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BrandConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BrandConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BrandConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BrandConfig).
func (m *BrandConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BrandConfigMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.singleton != nil {
		fields = append(fields, brandconfig.FieldSingleton)
	}
	if m.name != nil {
		fields = append(fields, brandconfig.FieldName)
	}
	if m.logo_url != nil {
		fields = append(fields, brandconfig.FieldLogoURL)
	}
	if m.colors != nil {
		fields = append(fields, brandconfig.FieldColors)
	}
	if m.contact != nil {
		fields = append(fields, brandconfig.FieldContact)
	}
	if m.social != nil {
		fields = append(fields, brandconfig.FieldSocial)
	}
	if m.updated_at != nil {
		fields = append(fields, brandconfig.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BrandConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case brandconfig.FieldSingleton:
		return m.Singleton()
	case brandconfig.FieldName:
		return m.Name()
	case brandconfig.FieldLogoURL:
		return m.LogoURL()
	case brandconfig.FieldColors:
		return m.Colors()
	case brandconfig.FieldContact:
		return m.Contact()
	case brandconfig.FieldSocial:
		return m.Social()
	case brandconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BrandConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case brandconfig.FieldSingleton:
		return m.OldSingleton(ctx)
	case brandconfig.FieldName:
		return m.OldName(ctx)
	case brandconfig.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case brandconfig.FieldColors:
		return m.OldColors(ctx)
	case brandconfig.FieldContact:
		return m.OldContact(ctx)
	case brandconfig.FieldSocial:
		return m.OldSocial(ctx)
	case brandconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BrandConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case brandconfig.FieldSingleton:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSingleton(v)
		return nil
	case brandconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case brandconfig.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case brandconfig.FieldColors:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColors(v)
		return nil
	case brandconfig.FieldContact:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case brandconfig.FieldSocial:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocial(v)
		return nil
	case brandconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BrandConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BrandConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BrandConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BrandConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BrandConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(brandconfig.FieldLogoURL) {
		fields = append(fields, brandconfig.FieldLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BrandConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BrandConfigMutation) ClearField(name string) error {
	switch name {
	case brandconfig.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	}
	return fmt.Errorf("unknown BrandConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BrandConfigMutation) ResetField(name string) error {
	switch name {
	case brandconfig.FieldSingleton:
		m.ResetSingleton()
		return nil
	case brandconfig.FieldName:
		m.ResetName()
		return nil
	case brandconfig.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case brandconfig.FieldColors:
		m.ResetColors()
		return nil
	case brandconfig.FieldContact:
		m.ResetContact()
		return nil
	case brandconfig.FieldSocial:
		m.ResetSocial()
		return nil
	case brandconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BrandConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BrandConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BrandConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BrandConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BrandConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BrandConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BrandConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BrandConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BrandConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BrandConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BrandConfig edge %s", name)
}

// ContentBlockMutation represents an operation that mutates the ContentBlock nodes in the graph.
type ContentBlockMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	_order                         *int
	add_order                      *int
	block_type                     *contentblock.BlockType
	_config                        *map[string]interface{}
	is_visible                     *bool
	hide_on_mobile                 *bool
	hide_on_tablet                 *bool
	hide_on_desktop                *bool
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	page                           *int
	clearedpage                    bool
	block_hero                     *int
	clearedblock_hero              bool
	block_text_content             *int
	clearedblock_text_content      bool
	block_faq                      *int
	clearedblock_faq               bool
	block_cta                      *int
	clearedblock_cta               bool
	block_testimonials             *int
	clearedblock_testimonials      bool
	block_stats                    *int
	clearedblock_stats             bool
	block_gallery                  *int
	clearedblock_gallery           bool
	block_program_cards            *int
	clearedblock_program_cards     bool
	block_success_stories          *int
	clearedblock_success_stories   bool
	block_donation_form            *int
	clearedblock_donation_form     bool
	block_volunteer_signup         *int
	clearedblock_volunteer_signup  bool
	block_newsletter_signup        *int
	clearedblock_newsletter_signup bool
	block_partner_logos            *int
	clearedblock_partner_logos     bool
	block_team_grid                *int
	clearedblock_team_grid         bool
	block_timeline                 *int
	clearedblock_timeline          bool
	block_contact_form             *int
	clearedblock_contact_form      bool
	block_video_embed              *int
	clearedblock_video_embed       bool
	block_map                      *int
	clearedblock_map               bool
	block_accordion                *int
	clearedblock_accordion         bool
	block_tabs                     *int
	clearedblock_tabs              bool
	block_divider                  *int
	clearedblock_divider           bool
	done                           bool
	oldValue                       func(context.Context) (*ContentBlock, error)
	predicates                     []predicate.ContentBlock
}

var _ ent.Mutation = (*ContentBlockMutation)(nil)

// contentblockOption allows management of the mutation configuration using functional options.
type contentblockOption func(*ContentBlockMutation)

// newContentBlockMutation creates new mutation for the ContentBlock entity.
func newContentBlockMutation(c config, op Op, opts ...contentblockOption) *ContentBlockMutation {
	m := &ContentBlockMutation{
		config:        c,
		op:            op,
		typ:           TypeContentBlock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContentBlockID sets the ID field of the mutation.
func withContentBlockID(id int) contentblockOption {
	return func(m *ContentBlockMutation) {
		var (
			err   error
			once  sync.Once
			value *ContentBlock
		)
		m.oldValue = func(ctx context.Context) (*ContentBlock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContentBlock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContentBlock sets the old ContentBlock of the mutation.
func withContentBlock(node *ContentBlock) contentblockOption {
	return func(m *ContentBlockMutation) {
		m.oldValue = func(context.Context) (*ContentBlock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContentBlockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContentBlockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContentBlockMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContentBlockMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContentBlock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *ContentBlockMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *ContentBlockMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the ContentBlock entity.
// If the ContentBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentBlockMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *ContentBlockMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *ContentBlockMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *ContentBlockMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetBlockType sets the "block_type" field.
func (m *ContentBlockMutation) SetBlockType(ct contentblock.BlockType) {
	m.block_type = &ct
}

// BlockType returns the value of the "block_type" field in the mutation.
func (m *ContentBlockMutation) BlockType() (r contentblock.BlockType, exists bool) {
	v := m.block_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockType returns the old "block_type" field's value of the ContentBlock entity.
// If the ContentBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentBlockMutation) OldBlockType(ctx context.Context) (v contentblock.BlockType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockType: %w", err)
	}
	return oldValue.BlockType, nil
}

// ResetBlockType resets all changes to the "block_type" field.
func (m *ContentBlockMutation) ResetBlockType() {
	m.block_type = nil
}

// SetConfig sets the "config" field.
func (m *ContentBlockMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *ContentBlockMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the ContentBlock entity.
// If the ContentBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentBlockMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *ContentBlockMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[contentblock.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *ContentBlockMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[contentblock.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *ContentBlockMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, contentblock.FieldConfig)
}

// SetIsVisible sets the "is_visible" field.
func (m *ContentBlockMutation) SetIsVisible(b bool) {
	m.is_visible = &b
}

// IsVisible returns the value of the "is_visible" field in the mutation.
func (m *ContentBlockMutation) IsVisible() (r bool, exists bool) {
	v := m.is_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVisible returns the old "is_visible" field's value of the ContentBlock entity.
// If the ContentBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentBlockMutation) OldIsVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVisible: %w", err)
	}
	return oldValue.IsVisible, nil
}

// ResetIsVisible resets all changes to the "is_visible" field.
func (m *ContentBlockMutation) ResetIsVisible() {
	m.is_visible = nil
}

// SetHideOnMobile sets the "hide_on_mobile" field.
func (m *ContentBlockMutation) SetHideOnMobile(b bool) {
	m.hide_on_mobile = &b
}

// HideOnMobile returns the value of the "hide_on_mobile" field in the mutation.
func (m *ContentBlockMutation) HideOnMobile() (r bool, exists bool) {
	v := m.hide_on_mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldHideOnMobile returns the old "hide_on_mobile" field's value of the ContentBlock entity.
// If the ContentBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentBlockMutation) OldHideOnMobile(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideOnMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideOnMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideOnMobile: %w", err)
	}
	return oldValue.HideOnMobile, nil
}

// ResetHideOnMobile resets all changes to the "hide_on_mobile" field.
func (m *ContentBlockMutation) ResetHideOnMobile() {
	m.hide_on_mobile = nil
}

// SetHideOnTablet sets the "hide_on_tablet" field.
func (m *ContentBlockMutation) SetHideOnTablet(b bool) {
	m.hide_on_tablet = &b
}

// HideOnTablet returns the value of the "hide_on_tablet" field in the mutation.
func (m *ContentBlockMutation) HideOnTablet() (r bool, exists bool) {
	v := m.hide_on_tablet
	if v == nil {
		return
	}
	return *v, true
}

// OldHideOnTablet returns the old "hide_on_tablet" field's value of the ContentBlock entity.
// If the ContentBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentBlockMutation) OldHideOnTablet(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideOnTablet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideOnTablet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideOnTablet: %w", err)
	}
	return oldValue.HideOnTablet, nil
}

// ResetHideOnTablet resets all changes to the "hide_on_tablet" field.
func (m *ContentBlockMutation) ResetHideOnTablet() {
	m.hide_on_tablet = nil
}

// SetHideOnDesktop sets the "hide_on_desktop" field.
func (m *ContentBlockMutation) SetHideOnDesktop(b bool) {
	m.hide_on_desktop = &b
}

// HideOnDesktop returns the value of the "hide_on_desktop" field in the mutation.
func (m *ContentBlockMutation) HideOnDesktop() (r bool, exists bool) {
	v := m.hide_on_desktop
	if v == nil {
		return
	}
	return *v, true
}

// OldHideOnDesktop returns the old "hide_on_desktop" field's value of the ContentBlock entity.
// If the ContentBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentBlockMutation) OldHideOnDesktop(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideOnDesktop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideOnDesktop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideOnDesktop: %w", err)
	}
	return oldValue.HideOnDesktop, nil
}

// ResetHideOnDesktop resets all changes to the "hide_on_desktop" field.
func (m *ContentBlockMutation) ResetHideOnDesktop() {
	m.hide_on_desktop = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ContentBlockMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContentBlockMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ContentBlock entity.
// If the ContentBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentBlockMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContentBlockMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContentBlockMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContentBlockMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ContentBlock entity.
// If the ContentBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentBlockMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContentBlockMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPageID sets the "page" edge to the Page entity by id.
func (m *ContentBlockMutation) SetPageID(id int) {
	m.page = &id
}

// ClearPage clears the "page" edge to the Page entity.
func (m *ContentBlockMutation) ClearPage() {
	m.clearedpage = true
}

// PageCleared reports if the "page" edge to the Page entity was cleared.
func (m *ContentBlockMutation) PageCleared() bool {
	return m.clearedpage
}

// PageID returns the "page" edge ID in the mutation.
func (m *ContentBlockMutation) PageID() (id int, exists bool) {
	if m.page != nil {
		return *m.page, true
	}
	return
}

// PageIDs returns the "page" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PageID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) PageIDs() (ids []int) {
	if id := m.page; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPage resets all changes to the "page" edge.
func (m *ContentBlockMutation) ResetPage() {
	m.page = nil
	m.clearedpage = false
}

// SetBlockHeroID sets the "block_hero" edge to the BlockHero entity by id.
func (m *ContentBlockMutation) SetBlockHeroID(id int) {
	m.block_hero = &id
}

// ClearBlockHero clears the "block_hero" edge to the BlockHero entity.
func (m *ContentBlockMutation) ClearBlockHero() {
	m.clearedblock_hero = true
}

// BlockHeroCleared reports if the "block_hero" edge to the BlockHero entity was cleared.
func (m *ContentBlockMutation) BlockHeroCleared() bool {
	return m.clearedblock_hero
}

// BlockHeroID returns the "block_hero" edge ID in the mutation.
func (m *ContentBlockMutation) BlockHeroID() (id int, exists bool) {
	if m.block_hero != nil {
		return *m.block_hero, true
	}
	return
}

// BlockHeroIDs returns the "block_hero" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockHeroID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockHeroIDs() (ids []int) {
	if id := m.block_hero; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockHero resets all changes to the "block_hero" edge.
func (m *ContentBlockMutation) ResetBlockHero() {
	m.block_hero = nil
	m.clearedblock_hero = false
}

// SetBlockTextContentID sets the "block_text_content" edge to the BlockTextContent entity by id.
func (m *ContentBlockMutation) SetBlockTextContentID(id int) {
	m.block_text_content = &id
}

// ClearBlockTextContent clears the "block_text_content" edge to the BlockTextContent entity.
func (m *ContentBlockMutation) ClearBlockTextContent() {
	m.clearedblock_text_content = true
}

// BlockTextContentCleared reports if the "block_text_content" edge to the BlockTextContent entity was cleared.
func (m *ContentBlockMutation) BlockTextContentCleared() bool {
	return m.clearedblock_text_content
}

// BlockTextContentID returns the "block_text_content" edge ID in the mutation.
func (m *ContentBlockMutation) BlockTextContentID() (id int, exists bool) {
	if m.block_text_content != nil {
		return *m.block_text_content, true
	}
	return
}

// BlockTextContentIDs returns the "block_text_content" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockTextContentID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockTextContentIDs() (ids []int) {
	if id := m.block_text_content; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockTextContent resets all changes to the "block_text_content" edge.
func (m *ContentBlockMutation) ResetBlockTextContent() {
	m.block_text_content = nil
	m.clearedblock_text_content = false
}

// SetBlockFaqID sets the "block_faq" edge to the BlockFaq entity by id.
func (m *ContentBlockMutation) SetBlockFaqID(id int) {
	m.block_faq = &id
}

// ClearBlockFaq clears the "block_faq" edge to the BlockFaq entity.
func (m *ContentBlockMutation) ClearBlockFaq() {
	m.clearedblock_faq = true
}

// BlockFaqCleared reports if the "block_faq" edge to the BlockFaq entity was cleared.
func (m *ContentBlockMutation) BlockFaqCleared() bool {
	return m.clearedblock_faq
}

// BlockFaqID returns the "block_faq" edge ID in the mutation.
func (m *ContentBlockMutation) BlockFaqID() (id int, exists bool) {
	if m.block_faq != nil {
		return *m.block_faq, true
	}
	return
}

// BlockFaqIDs returns the "block_faq" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockFaqID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockFaqIDs() (ids []int) {
	if id := m.block_faq; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockFaq resets all changes to the "block_faq" edge.
func (m *ContentBlockMutation) ResetBlockFaq() {
	m.block_faq = nil
	m.clearedblock_faq = false
}

// SetBlockCtaID sets the "block_cta" edge to the BlockCta entity by id.
func (m *ContentBlockMutation) SetBlockCtaID(id int) {
	m.block_cta = &id
}

// ClearBlockCta clears the "block_cta" edge to the BlockCta entity.
func (m *ContentBlockMutation) ClearBlockCta() {
	m.clearedblock_cta = true
}

// BlockCtaCleared reports if the "block_cta" edge to the BlockCta entity was cleared.
func (m *ContentBlockMutation) BlockCtaCleared() bool {
	return m.clearedblock_cta
}

// BlockCtaID returns the "block_cta" edge ID in the mutation.
func (m *ContentBlockMutation) BlockCtaID() (id int, exists bool) {
	if m.block_cta != nil {
		return *m.block_cta, true
	}
	return
}

// BlockCtaIDs returns the "block_cta" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockCtaID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockCtaIDs() (ids []int) {
	if id := m.block_cta; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockCta resets all changes to the "block_cta" edge.
func (m *ContentBlockMutation) ResetBlockCta() {
	m.block_cta = nil
	m.clearedblock_cta = false
}

// SetBlockTestimonialsID sets the "block_testimonials" edge to the BlockTestimonials entity by id.
func (m *ContentBlockMutation) SetBlockTestimonialsID(id int) {
	m.block_testimonials = &id
}

// ClearBlockTestimonials clears the "block_testimonials" edge to the BlockTestimonials entity.
func (m *ContentBlockMutation) ClearBlockTestimonials() {
	m.clearedblock_testimonials = true
}

// BlockTestimonialsCleared reports if the "block_testimonials" edge to the BlockTestimonials entity was cleared.
func (m *ContentBlockMutation) BlockTestimonialsCleared() bool {
	return m.clearedblock_testimonials
}

// BlockTestimonialsID returns the "block_testimonials" edge ID in the mutation.
func (m *ContentBlockMutation) BlockTestimonialsID() (id int, exists bool) {
	if m.block_testimonials != nil {
		return *m.block_testimonials, true
	}
	return
}

// BlockTestimonialsIDs returns the "block_testimonials" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockTestimonialsID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockTestimonialsIDs() (ids []int) {
	if id := m.block_testimonials; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockTestimonials resets all changes to the "block_testimonials" edge.
func (m *ContentBlockMutation) ResetBlockTestimonials() {
	m.block_testimonials = nil
	m.clearedblock_testimonials = false
}

// SetBlockStatsID sets the "block_stats" edge to the BlockStats entity by id.
func (m *ContentBlockMutation) SetBlockStatsID(id int) {
	m.block_stats = &id
}

// ClearBlockStats clears the "block_stats" edge to the BlockStats entity.
func (m *ContentBlockMutation) ClearBlockStats() {
	m.clearedblock_stats = true
}

// BlockStatsCleared reports if the "block_stats" edge to the BlockStats entity was cleared.
func (m *ContentBlockMutation) BlockStatsCleared() bool {
	return m.clearedblock_stats
}

// BlockStatsID returns the "block_stats" edge ID in the mutation.
func (m *ContentBlockMutation) BlockStatsID() (id int, exists bool) {
	if m.block_stats != nil {
		return *m.block_stats, true
	}
	return
}

// BlockStatsIDs returns the "block_stats" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockStatsID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockStatsIDs() (ids []int) {
	if id := m.block_stats; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockStats resets all changes to the "block_stats" edge.
func (m *ContentBlockMutation) ResetBlockStats() {
	m.block_stats = nil
	m.clearedblock_stats = false
}

// SetBlockGalleryID sets the "block_gallery" edge to the BlockGallery entity by id.
func (m *ContentBlockMutation) SetBlockGalleryID(id int) {
	m.block_gallery = &id
}

// ClearBlockGallery clears the "block_gallery" edge to the BlockGallery entity.
func (m *ContentBlockMutation) ClearBlockGallery() {
	m.clearedblock_gallery = true
}

// BlockGalleryCleared reports if the "block_gallery" edge to the BlockGallery entity was cleared.
func (m *ContentBlockMutation) BlockGalleryCleared() bool {
	return m.clearedblock_gallery
}

// BlockGalleryID returns the "block_gallery" edge ID in the mutation.
func (m *ContentBlockMutation) BlockGalleryID() (id int, exists bool) {
	if m.block_gallery != nil {
		return *m.block_gallery, true
	}
	return
}

// BlockGalleryIDs returns the "block_gallery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockGalleryID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockGalleryIDs() (ids []int) {
	if id := m.block_gallery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockGallery resets all changes to the "block_gallery" edge.
func (m *ContentBlockMutation) ResetBlockGallery() {
	m.block_gallery = nil
	m.clearedblock_gallery = false
}

// SetBlockProgramCardsID sets the "block_program_cards" edge to the BlockProgramCards entity by id.
func (m *ContentBlockMutation) SetBlockProgramCardsID(id int) {
	m.block_program_cards = &id
}

// ClearBlockProgramCards clears the "block_program_cards" edge to the BlockProgramCards entity.
func (m *ContentBlockMutation) ClearBlockProgramCards() {
	m.clearedblock_program_cards = true
}

// BlockProgramCardsCleared reports if the "block_program_cards" edge to the BlockProgramCards entity was cleared.
func (m *ContentBlockMutation) BlockProgramCardsCleared() bool {
	return m.clearedblock_program_cards
}

// BlockProgramCardsID returns the "block_program_cards" edge ID in the mutation.
func (m *ContentBlockMutation) BlockProgramCardsID() (id int, exists bool) {
	if m.block_program_cards != nil {
		return *m.block_program_cards, true
	}
	return
}

// BlockProgramCardsIDs returns the "block_program_cards" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockProgramCardsID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockProgramCardsIDs() (ids []int) {
	if id := m.block_program_cards; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockProgramCards resets all changes to the "block_program_cards" edge.
func (m *ContentBlockMutation) ResetBlockProgramCards() {
	m.block_program_cards = nil
	m.clearedblock_program_cards = false
}

// SetBlockSuccessStoriesID sets the "block_success_stories" edge to the BlockSuccessStories entity by id.
func (m *ContentBlockMutation) SetBlockSuccessStoriesID(id int) {
	m.block_success_stories = &id
}

// ClearBlockSuccessStories clears the "block_success_stories" edge to the BlockSuccessStories entity.
func (m *ContentBlockMutation) ClearBlockSuccessStories() {
	m.clearedblock_success_stories = true
}

// BlockSuccessStoriesCleared reports if the "block_success_stories" edge to the BlockSuccessStories entity was cleared.
func (m *ContentBlockMutation) BlockSuccessStoriesCleared() bool {
	return m.clearedblock_success_stories
}

// BlockSuccessStoriesID returns the "block_success_stories" edge ID in the mutation.
func (m *ContentBlockMutation) BlockSuccessStoriesID() (id int, exists bool) {
	if m.block_success_stories != nil {
		return *m.block_success_stories, true
	}
	return
}

// BlockSuccessStoriesIDs returns the "block_success_stories" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockSuccessStoriesID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockSuccessStoriesIDs() (ids []int) {
	if id := m.block_success_stories; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockSuccessStories resets all changes to the "block_success_stories" edge.
func (m *ContentBlockMutation) ResetBlockSuccessStories() {
	m.block_success_stories = nil
	m.clearedblock_success_stories = false
}

// SetBlockDonationFormID sets the "block_donation_form" edge to the BlockDonationForm entity by id.
func (m *ContentBlockMutation) SetBlockDonationFormID(id int) {
	m.block_donation_form = &id
}

// ClearBlockDonationForm clears the "block_donation_form" edge to the BlockDonationForm entity.
func (m *ContentBlockMutation) ClearBlockDonationForm() {
	m.clearedblock_donation_form = true
}

// BlockDonationFormCleared reports if the "block_donation_form" edge to the BlockDonationForm entity was cleared.
func (m *ContentBlockMutation) BlockDonationFormCleared() bool {
	return m.clearedblock_donation_form
}

// BlockDonationFormID returns the "block_donation_form" edge ID in the mutation.
func (m *ContentBlockMutation) BlockDonationFormID() (id int, exists bool) {
	if m.block_donation_form != nil {
		return *m.block_donation_form, true
	}
	return
}

// BlockDonationFormIDs returns the "block_donation_form" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockDonationFormID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockDonationFormIDs() (ids []int) {
	if id := m.block_donation_form; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockDonationForm resets all changes to the "block_donation_form" edge.
func (m *ContentBlockMutation) ResetBlockDonationForm() {
	m.block_donation_form = nil
	m.clearedblock_donation_form = false
}

// SetBlockVolunteerSignupID sets the "block_volunteer_signup" edge to the BlockVolunteerSignup entity by id.
func (m *ContentBlockMutation) SetBlockVolunteerSignupID(id int) {
	m.block_volunteer_signup = &id
}

// ClearBlockVolunteerSignup clears the "block_volunteer_signup" edge to the BlockVolunteerSignup entity.
func (m *ContentBlockMutation) ClearBlockVolunteerSignup() {
	m.clearedblock_volunteer_signup = true
}

// BlockVolunteerSignupCleared reports if the "block_volunteer_signup" edge to the BlockVolunteerSignup entity was cleared.
func (m *ContentBlockMutation) BlockVolunteerSignupCleared() bool {
	return m.clearedblock_volunteer_signup
}

// BlockVolunteerSignupID returns the "block_volunteer_signup" edge ID in the mutation.
func (m *ContentBlockMutation) BlockVolunteerSignupID() (id int, exists bool) {
	if m.block_volunteer_signup != nil {
		return *m.block_volunteer_signup, true
	}
	return
}

// BlockVolunteerSignupIDs returns the "block_volunteer_signup" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockVolunteerSignupID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockVolunteerSignupIDs() (ids []int) {
	if id := m.block_volunteer_signup; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockVolunteerSignup resets all changes to the "block_volunteer_signup" edge.
func (m *ContentBlockMutation) ResetBlockVolunteerSignup() {
	m.block_volunteer_signup = nil
	m.clearedblock_volunteer_signup = false
}

// SetBlockNewsletterSignupID sets the "block_newsletter_signup" edge to the BlockNewsletterSignup entity by id.
func (m *ContentBlockMutation) SetBlockNewsletterSignupID(id int) {
	m.block_newsletter_signup = &id
}

// ClearBlockNewsletterSignup clears the "block_newsletter_signup" edge to the BlockNewsletterSignup entity.
func (m *ContentBlockMutation) ClearBlockNewsletterSignup() {
	m.clearedblock_newsletter_signup = true
}

// BlockNewsletterSignupCleared reports if the "block_newsletter_signup" edge to the BlockNewsletterSignup entity was cleared.
func (m *ContentBlockMutation) BlockNewsletterSignupCleared() bool {
	return m.clearedblock_newsletter_signup
}

// BlockNewsletterSignupID returns the "block_newsletter_signup" edge ID in the mutation.
func (m *ContentBlockMutation) BlockNewsletterSignupID() (id int, exists bool) {
	if m.block_newsletter_signup != nil {
		return *m.block_newsletter_signup, true
	}
	return
}

// BlockNewsletterSignupIDs returns the "block_newsletter_signup" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockNewsletterSignupID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockNewsletterSignupIDs() (ids []int) {
	if id := m.block_newsletter_signup; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockNewsletterSignup resets all changes to the "block_newsletter_signup" edge.
func (m *ContentBlockMutation) ResetBlockNewsletterSignup() {
	m.block_newsletter_signup = nil
	m.clearedblock_newsletter_signup = false
}

// SetBlockPartnerLogosID sets the "block_partner_logos" edge to the BlockPartnerLogos entity by id.
func (m *ContentBlockMutation) SetBlockPartnerLogosID(id int) {
	m.block_partner_logos = &id
}

// ClearBlockPartnerLogos clears the "block_partner_logos" edge to the BlockPartnerLogos entity.
func (m *ContentBlockMutation) ClearBlockPartnerLogos() {
	m.clearedblock_partner_logos = true
}

// BlockPartnerLogosCleared reports if the "block_partner_logos" edge to the BlockPartnerLogos entity was cleared.
func (m *ContentBlockMutation) BlockPartnerLogosCleared() bool {
	return m.clearedblock_partner_logos
}

// BlockPartnerLogosID returns the "block_partner_logos" edge ID in the mutation.
func (m *ContentBlockMutation) BlockPartnerLogosID() (id int, exists bool) {
	if m.block_partner_logos != nil {
		return *m.block_partner_logos, true
	}
	return
}

// BlockPartnerLogosIDs returns the "block_partner_logos" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockPartnerLogosID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockPartnerLogosIDs() (ids []int) {
	if id := m.block_partner_logos; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockPartnerLogos resets all changes to the "block_partner_logos" edge.
func (m *ContentBlockMutation) ResetBlockPartnerLogos() {
	m.block_partner_logos = nil
	m.clearedblock_partner_logos = false
}

// SetBlockTeamGridID sets the "block_team_grid" edge to the BlockTeamGrid entity by id.
func (m *ContentBlockMutation) SetBlockTeamGridID(id int) {
	m.block_team_grid = &id
}

// ClearBlockTeamGrid clears the "block_team_grid" edge to the BlockTeamGrid entity.
func (m *ContentBlockMutation) ClearBlockTeamGrid() {
	m.clearedblock_team_grid = true
}

// BlockTeamGridCleared reports if the "block_team_grid" edge to the BlockTeamGrid entity was cleared.
func (m *ContentBlockMutation) BlockTeamGridCleared() bool {
	return m.clearedblock_team_grid
}

// BlockTeamGridID returns the "block_team_grid" edge ID in the mutation.
func (m *ContentBlockMutation) BlockTeamGridID() (id int, exists bool) {
	if m.block_team_grid != nil {
		return *m.block_team_grid, true
	}
	return
}

// BlockTeamGridIDs returns the "block_team_grid" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockTeamGridID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockTeamGridIDs() (ids []int) {
	if id := m.block_team_grid; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockTeamGrid resets all changes to the "block_team_grid" edge.
func (m *ContentBlockMutation) ResetBlockTeamGrid() {
	m.block_team_grid = nil
	m.clearedblock_team_grid = false
}

// SetBlockTimelineID sets the "block_timeline" edge to the BlockTimeline entity by id.
func (m *ContentBlockMutation) SetBlockTimelineID(id int) {
	m.block_timeline = &id
}

// ClearBlockTimeline clears the "block_timeline" edge to the BlockTimeline entity.
func (m *ContentBlockMutation) ClearBlockTimeline() {
	m.clearedblock_timeline = true
}

// BlockTimelineCleared reports if the "block_timeline" edge to the BlockTimeline entity was cleared.
func (m *ContentBlockMutation) BlockTimelineCleared() bool {
	return m.clearedblock_timeline
}

// BlockTimelineID returns the "block_timeline" edge ID in the mutation.
func (m *ContentBlockMutation) BlockTimelineID() (id int, exists bool) {
	if m.block_timeline != nil {
		return *m.block_timeline, true
	}
	return
}

// BlockTimelineIDs returns the "block_timeline" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockTimelineID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockTimelineIDs() (ids []int) {
	if id := m.block_timeline; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockTimeline resets all changes to the "block_timeline" edge.
func (m *ContentBlockMutation) ResetBlockTimeline() {
	m.block_timeline = nil
	m.clearedblock_timeline = false
}

// SetBlockContactFormID sets the "block_contact_form" edge to the BlockContactForm entity by id.
func (m *ContentBlockMutation) SetBlockContactFormID(id int) {
	m.block_contact_form = &id
}

// ClearBlockContactForm clears the "block_contact_form" edge to the BlockContactForm entity.
func (m *ContentBlockMutation) ClearBlockContactForm() {
	m.clearedblock_contact_form = true
}

// BlockContactFormCleared reports if the "block_contact_form" edge to the BlockContactForm entity was cleared.
func (m *ContentBlockMutation) BlockContactFormCleared() bool {
	return m.clearedblock_contact_form
}

// BlockContactFormID returns the "block_contact_form" edge ID in the mutation.
func (m *ContentBlockMutation) BlockContactFormID() (id int, exists bool) {
	if m.block_contact_form != nil {
		return *m.block_contact_form, true
	}
	return
}

// BlockContactFormIDs returns the "block_contact_form" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockContactFormID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockContactFormIDs() (ids []int) {
	if id := m.block_contact_form; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockContactForm resets all changes to the "block_contact_form" edge.
func (m *ContentBlockMutation) ResetBlockContactForm() {
	m.block_contact_form = nil
	m.clearedblock_contact_form = false
}

// SetBlockVideoEmbedID sets the "block_video_embed" edge to the BlockVideoEmbed entity by id.
func (m *ContentBlockMutation) SetBlockVideoEmbedID(id int) {
	m.block_video_embed = &id
}

// ClearBlockVideoEmbed clears the "block_video_embed" edge to the BlockVideoEmbed entity.
func (m *ContentBlockMutation) ClearBlockVideoEmbed() {
	m.clearedblock_video_embed = true
}

// BlockVideoEmbedCleared reports if the "block_video_embed" edge to the BlockVideoEmbed entity was cleared.
func (m *ContentBlockMutation) BlockVideoEmbedCleared() bool {
	return m.clearedblock_video_embed
}

// BlockVideoEmbedID returns the "block_video_embed" edge ID in the mutation.
func (m *ContentBlockMutation) BlockVideoEmbedID() (id int, exists bool) {
	if m.block_video_embed != nil {
		return *m.block_video_embed, true
	}
	return
}

// BlockVideoEmbedIDs returns the "block_video_embed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockVideoEmbedID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockVideoEmbedIDs() (ids []int) {
	if id := m.block_video_embed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockVideoEmbed resets all changes to the "block_video_embed" edge.
func (m *ContentBlockMutation) ResetBlockVideoEmbed() {
	m.block_video_embed = nil
	m.clearedblock_video_embed = false
}

// SetBlockMapID sets the "block_map" edge to the BlockMap entity by id.
func (m *ContentBlockMutation) SetBlockMapID(id int) {
	m.block_map = &id
}

// ClearBlockMap clears the "block_map" edge to the BlockMap entity.
func (m *ContentBlockMutation) ClearBlockMap() {
	m.clearedblock_map = true
}

// BlockMapCleared reports if the "block_map" edge to the BlockMap entity was cleared.
func (m *ContentBlockMutation) BlockMapCleared() bool {
	return m.clearedblock_map
}

// BlockMapID returns the "block_map" edge ID in the mutation.
func (m *ContentBlockMutation) BlockMapID() (id int, exists bool) {
	if m.block_map != nil {
		return *m.block_map, true
	}
	return
}

// BlockMapIDs returns the "block_map" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockMapID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockMapIDs() (ids []int) {
	if id := m.block_map; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockMap resets all changes to the "block_map" edge.
func (m *ContentBlockMutation) ResetBlockMap() {
	m.block_map = nil
	m.clearedblock_map = false
}

// SetBlockAccordionID sets the "block_accordion" edge to the BlockAccordion entity by id.
func (m *ContentBlockMutation) SetBlockAccordionID(id int) {
	m.block_accordion = &id
}

// ClearBlockAccordion clears the "block_accordion" edge to the BlockAccordion entity.
func (m *ContentBlockMutation) ClearBlockAccordion() {
	m.clearedblock_accordion = true
}

// BlockAccordionCleared reports if the "block_accordion" edge to the BlockAccordion entity was cleared.
func (m *ContentBlockMutation) BlockAccordionCleared() bool {
	return m.clearedblock_accordion
}

// BlockAccordionID returns the "block_accordion" edge ID in the mutation.
func (m *ContentBlockMutation) BlockAccordionID() (id int, exists bool) {
	if m.block_accordion != nil {
		return *m.block_accordion, true
	}
	return
}

// BlockAccordionIDs returns the "block_accordion" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockAccordionID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockAccordionIDs() (ids []int) {
	if id := m.block_accordion; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockAccordion resets all changes to the "block_accordion" edge.
func (m *ContentBlockMutation) ResetBlockAccordion() {
	m.block_accordion = nil
	m.clearedblock_accordion = false
}

// SetBlockTabsID sets the "block_tabs" edge to the BlockTabs entity by id.
func (m *ContentBlockMutation) SetBlockTabsID(id int) {
	m.block_tabs = &id
}

// ClearBlockTabs clears the "block_tabs" edge to the BlockTabs entity.
func (m *ContentBlockMutation) ClearBlockTabs() {
	m.clearedblock_tabs = true
}

// BlockTabsCleared reports if the "block_tabs" edge to the BlockTabs entity was cleared.
func (m *ContentBlockMutation) BlockTabsCleared() bool {
	return m.clearedblock_tabs
}

// BlockTabsID returns the "block_tabs" edge ID in the mutation.
func (m *ContentBlockMutation) BlockTabsID() (id int, exists bool) {
	if m.block_tabs != nil {
		return *m.block_tabs, true
	}
	return
}

// BlockTabsIDs returns the "block_tabs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockTabsID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockTabsIDs() (ids []int) {
	if id := m.block_tabs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockTabs resets all changes to the "block_tabs" edge.
func (m *ContentBlockMutation) ResetBlockTabs() {
	m.block_tabs = nil
	m.clearedblock_tabs = false
}

// SetBlockDividerID sets the "block_divider" edge to the BlockDivider entity by id.
func (m *ContentBlockMutation) SetBlockDividerID(id int) {
	m.block_divider = &id
}

// ClearBlockDivider clears the "block_divider" edge to the BlockDivider entity.
func (m *ContentBlockMutation) ClearBlockDivider() {
	m.clearedblock_divider = true
}

// BlockDividerCleared reports if the "block_divider" edge to the BlockDivider entity was cleared.
func (m *ContentBlockMutation) BlockDividerCleared() bool {
	return m.clearedblock_divider
}

// BlockDividerID returns the "block_divider" edge ID in the mutation.
func (m *ContentBlockMutation) BlockDividerID() (id int, exists bool) {
	if m.block_divider != nil {
		return *m.block_divider, true
	}
	return
}

// BlockDividerIDs returns the "block_divider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockDividerID instead. It exists only for internal usage by the builders.
func (m *ContentBlockMutation) BlockDividerIDs() (ids []int) {
	if id := m.block_divider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockDivider resets all changes to the "block_divider" edge.
func (m *ContentBlockMutation) ResetBlockDivider() {
	m.block_divider = nil
	m.clearedblock_divider = false
}

// Where appends a list predicates to the ContentBlockMutation builder.
func (m *ContentBlockMutation) Where(ps ...predicate.ContentBlock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContentBlockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContentBlockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContentBlock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContentBlockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContentBlockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContentBlock).
func (m *ContentBlockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContentBlockMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._order != nil {
		fields = append(fields, contentblock.FieldOrder)
	}
	if m.block_type != nil {
		fields = append(fields, contentblock.FieldBlockType)
	}
	if m._config != nil {
		fields = append(fields, contentblock.FieldConfig)
	}
	if m.is_visible != nil {
		fields = append(fields, contentblock.FieldIsVisible)
	}
	if m.hide_on_mobile != nil {
		fields = append(fields, contentblock.FieldHideOnMobile)
	}
	if m.hide_on_tablet != nil {
		fields = append(fields, contentblock.FieldHideOnTablet)
	}
	if m.hide_on_desktop != nil {
		fields = append(fields, contentblock.FieldHideOnDesktop)
	}
	if m.created_at != nil {
		fields = append(fields, contentblock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contentblock.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContentBlockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contentblock.FieldOrder:
		return m.Order()
	case contentblock.FieldBlockType:
		return m.BlockType()
	case contentblock.FieldConfig:
		return m.Config()
	case contentblock.FieldIsVisible:
		return m.IsVisible()
	case contentblock.FieldHideOnMobile:
		return m.HideOnMobile()
	case contentblock.FieldHideOnTablet:
		return m.HideOnTablet()
	case contentblock.FieldHideOnDesktop:
		return m.HideOnDesktop()
	case contentblock.FieldCreatedAt:
		return m.CreatedAt()
	case contentblock.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContentBlockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contentblock.FieldOrder:
		return m.OldOrder(ctx)
	case contentblock.FieldBlockType:
		return m.OldBlockType(ctx)
	case contentblock.FieldConfig:
		return m.OldConfig(ctx)
	case contentblock.FieldIsVisible:
		return m.OldIsVisible(ctx)
	case contentblock.FieldHideOnMobile:
		return m.OldHideOnMobile(ctx)
	case contentblock.FieldHideOnTablet:
		return m.OldHideOnTablet(ctx)
	case contentblock.FieldHideOnDesktop:
		return m.OldHideOnDesktop(ctx)
	case contentblock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contentblock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ContentBlock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentBlockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contentblock.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case contentblock.FieldBlockType:
		v, ok := value.(contentblock.BlockType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockType(v)
		return nil
	case contentblock.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case contentblock.FieldIsVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVisible(v)
		return nil
	case contentblock.FieldHideOnMobile:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideOnMobile(v)
		return nil
	case contentblock.FieldHideOnTablet:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideOnTablet(v)
		return nil
	case contentblock.FieldHideOnDesktop:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideOnDesktop(v)
		return nil
	case contentblock.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contentblock.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ContentBlock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContentBlockMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, contentblock.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContentBlockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contentblock.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentBlockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contentblock.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ContentBlock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContentBlockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contentblock.FieldConfig) {
		fields = append(fields, contentblock.FieldConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContentBlockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContentBlockMutation) ClearField(name string) error {
	switch name {
	case contentblock.FieldConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown ContentBlock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContentBlockMutation) ResetField(name string) error {
	switch name {
	case contentblock.FieldOrder:
		m.ResetOrder()
		return nil
	case contentblock.FieldBlockType:
		m.ResetBlockType()
		return nil
	case contentblock.FieldConfig:
		m.ResetConfig()
		return nil
	case contentblock.FieldIsVisible:
		m.ResetIsVisible()
		return nil
	case contentblock.FieldHideOnMobile:
		m.ResetHideOnMobile()
		return nil
	case contentblock.FieldHideOnTablet:
		m.ResetHideOnTablet()
		return nil
	case contentblock.FieldHideOnDesktop:
		m.ResetHideOnDesktop()
		return nil
	case contentblock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contentblock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ContentBlock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContentBlockMutation) AddedEdges() []string {
	edges := make([]string, 0, 22)
	if m.page != nil {
		edges = append(edges, contentblock.EdgePage)
	}
	if m.block_hero != nil {
		edges = append(edges, contentblock.EdgeBlockHero)
	}
	if m.block_text_content != nil {
		edges = append(edges, contentblock.EdgeBlockTextContent)
	}
	if m.block_faq != nil {
		edges = append(edges, contentblock.EdgeBlockFaq)
	}
	if m.block_cta != nil {
		edges = append(edges, contentblock.EdgeBlockCta)
	}
	if m.block_testimonials != nil {
		edges = append(edges, contentblock.EdgeBlockTestimonials)
	}
	if m.block_stats != nil {
		edges = append(edges, contentblock.EdgeBlockStats)
	}
	if m.block_gallery != nil {
		edges = append(edges, contentblock.EdgeBlockGallery)
	}
	if m.block_program_cards != nil {
		edges = append(edges, contentblock.EdgeBlockProgramCards)
	}
	if m.block_success_stories != nil {
		edges = append(edges, contentblock.EdgeBlockSuccessStories)
	}
	if m.block_donation_form != nil {
		edges = append(edges, contentblock.EdgeBlockDonationForm)
	}
	if m.block_volunteer_signup != nil {
		edges = append(edges, contentblock.EdgeBlockVolunteerSignup)
	}
	if m.block_newsletter_signup != nil {
		edges = append(edges, contentblock.EdgeBlockNewsletterSignup)
	}
	if m.block_partner_logos != nil {
		edges = append(edges, contentblock.EdgeBlockPartnerLogos)
	}
	if m.block_team_grid != nil {
		edges = append(edges, contentblock.EdgeBlockTeamGrid)
	}
	if m.block_timeline != nil {
		edges = append(edges, contentblock.EdgeBlockTimeline)
	}
	if m.block_contact_form != nil {
		edges = append(edges, contentblock.EdgeBlockContactForm)
	}
	if m.block_video_embed != nil {
		edges = append(edges, contentblock.EdgeBlockVideoEmbed)
	}
	if m.block_map != nil {
		edges = append(edges, contentblock.EdgeBlockMap)
	}
	if m.block_accordion != nil {
		edges = append(edges, contentblock.EdgeBlockAccordion)
	}
	if m.block_tabs != nil {
		edges = append(edges, contentblock.EdgeBlockTabs)
	}
	if m.block_divider != nil {
		edges = append(edges, contentblock.EdgeBlockDivider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContentBlockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contentblock.EdgePage:
		if id := m.page; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockHero:
		if id := m.block_hero; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockTextContent:
		if id := m.block_text_content; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockFaq:
		if id := m.block_faq; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockCta:
		if id := m.block_cta; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockTestimonials:
		if id := m.block_testimonials; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockStats:
		if id := m.block_stats; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockGallery:
		if id := m.block_gallery; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockProgramCards:
		if id := m.block_program_cards; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockSuccessStories:
		if id := m.block_success_stories; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockDonationForm:
		if id := m.block_donation_form; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockVolunteerSignup:
		if id := m.block_volunteer_signup; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockNewsletterSignup:
		if id := m.block_newsletter_signup; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockPartnerLogos:
		if id := m.block_partner_logos; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockTeamGrid:
		if id := m.block_team_grid; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockTimeline:
		if id := m.block_timeline; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockContactForm:
		if id := m.block_contact_form; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockVideoEmbed:
		if id := m.block_video_embed; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockMap:
		if id := m.block_map; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockAccordion:
		if id := m.block_accordion; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockTabs:
		if id := m.block_tabs; id != nil {
			return []ent.Value{*id}
		}
	case contentblock.EdgeBlockDivider:
		if id := m.block_divider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContentBlockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 22)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContentBlockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContentBlockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 22)
	if m.clearedpage {
		edges = append(edges, contentblock.EdgePage)
	}
	if m.clearedblock_hero {
		edges = append(edges, contentblock.EdgeBlockHero)
	}
	if m.clearedblock_text_content {
		edges = append(edges, contentblock.EdgeBlockTextContent)
	}
	if m.clearedblock_faq {
		edges = append(edges, contentblock.EdgeBlockFaq)
	}
	if m.clearedblock_cta {
		edges = append(edges, contentblock.EdgeBlockCta)
	}
	if m.clearedblock_testimonials {
		edges = append(edges, contentblock.EdgeBlockTestimonials)
	}
	if m.clearedblock_stats {
		edges = append(edges, contentblock.EdgeBlockStats)
	}
	if m.clearedblock_gallery {
		edges = append(edges, contentblock.EdgeBlockGallery)
	}
	if m.clearedblock_program_cards {
		edges = append(edges, contentblock.EdgeBlockProgramCards)
	}
	if m.clearedblock_success_stories {
		edges = append(edges, contentblock.EdgeBlockSuccessStories)
	}
	if m.clearedblock_donation_form {
		edges = append(edges, contentblock.EdgeBlockDonationForm)
	}
	if m.clearedblock_volunteer_signup {
		edges = append(edges, contentblock.EdgeBlockVolunteerSignup)
	}
	if m.clearedblock_newsletter_signup {
		edges = append(edges, contentblock.EdgeBlockNewsletterSignup)
	}
	if m.clearedblock_partner_logos {
		edges = append(edges, contentblock.EdgeBlockPartnerLogos)
	}
	if m.clearedblock_team_grid {
		edges = append(edges, contentblock.EdgeBlockTeamGrid)
	}
	if m.clearedblock_timeline {
		edges = append(edges, contentblock.EdgeBlockTimeline)
	}
	if m.clearedblock_contact_form {
		edges = append(edges, contentblock.EdgeBlockContactForm)
	}
	if m.clearedblock_video_embed {
		edges = append(edges, contentblock.EdgeBlockVideoEmbed)
	}
	if m.clearedblock_map {
		edges = append(edges, contentblock.EdgeBlockMap)
	}
	if m.clearedblock_accordion {
		edges = append(edges, contentblock.EdgeBlockAccordion)
	}
	if m.clearedblock_tabs {
		edges = append(edges, contentblock.EdgeBlockTabs)
	}
	if m.clearedblock_divider {
		edges = append(edges, contentblock.EdgeBlockDivider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContentBlockMutation) EdgeCleared(name string) bool {
	switch name {
	case contentblock.EdgePage:
		return m.clearedpage
	case contentblock.EdgeBlockHero:
		return m.clearedblock_hero
	case contentblock.EdgeBlockTextContent:
		return m.clearedblock_text_content
	case contentblock.EdgeBlockFaq:
		return m.clearedblock_faq
	case contentblock.EdgeBlockCta:
		return m.clearedblock_cta
	case contentblock.EdgeBlockTestimonials:
		return m.clearedblock_testimonials
	case contentblock.EdgeBlockStats:
		return m.clearedblock_stats
	case contentblock.EdgeBlockGallery:
		return m.clearedblock_gallery
	case contentblock.EdgeBlockProgramCards:
		return m.clearedblock_program_cards
	case contentblock.EdgeBlockSuccessStories:
		return m.clearedblock_success_stories
	case contentblock.EdgeBlockDonationForm:
		return m.clearedblock_donation_form
	case contentblock.EdgeBlockVolunteerSignup:
		return m.clearedblock_volunteer_signup
	case contentblock.EdgeBlockNewsletterSignup:
		return m.clearedblock_newsletter_signup
	case contentblock.EdgeBlockPartnerLogos:
		return m.clearedblock_partner_logos
	case contentblock.EdgeBlockTeamGrid:
		return m.clearedblock_team_grid
	case contentblock.EdgeBlockTimeline:
		return m.clearedblock_timeline
	case contentblock.EdgeBlockContactForm:
		return m.clearedblock_contact_form
	case contentblock.EdgeBlockVideoEmbed:
		return m.clearedblock_video_embed
	case contentblock.EdgeBlockMap:
		return m.clearedblock_map
	case contentblock.EdgeBlockAccordion:
		return m.clearedblock_accordion
	case contentblock.EdgeBlockTabs:
		return m.clearedblock_tabs
	case contentblock.EdgeBlockDivider:
		return m.clearedblock_divider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContentBlockMutation) ClearEdge(name string) error {
	switch name {
	case contentblock.EdgePage:
		m.ClearPage()
		return nil
	case contentblock.EdgeBlockHero:
		m.ClearBlockHero()
		return nil
	case contentblock.EdgeBlockTextContent:
		m.ClearBlockTextContent()
		return nil
	case contentblock.EdgeBlockFaq:
		m.ClearBlockFaq()
		return nil
	case contentblock.EdgeBlockCta:
		m.ClearBlockCta()
		return nil
	case contentblock.EdgeBlockTestimonials:
		m.ClearBlockTestimonials()
		return nil
	case contentblock.EdgeBlockStats:
		m.ClearBlockStats()
		return nil
	case contentblock.EdgeBlockGallery:
		m.ClearBlockGallery()
		return nil
	case contentblock.EdgeBlockProgramCards:
		m.ClearBlockProgramCards()
		return nil
	case contentblock.EdgeBlockSuccessStories:
		m.ClearBlockSuccessStories()
		return nil
	case contentblock.EdgeBlockDonationForm:
		m.ClearBlockDonationForm()
		return nil
	case contentblock.EdgeBlockVolunteerSignup:
		m.ClearBlockVolunteerSignup()
		return nil
	case contentblock.EdgeBlockNewsletterSignup:
		m.ClearBlockNewsletterSignup()
		return nil
	case contentblock.EdgeBlockPartnerLogos:
		m.ClearBlockPartnerLogos()
		return nil
	case contentblock.EdgeBlockTeamGrid:
		m.ClearBlockTeamGrid()
		return nil
	case contentblock.EdgeBlockTimeline:
		m.ClearBlockTimeline()
		return nil
	case contentblock.EdgeBlockContactForm:
		m.ClearBlockContactForm()
		return nil
	case contentblock.EdgeBlockVideoEmbed:
		m.ClearBlockVideoEmbed()
		return nil
	case contentblock.EdgeBlockMap:
		m.ClearBlockMap()
		return nil
	case contentblock.EdgeBlockAccordion:
		m.ClearBlockAccordion()
		return nil
	case contentblock.EdgeBlockTabs:
		m.ClearBlockTabs()
		return nil
	case contentblock.EdgeBlockDivider:
		m.ClearBlockDivider()
		return nil
	}
	return fmt.Errorf("unknown ContentBlock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContentBlockMutation) ResetEdge(name string) error {
	switch name {
	case contentblock.EdgePage:
		m.ResetPage()
		return nil
	case contentblock.EdgeBlockHero:
		m.ResetBlockHero()
		return nil
	case contentblock.EdgeBlockTextContent:
		m.ResetBlockTextContent()
		return nil
	case contentblock.EdgeBlockFaq:
		m.ResetBlockFaq()
		return nil
	case contentblock.EdgeBlockCta:
		m.ResetBlockCta()
		return nil
	case contentblock.EdgeBlockTestimonials:
		m.ResetBlockTestimonials()
		return nil
	case contentblock.EdgeBlockStats:
		m.ResetBlockStats()
		return nil
	case contentblock.EdgeBlockGallery:
		m.ResetBlockGallery()
		return nil
	case contentblock.EdgeBlockProgramCards:
		m.ResetBlockProgramCards()
		return nil
	case contentblock.EdgeBlockSuccessStories:
		m.ResetBlockSuccessStories()
		return nil
	case contentblock.EdgeBlockDonationForm:
		m.ResetBlockDonationForm()
		return nil
	case contentblock.EdgeBlockVolunteerSignup:
		m.ResetBlockVolunteerSignup()
		return nil
	case contentblock.EdgeBlockNewsletterSignup:
		m.ResetBlockNewsletterSignup()
		return nil
	case contentblock.EdgeBlockPartnerLogos:
		m.ResetBlockPartnerLogos()
		return nil
	case contentblock.EdgeBlockTeamGrid:
		m.ResetBlockTeamGrid()
		return nil
	case contentblock.EdgeBlockTimeline:
		m.ResetBlockTimeline()
		return nil
	case contentblock.EdgeBlockContactForm:
		m.ResetBlockContactForm()
		return nil
	case contentblock.EdgeBlockVideoEmbed:
		m.ResetBlockVideoEmbed()
		return nil
	case contentblock.EdgeBlockMap:
		m.ResetBlockMap()
		return nil
	case contentblock.EdgeBlockAccordion:
		m.ResetBlockAccordion()
		return nil
	case contentblock.EdgeBlockTabs:
		m.ResetBlockTabs()
		return nil
	case contentblock.EdgeBlockDivider:
		m.ResetBlockDivider()
		return nil
	}
	return fmt.Errorf("unknown ContentBlock edge %s", name)
}

// ConversationMutation represents an operation that mutates the Conversation nodes in the graph.
type ConversationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	messages            map[int]struct{}
	removedmessages     map[int]struct{}
	clearedmessages     bool
	participants        map[int]struct{}
	removedparticipants map[int]struct{}
	clearedparticipants bool
	done                bool
	oldValue            func(context.Context) (*Conversation, error)
	predicates          []predicate.Conversation
}

var _ ent.Mutation = (*ConversationMutation)(nil)

// conversationOption allows management of the mutation configuration using functional options.
type conversationOption func(*ConversationMutation)

// newConversationMutation creates new mutation for the Conversation entity.
func newConversationMutation(c config, op Op, opts ...conversationOption) *ConversationMutation {
	m := &ConversationMutation{
		config:        c,
		op:            op,
		typ:           TypeConversation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConversationID sets the ID field of the mutation.
func withConversationID(id int) conversationOption {
	return func(m *ConversationMutation) {
		var (
			err   error
			once  sync.Once
			value *Conversation
		)
		m.oldValue = func(ctx context.Context) (*Conversation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conversation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConversation sets the old Conversation of the mutation.
func withConversation(node *Conversation) conversationOption {
	return func(m *ConversationMutation) {
		m.oldValue = func(context.Context) (*Conversation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConversationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConversationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConversationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConversationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Conversation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConversationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConversationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConversationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConversationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConversationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Conversation entity.
// If the Conversation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConversationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *ConversationMutation) AddMessageIDs(ids ...int) {
	if m.messages == nil {
		m.messages = make(map[int]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *ConversationMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *ConversationMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *ConversationMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *ConversationMutation) RemovedMessagesIDs() (ids []int) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *ConversationMutation) MessagesIDs() (ids []int) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *ConversationMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddParticipantIDs adds the "participants" edge to the ConversationParticipant entity by ids.
func (m *ConversationMutation) AddParticipantIDs(ids ...int) {
	if m.participants == nil {
		m.participants = make(map[int]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the ConversationParticipant entity.
func (m *ConversationMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the ConversationParticipant entity was cleared.
func (m *ConversationMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the ConversationParticipant entity by IDs.
func (m *ConversationMutation) RemoveParticipantIDs(ids ...int) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the ConversationParticipant entity.
func (m *ConversationMutation) RemovedParticipantsIDs() (ids []int) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *ConversationMutation) ParticipantsIDs() (ids []int) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *ConversationMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// Where appends a list predicates to the ConversationMutation builder.
func (m *ConversationMutation) Where(ps ...predicate.Conversation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConversationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConversationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Conversation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConversationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConversationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Conversation).
func (m *ConversationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConversationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, conversation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, conversation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConversationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.CreatedAt()
	case conversation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConversationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conversation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case conversation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Conversation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conversation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case conversation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConversationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConversationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Conversation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConversationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConversationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConversationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Conversation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConversationMutation) ResetField(name string) error {
	switch name {
	case conversation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case conversation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Conversation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConversationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.messages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.participants != nil {
		edges = append(edges, conversation.EdgeParticipants)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConversationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case conversation.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConversationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessages != nil {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.removedparticipants != nil {
		edges = append(edges, conversation.EdgeParticipants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConversationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case conversation.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case conversation.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConversationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmessages {
		edges = append(edges, conversation.EdgeMessages)
	}
	if m.clearedparticipants {
		edges = append(edges, conversation.EdgeParticipants)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConversationMutation) EdgeCleared(name string) bool {
	switch name {
	case conversation.EdgeMessages:
		return m.clearedmessages
	case conversation.EdgeParticipants:
		return m.clearedparticipants
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConversationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Conversation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConversationMutation) ResetEdge(name string) error {
	switch name {
	case conversation.EdgeMessages:
		m.ResetMessages()
		return nil
	case conversation.EdgeParticipants:
		m.ResetParticipants()
		return nil
	}
	return fmt.Errorf("unknown Conversation edge %s", name)
}

// ConversationParticipantMutation represents an operation that mutates the ConversationParticipant nodes in the graph.
type ConversationParticipantMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	last_read_at        *time.Time
	clearedFields       map[string]struct{}
	conversation        *int
	clearedconversation bool
	user                *int
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*ConversationParticipant, error)
	predicates          []predicate.ConversationParticipant
}

var _ ent.Mutation = (*ConversationParticipantMutation)(nil)

// conversationparticipantOption allows management of the mutation configuration using functional options.
type conversationparticipantOption func(*ConversationParticipantMutation)

// newConversationParticipantMutation creates new mutation for the ConversationParticipant entity.
func newConversationParticipantMutation(c config, op Op, opts ...conversationparticipantOption) *ConversationParticipantMutation {
	m := &ConversationParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeConversationParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConversationParticipantID sets the ID field of the mutation.
func withConversationParticipantID(id int) conversationparticipantOption {
	return func(m *ConversationParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *ConversationParticipant
		)
		m.oldValue = func(ctx context.Context) (*ConversationParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConversationParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConversationParticipant sets the old ConversationParticipant of the mutation.
func withConversationParticipant(node *ConversationParticipant) conversationparticipantOption {
	return func(m *ConversationParticipantMutation) {
		m.oldValue = func(context.Context) (*ConversationParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConversationParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConversationParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConversationParticipantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConversationParticipantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConversationParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastReadAt sets the "last_read_at" field.
func (m *ConversationParticipantMutation) SetLastReadAt(t time.Time) {
	m.last_read_at = &t
}

// LastReadAt returns the value of the "last_read_at" field in the mutation.
func (m *ConversationParticipantMutation) LastReadAt() (r time.Time, exists bool) {
	v := m.last_read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReadAt returns the old "last_read_at" field's value of the ConversationParticipant entity.
// If the ConversationParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConversationParticipantMutation) OldLastReadAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReadAt: %w", err)
	}
	return oldValue.LastReadAt, nil
}

// ClearLastReadAt clears the value of the "last_read_at" field.
func (m *ConversationParticipantMutation) ClearLastReadAt() {
	m.last_read_at = nil
	m.clearedFields[conversationparticipant.FieldLastReadAt] = struct{}{}
}

// LastReadAtCleared returns if the "last_read_at" field was cleared in this mutation.
func (m *ConversationParticipantMutation) LastReadAtCleared() bool {
	_, ok := m.clearedFields[conversationparticipant.FieldLastReadAt]
	return ok
}

// ResetLastReadAt resets all changes to the "last_read_at" field.
func (m *ConversationParticipantMutation) ResetLastReadAt() {
	m.last_read_at = nil
	delete(m.clearedFields, conversationparticipant.FieldLastReadAt)
}

// SetConversationID sets the "conversation" edge to the Conversation entity by id.
func (m *ConversationParticipantMutation) SetConversationID(id int) {
	m.conversation = &id
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *ConversationParticipantMutation) ClearConversation() {
	m.clearedconversation = true
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *ConversationParticipantMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationID returns the "conversation" edge ID in the mutation.
func (m *ConversationParticipantMutation) ConversationID() (id int, exists bool) {
	if m.conversation != nil {
		return *m.conversation, true
	}
	return
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *ConversationParticipantMutation) ConversationIDs() (ids []int) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *ConversationParticipantMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ConversationParticipantMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ConversationParticipantMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ConversationParticipantMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ConversationParticipantMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ConversationParticipantMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ConversationParticipantMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ConversationParticipantMutation builder.
func (m *ConversationParticipantMutation) Where(ps ...predicate.ConversationParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConversationParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConversationParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConversationParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConversationParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConversationParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConversationParticipant).
func (m *ConversationParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConversationParticipantMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.last_read_at != nil {
		fields = append(fields, conversationparticipant.FieldLastReadAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConversationParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conversationparticipant.FieldLastReadAt:
		return m.LastReadAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConversationParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conversationparticipant.FieldLastReadAt:
		return m.OldLastReadAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConversationParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conversationparticipant.FieldLastReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReadAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConversationParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConversationParticipantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConversationParticipantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConversationParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ConversationParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConversationParticipantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(conversationparticipant.FieldLastReadAt) {
		fields = append(fields, conversationparticipant.FieldLastReadAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConversationParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConversationParticipantMutation) ClearField(name string) error {
	switch name {
	case conversationparticipant.FieldLastReadAt:
		m.ClearLastReadAt()
		return nil
	}
	return fmt.Errorf("unknown ConversationParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConversationParticipantMutation) ResetField(name string) error {
	switch name {
	case conversationparticipant.FieldLastReadAt:
		m.ResetLastReadAt()
		return nil
	}
	return fmt.Errorf("unknown ConversationParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConversationParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.conversation != nil {
		edges = append(edges, conversationparticipant.EdgeConversation)
	}
	if m.user != nil {
		edges = append(edges, conversationparticipant.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConversationParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case conversationparticipant.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	case conversationparticipant.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConversationParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConversationParticipantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConversationParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedconversation {
		edges = append(edges, conversationparticipant.EdgeConversation)
	}
	if m.cleareduser {
		edges = append(edges, conversationparticipant.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConversationParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case conversationparticipant.EdgeConversation:
		return m.clearedconversation
	case conversationparticipant.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConversationParticipantMutation) ClearEdge(name string) error {
	switch name {
	case conversationparticipant.EdgeConversation:
		m.ClearConversation()
		return nil
	case conversationparticipant.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ConversationParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConversationParticipantMutation) ResetEdge(name string) error {
	switch name {
	case conversationparticipant.EdgeConversation:
		m.ResetConversation()
		return nil
	case conversationparticipant.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ConversationParticipant edge %s", name)
}

// DashboardWidgetMutation represents an operation that mutates the DashboardWidget nodes in the graph.
type DashboardWidgetMutation struct {
	config
	op               Op
	typ              string
	id               *int
	title            *map[string]string
	_type            *string
	_config          *map[string]interface{}
	data_source      *string
	query            *map[string]interface{}
	_order           *int
	add_order        *int
	position         *map[string]int
	is_visible       *bool
	refresh_rate     *int
	addrefresh_rate  *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	dashboard        *int
	cleareddashboard bool
	done             bool
	oldValue         func(context.Context) (*DashboardWidget, error)
	predicates       []predicate.DashboardWidget
}

var _ ent.Mutation = (*DashboardWidgetMutation)(nil)

// dashboardwidgetOption allows management of the mutation configuration using functional options.
type dashboardwidgetOption func(*DashboardWidgetMutation)

// newDashboardWidgetMutation creates new mutation for the DashboardWidget entity.
func newDashboardWidgetMutation(c config, op Op, opts ...dashboardwidgetOption) *DashboardWidgetMutation {
	m := &DashboardWidgetMutation{
		config:        c,
		op:            op,
		typ:           TypeDashboardWidget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDashboardWidgetID sets the ID field of the mutation.
func withDashboardWidgetID(id int) dashboardwidgetOption {
	return func(m *DashboardWidgetMutation) {
		var (
			err   error
			once  sync.Once
			value *DashboardWidget
		)
		m.oldValue = func(ctx context.Context) (*DashboardWidget, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DashboardWidget.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDashboardWidget sets the old DashboardWidget of the mutation.
func withDashboardWidget(node *DashboardWidget) dashboardwidgetOption {
	return func(m *DashboardWidgetMutation) {
		m.oldValue = func(context.Context) (*DashboardWidget, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DashboardWidgetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DashboardWidgetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DashboardWidgetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DashboardWidgetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DashboardWidget.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *DashboardWidgetMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *DashboardWidgetMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DashboardWidget entity.
// If the DashboardWidget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DashboardWidgetMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DashboardWidgetMutation) ResetTitle() {
	m.title = nil
}

// SetType sets the "type" field.
func (m *DashboardWidgetMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DashboardWidgetMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DashboardWidget entity.
// If the DashboardWidget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DashboardWidgetMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DashboardWidgetMutation) ResetType() {
	m._type = nil
}

// SetConfig sets the "config" field.
func (m *DashboardWidgetMutation) SetConfig(value map[string]interface{}) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *DashboardWidgetMutation) Config() (r map[string]interface{}, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the DashboardWidget entity.
// If the DashboardWidget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DashboardWidgetMutation) OldConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *DashboardWidgetMutation) ResetConfig() {
	m._config = nil
}

// SetDataSource sets the "data_source" field.
func (m *DashboardWidgetMutation) SetDataSource(s string) {
	m.data_source = &s
}

// DataSource returns the value of the "data_source" field in the mutation.
func (m *DashboardWidgetMutation) DataSource() (r string, exists bool) {
	v := m.data_source
	if v == nil {
		return
	}
	return *v, true
}

// OldDataSource returns the old "data_source" field's value of the DashboardWidget entity.
// If the DashboardWidget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DashboardWidgetMutation) OldDataSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataSource: %w", err)
	}
	return oldValue.DataSource, nil
}

// ResetDataSource resets all changes to the "data_source" field.
func (m *DashboardWidgetMutation) ResetDataSource() {
	m.data_source = nil
}

// SetQuery sets the "query" field.
func (m *DashboardWidgetMutation) SetQuery(value map[string]interface{}) {
	m.query = &value
}

// Query returns the value of the "query" field in the mutation.
func (m *DashboardWidgetMutation) Query() (r map[string]interface{}, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the DashboardWidget entity.
// If the DashboardWidget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DashboardWidgetMutation) OldQuery(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ClearQuery clears the value of the "query" field.
func (m *DashboardWidgetMutation) ClearQuery() {
	m.query = nil
	m.clearedFields[dashboardwidget.FieldQuery] = struct{}{}
}

// QueryCleared returns if the "query" field was cleared in this mutation.
func (m *DashboardWidgetMutation) QueryCleared() bool {
	_, ok := m.clearedFields[dashboardwidget.FieldQuery]
	return ok
}

// ResetQuery resets all changes to the "query" field.
func (m *DashboardWidgetMutation) ResetQuery() {
	m.query = nil
	delete(m.clearedFields, dashboardwidget.FieldQuery)
}

// SetOrder sets the "order" field.
func (m *DashboardWidgetMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *DashboardWidgetMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the DashboardWidget entity.
// If the DashboardWidget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DashboardWidgetMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *DashboardWidgetMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *DashboardWidgetMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *DashboardWidgetMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetPosition sets the "position" field.
func (m *DashboardWidgetMutation) SetPosition(value map[string]int) {
	m.position = &value
}

// Position returns the value of the "position" field in the mutation.
func (m *DashboardWidgetMutation) Position() (r map[string]int, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the DashboardWidget entity.
// If the DashboardWidget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DashboardWidgetMutation) OldPosition(ctx context.Context) (v map[string]int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *DashboardWidgetMutation) ResetPosition() {
	m.position = nil
}

// SetIsVisible sets the "is_visible" field.
func (m *DashboardWidgetMutation) SetIsVisible(b bool) {
	m.is_visible = &b
}

// IsVisible returns the value of the "is_visible" field in the mutation.
func (m *DashboardWidgetMutation) IsVisible() (r bool, exists bool) {
	v := m.is_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVisible returns the old "is_visible" field's value of the DashboardWidget entity.
// If the DashboardWidget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DashboardWidgetMutation) OldIsVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVisible: %w", err)
	}
	return oldValue.IsVisible, nil
}

// ResetIsVisible resets all changes to the "is_visible" field.
func (m *DashboardWidgetMutation) ResetIsVisible() {
	m.is_visible = nil
}

// SetRefreshRate sets the "refresh_rate" field.
func (m *DashboardWidgetMutation) SetRefreshRate(i int) {
	m.refresh_rate = &i
	m.addrefresh_rate = nil
}

// RefreshRate returns the value of the "refresh_rate" field in the mutation.
func (m *DashboardWidgetMutation) RefreshRate() (r int, exists bool) {
	v := m.refresh_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshRate returns the old "refresh_rate" field's value of the DashboardWidget entity.
// If the DashboardWidget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DashboardWidgetMutation) OldRefreshRate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshRate: %w", err)
	}
	return oldValue.RefreshRate, nil
}

// AddRefreshRate adds i to the "refresh_rate" field.
func (m *DashboardWidgetMutation) AddRefreshRate(i int) {
	if m.addrefresh_rate != nil {
		*m.addrefresh_rate += i
	} else {
		m.addrefresh_rate = &i
	}
}

// AddedRefreshRate returns the value that was added to the "refresh_rate" field in this mutation.
func (m *DashboardWidgetMutation) AddedRefreshRate() (r int, exists bool) {
	v := m.addrefresh_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefreshRate clears the value of the "refresh_rate" field.
func (m *DashboardWidgetMutation) ClearRefreshRate() {
	m.refresh_rate = nil
	m.addrefresh_rate = nil
	m.clearedFields[dashboardwidget.FieldRefreshRate] = struct{}{}
}

// RefreshRateCleared returns if the "refresh_rate" field was cleared in this mutation.
func (m *DashboardWidgetMutation) RefreshRateCleared() bool {
	_, ok := m.clearedFields[dashboardwidget.FieldRefreshRate]
	return ok
}

// ResetRefreshRate resets all changes to the "refresh_rate" field.
func (m *DashboardWidgetMutation) ResetRefreshRate() {
	m.refresh_rate = nil
	m.addrefresh_rate = nil
	delete(m.clearedFields, dashboardwidget.FieldRefreshRate)
}

// SetCreatedAt sets the "created_at" field.
func (m *DashboardWidgetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DashboardWidgetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DashboardWidget entity.
// If the DashboardWidget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DashboardWidgetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DashboardWidgetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DashboardWidgetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DashboardWidgetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DashboardWidget entity.
// If the DashboardWidget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DashboardWidgetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DashboardWidgetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDashboardID sets the "dashboard" edge to the AnalyticsDashboard entity by id.
func (m *DashboardWidgetMutation) SetDashboardID(id int) {
	m.dashboard = &id
}

// ClearDashboard clears the "dashboard" edge to the AnalyticsDashboard entity.
func (m *DashboardWidgetMutation) ClearDashboard() {
	m.cleareddashboard = true
}

// DashboardCleared reports if the "dashboard" edge to the AnalyticsDashboard entity was cleared.
func (m *DashboardWidgetMutation) DashboardCleared() bool {
	return m.cleareddashboard
}

// DashboardID returns the "dashboard" edge ID in the mutation.
func (m *DashboardWidgetMutation) DashboardID() (id int, exists bool) {
	if m.dashboard != nil {
		return *m.dashboard, true
	}
	return
}

// DashboardIDs returns the "dashboard" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DashboardID instead. It exists only for internal usage by the builders.
func (m *DashboardWidgetMutation) DashboardIDs() (ids []int) {
	if id := m.dashboard; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDashboard resets all changes to the "dashboard" edge.
func (m *DashboardWidgetMutation) ResetDashboard() {
	m.dashboard = nil
	m.cleareddashboard = false
}

// Where appends a list predicates to the DashboardWidgetMutation builder.
func (m *DashboardWidgetMutation) Where(ps ...predicate.DashboardWidget) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DashboardWidgetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DashboardWidgetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DashboardWidget, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DashboardWidgetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DashboardWidgetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DashboardWidget).
func (m *DashboardWidgetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DashboardWidgetMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.title != nil {
		fields = append(fields, dashboardwidget.FieldTitle)
	}
	if m._type != nil {
		fields = append(fields, dashboardwidget.FieldType)
	}
	if m._config != nil {
		fields = append(fields, dashboardwidget.FieldConfig)
	}
	if m.data_source != nil {
		fields = append(fields, dashboardwidget.FieldDataSource)
	}
	if m.query != nil {
		fields = append(fields, dashboardwidget.FieldQuery)
	}
	if m._order != nil {
		fields = append(fields, dashboardwidget.FieldOrder)
	}
	if m.position != nil {
		fields = append(fields, dashboardwidget.FieldPosition)
	}
	if m.is_visible != nil {
		fields = append(fields, dashboardwidget.FieldIsVisible)
	}
	if m.refresh_rate != nil {
		fields = append(fields, dashboardwidget.FieldRefreshRate)
	}
	if m.created_at != nil {
		fields = append(fields, dashboardwidget.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dashboardwidget.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DashboardWidgetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dashboardwidget.FieldTitle:
		return m.Title()
	case dashboardwidget.FieldType:
		return m.GetType()
	case dashboardwidget.FieldConfig:
		return m.Config()
	case dashboardwidget.FieldDataSource:
		return m.DataSource()
	case dashboardwidget.FieldQuery:
		return m.Query()
	case dashboardwidget.FieldOrder:
		return m.Order()
	case dashboardwidget.FieldPosition:
		return m.Position()
	case dashboardwidget.FieldIsVisible:
		return m.IsVisible()
	case dashboardwidget.FieldRefreshRate:
		return m.RefreshRate()
	case dashboardwidget.FieldCreatedAt:
		return m.CreatedAt()
	case dashboardwidget.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DashboardWidgetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dashboardwidget.FieldTitle:
		return m.OldTitle(ctx)
	case dashboardwidget.FieldType:
		return m.OldType(ctx)
	case dashboardwidget.FieldConfig:
		return m.OldConfig(ctx)
	case dashboardwidget.FieldDataSource:
		return m.OldDataSource(ctx)
	case dashboardwidget.FieldQuery:
		return m.OldQuery(ctx)
	case dashboardwidget.FieldOrder:
		return m.OldOrder(ctx)
	case dashboardwidget.FieldPosition:
		return m.OldPosition(ctx)
	case dashboardwidget.FieldIsVisible:
		return m.OldIsVisible(ctx)
	case dashboardwidget.FieldRefreshRate:
		return m.OldRefreshRate(ctx)
	case dashboardwidget.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dashboardwidget.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DashboardWidget field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DashboardWidgetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dashboardwidget.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dashboardwidget.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dashboardwidget.FieldConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case dashboardwidget.FieldDataSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataSource(v)
		return nil
	case dashboardwidget.FieldQuery:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	case dashboardwidget.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case dashboardwidget.FieldPosition:
		v, ok := value.(map[string]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case dashboardwidget.FieldIsVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVisible(v)
		return nil
	case dashboardwidget.FieldRefreshRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshRate(v)
		return nil
	case dashboardwidget.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dashboardwidget.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DashboardWidget field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DashboardWidgetMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, dashboardwidget.FieldOrder)
	}
	if m.addrefresh_rate != nil {
		fields = append(fields, dashboardwidget.FieldRefreshRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DashboardWidgetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dashboardwidget.FieldOrder:
		return m.AddedOrder()
	case dashboardwidget.FieldRefreshRate:
		return m.AddedRefreshRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DashboardWidgetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dashboardwidget.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case dashboardwidget.FieldRefreshRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefreshRate(v)
		return nil
	}
	return fmt.Errorf("unknown DashboardWidget numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DashboardWidgetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dashboardwidget.FieldQuery) {
		fields = append(fields, dashboardwidget.FieldQuery)
	}
	if m.FieldCleared(dashboardwidget.FieldRefreshRate) {
		fields = append(fields, dashboardwidget.FieldRefreshRate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DashboardWidgetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DashboardWidgetMutation) ClearField(name string) error {
	switch name {
	case dashboardwidget.FieldQuery:
		m.ClearQuery()
		return nil
	case dashboardwidget.FieldRefreshRate:
		m.ClearRefreshRate()
		return nil
	}
	return fmt.Errorf("unknown DashboardWidget nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DashboardWidgetMutation) ResetField(name string) error {
	switch name {
	case dashboardwidget.FieldTitle:
		m.ResetTitle()
		return nil
	case dashboardwidget.FieldType:
		m.ResetType()
		return nil
	case dashboardwidget.FieldConfig:
		m.ResetConfig()
		return nil
	case dashboardwidget.FieldDataSource:
		m.ResetDataSource()
		return nil
	case dashboardwidget.FieldQuery:
		m.ResetQuery()
		return nil
	case dashboardwidget.FieldOrder:
		m.ResetOrder()
		return nil
	case dashboardwidget.FieldPosition:
		m.ResetPosition()
		return nil
	case dashboardwidget.FieldIsVisible:
		m.ResetIsVisible()
		return nil
	case dashboardwidget.FieldRefreshRate:
		m.ResetRefreshRate()
		return nil
	case dashboardwidget.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dashboardwidget.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DashboardWidget field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DashboardWidgetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dashboard != nil {
		edges = append(edges, dashboardwidget.EdgeDashboard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DashboardWidgetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dashboardwidget.EdgeDashboard:
		if id := m.dashboard; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DashboardWidgetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DashboardWidgetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DashboardWidgetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddashboard {
		edges = append(edges, dashboardwidget.EdgeDashboard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DashboardWidgetMutation) EdgeCleared(name string) bool {
	switch name {
	case dashboardwidget.EdgeDashboard:
		return m.cleareddashboard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DashboardWidgetMutation) ClearEdge(name string) error {
	switch name {
	case dashboardwidget.EdgeDashboard:
		m.ClearDashboard()
		return nil
	}
	return fmt.Errorf("unknown DashboardWidget unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DashboardWidgetMutation) ResetEdge(name string) error {
	switch name {
	case dashboardwidget.EdgeDashboard:
		m.ResetDashboard()
		return nil
	}
	return fmt.Errorf("unknown DashboardWidget edge %s", name)
}

// DocumentMutation represents an operation that mutates the Document nodes in the graph.
type DocumentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	title               *map[string]string
	_type               *document.Type
	file_url            *string
	file_name           *string
	mime_type           *string
	size                *int
	addsize             *int
	description         *map[string]string
	tags                *[]string
	appendtags          []string
	version             *string
	language            *string
	is_public           *bool
	allowed_roles       *[]string
	appendallowed_roles []string
	access_password     *string
	requires_approval   *bool
	is_approved         *bool
	approved_by         *string
	approved_at         *time.Time
	download_count      *int
	adddownload_count   *int
	last_accessed       *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	uploader            *int
	cleareduploader     bool
	category            *int
	clearedcategory     bool
	done                bool
	oldValue            func(context.Context) (*Document, error)
	predicates          []predicate.Document
}

var _ ent.Mutation = (*DocumentMutation)(nil)

// documentOption allows management of the mutation configuration using functional options.
type documentOption func(*DocumentMutation)

// newDocumentMutation creates new mutation for the Document entity.
func newDocumentMutation(c config, op Op, opts ...documentOption) *DocumentMutation {
	m := &DocumentMutation{
		config:        c,
		op:            op,
		typ:           TypeDocument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentID sets the ID field of the mutation.
func withDocumentID(id int) documentOption {
	return func(m *DocumentMutation) {
		var (
			err   error
			once  sync.Once
			value *Document
		)
		m.oldValue = func(ctx context.Context) (*Document, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Document.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocument sets the old Document of the mutation.
func withDocument(node *Document) documentOption {
	return func(m *DocumentMutation) {
		m.oldValue = func(context.Context) (*Document, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Document.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *DocumentMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *DocumentMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DocumentMutation) ResetTitle() {
	m.title = nil
}

// SetType sets the "type" field.
func (m *DocumentMutation) SetType(d document.Type) {
	m._type = &d
}

// GetType returns the value of the "type" field in the mutation.
func (m *DocumentMutation) GetType() (r document.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldType(ctx context.Context) (v document.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DocumentMutation) ResetType() {
	m._type = nil
}

// SetFileURL sets the "file_url" field.
func (m *DocumentMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *DocumentMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *DocumentMutation) ResetFileURL() {
	m.file_url = nil
}

// SetFileName sets the "file_name" field.
func (m *DocumentMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *DocumentMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *DocumentMutation) ResetFileName() {
	m.file_name = nil
}

// SetMimeType sets the "mime_type" field.
func (m *DocumentMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *DocumentMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *DocumentMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[document.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *DocumentMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[document.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *DocumentMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, document.FieldMimeType)
}

// SetSize sets the "size" field.
func (m *DocumentMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *DocumentMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *DocumentMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *DocumentMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *DocumentMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[document.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *DocumentMutation) SizeCleared() bool {
	_, ok := m.clearedFields[document.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *DocumentMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, document.FieldSize)
}

// SetDescription sets the "description" field.
func (m *DocumentMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *DocumentMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DocumentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[document.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DocumentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[document.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DocumentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, document.FieldDescription)
}

// SetTags sets the "tags" field.
func (m *DocumentMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DocumentMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *DocumentMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *DocumentMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *DocumentMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetVersion sets the "version" field.
func (m *DocumentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *DocumentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *DocumentMutation) ResetVersion() {
	m.version = nil
}

// SetLanguage sets the "language" field.
func (m *DocumentMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *DocumentMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *DocumentMutation) ResetLanguage() {
	m.language = nil
}

// SetIsPublic sets the "is_public" field.
func (m *DocumentMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *DocumentMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *DocumentMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetAllowedRoles sets the "allowed_roles" field.
func (m *DocumentMutation) SetAllowedRoles(s []string) {
	m.allowed_roles = &s
	m.appendallowed_roles = nil
}

// AllowedRoles returns the value of the "allowed_roles" field in the mutation.
func (m *DocumentMutation) AllowedRoles() (r []string, exists bool) {
	v := m.allowed_roles
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedRoles returns the old "allowed_roles" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldAllowedRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedRoles: %w", err)
	}
	return oldValue.AllowedRoles, nil
}

// AppendAllowedRoles adds s to the "allowed_roles" field.
func (m *DocumentMutation) AppendAllowedRoles(s []string) {
	m.appendallowed_roles = append(m.appendallowed_roles, s...)
}

// AppendedAllowedRoles returns the list of values that were appended to the "allowed_roles" field in this mutation.
func (m *DocumentMutation) AppendedAllowedRoles() ([]string, bool) {
	if len(m.appendallowed_roles) == 0 {
		return nil, false
	}
	return m.appendallowed_roles, true
}

// ResetAllowedRoles resets all changes to the "allowed_roles" field.
func (m *DocumentMutation) ResetAllowedRoles() {
	m.allowed_roles = nil
	m.appendallowed_roles = nil
}

// SetAccessPassword sets the "access_password" field.
func (m *DocumentMutation) SetAccessPassword(s string) {
	m.access_password = &s
}

// AccessPassword returns the value of the "access_password" field in the mutation.
func (m *DocumentMutation) AccessPassword() (r string, exists bool) {
	v := m.access_password
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessPassword returns the old "access_password" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldAccessPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessPassword: %w", err)
	}
	return oldValue.AccessPassword, nil
}

// ClearAccessPassword clears the value of the "access_password" field.
func (m *DocumentMutation) ClearAccessPassword() {
	m.access_password = nil
	m.clearedFields[document.FieldAccessPassword] = struct{}{}
}

// AccessPasswordCleared returns if the "access_password" field was cleared in this mutation.
func (m *DocumentMutation) AccessPasswordCleared() bool {
	_, ok := m.clearedFields[document.FieldAccessPassword]
	return ok
}

// ResetAccessPassword resets all changes to the "access_password" field.
func (m *DocumentMutation) ResetAccessPassword() {
	m.access_password = nil
	delete(m.clearedFields, document.FieldAccessPassword)
}

// SetRequiresApproval sets the "requires_approval" field.
func (m *DocumentMutation) SetRequiresApproval(b bool) {
	m.requires_approval = &b
}

// RequiresApproval returns the value of the "requires_approval" field in the mutation.
func (m *DocumentMutation) RequiresApproval() (r bool, exists bool) {
	v := m.requires_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresApproval returns the old "requires_approval" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldRequiresApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresApproval: %w", err)
	}
	return oldValue.RequiresApproval, nil
}

// ResetRequiresApproval resets all changes to the "requires_approval" field.
func (m *DocumentMutation) ResetRequiresApproval() {
	m.requires_approval = nil
}

// SetIsApproved sets the "is_approved" field.
func (m *DocumentMutation) SetIsApproved(b bool) {
	m.is_approved = &b
}

// IsApproved returns the value of the "is_approved" field in the mutation.
func (m *DocumentMutation) IsApproved() (r bool, exists bool) {
	v := m.is_approved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsApproved returns the old "is_approved" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldIsApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsApproved: %w", err)
	}
	return oldValue.IsApproved, nil
}

// ResetIsApproved resets all changes to the "is_approved" field.
func (m *DocumentMutation) ResetIsApproved() {
	m.is_approved = nil
}

// SetApprovedBy sets the "approved_by" field.
func (m *DocumentMutation) SetApprovedBy(s string) {
	m.approved_by = &s
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *DocumentMutation) ApprovedBy() (r string, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldApprovedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *DocumentMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.clearedFields[document.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *DocumentMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[document.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *DocumentMutation) ResetApprovedBy() {
	m.approved_by = nil
	delete(m.clearedFields, document.FieldApprovedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *DocumentMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *DocumentMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldApprovedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *DocumentMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[document.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *DocumentMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[document.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *DocumentMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, document.FieldApprovedAt)
}

// SetDownloadCount sets the "download_count" field.
func (m *DocumentMutation) SetDownloadCount(i int) {
	m.download_count = &i
	m.adddownload_count = nil
}

// DownloadCount returns the value of the "download_count" field in the mutation.
func (m *DocumentMutation) DownloadCount() (r int, exists bool) {
	v := m.download_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadCount returns the old "download_count" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldDownloadCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadCount: %w", err)
	}
	return oldValue.DownloadCount, nil
}

// AddDownloadCount adds i to the "download_count" field.
func (m *DocumentMutation) AddDownloadCount(i int) {
	if m.adddownload_count != nil {
		*m.adddownload_count += i
	} else {
		m.adddownload_count = &i
	}
}

// AddedDownloadCount returns the value that was added to the "download_count" field in this mutation.
func (m *DocumentMutation) AddedDownloadCount() (r int, exists bool) {
	v := m.adddownload_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloadCount resets all changes to the "download_count" field.
func (m *DocumentMutation) ResetDownloadCount() {
	m.download_count = nil
	m.adddownload_count = nil
}

// SetLastAccessed sets the "last_accessed" field.
func (m *DocumentMutation) SetLastAccessed(t time.Time) {
	m.last_accessed = &t
}

// LastAccessed returns the value of the "last_accessed" field in the mutation.
func (m *DocumentMutation) LastAccessed() (r time.Time, exists bool) {
	v := m.last_accessed
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAccessed returns the old "last_accessed" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldLastAccessed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAccessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAccessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAccessed: %w", err)
	}
	return oldValue.LastAccessed, nil
}

// ClearLastAccessed clears the value of the "last_accessed" field.
func (m *DocumentMutation) ClearLastAccessed() {
	m.last_accessed = nil
	m.clearedFields[document.FieldLastAccessed] = struct{}{}
}

// LastAccessedCleared returns if the "last_accessed" field was cleared in this mutation.
func (m *DocumentMutation) LastAccessedCleared() bool {
	_, ok := m.clearedFields[document.FieldLastAccessed]
	return ok
}

// ResetLastAccessed resets all changes to the "last_accessed" field.
func (m *DocumentMutation) ResetLastAccessed() {
	m.last_accessed = nil
	delete(m.clearedFields, document.FieldLastAccessed)
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocumentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocumentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocumentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUploaderID sets the "uploader" edge to the User entity by id.
func (m *DocumentMutation) SetUploaderID(id int) {
	m.uploader = &id
}

// ClearUploader clears the "uploader" edge to the User entity.
func (m *DocumentMutation) ClearUploader() {
	m.cleareduploader = true
}

// UploaderCleared reports if the "uploader" edge to the User entity was cleared.
func (m *DocumentMutation) UploaderCleared() bool {
	return m.cleareduploader
}

// UploaderID returns the "uploader" edge ID in the mutation.
func (m *DocumentMutation) UploaderID() (id int, exists bool) {
	if m.uploader != nil {
		return *m.uploader, true
	}
	return
}

// UploaderIDs returns the "uploader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UploaderID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) UploaderIDs() (ids []int) {
	if id := m.uploader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUploader resets all changes to the "uploader" edge.
func (m *DocumentMutation) ResetUploader() {
	m.uploader = nil
	m.cleareduploader = false
}

// SetCategoryID sets the "category" edge to the DocumentCategory entity by id.
func (m *DocumentMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the DocumentCategory entity.
func (m *DocumentMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the DocumentCategory entity was cleared.
func (m *DocumentMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *DocumentMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *DocumentMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// Where appends a list predicates to the DocumentMutation builder.
func (m *DocumentMutation) Where(ps ...predicate.Document) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Document, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Document).
func (m *DocumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.title != nil {
		fields = append(fields, document.FieldTitle)
	}
	if m._type != nil {
		fields = append(fields, document.FieldType)
	}
	if m.file_url != nil {
		fields = append(fields, document.FieldFileURL)
	}
	if m.file_name != nil {
		fields = append(fields, document.FieldFileName)
	}
	if m.mime_type != nil {
		fields = append(fields, document.FieldMimeType)
	}
	if m.size != nil {
		fields = append(fields, document.FieldSize)
	}
	if m.description != nil {
		fields = append(fields, document.FieldDescription)
	}
	if m.tags != nil {
		fields = append(fields, document.FieldTags)
	}
	if m.version != nil {
		fields = append(fields, document.FieldVersion)
	}
	if m.language != nil {
		fields = append(fields, document.FieldLanguage)
	}
	if m.is_public != nil {
		fields = append(fields, document.FieldIsPublic)
	}
	if m.allowed_roles != nil {
		fields = append(fields, document.FieldAllowedRoles)
	}
	if m.access_password != nil {
		fields = append(fields, document.FieldAccessPassword)
	}
	if m.requires_approval != nil {
		fields = append(fields, document.FieldRequiresApproval)
	}
	if m.is_approved != nil {
		fields = append(fields, document.FieldIsApproved)
	}
	if m.approved_by != nil {
		fields = append(fields, document.FieldApprovedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, document.FieldApprovedAt)
	}
	if m.download_count != nil {
		fields = append(fields, document.FieldDownloadCount)
	}
	if m.last_accessed != nil {
		fields = append(fields, document.FieldLastAccessed)
	}
	if m.created_at != nil {
		fields = append(fields, document.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, document.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case document.FieldTitle:
		return m.Title()
	case document.FieldType:
		return m.GetType()
	case document.FieldFileURL:
		return m.FileURL()
	case document.FieldFileName:
		return m.FileName()
	case document.FieldMimeType:
		return m.MimeType()
	case document.FieldSize:
		return m.Size()
	case document.FieldDescription:
		return m.Description()
	case document.FieldTags:
		return m.Tags()
	case document.FieldVersion:
		return m.Version()
	case document.FieldLanguage:
		return m.Language()
	case document.FieldIsPublic:
		return m.IsPublic()
	case document.FieldAllowedRoles:
		return m.AllowedRoles()
	case document.FieldAccessPassword:
		return m.AccessPassword()
	case document.FieldRequiresApproval:
		return m.RequiresApproval()
	case document.FieldIsApproved:
		return m.IsApproved()
	case document.FieldApprovedBy:
		return m.ApprovedBy()
	case document.FieldApprovedAt:
		return m.ApprovedAt()
	case document.FieldDownloadCount:
		return m.DownloadCount()
	case document.FieldLastAccessed:
		return m.LastAccessed()
	case document.FieldCreatedAt:
		return m.CreatedAt()
	case document.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case document.FieldTitle:
		return m.OldTitle(ctx)
	case document.FieldType:
		return m.OldType(ctx)
	case document.FieldFileURL:
		return m.OldFileURL(ctx)
	case document.FieldFileName:
		return m.OldFileName(ctx)
	case document.FieldMimeType:
		return m.OldMimeType(ctx)
	case document.FieldSize:
		return m.OldSize(ctx)
	case document.FieldDescription:
		return m.OldDescription(ctx)
	case document.FieldTags:
		return m.OldTags(ctx)
	case document.FieldVersion:
		return m.OldVersion(ctx)
	case document.FieldLanguage:
		return m.OldLanguage(ctx)
	case document.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case document.FieldAllowedRoles:
		return m.OldAllowedRoles(ctx)
	case document.FieldAccessPassword:
		return m.OldAccessPassword(ctx)
	case document.FieldRequiresApproval:
		return m.OldRequiresApproval(ctx)
	case document.FieldIsApproved:
		return m.OldIsApproved(ctx)
	case document.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case document.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case document.FieldDownloadCount:
		return m.OldDownloadCount(ctx)
	case document.FieldLastAccessed:
		return m.OldLastAccessed(ctx)
	case document.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case document.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Document field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case document.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case document.FieldType:
		v, ok := value.(document.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case document.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	case document.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case document.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case document.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case document.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case document.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case document.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case document.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case document.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case document.FieldAllowedRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedRoles(v)
		return nil
	case document.FieldAccessPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessPassword(v)
		return nil
	case document.FieldRequiresApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresApproval(v)
		return nil
	case document.FieldIsApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsApproved(v)
		return nil
	case document.FieldApprovedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case document.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case document.FieldDownloadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadCount(v)
		return nil
	case document.FieldLastAccessed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAccessed(v)
		return nil
	case document.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case document.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, document.FieldSize)
	}
	if m.adddownload_count != nil {
		fields = append(fields, document.FieldDownloadCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case document.FieldSize:
		return m.AddedSize()
	case document.FieldDownloadCount:
		return m.AddedDownloadCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case document.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case document.FieldDownloadCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloadCount(v)
		return nil
	}
	return fmt.Errorf("unknown Document numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(document.FieldMimeType) {
		fields = append(fields, document.FieldMimeType)
	}
	if m.FieldCleared(document.FieldSize) {
		fields = append(fields, document.FieldSize)
	}
	if m.FieldCleared(document.FieldDescription) {
		fields = append(fields, document.FieldDescription)
	}
	if m.FieldCleared(document.FieldAccessPassword) {
		fields = append(fields, document.FieldAccessPassword)
	}
	if m.FieldCleared(document.FieldApprovedBy) {
		fields = append(fields, document.FieldApprovedBy)
	}
	if m.FieldCleared(document.FieldApprovedAt) {
		fields = append(fields, document.FieldApprovedAt)
	}
	if m.FieldCleared(document.FieldLastAccessed) {
		fields = append(fields, document.FieldLastAccessed)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentMutation) ClearField(name string) error {
	switch name {
	case document.FieldMimeType:
		m.ClearMimeType()
		return nil
	case document.FieldSize:
		m.ClearSize()
		return nil
	case document.FieldDescription:
		m.ClearDescription()
		return nil
	case document.FieldAccessPassword:
		m.ClearAccessPassword()
		return nil
	case document.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case document.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case document.FieldLastAccessed:
		m.ClearLastAccessed()
		return nil
	}
	return fmt.Errorf("unknown Document nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentMutation) ResetField(name string) error {
	switch name {
	case document.FieldTitle:
		m.ResetTitle()
		return nil
	case document.FieldType:
		m.ResetType()
		return nil
	case document.FieldFileURL:
		m.ResetFileURL()
		return nil
	case document.FieldFileName:
		m.ResetFileName()
		return nil
	case document.FieldMimeType:
		m.ResetMimeType()
		return nil
	case document.FieldSize:
		m.ResetSize()
		return nil
	case document.FieldDescription:
		m.ResetDescription()
		return nil
	case document.FieldTags:
		m.ResetTags()
		return nil
	case document.FieldVersion:
		m.ResetVersion()
		return nil
	case document.FieldLanguage:
		m.ResetLanguage()
		return nil
	case document.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case document.FieldAllowedRoles:
		m.ResetAllowedRoles()
		return nil
	case document.FieldAccessPassword:
		m.ResetAccessPassword()
		return nil
	case document.FieldRequiresApproval:
		m.ResetRequiresApproval()
		return nil
	case document.FieldIsApproved:
		m.ResetIsApproved()
		return nil
	case document.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case document.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case document.FieldDownloadCount:
		m.ResetDownloadCount()
		return nil
	case document.FieldLastAccessed:
		m.ResetLastAccessed()
		return nil
	case document.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case document.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.uploader != nil {
		edges = append(edges, document.EdgeUploader)
	}
	if m.category != nil {
		edges = append(edges, document.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeUploader:
		if id := m.uploader; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduploader {
		edges = append(edges, document.EdgeUploader)
	}
	if m.clearedcategory {
		edges = append(edges, document.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentMutation) EdgeCleared(name string) bool {
	switch name {
	case document.EdgeUploader:
		return m.cleareduploader
	case document.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentMutation) ClearEdge(name string) error {
	switch name {
	case document.EdgeUploader:
		m.ClearUploader()
		return nil
	case document.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Document unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentMutation) ResetEdge(name string) error {
	switch name {
	case document.EdgeUploader:
		m.ResetUploader()
		return nil
	case document.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Document edge %s", name)
}

// DocumentCategoryMutation represents an operation that mutates the DocumentCategory nodes in the graph.
type DocumentCategoryMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *map[string]string
	description      *map[string]string
	slug             *string
	display_order    *int
	adddisplay_order *int
	is_active        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	children         map[int]struct{}
	removedchildren  map[int]struct{}
	clearedchildren  bool
	parent           *int
	clearedparent    bool
	documents        map[int]struct{}
	removeddocuments map[int]struct{}
	cleareddocuments bool
	done             bool
	oldValue         func(context.Context) (*DocumentCategory, error)
	predicates       []predicate.DocumentCategory
}

var _ ent.Mutation = (*DocumentCategoryMutation)(nil)

// documentcategoryOption allows management of the mutation configuration using functional options.
type documentcategoryOption func(*DocumentCategoryMutation)

// newDocumentCategoryMutation creates new mutation for the DocumentCategory entity.
func newDocumentCategoryMutation(c config, op Op, opts ...documentcategoryOption) *DocumentCategoryMutation {
	m := &DocumentCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentCategoryID sets the ID field of the mutation.
func withDocumentCategoryID(id int) documentcategoryOption {
	return func(m *DocumentCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentCategory
		)
		m.oldValue = func(ctx context.Context) (*DocumentCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentCategory sets the old DocumentCategory of the mutation.
func withDocumentCategory(node *DocumentCategory) documentcategoryOption {
	return func(m *DocumentCategoryMutation) {
		m.oldValue = func(context.Context) (*DocumentCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocumentCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DocumentCategoryMutation) SetName(value map[string]string) {
	m.name = &value
}

// Name returns the value of the "name" field in the mutation.
func (m *DocumentCategoryMutation) Name() (r map[string]string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DocumentCategory entity.
// If the DocumentCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentCategoryMutation) OldName(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DocumentCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DocumentCategoryMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *DocumentCategoryMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DocumentCategory entity.
// If the DocumentCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentCategoryMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DocumentCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[documentcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DocumentCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[documentcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DocumentCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, documentcategory.FieldDescription)
}

// SetSlug sets the "slug" field.
func (m *DocumentCategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *DocumentCategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the DocumentCategory entity.
// If the DocumentCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentCategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *DocumentCategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *DocumentCategoryMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *DocumentCategoryMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the DocumentCategory entity.
// If the DocumentCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentCategoryMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *DocumentCategoryMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *DocumentCategoryMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *DocumentCategoryMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetIsActive sets the "is_active" field.
func (m *DocumentCategoryMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *DocumentCategoryMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the DocumentCategory entity.
// If the DocumentCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentCategoryMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *DocumentCategoryMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DocumentCategory entity.
// If the DocumentCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocumentCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocumentCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DocumentCategory entity.
// If the DocumentCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocumentCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddChildIDs adds the "children" edge to the DocumentCategory entity by ids.
func (m *DocumentCategoryMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the DocumentCategory entity.
func (m *DocumentCategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the DocumentCategory entity was cleared.
func (m *DocumentCategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the DocumentCategory entity by IDs.
func (m *DocumentCategoryMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the DocumentCategory entity.
func (m *DocumentCategoryMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *DocumentCategoryMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *DocumentCategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetParentID sets the "parent" edge to the DocumentCategory entity by id.
func (m *DocumentCategoryMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the DocumentCategory entity.
func (m *DocumentCategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the DocumentCategory entity was cleared.
func (m *DocumentCategoryMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *DocumentCategoryMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *DocumentCategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *DocumentCategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *DocumentCategoryMutation) AddDocumentIDs(ids ...int) {
	if m.documents == nil {
		m.documents = make(map[int]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *DocumentCategoryMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *DocumentCategoryMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *DocumentCategoryMutation) RemoveDocumentIDs(ids ...int) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *DocumentCategoryMutation) RemovedDocumentsIDs() (ids []int) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *DocumentCategoryMutation) DocumentsIDs() (ids []int) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *DocumentCategoryMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// Where appends a list predicates to the DocumentCategoryMutation builder.
func (m *DocumentCategoryMutation) Where(ps ...predicate.DocumentCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocumentCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocumentCategory).
func (m *DocumentCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentCategoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, documentcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, documentcategory.FieldDescription)
	}
	if m.slug != nil {
		fields = append(fields, documentcategory.FieldSlug)
	}
	if m.display_order != nil {
		fields = append(fields, documentcategory.FieldDisplayOrder)
	}
	if m.is_active != nil {
		fields = append(fields, documentcategory.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, documentcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, documentcategory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documentcategory.FieldName:
		return m.Name()
	case documentcategory.FieldDescription:
		return m.Description()
	case documentcategory.FieldSlug:
		return m.Slug()
	case documentcategory.FieldDisplayOrder:
		return m.DisplayOrder()
	case documentcategory.FieldIsActive:
		return m.IsActive()
	case documentcategory.FieldCreatedAt:
		return m.CreatedAt()
	case documentcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documentcategory.FieldName:
		return m.OldName(ctx)
	case documentcategory.FieldDescription:
		return m.OldDescription(ctx)
	case documentcategory.FieldSlug:
		return m.OldSlug(ctx)
	case documentcategory.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case documentcategory.FieldIsActive:
		return m.OldIsActive(ctx)
	case documentcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case documentcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documentcategory.FieldName:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case documentcategory.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case documentcategory.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case documentcategory.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case documentcategory.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case documentcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case documentcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentCategoryMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, documentcategory.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case documentcategory.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case documentcategory.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(documentcategory.FieldDescription) {
		fields = append(fields, documentcategory.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentCategoryMutation) ClearField(name string) error {
	switch name {
	case documentcategory.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DocumentCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentCategoryMutation) ResetField(name string) error {
	switch name {
	case documentcategory.FieldName:
		m.ResetName()
		return nil
	case documentcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case documentcategory.FieldSlug:
		m.ResetSlug()
		return nil
	case documentcategory.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case documentcategory.FieldIsActive:
		m.ResetIsActive()
		return nil
	case documentcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case documentcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DocumentCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.children != nil {
		edges = append(edges, documentcategory.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, documentcategory.EdgeParent)
	}
	if m.documents != nil {
		edges = append(edges, documentcategory.EdgeDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case documentcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case documentcategory.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case documentcategory.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, documentcategory.EdgeChildren)
	}
	if m.removeddocuments != nil {
		edges = append(edges, documentcategory.EdgeDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case documentcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case documentcategory.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchildren {
		edges = append(edges, documentcategory.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, documentcategory.EdgeParent)
	}
	if m.cleareddocuments {
		edges = append(edges, documentcategory.EdgeDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case documentcategory.EdgeChildren:
		return m.clearedchildren
	case documentcategory.EdgeParent:
		return m.clearedparent
	case documentcategory.EdgeDocuments:
		return m.cleareddocuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentCategoryMutation) ClearEdge(name string) error {
	switch name {
	case documentcategory.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown DocumentCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentCategoryMutation) ResetEdge(name string) error {
	switch name {
	case documentcategory.EdgeChildren:
		m.ResetChildren()
		return nil
	case documentcategory.EdgeParent:
		m.ResetParent()
		return nil
	case documentcategory.EdgeDocuments:
		m.ResetDocuments()
		return nil
	}
	return fmt.Errorf("unknown DocumentCategory edge %s", name)
}

// DonationMutation represents an operation that mutates the Donation nodes in the graph.
type DonationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	amount              *float64
	addamount           *float64
	currency            *string
	is_recurring        *bool
	frequency           *string
	payment_method      *string
	payment_id          *string
	status              *string
	processed_at        *time.Time
	anonymous           *bool
	payment_gateway_ref *string
	donor_message       *string
	tax_receipt_sent    *bool
	tax_receipt_sent_at *time.Time
	recurring_interval  *string
	next_payment_date   *time.Time
	metadata            *map[string]interface{}
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	donor               *int
	cleareddonor        bool
	program             *int
	clearedprogram      bool
	campaign            *int
	clearedcampaign     bool
	done                bool
	oldValue            func(context.Context) (*Donation, error)
	predicates          []predicate.Donation
}

var _ ent.Mutation = (*DonationMutation)(nil)

// donationOption allows management of the mutation configuration using functional options.
type donationOption func(*DonationMutation)

// newDonationMutation creates new mutation for the Donation entity.
func newDonationMutation(c config, op Op, opts ...donationOption) *DonationMutation {
	m := &DonationMutation{
		config:        c,
		op:            op,
		typ:           TypeDonation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDonationID sets the ID field of the mutation.
func withDonationID(id int) donationOption {
	return func(m *DonationMutation) {
		var (
			err   error
			once  sync.Once
			value *Donation
		)
		m.oldValue = func(ctx context.Context) (*Donation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Donation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDonation sets the old Donation of the mutation.
func withDonation(node *Donation) donationOption {
	return func(m *DonationMutation) {
		m.oldValue = func(context.Context) (*Donation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DonationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DonationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DonationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DonationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Donation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *DonationMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *DonationMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *DonationMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *DonationMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *DonationMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCurrency sets the "currency" field.
func (m *DonationMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *DonationMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *DonationMutation) ResetCurrency() {
	m.currency = nil
}

// SetIsRecurring sets the "is_recurring" field.
func (m *DonationMutation) SetIsRecurring(b bool) {
	m.is_recurring = &b
}

// IsRecurring returns the value of the "is_recurring" field in the mutation.
func (m *DonationMutation) IsRecurring() (r bool, exists bool) {
	v := m.is_recurring
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRecurring returns the old "is_recurring" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldIsRecurring(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRecurring is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRecurring requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRecurring: %w", err)
	}
	return oldValue.IsRecurring, nil
}

// ResetIsRecurring resets all changes to the "is_recurring" field.
func (m *DonationMutation) ResetIsRecurring() {
	m.is_recurring = nil
}

// SetFrequency sets the "frequency" field.
func (m *DonationMutation) SetFrequency(s string) {
	m.frequency = &s
}

// Frequency returns the value of the "frequency" field in the mutation.
func (m *DonationMutation) Frequency() (r string, exists bool) {
	v := m.frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequency returns the old "frequency" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldFrequency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequency: %w", err)
	}
	return oldValue.Frequency, nil
}

// ResetFrequency resets all changes to the "frequency" field.
func (m *DonationMutation) ResetFrequency() {
	m.frequency = nil
}

// SetPaymentMethod sets the "payment_method" field.
func (m *DonationMutation) SetPaymentMethod(s string) {
	m.payment_method = &s
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *DonationMutation) PaymentMethod() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldPaymentMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ClearPaymentMethod clears the value of the "payment_method" field.
func (m *DonationMutation) ClearPaymentMethod() {
	m.payment_method = nil
	m.clearedFields[donation.FieldPaymentMethod] = struct{}{}
}

// PaymentMethodCleared returns if the "payment_method" field was cleared in this mutation.
func (m *DonationMutation) PaymentMethodCleared() bool {
	_, ok := m.clearedFields[donation.FieldPaymentMethod]
	return ok
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *DonationMutation) ResetPaymentMethod() {
	m.payment_method = nil
	delete(m.clearedFields, donation.FieldPaymentMethod)
}

// SetPaymentID sets the "payment_id" field.
func (m *DonationMutation) SetPaymentID(s string) {
	m.payment_id = &s
}

// PaymentID returns the value of the "payment_id" field in the mutation.
func (m *DonationMutation) PaymentID() (r string, exists bool) {
	v := m.payment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentID returns the old "payment_id" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldPaymentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentID: %w", err)
	}
	return oldValue.PaymentID, nil
}

// ClearPaymentID clears the value of the "payment_id" field.
func (m *DonationMutation) ClearPaymentID() {
	m.payment_id = nil
	m.clearedFields[donation.FieldPaymentID] = struct{}{}
}

// PaymentIDCleared returns if the "payment_id" field was cleared in this mutation.
func (m *DonationMutation) PaymentIDCleared() bool {
	_, ok := m.clearedFields[donation.FieldPaymentID]
	return ok
}

// ResetPaymentID resets all changes to the "payment_id" field.
func (m *DonationMutation) ResetPaymentID() {
	m.payment_id = nil
	delete(m.clearedFields, donation.FieldPaymentID)
}

// SetStatus sets the "status" field.
func (m *DonationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *DonationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DonationMutation) ResetStatus() {
	m.status = nil
}

// SetProcessedAt sets the "processed_at" field.
func (m *DonationMutation) SetProcessedAt(t time.Time) {
	m.processed_at = &t
}

// ProcessedAt returns the value of the "processed_at" field in the mutation.
func (m *DonationMutation) ProcessedAt() (r time.Time, exists bool) {
	v := m.processed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedAt returns the old "processed_at" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldProcessedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedAt: %w", err)
	}
	return oldValue.ProcessedAt, nil
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (m *DonationMutation) ClearProcessedAt() {
	m.processed_at = nil
	m.clearedFields[donation.FieldProcessedAt] = struct{}{}
}

// ProcessedAtCleared returns if the "processed_at" field was cleared in this mutation.
func (m *DonationMutation) ProcessedAtCleared() bool {
	_, ok := m.clearedFields[donation.FieldProcessedAt]
	return ok
}

// ResetProcessedAt resets all changes to the "processed_at" field.
func (m *DonationMutation) ResetProcessedAt() {
	m.processed_at = nil
	delete(m.clearedFields, donation.FieldProcessedAt)
}

// SetAnonymous sets the "anonymous" field.
func (m *DonationMutation) SetAnonymous(b bool) {
	m.anonymous = &b
}

// Anonymous returns the value of the "anonymous" field in the mutation.
func (m *DonationMutation) Anonymous() (r bool, exists bool) {
	v := m.anonymous
	if v == nil {
		return
	}
	return *v, true
}

// OldAnonymous returns the old "anonymous" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldAnonymous(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnonymous is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnonymous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnonymous: %w", err)
	}
	return oldValue.Anonymous, nil
}

// ResetAnonymous resets all changes to the "anonymous" field.
func (m *DonationMutation) ResetAnonymous() {
	m.anonymous = nil
}

// SetPaymentGatewayRef sets the "payment_gateway_ref" field.
func (m *DonationMutation) SetPaymentGatewayRef(s string) {
	m.payment_gateway_ref = &s
}

// PaymentGatewayRef returns the value of the "payment_gateway_ref" field in the mutation.
func (m *DonationMutation) PaymentGatewayRef() (r string, exists bool) {
	v := m.payment_gateway_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentGatewayRef returns the old "payment_gateway_ref" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldPaymentGatewayRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentGatewayRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentGatewayRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentGatewayRef: %w", err)
	}
	return oldValue.PaymentGatewayRef, nil
}

// ClearPaymentGatewayRef clears the value of the "payment_gateway_ref" field.
func (m *DonationMutation) ClearPaymentGatewayRef() {
	m.payment_gateway_ref = nil
	m.clearedFields[donation.FieldPaymentGatewayRef] = struct{}{}
}

// PaymentGatewayRefCleared returns if the "payment_gateway_ref" field was cleared in this mutation.
func (m *DonationMutation) PaymentGatewayRefCleared() bool {
	_, ok := m.clearedFields[donation.FieldPaymentGatewayRef]
	return ok
}

// ResetPaymentGatewayRef resets all changes to the "payment_gateway_ref" field.
func (m *DonationMutation) ResetPaymentGatewayRef() {
	m.payment_gateway_ref = nil
	delete(m.clearedFields, donation.FieldPaymentGatewayRef)
}

// SetDonorMessage sets the "donor_message" field.
func (m *DonationMutation) SetDonorMessage(s string) {
	m.donor_message = &s
}

// DonorMessage returns the value of the "donor_message" field in the mutation.
func (m *DonationMutation) DonorMessage() (r string, exists bool) {
	v := m.donor_message
	if v == nil {
		return
	}
	return *v, true
}

// OldDonorMessage returns the old "donor_message" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldDonorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDonorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDonorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDonorMessage: %w", err)
	}
	return oldValue.DonorMessage, nil
}

// ClearDonorMessage clears the value of the "donor_message" field.
func (m *DonationMutation) ClearDonorMessage() {
	m.donor_message = nil
	m.clearedFields[donation.FieldDonorMessage] = struct{}{}
}

// DonorMessageCleared returns if the "donor_message" field was cleared in this mutation.
func (m *DonationMutation) DonorMessageCleared() bool {
	_, ok := m.clearedFields[donation.FieldDonorMessage]
	return ok
}

// ResetDonorMessage resets all changes to the "donor_message" field.
func (m *DonationMutation) ResetDonorMessage() {
	m.donor_message = nil
	delete(m.clearedFields, donation.FieldDonorMessage)
}

// SetTaxReceiptSent sets the "tax_receipt_sent" field.
func (m *DonationMutation) SetTaxReceiptSent(b bool) {
	m.tax_receipt_sent = &b
}

// TaxReceiptSent returns the value of the "tax_receipt_sent" field in the mutation.
func (m *DonationMutation) TaxReceiptSent() (r bool, exists bool) {
	v := m.tax_receipt_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxReceiptSent returns the old "tax_receipt_sent" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldTaxReceiptSent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxReceiptSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxReceiptSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxReceiptSent: %w", err)
	}
	return oldValue.TaxReceiptSent, nil
}

// ResetTaxReceiptSent resets all changes to the "tax_receipt_sent" field.
func (m *DonationMutation) ResetTaxReceiptSent() {
	m.tax_receipt_sent = nil
}

// SetTaxReceiptSentAt sets the "tax_receipt_sent_at" field.
func (m *DonationMutation) SetTaxReceiptSentAt(t time.Time) {
	m.tax_receipt_sent_at = &t
}

// TaxReceiptSentAt returns the value of the "tax_receipt_sent_at" field in the mutation.
func (m *DonationMutation) TaxReceiptSentAt() (r time.Time, exists bool) {
	v := m.tax_receipt_sent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxReceiptSentAt returns the old "tax_receipt_sent_at" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldTaxReceiptSentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxReceiptSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxReceiptSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxReceiptSentAt: %w", err)
	}
	return oldValue.TaxReceiptSentAt, nil
}

// ClearTaxReceiptSentAt clears the value of the "tax_receipt_sent_at" field.
func (m *DonationMutation) ClearTaxReceiptSentAt() {
	m.tax_receipt_sent_at = nil
	m.clearedFields[donation.FieldTaxReceiptSentAt] = struct{}{}
}

// TaxReceiptSentAtCleared returns if the "tax_receipt_sent_at" field was cleared in this mutation.
func (m *DonationMutation) TaxReceiptSentAtCleared() bool {
	_, ok := m.clearedFields[donation.FieldTaxReceiptSentAt]
	return ok
}

// ResetTaxReceiptSentAt resets all changes to the "tax_receipt_sent_at" field.
func (m *DonationMutation) ResetTaxReceiptSentAt() {
	m.tax_receipt_sent_at = nil
	delete(m.clearedFields, donation.FieldTaxReceiptSentAt)
}

// SetRecurringInterval sets the "recurring_interval" field.
func (m *DonationMutation) SetRecurringInterval(s string) {
	m.recurring_interval = &s
}

// RecurringInterval returns the value of the "recurring_interval" field in the mutation.
func (m *DonationMutation) RecurringInterval() (r string, exists bool) {
	v := m.recurring_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurringInterval returns the old "recurring_interval" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldRecurringInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecurringInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecurringInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurringInterval: %w", err)
	}
	return oldValue.RecurringInterval, nil
}

// ClearRecurringInterval clears the value of the "recurring_interval" field.
func (m *DonationMutation) ClearRecurringInterval() {
	m.recurring_interval = nil
	m.clearedFields[donation.FieldRecurringInterval] = struct{}{}
}

// RecurringIntervalCleared returns if the "recurring_interval" field was cleared in this mutation.
func (m *DonationMutation) RecurringIntervalCleared() bool {
	_, ok := m.clearedFields[donation.FieldRecurringInterval]
	return ok
}

// ResetRecurringInterval resets all changes to the "recurring_interval" field.
func (m *DonationMutation) ResetRecurringInterval() {
	m.recurring_interval = nil
	delete(m.clearedFields, donation.FieldRecurringInterval)
}

// SetNextPaymentDate sets the "next_payment_date" field.
func (m *DonationMutation) SetNextPaymentDate(t time.Time) {
	m.next_payment_date = &t
}

// NextPaymentDate returns the value of the "next_payment_date" field in the mutation.
func (m *DonationMutation) NextPaymentDate() (r time.Time, exists bool) {
	v := m.next_payment_date
	if v == nil {
		return
	}
	return *v, true
}

// OldNextPaymentDate returns the old "next_payment_date" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldNextPaymentDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextPaymentDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextPaymentDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextPaymentDate: %w", err)
	}
	return oldValue.NextPaymentDate, nil
}

// ClearNextPaymentDate clears the value of the "next_payment_date" field.
func (m *DonationMutation) ClearNextPaymentDate() {
	m.next_payment_date = nil
	m.clearedFields[donation.FieldNextPaymentDate] = struct{}{}
}

// NextPaymentDateCleared returns if the "next_payment_date" field was cleared in this mutation.
func (m *DonationMutation) NextPaymentDateCleared() bool {
	_, ok := m.clearedFields[donation.FieldNextPaymentDate]
	return ok
}

// ResetNextPaymentDate resets all changes to the "next_payment_date" field.
func (m *DonationMutation) ResetNextPaymentDate() {
	m.next_payment_date = nil
	delete(m.clearedFields, donation.FieldNextPaymentDate)
}

// SetMetadata sets the "metadata" field.
func (m *DonationMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *DonationMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *DonationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[donation.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *DonationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[donation.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *DonationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, donation.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *DonationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DonationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DonationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DonationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DonationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Donation entity.
// If the Donation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DonationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DonationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDonorID sets the "donor" edge to the User entity by id.
func (m *DonationMutation) SetDonorID(id int) {
	m.donor = &id
}

// ClearDonor clears the "donor" edge to the User entity.
func (m *DonationMutation) ClearDonor() {
	m.cleareddonor = true
}

// DonorCleared reports if the "donor" edge to the User entity was cleared.
func (m *DonationMutation) DonorCleared() bool {
	return m.cleareddonor
}

// DonorID returns the "donor" edge ID in the mutation.
func (m *DonationMutation) DonorID() (id int, exists bool) {
	if m.donor != nil {
		return *m.donor, true
	}
	return
}

// DonorIDs returns the "donor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DonorID instead. It exists only for internal usage by the builders.
func (m *DonationMutation) DonorIDs() (ids []int) {
	if id := m.donor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDonor resets all changes to the "donor" edge.
func (m *DonationMutation) ResetDonor() {
	m.donor = nil
	m.cleareddonor = false
}

// SetProgramID sets the "program" edge to the Program entity by id.
func (m *DonationMutation) SetProgramID(id int) {
	m.program = &id
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *DonationMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *DonationMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// ProgramID returns the "program" edge ID in the mutation.
func (m *DonationMutation) ProgramID() (id int, exists bool) {
	if m.program != nil {
		return *m.program, true
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgramID instead. It exists only for internal usage by the builders.
func (m *DonationMutation) ProgramIDs() (ids []int) {
	if id := m.program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *DonationMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
}

// SetCampaignID sets the "campaign" edge to the FundraisingCampaign entity by id.
func (m *DonationMutation) SetCampaignID(id int) {
	m.campaign = &id
}

// ClearCampaign clears the "campaign" edge to the FundraisingCampaign entity.
func (m *DonationMutation) ClearCampaign() {
	m.clearedcampaign = true
}

// CampaignCleared reports if the "campaign" edge to the FundraisingCampaign entity was cleared.
func (m *DonationMutation) CampaignCleared() bool {
	return m.clearedcampaign
}

// CampaignID returns the "campaign" edge ID in the mutation.
func (m *DonationMutation) CampaignID() (id int, exists bool) {
	if m.campaign != nil {
		return *m.campaign, true
	}
	return
}

// CampaignIDs returns the "campaign" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignID instead. It exists only for internal usage by the builders.
func (m *DonationMutation) CampaignIDs() (ids []int) {
	if id := m.campaign; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaign resets all changes to the "campaign" edge.
func (m *DonationMutation) ResetCampaign() {
	m.campaign = nil
	m.clearedcampaign = false
}

// Where appends a list predicates to the DonationMutation builder.
func (m *DonationMutation) Where(ps ...predicate.Donation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DonationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DonationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Donation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DonationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DonationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Donation).
func (m *DonationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DonationMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.amount != nil {
		fields = append(fields, donation.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, donation.FieldCurrency)
	}
	if m.is_recurring != nil {
		fields = append(fields, donation.FieldIsRecurring)
	}
	if m.frequency != nil {
		fields = append(fields, donation.FieldFrequency)
	}
	if m.payment_method != nil {
		fields = append(fields, donation.FieldPaymentMethod)
	}
	if m.payment_id != nil {
		fields = append(fields, donation.FieldPaymentID)
	}
	if m.status != nil {
		fields = append(fields, donation.FieldStatus)
	}
	if m.processed_at != nil {
		fields = append(fields, donation.FieldProcessedAt)
	}
	if m.anonymous != nil {
		fields = append(fields, donation.FieldAnonymous)
	}
	if m.payment_gateway_ref != nil {
		fields = append(fields, donation.FieldPaymentGatewayRef)
	}
	if m.donor_message != nil {
		fields = append(fields, donation.FieldDonorMessage)
	}
	if m.tax_receipt_sent != nil {
		fields = append(fields, donation.FieldTaxReceiptSent)
	}
	if m.tax_receipt_sent_at != nil {
		fields = append(fields, donation.FieldTaxReceiptSentAt)
	}
	if m.recurring_interval != nil {
		fields = append(fields, donation.FieldRecurringInterval)
	}
	if m.next_payment_date != nil {
		fields = append(fields, donation.FieldNextPaymentDate)
	}
	if m.metadata != nil {
		fields = append(fields, donation.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, donation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, donation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DonationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case donation.FieldAmount:
		return m.Amount()
	case donation.FieldCurrency:
		return m.Currency()
	case donation.FieldIsRecurring:
		return m.IsRecurring()
	case donation.FieldFrequency:
		return m.Frequency()
	case donation.FieldPaymentMethod:
		return m.PaymentMethod()
	case donation.FieldPaymentID:
		return m.PaymentID()
	case donation.FieldStatus:
		return m.Status()
	case donation.FieldProcessedAt:
		return m.ProcessedAt()
	case donation.FieldAnonymous:
		return m.Anonymous()
	case donation.FieldPaymentGatewayRef:
		return m.PaymentGatewayRef()
	case donation.FieldDonorMessage:
		return m.DonorMessage()
	case donation.FieldTaxReceiptSent:
		return m.TaxReceiptSent()
	case donation.FieldTaxReceiptSentAt:
		return m.TaxReceiptSentAt()
	case donation.FieldRecurringInterval:
		return m.RecurringInterval()
	case donation.FieldNextPaymentDate:
		return m.NextPaymentDate()
	case donation.FieldMetadata:
		return m.Metadata()
	case donation.FieldCreatedAt:
		return m.CreatedAt()
	case donation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DonationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case donation.FieldAmount:
		return m.OldAmount(ctx)
	case donation.FieldCurrency:
		return m.OldCurrency(ctx)
	case donation.FieldIsRecurring:
		return m.OldIsRecurring(ctx)
	case donation.FieldFrequency:
		return m.OldFrequency(ctx)
	case donation.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case donation.FieldPaymentID:
		return m.OldPaymentID(ctx)
	case donation.FieldStatus:
		return m.OldStatus(ctx)
	case donation.FieldProcessedAt:
		return m.OldProcessedAt(ctx)
	case donation.FieldAnonymous:
		return m.OldAnonymous(ctx)
	case donation.FieldPaymentGatewayRef:
		return m.OldPaymentGatewayRef(ctx)
	case donation.FieldDonorMessage:
		return m.OldDonorMessage(ctx)
	case donation.FieldTaxReceiptSent:
		return m.OldTaxReceiptSent(ctx)
	case donation.FieldTaxReceiptSentAt:
		return m.OldTaxReceiptSentAt(ctx)
	case donation.FieldRecurringInterval:
		return m.OldRecurringInterval(ctx)
	case donation.FieldNextPaymentDate:
		return m.OldNextPaymentDate(ctx)
	case donation.FieldMetadata:
		return m.OldMetadata(ctx)
	case donation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case donation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Donation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DonationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case donation.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case donation.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case donation.FieldIsRecurring:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRecurring(v)
		return nil
	case donation.FieldFrequency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequency(v)
		return nil
	case donation.FieldPaymentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case donation.FieldPaymentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentID(v)
		return nil
	case donation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case donation.FieldProcessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedAt(v)
		return nil
	case donation.FieldAnonymous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnonymous(v)
		return nil
	case donation.FieldPaymentGatewayRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentGatewayRef(v)
		return nil
	case donation.FieldDonorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDonorMessage(v)
		return nil
	case donation.FieldTaxReceiptSent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxReceiptSent(v)
		return nil
	case donation.FieldTaxReceiptSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxReceiptSentAt(v)
		return nil
	case donation.FieldRecurringInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurringInterval(v)
		return nil
	case donation.FieldNextPaymentDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextPaymentDate(v)
		return nil
	case donation.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case donation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case donation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Donation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DonationMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, donation.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DonationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case donation.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DonationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case donation.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Donation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DonationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(donation.FieldPaymentMethod) {
		fields = append(fields, donation.FieldPaymentMethod)
	}
	if m.FieldCleared(donation.FieldPaymentID) {
		fields = append(fields, donation.FieldPaymentID)
	}
	if m.FieldCleared(donation.FieldProcessedAt) {
		fields = append(fields, donation.FieldProcessedAt)
	}
	if m.FieldCleared(donation.FieldPaymentGatewayRef) {
		fields = append(fields, donation.FieldPaymentGatewayRef)
	}
	if m.FieldCleared(donation.FieldDonorMessage) {
		fields = append(fields, donation.FieldDonorMessage)
	}
	if m.FieldCleared(donation.FieldTaxReceiptSentAt) {
		fields = append(fields, donation.FieldTaxReceiptSentAt)
	}
	if m.FieldCleared(donation.FieldRecurringInterval) {
		fields = append(fields, donation.FieldRecurringInterval)
	}
	if m.FieldCleared(donation.FieldNextPaymentDate) {
		fields = append(fields, donation.FieldNextPaymentDate)
	}
	if m.FieldCleared(donation.FieldMetadata) {
		fields = append(fields, donation.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DonationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DonationMutation) ClearField(name string) error {
	switch name {
	case donation.FieldPaymentMethod:
		m.ClearPaymentMethod()
		return nil
	case donation.FieldPaymentID:
		m.ClearPaymentID()
		return nil
	case donation.FieldProcessedAt:
		m.ClearProcessedAt()
		return nil
	case donation.FieldPaymentGatewayRef:
		m.ClearPaymentGatewayRef()
		return nil
	case donation.FieldDonorMessage:
		m.ClearDonorMessage()
		return nil
	case donation.FieldTaxReceiptSentAt:
		m.ClearTaxReceiptSentAt()
		return nil
	case donation.FieldRecurringInterval:
		m.ClearRecurringInterval()
		return nil
	case donation.FieldNextPaymentDate:
		m.ClearNextPaymentDate()
		return nil
	case donation.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Donation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DonationMutation) ResetField(name string) error {
	switch name {
	case donation.FieldAmount:
		m.ResetAmount()
		return nil
	case donation.FieldCurrency:
		m.ResetCurrency()
		return nil
	case donation.FieldIsRecurring:
		m.ResetIsRecurring()
		return nil
	case donation.FieldFrequency:
		m.ResetFrequency()
		return nil
	case donation.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case donation.FieldPaymentID:
		m.ResetPaymentID()
		return nil
	case donation.FieldStatus:
		m.ResetStatus()
		return nil
	case donation.FieldProcessedAt:
		m.ResetProcessedAt()
		return nil
	case donation.FieldAnonymous:
		m.ResetAnonymous()
		return nil
	case donation.FieldPaymentGatewayRef:
		m.ResetPaymentGatewayRef()
		return nil
	case donation.FieldDonorMessage:
		m.ResetDonorMessage()
		return nil
	case donation.FieldTaxReceiptSent:
		m.ResetTaxReceiptSent()
		return nil
	case donation.FieldTaxReceiptSentAt:
		m.ResetTaxReceiptSentAt()
		return nil
	case donation.FieldRecurringInterval:
		m.ResetRecurringInterval()
		return nil
	case donation.FieldNextPaymentDate:
		m.ResetNextPaymentDate()
		return nil
	case donation.FieldMetadata:
		m.ResetMetadata()
		return nil
	case donation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case donation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Donation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DonationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.donor != nil {
		edges = append(edges, donation.EdgeDonor)
	}
	if m.program != nil {
		edges = append(edges, donation.EdgeProgram)
	}
	if m.campaign != nil {
		edges = append(edges, donation.EdgeCampaign)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DonationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case donation.EdgeDonor:
		if id := m.donor; id != nil {
			return []ent.Value{*id}
		}
	case donation.EdgeProgram:
		if id := m.program; id != nil {
			return []ent.Value{*id}
		}
	case donation.EdgeCampaign:
		if id := m.campaign; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DonationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DonationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DonationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddonor {
		edges = append(edges, donation.EdgeDonor)
	}
	if m.clearedprogram {
		edges = append(edges, donation.EdgeProgram)
	}
	if m.clearedcampaign {
		edges = append(edges, donation.EdgeCampaign)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DonationMutation) EdgeCleared(name string) bool {
	switch name {
	case donation.EdgeDonor:
		return m.cleareddonor
	case donation.EdgeProgram:
		return m.clearedprogram
	case donation.EdgeCampaign:
		return m.clearedcampaign
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DonationMutation) ClearEdge(name string) error {
	switch name {
	case donation.EdgeDonor:
		m.ClearDonor()
		return nil
	case donation.EdgeProgram:
		m.ClearProgram()
		return nil
	case donation.EdgeCampaign:
		m.ClearCampaign()
		return nil
	}
	return fmt.Errorf("unknown Donation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DonationMutation) ResetEdge(name string) error {
	switch name {
	case donation.EdgeDonor:
		m.ResetDonor()
		return nil
	case donation.EdgeProgram:
		m.ResetProgram()
		return nil
	case donation.EdgeCampaign:
		m.ResetCampaign()
		return nil
	}
	return fmt.Errorf("unknown Donation edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	title                        *map[string]string
	description                  *map[string]interface{}
	event_type                   *string
	start_date                   *time.Time
	end_date                     *time.Time
	capacity                     *int
	addcapacity                  *int
	status                       *event.Status
	is_virtual                   *bool
	meeting_url                  *string
	registration_required        *bool
	registration_deadline        *time.Time
	requires_approval            *bool
	tags                         *[]string
	appendtags                   []string
	image_url                    *string
	corporate_volunteer_friendly *bool
	alumni_only                  *bool
	major_donor_only             *bool
	created_at                   *time.Time
	updated_at                   *time.Time
	clearedFields                map[string]struct{}
	program                      *int
	clearedprogram               bool
	created_by                   *int
	clearedcreated_by            bool
	registrations                map[int]struct{}
	removedregistrations         map[int]struct{}
	clearedregistrations         bool
	agenda                       *int
	clearedagenda                bool
	location                     *int
	clearedlocation              bool
	done                         bool
	oldValue                     func(context.Context) (*Event, error)
	predicates                   []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *EventMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *EventMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EventMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *EventMutation) SetDescription(value map[string]interface{}) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *EventMutation) Description() (r map[string]interface{}, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDescription(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *EventMutation) ResetDescription() {
	m.description = nil
}

// SetEventType sets the "event_type" field.
func (m *EventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *EventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *EventMutation) ResetEventType() {
	m.event_type = nil
}

// SetStartDate sets the "start_date" field.
func (m *EventMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *EventMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *EventMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *EventMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *EventMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *EventMutation) ResetEndDate() {
	m.end_date = nil
}

// SetCapacity sets the "capacity" field.
func (m *EventMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *EventMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *EventMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *EventMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCapacity clears the value of the "capacity" field.
func (m *EventMutation) ClearCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	m.clearedFields[event.FieldCapacity] = struct{}{}
}

// CapacityCleared returns if the "capacity" field was cleared in this mutation.
func (m *EventMutation) CapacityCleared() bool {
	_, ok := m.clearedFields[event.FieldCapacity]
	return ok
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *EventMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	delete(m.clearedFields, event.FieldCapacity)
}

// SetStatus sets the "status" field.
func (m *EventMutation) SetStatus(e event.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EventMutation) Status() (r event.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStatus(ctx context.Context) (v event.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EventMutation) ResetStatus() {
	m.status = nil
}

// SetIsVirtual sets the "is_virtual" field.
func (m *EventMutation) SetIsVirtual(b bool) {
	m.is_virtual = &b
}

// IsVirtual returns the value of the "is_virtual" field in the mutation.
func (m *EventMutation) IsVirtual() (r bool, exists bool) {
	v := m.is_virtual
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVirtual returns the old "is_virtual" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsVirtual(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVirtual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVirtual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVirtual: %w", err)
	}
	return oldValue.IsVirtual, nil
}

// ResetIsVirtual resets all changes to the "is_virtual" field.
func (m *EventMutation) ResetIsVirtual() {
	m.is_virtual = nil
}

// SetMeetingURL sets the "meeting_url" field.
func (m *EventMutation) SetMeetingURL(s string) {
	m.meeting_url = &s
}

// MeetingURL returns the value of the "meeting_url" field in the mutation.
func (m *EventMutation) MeetingURL() (r string, exists bool) {
	v := m.meeting_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMeetingURL returns the old "meeting_url" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMeetingURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeetingURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeetingURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeetingURL: %w", err)
	}
	return oldValue.MeetingURL, nil
}

// ClearMeetingURL clears the value of the "meeting_url" field.
func (m *EventMutation) ClearMeetingURL() {
	m.meeting_url = nil
	m.clearedFields[event.FieldMeetingURL] = struct{}{}
}

// MeetingURLCleared returns if the "meeting_url" field was cleared in this mutation.
func (m *EventMutation) MeetingURLCleared() bool {
	_, ok := m.clearedFields[event.FieldMeetingURL]
	return ok
}

// ResetMeetingURL resets all changes to the "meeting_url" field.
func (m *EventMutation) ResetMeetingURL() {
	m.meeting_url = nil
	delete(m.clearedFields, event.FieldMeetingURL)
}

// SetRegistrationRequired sets the "registration_required" field.
func (m *EventMutation) SetRegistrationRequired(b bool) {
	m.registration_required = &b
}

// RegistrationRequired returns the value of the "registration_required" field in the mutation.
func (m *EventMutation) RegistrationRequired() (r bool, exists bool) {
	v := m.registration_required
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationRequired returns the old "registration_required" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldRegistrationRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationRequired: %w", err)
	}
	return oldValue.RegistrationRequired, nil
}

// ResetRegistrationRequired resets all changes to the "registration_required" field.
func (m *EventMutation) ResetRegistrationRequired() {
	m.registration_required = nil
}

// SetRegistrationDeadline sets the "registration_deadline" field.
func (m *EventMutation) SetRegistrationDeadline(t time.Time) {
	m.registration_deadline = &t
}

// RegistrationDeadline returns the value of the "registration_deadline" field in the mutation.
func (m *EventMutation) RegistrationDeadline() (r time.Time, exists bool) {
	v := m.registration_deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationDeadline returns the old "registration_deadline" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldRegistrationDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationDeadline: %w", err)
	}
	return oldValue.RegistrationDeadline, nil
}

// ClearRegistrationDeadline clears the value of the "registration_deadline" field.
func (m *EventMutation) ClearRegistrationDeadline() {
	m.registration_deadline = nil
	m.clearedFields[event.FieldRegistrationDeadline] = struct{}{}
}

// RegistrationDeadlineCleared returns if the "registration_deadline" field was cleared in this mutation.
func (m *EventMutation) RegistrationDeadlineCleared() bool {
	_, ok := m.clearedFields[event.FieldRegistrationDeadline]
	return ok
}

// ResetRegistrationDeadline resets all changes to the "registration_deadline" field.
func (m *EventMutation) ResetRegistrationDeadline() {
	m.registration_deadline = nil
	delete(m.clearedFields, event.FieldRegistrationDeadline)
}

// SetRequiresApproval sets the "requires_approval" field.
func (m *EventMutation) SetRequiresApproval(b bool) {
	m.requires_approval = &b
}

// RequiresApproval returns the value of the "requires_approval" field in the mutation.
func (m *EventMutation) RequiresApproval() (r bool, exists bool) {
	v := m.requires_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresApproval returns the old "requires_approval" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldRequiresApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresApproval: %w", err)
	}
	return oldValue.RequiresApproval, nil
}

// ResetRequiresApproval resets all changes to the "requires_approval" field.
func (m *EventMutation) ResetRequiresApproval() {
	m.requires_approval = nil
}

// SetTags sets the "tags" field.
func (m *EventMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EventMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EventMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EventMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *EventMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetImageURL sets the "image_url" field.
func (m *EventMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *EventMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *EventMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[event.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *EventMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[event.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *EventMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, event.FieldImageURL)
}

// SetCorporateVolunteerFriendly sets the "corporate_volunteer_friendly" field.
func (m *EventMutation) SetCorporateVolunteerFriendly(b bool) {
	m.corporate_volunteer_friendly = &b
}

// CorporateVolunteerFriendly returns the value of the "corporate_volunteer_friendly" field in the mutation.
func (m *EventMutation) CorporateVolunteerFriendly() (r bool, exists bool) {
	v := m.corporate_volunteer_friendly
	if v == nil {
		return
	}
	return *v, true
}

// OldCorporateVolunteerFriendly returns the old "corporate_volunteer_friendly" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCorporateVolunteerFriendly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorporateVolunteerFriendly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorporateVolunteerFriendly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorporateVolunteerFriendly: %w", err)
	}
	return oldValue.CorporateVolunteerFriendly, nil
}

// ResetCorporateVolunteerFriendly resets all changes to the "corporate_volunteer_friendly" field.
func (m *EventMutation) ResetCorporateVolunteerFriendly() {
	m.corporate_volunteer_friendly = nil
}

// SetAlumniOnly sets the "alumni_only" field.
func (m *EventMutation) SetAlumniOnly(b bool) {
	m.alumni_only = &b
}

// AlumniOnly returns the value of the "alumni_only" field in the mutation.
func (m *EventMutation) AlumniOnly() (r bool, exists bool) {
	v := m.alumni_only
	if v == nil {
		return
	}
	return *v, true
}

// OldAlumniOnly returns the old "alumni_only" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAlumniOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlumniOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlumniOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlumniOnly: %w", err)
	}
	return oldValue.AlumniOnly, nil
}

// ResetAlumniOnly resets all changes to the "alumni_only" field.
func (m *EventMutation) ResetAlumniOnly() {
	m.alumni_only = nil
}

// SetMajorDonorOnly sets the "major_donor_only" field.
func (m *EventMutation) SetMajorDonorOnly(b bool) {
	m.major_donor_only = &b
}

// MajorDonorOnly returns the value of the "major_donor_only" field in the mutation.
func (m *EventMutation) MajorDonorOnly() (r bool, exists bool) {
	v := m.major_donor_only
	if v == nil {
		return
	}
	return *v, true
}

// OldMajorDonorOnly returns the old "major_donor_only" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMajorDonorOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMajorDonorOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMajorDonorOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMajorDonorOnly: %w", err)
	}
	return oldValue.MajorDonorOnly, nil
}

// ResetMajorDonorOnly resets all changes to the "major_donor_only" field.
func (m *EventMutation) ResetMajorDonorOnly() {
	m.major_donor_only = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProgramID sets the "program" edge to the Program entity by id.
func (m *EventMutation) SetProgramID(id int) {
	m.program = &id
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *EventMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *EventMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// ProgramID returns the "program" edge ID in the mutation.
func (m *EventMutation) ProgramID() (id int, exists bool) {
	if m.program != nil {
		return *m.program, true
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgramID instead. It exists only for internal usage by the builders.
func (m *EventMutation) ProgramIDs() (ids []int) {
	if id := m.program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *EventMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *EventMutation) SetCreatedByID(id int) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *EventMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *EventMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *EventMutation) CreatedByID() (id int, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *EventMutation) CreatedByIDs() (ids []int) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *EventMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddRegistrationIDs adds the "registrations" edge to the EventRegistration entity by ids.
func (m *EventMutation) AddRegistrationIDs(ids ...int) {
	if m.registrations == nil {
		m.registrations = make(map[int]struct{})
	}
	for i := range ids {
		m.registrations[ids[i]] = struct{}{}
	}
}

// ClearRegistrations clears the "registrations" edge to the EventRegistration entity.
func (m *EventMutation) ClearRegistrations() {
	m.clearedregistrations = true
}

// RegistrationsCleared reports if the "registrations" edge to the EventRegistration entity was cleared.
func (m *EventMutation) RegistrationsCleared() bool {
	return m.clearedregistrations
}

// RemoveRegistrationIDs removes the "registrations" edge to the EventRegistration entity by IDs.
func (m *EventMutation) RemoveRegistrationIDs(ids ...int) {
	if m.removedregistrations == nil {
		m.removedregistrations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.registrations, ids[i])
		m.removedregistrations[ids[i]] = struct{}{}
	}
}

// RemovedRegistrations returns the removed IDs of the "registrations" edge to the EventRegistration entity.
func (m *EventMutation) RemovedRegistrationsIDs() (ids []int) {
	for id := range m.removedregistrations {
		ids = append(ids, id)
	}
	return
}

// RegistrationsIDs returns the "registrations" edge IDs in the mutation.
func (m *EventMutation) RegistrationsIDs() (ids []int) {
	for id := range m.registrations {
		ids = append(ids, id)
	}
	return
}

// ResetRegistrations resets all changes to the "registrations" edge.
func (m *EventMutation) ResetRegistrations() {
	m.registrations = nil
	m.clearedregistrations = false
	m.removedregistrations = nil
}

// SetAgendaID sets the "agenda" edge to the Agenda entity by id.
func (m *EventMutation) SetAgendaID(id int) {
	m.agenda = &id
}

// ClearAgenda clears the "agenda" edge to the Agenda entity.
func (m *EventMutation) ClearAgenda() {
	m.clearedagenda = true
}

// AgendaCleared reports if the "agenda" edge to the Agenda entity was cleared.
func (m *EventMutation) AgendaCleared() bool {
	return m.clearedagenda
}

// AgendaID returns the "agenda" edge ID in the mutation.
func (m *EventMutation) AgendaID() (id int, exists bool) {
	if m.agenda != nil {
		return *m.agenda, true
	}
	return
}

// AgendaIDs returns the "agenda" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgendaID instead. It exists only for internal usage by the builders.
func (m *EventMutation) AgendaIDs() (ids []int) {
	if id := m.agenda; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgenda resets all changes to the "agenda" edge.
func (m *EventMutation) ResetAgenda() {
	m.agenda = nil
	m.clearedagenda = false
}

// SetLocationID sets the "location" edge to the Address entity by id.
func (m *EventMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the Address entity.
func (m *EventMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Address entity was cleared.
func (m *EventMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *EventMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *EventMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *EventMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.title != nil {
		fields = append(fields, event.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, event.FieldDescription)
	}
	if m.event_type != nil {
		fields = append(fields, event.FieldEventType)
	}
	if m.start_date != nil {
		fields = append(fields, event.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, event.FieldEndDate)
	}
	if m.capacity != nil {
		fields = append(fields, event.FieldCapacity)
	}
	if m.status != nil {
		fields = append(fields, event.FieldStatus)
	}
	if m.is_virtual != nil {
		fields = append(fields, event.FieldIsVirtual)
	}
	if m.meeting_url != nil {
		fields = append(fields, event.FieldMeetingURL)
	}
	if m.registration_required != nil {
		fields = append(fields, event.FieldRegistrationRequired)
	}
	if m.registration_deadline != nil {
		fields = append(fields, event.FieldRegistrationDeadline)
	}
	if m.requires_approval != nil {
		fields = append(fields, event.FieldRequiresApproval)
	}
	if m.tags != nil {
		fields = append(fields, event.FieldTags)
	}
	if m.image_url != nil {
		fields = append(fields, event.FieldImageURL)
	}
	if m.corporate_volunteer_friendly != nil {
		fields = append(fields, event.FieldCorporateVolunteerFriendly)
	}
	if m.alumni_only != nil {
		fields = append(fields, event.FieldAlumniOnly)
	}
	if m.major_donor_only != nil {
		fields = append(fields, event.FieldMajorDonorOnly)
	}
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldTitle:
		return m.Title()
	case event.FieldDescription:
		return m.Description()
	case event.FieldEventType:
		return m.EventType()
	case event.FieldStartDate:
		return m.StartDate()
	case event.FieldEndDate:
		return m.EndDate()
	case event.FieldCapacity:
		return m.Capacity()
	case event.FieldStatus:
		return m.Status()
	case event.FieldIsVirtual:
		return m.IsVirtual()
	case event.FieldMeetingURL:
		return m.MeetingURL()
	case event.FieldRegistrationRequired:
		return m.RegistrationRequired()
	case event.FieldRegistrationDeadline:
		return m.RegistrationDeadline()
	case event.FieldRequiresApproval:
		return m.RequiresApproval()
	case event.FieldTags:
		return m.Tags()
	case event.FieldImageURL:
		return m.ImageURL()
	case event.FieldCorporateVolunteerFriendly:
		return m.CorporateVolunteerFriendly()
	case event.FieldAlumniOnly:
		return m.AlumniOnly()
	case event.FieldMajorDonorOnly:
		return m.MajorDonorOnly()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldTitle:
		return m.OldTitle(ctx)
	case event.FieldDescription:
		return m.OldDescription(ctx)
	case event.FieldEventType:
		return m.OldEventType(ctx)
	case event.FieldStartDate:
		return m.OldStartDate(ctx)
	case event.FieldEndDate:
		return m.OldEndDate(ctx)
	case event.FieldCapacity:
		return m.OldCapacity(ctx)
	case event.FieldStatus:
		return m.OldStatus(ctx)
	case event.FieldIsVirtual:
		return m.OldIsVirtual(ctx)
	case event.FieldMeetingURL:
		return m.OldMeetingURL(ctx)
	case event.FieldRegistrationRequired:
		return m.OldRegistrationRequired(ctx)
	case event.FieldRegistrationDeadline:
		return m.OldRegistrationDeadline(ctx)
	case event.FieldRequiresApproval:
		return m.OldRequiresApproval(ctx)
	case event.FieldTags:
		return m.OldTags(ctx)
	case event.FieldImageURL:
		return m.OldImageURL(ctx)
	case event.FieldCorporateVolunteerFriendly:
		return m.OldCorporateVolunteerFriendly(ctx)
	case event.FieldAlumniOnly:
		return m.OldAlumniOnly(ctx)
	case event.FieldMajorDonorOnly:
		return m.OldMajorDonorOnly(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case event.FieldDescription:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case event.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case event.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case event.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case event.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case event.FieldStatus:
		v, ok := value.(event.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case event.FieldIsVirtual:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVirtual(v)
		return nil
	case event.FieldMeetingURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeetingURL(v)
		return nil
	case event.FieldRegistrationRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationRequired(v)
		return nil
	case event.FieldRegistrationDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationDeadline(v)
		return nil
	case event.FieldRequiresApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresApproval(v)
		return nil
	case event.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case event.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case event.FieldCorporateVolunteerFriendly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorporateVolunteerFriendly(v)
		return nil
	case event.FieldAlumniOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlumniOnly(v)
		return nil
	case event.FieldMajorDonorOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMajorDonorOnly(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addcapacity != nil {
		fields = append(fields, event.FieldCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCapacity:
		return m.AddedCapacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldCapacity) {
		fields = append(fields, event.FieldCapacity)
	}
	if m.FieldCleared(event.FieldMeetingURL) {
		fields = append(fields, event.FieldMeetingURL)
	}
	if m.FieldCleared(event.FieldRegistrationDeadline) {
		fields = append(fields, event.FieldRegistrationDeadline)
	}
	if m.FieldCleared(event.FieldImageURL) {
		fields = append(fields, event.FieldImageURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldCapacity:
		m.ClearCapacity()
		return nil
	case event.FieldMeetingURL:
		m.ClearMeetingURL()
		return nil
	case event.FieldRegistrationDeadline:
		m.ClearRegistrationDeadline()
		return nil
	case event.FieldImageURL:
		m.ClearImageURL()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldTitle:
		m.ResetTitle()
		return nil
	case event.FieldDescription:
		m.ResetDescription()
		return nil
	case event.FieldEventType:
		m.ResetEventType()
		return nil
	case event.FieldStartDate:
		m.ResetStartDate()
		return nil
	case event.FieldEndDate:
		m.ResetEndDate()
		return nil
	case event.FieldCapacity:
		m.ResetCapacity()
		return nil
	case event.FieldStatus:
		m.ResetStatus()
		return nil
	case event.FieldIsVirtual:
		m.ResetIsVirtual()
		return nil
	case event.FieldMeetingURL:
		m.ResetMeetingURL()
		return nil
	case event.FieldRegistrationRequired:
		m.ResetRegistrationRequired()
		return nil
	case event.FieldRegistrationDeadline:
		m.ResetRegistrationDeadline()
		return nil
	case event.FieldRequiresApproval:
		m.ResetRequiresApproval()
		return nil
	case event.FieldTags:
		m.ResetTags()
		return nil
	case event.FieldImageURL:
		m.ResetImageURL()
		return nil
	case event.FieldCorporateVolunteerFriendly:
		m.ResetCorporateVolunteerFriendly()
		return nil
	case event.FieldAlumniOnly:
		m.ResetAlumniOnly()
		return nil
	case event.FieldMajorDonorOnly:
		m.ResetMajorDonorOnly()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.program != nil {
		edges = append(edges, event.EdgeProgram)
	}
	if m.created_by != nil {
		edges = append(edges, event.EdgeCreatedBy)
	}
	if m.registrations != nil {
		edges = append(edges, event.EdgeRegistrations)
	}
	if m.agenda != nil {
		edges = append(edges, event.EdgeAgenda)
	}
	if m.location != nil {
		edges = append(edges, event.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeProgram:
		if id := m.program; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeRegistrations:
		ids := make([]ent.Value, 0, len(m.registrations))
		for id := range m.registrations {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeAgenda:
		if id := m.agenda; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedregistrations != nil {
		edges = append(edges, event.EdgeRegistrations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeRegistrations:
		ids := make([]ent.Value, 0, len(m.removedregistrations))
		for id := range m.removedregistrations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedprogram {
		edges = append(edges, event.EdgeProgram)
	}
	if m.clearedcreated_by {
		edges = append(edges, event.EdgeCreatedBy)
	}
	if m.clearedregistrations {
		edges = append(edges, event.EdgeRegistrations)
	}
	if m.clearedagenda {
		edges = append(edges, event.EdgeAgenda)
	}
	if m.clearedlocation {
		edges = append(edges, event.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeProgram:
		return m.clearedprogram
	case event.EdgeCreatedBy:
		return m.clearedcreated_by
	case event.EdgeRegistrations:
		return m.clearedregistrations
	case event.EdgeAgenda:
		return m.clearedagenda
	case event.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeProgram:
		m.ClearProgram()
		return nil
	case event.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case event.EdgeAgenda:
		m.ClearAgenda()
		return nil
	case event.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeProgram:
		m.ResetProgram()
		return nil
	case event.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case event.EdgeRegistrations:
		m.ResetRegistrations()
		return nil
	case event.EdgeAgenda:
		m.ResetAgenda()
		return nil
	case event.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// EventRegistrationMutation represents an operation that mutates the EventRegistration nodes in the graph.
type EventRegistrationMutation struct {
	config
	op                Op
	typ               string
	id                *int
	status            *eventregistration.Status
	attendance_status *eventregistration.AttendanceStatus
	registration_data *map[string]interface{}
	feedback          *map[string]interface{}
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	event             *int
	clearedevent      bool
	user              *int
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*EventRegistration, error)
	predicates        []predicate.EventRegistration
}

var _ ent.Mutation = (*EventRegistrationMutation)(nil)

// eventregistrationOption allows management of the mutation configuration using functional options.
type eventregistrationOption func(*EventRegistrationMutation)

// newEventRegistrationMutation creates new mutation for the EventRegistration entity.
func newEventRegistrationMutation(c config, op Op, opts ...eventregistrationOption) *EventRegistrationMutation {
	m := &EventRegistrationMutation{
		config:        c,
		op:            op,
		typ:           TypeEventRegistration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventRegistrationID sets the ID field of the mutation.
func withEventRegistrationID(id int) eventregistrationOption {
	return func(m *EventRegistrationMutation) {
		var (
			err   error
			once  sync.Once
			value *EventRegistration
		)
		m.oldValue = func(ctx context.Context) (*EventRegistration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventRegistration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventRegistration sets the old EventRegistration of the mutation.
func withEventRegistration(node *EventRegistration) eventregistrationOption {
	return func(m *EventRegistrationMutation) {
		m.oldValue = func(context.Context) (*EventRegistration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventRegistrationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventRegistrationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventRegistrationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventRegistrationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventRegistration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *EventRegistrationMutation) SetStatus(e eventregistration.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EventRegistrationMutation) Status() (r eventregistration.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EventRegistration entity.
// If the EventRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventRegistrationMutation) OldStatus(ctx context.Context) (v eventregistration.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EventRegistrationMutation) ResetStatus() {
	m.status = nil
}

// SetAttendanceStatus sets the "attendance_status" field.
func (m *EventRegistrationMutation) SetAttendanceStatus(es eventregistration.AttendanceStatus) {
	m.attendance_status = &es
}

// AttendanceStatus returns the value of the "attendance_status" field in the mutation.
func (m *EventRegistrationMutation) AttendanceStatus() (r eventregistration.AttendanceStatus, exists bool) {
	v := m.attendance_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAttendanceStatus returns the old "attendance_status" field's value of the EventRegistration entity.
// If the EventRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventRegistrationMutation) OldAttendanceStatus(ctx context.Context) (v eventregistration.AttendanceStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttendanceStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttendanceStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttendanceStatus: %w", err)
	}
	return oldValue.AttendanceStatus, nil
}

// ResetAttendanceStatus resets all changes to the "attendance_status" field.
func (m *EventRegistrationMutation) ResetAttendanceStatus() {
	m.attendance_status = nil
}

// SetRegistrationData sets the "registration_data" field.
func (m *EventRegistrationMutation) SetRegistrationData(value map[string]interface{}) {
	m.registration_data = &value
}

// RegistrationData returns the value of the "registration_data" field in the mutation.
func (m *EventRegistrationMutation) RegistrationData() (r map[string]interface{}, exists bool) {
	v := m.registration_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationData returns the old "registration_data" field's value of the EventRegistration entity.
// If the EventRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventRegistrationMutation) OldRegistrationData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationData: %w", err)
	}
	return oldValue.RegistrationData, nil
}

// ClearRegistrationData clears the value of the "registration_data" field.
func (m *EventRegistrationMutation) ClearRegistrationData() {
	m.registration_data = nil
	m.clearedFields[eventregistration.FieldRegistrationData] = struct{}{}
}

// RegistrationDataCleared returns if the "registration_data" field was cleared in this mutation.
func (m *EventRegistrationMutation) RegistrationDataCleared() bool {
	_, ok := m.clearedFields[eventregistration.FieldRegistrationData]
	return ok
}

// ResetRegistrationData resets all changes to the "registration_data" field.
func (m *EventRegistrationMutation) ResetRegistrationData() {
	m.registration_data = nil
	delete(m.clearedFields, eventregistration.FieldRegistrationData)
}

// SetFeedback sets the "feedback" field.
func (m *EventRegistrationMutation) SetFeedback(value map[string]interface{}) {
	m.feedback = &value
}

// Feedback returns the value of the "feedback" field in the mutation.
func (m *EventRegistrationMutation) Feedback() (r map[string]interface{}, exists bool) {
	v := m.feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedback returns the old "feedback" field's value of the EventRegistration entity.
// If the EventRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventRegistrationMutation) OldFeedback(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedback: %w", err)
	}
	return oldValue.Feedback, nil
}

// ClearFeedback clears the value of the "feedback" field.
func (m *EventRegistrationMutation) ClearFeedback() {
	m.feedback = nil
	m.clearedFields[eventregistration.FieldFeedback] = struct{}{}
}

// FeedbackCleared returns if the "feedback" field was cleared in this mutation.
func (m *EventRegistrationMutation) FeedbackCleared() bool {
	_, ok := m.clearedFields[eventregistration.FieldFeedback]
	return ok
}

// ResetFeedback resets all changes to the "feedback" field.
func (m *EventRegistrationMutation) ResetFeedback() {
	m.feedback = nil
	delete(m.clearedFields, eventregistration.FieldFeedback)
}

// SetCreatedAt sets the "created_at" field.
func (m *EventRegistrationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventRegistrationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EventRegistration entity.
// If the EventRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventRegistrationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventRegistrationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventRegistrationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventRegistrationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EventRegistration entity.
// If the EventRegistration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventRegistrationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventRegistrationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *EventRegistrationMutation) SetEventID(id int) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *EventRegistrationMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *EventRegistrationMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *EventRegistrationMutation) EventID() (id int, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *EventRegistrationMutation) EventIDs() (ids []int) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *EventRegistrationMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *EventRegistrationMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *EventRegistrationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EventRegistrationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *EventRegistrationMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EventRegistrationMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EventRegistrationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the EventRegistrationMutation builder.
func (m *EventRegistrationMutation) Where(ps ...predicate.EventRegistration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventRegistrationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventRegistrationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventRegistration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventRegistrationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventRegistrationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventRegistration).
func (m *EventRegistrationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventRegistrationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.status != nil {
		fields = append(fields, eventregistration.FieldStatus)
	}
	if m.attendance_status != nil {
		fields = append(fields, eventregistration.FieldAttendanceStatus)
	}
	if m.registration_data != nil {
		fields = append(fields, eventregistration.FieldRegistrationData)
	}
	if m.feedback != nil {
		fields = append(fields, eventregistration.FieldFeedback)
	}
	if m.created_at != nil {
		fields = append(fields, eventregistration.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, eventregistration.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventRegistrationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventregistration.FieldStatus:
		return m.Status()
	case eventregistration.FieldAttendanceStatus:
		return m.AttendanceStatus()
	case eventregistration.FieldRegistrationData:
		return m.RegistrationData()
	case eventregistration.FieldFeedback:
		return m.Feedback()
	case eventregistration.FieldCreatedAt:
		return m.CreatedAt()
	case eventregistration.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventRegistrationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventregistration.FieldStatus:
		return m.OldStatus(ctx)
	case eventregistration.FieldAttendanceStatus:
		return m.OldAttendanceStatus(ctx)
	case eventregistration.FieldRegistrationData:
		return m.OldRegistrationData(ctx)
	case eventregistration.FieldFeedback:
		return m.OldFeedback(ctx)
	case eventregistration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case eventregistration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EventRegistration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventRegistrationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventregistration.FieldStatus:
		v, ok := value.(eventregistration.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case eventregistration.FieldAttendanceStatus:
		v, ok := value.(eventregistration.AttendanceStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttendanceStatus(v)
		return nil
	case eventregistration.FieldRegistrationData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationData(v)
		return nil
	case eventregistration.FieldFeedback:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedback(v)
		return nil
	case eventregistration.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case eventregistration.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EventRegistration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventRegistrationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventRegistrationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventRegistrationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventRegistration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventRegistrationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventregistration.FieldRegistrationData) {
		fields = append(fields, eventregistration.FieldRegistrationData)
	}
	if m.FieldCleared(eventregistration.FieldFeedback) {
		fields = append(fields, eventregistration.FieldFeedback)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventRegistrationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventRegistrationMutation) ClearField(name string) error {
	switch name {
	case eventregistration.FieldRegistrationData:
		m.ClearRegistrationData()
		return nil
	case eventregistration.FieldFeedback:
		m.ClearFeedback()
		return nil
	}
	return fmt.Errorf("unknown EventRegistration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventRegistrationMutation) ResetField(name string) error {
	switch name {
	case eventregistration.FieldStatus:
		m.ResetStatus()
		return nil
	case eventregistration.FieldAttendanceStatus:
		m.ResetAttendanceStatus()
		return nil
	case eventregistration.FieldRegistrationData:
		m.ResetRegistrationData()
		return nil
	case eventregistration.FieldFeedback:
		m.ResetFeedback()
		return nil
	case eventregistration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case eventregistration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown EventRegistration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventRegistrationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.event != nil {
		edges = append(edges, eventregistration.EdgeEvent)
	}
	if m.user != nil {
		edges = append(edges, eventregistration.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventRegistrationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventregistration.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case eventregistration.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventRegistrationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventRegistrationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventRegistrationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevent {
		edges = append(edges, eventregistration.EdgeEvent)
	}
	if m.cleareduser {
		edges = append(edges, eventregistration.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventRegistrationMutation) EdgeCleared(name string) bool {
	switch name {
	case eventregistration.EdgeEvent:
		return m.clearedevent
	case eventregistration.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventRegistrationMutation) ClearEdge(name string) error {
	switch name {
	case eventregistration.EdgeEvent:
		m.ClearEvent()
		return nil
	case eventregistration.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown EventRegistration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventRegistrationMutation) ResetEdge(name string) error {
	switch name {
	case eventregistration.EdgeEvent:
		m.ResetEvent()
		return nil
	case eventregistration.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown EventRegistration edge %s", name)
}

// FaqItemMutation represents an operation that mutates the FaqItem nodes in the graph.
type FaqItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_order        *int
	add_order     *int
	question      *map[string]string
	answer        *map[string]string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	block         *int
	clearedblock  bool
	done          bool
	oldValue      func(context.Context) (*FaqItem, error)
	predicates    []predicate.FaqItem
}

var _ ent.Mutation = (*FaqItemMutation)(nil)

// faqitemOption allows management of the mutation configuration using functional options.
type faqitemOption func(*FaqItemMutation)

// newFaqItemMutation creates new mutation for the FaqItem entity.
func newFaqItemMutation(c config, op Op, opts ...faqitemOption) *FaqItemMutation {
	m := &FaqItemMutation{
		config:        c,
		op:            op,
		typ:           TypeFaqItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFaqItemID sets the ID field of the mutation.
func withFaqItemID(id int) faqitemOption {
	return func(m *FaqItemMutation) {
		var (
			err   error
			once  sync.Once
			value *FaqItem
		)
		m.oldValue = func(ctx context.Context) (*FaqItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FaqItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFaqItem sets the old FaqItem of the mutation.
func withFaqItem(node *FaqItem) faqitemOption {
	return func(m *FaqItemMutation) {
		m.oldValue = func(context.Context) (*FaqItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FaqItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FaqItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FaqItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FaqItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FaqItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *FaqItemMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *FaqItemMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the FaqItem entity.
// If the FaqItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaqItemMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *FaqItemMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *FaqItemMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *FaqItemMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetQuestion sets the "question" field.
func (m *FaqItemMutation) SetQuestion(value map[string]string) {
	m.question = &value
}

// Question returns the value of the "question" field in the mutation.
func (m *FaqItemMutation) Question() (r map[string]string, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestion returns the old "question" field's value of the FaqItem entity.
// If the FaqItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaqItemMutation) OldQuestion(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestion: %w", err)
	}
	return oldValue.Question, nil
}

// ResetQuestion resets all changes to the "question" field.
func (m *FaqItemMutation) ResetQuestion() {
	m.question = nil
}

// SetAnswer sets the "answer" field.
func (m *FaqItemMutation) SetAnswer(value map[string]string) {
	m.answer = &value
}

// Answer returns the value of the "answer" field in the mutation.
func (m *FaqItemMutation) Answer() (r map[string]string, exists bool) {
	v := m.answer
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswer returns the old "answer" field's value of the FaqItem entity.
// If the FaqItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaqItemMutation) OldAnswer(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswer: %w", err)
	}
	return oldValue.Answer, nil
}

// ResetAnswer resets all changes to the "answer" field.
func (m *FaqItemMutation) ResetAnswer() {
	m.answer = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FaqItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FaqItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FaqItem entity.
// If the FaqItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaqItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FaqItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FaqItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FaqItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FaqItem entity.
// If the FaqItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FaqItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FaqItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBlockID sets the "block" edge to the BlockFaq entity by id.
func (m *FaqItemMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the BlockFaq entity.
func (m *FaqItemMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the BlockFaq entity was cleared.
func (m *FaqItemMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *FaqItemMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *FaqItemMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *FaqItemMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// Where appends a list predicates to the FaqItemMutation builder.
func (m *FaqItemMutation) Where(ps ...predicate.FaqItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FaqItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FaqItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FaqItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FaqItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FaqItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FaqItem).
func (m *FaqItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FaqItemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._order != nil {
		fields = append(fields, faqitem.FieldOrder)
	}
	if m.question != nil {
		fields = append(fields, faqitem.FieldQuestion)
	}
	if m.answer != nil {
		fields = append(fields, faqitem.FieldAnswer)
	}
	if m.created_at != nil {
		fields = append(fields, faqitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, faqitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FaqItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case faqitem.FieldOrder:
		return m.Order()
	case faqitem.FieldQuestion:
		return m.Question()
	case faqitem.FieldAnswer:
		return m.Answer()
	case faqitem.FieldCreatedAt:
		return m.CreatedAt()
	case faqitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FaqItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case faqitem.FieldOrder:
		return m.OldOrder(ctx)
	case faqitem.FieldQuestion:
		return m.OldQuestion(ctx)
	case faqitem.FieldAnswer:
		return m.OldAnswer(ctx)
	case faqitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case faqitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FaqItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FaqItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case faqitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case faqitem.FieldQuestion:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestion(v)
		return nil
	case faqitem.FieldAnswer:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswer(v)
		return nil
	case faqitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case faqitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FaqItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FaqItemMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, faqitem.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FaqItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case faqitem.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FaqItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case faqitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown FaqItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FaqItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FaqItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FaqItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FaqItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FaqItemMutation) ResetField(name string) error {
	switch name {
	case faqitem.FieldOrder:
		m.ResetOrder()
		return nil
	case faqitem.FieldQuestion:
		m.ResetQuestion()
		return nil
	case faqitem.FieldAnswer:
		m.ResetAnswer()
		return nil
	case faqitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case faqitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FaqItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FaqItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.block != nil {
		edges = append(edges, faqitem.EdgeBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FaqItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case faqitem.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FaqItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FaqItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FaqItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblock {
		edges = append(edges, faqitem.EdgeBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FaqItemMutation) EdgeCleared(name string) bool {
	switch name {
	case faqitem.EdgeBlock:
		return m.clearedblock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FaqItemMutation) ClearEdge(name string) error {
	switch name {
	case faqitem.EdgeBlock:
		m.ClearBlock()
		return nil
	}
	return fmt.Errorf("unknown FaqItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FaqItemMutation) ResetEdge(name string) error {
	switch name {
	case faqitem.EdgeBlock:
		m.ResetBlock()
		return nil
	}
	return fmt.Errorf("unknown FaqItem edge %s", name)
}

// FeatureFlagMutation represents an operation that mutates the FeatureFlag nodes in the graph.
type FeatureFlagMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	description            *string
	is_active              *bool
	rollout_percentage     *int
	addrollout_percentage  *int
	allowed_user_ids       *[]string
	appendallowed_user_ids []string
	allowed_roles          *[]string
	appendallowed_roles    []string
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*FeatureFlag, error)
	predicates             []predicate.FeatureFlag
}

var _ ent.Mutation = (*FeatureFlagMutation)(nil)

// featureflagOption allows management of the mutation configuration using functional options.
type featureflagOption func(*FeatureFlagMutation)

// newFeatureFlagMutation creates new mutation for the FeatureFlag entity.
func newFeatureFlagMutation(c config, op Op, opts ...featureflagOption) *FeatureFlagMutation {
	m := &FeatureFlagMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatureFlag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureFlagID sets the ID field of the mutation.
func withFeatureFlagID(id string) featureflagOption {
	return func(m *FeatureFlagMutation) {
		var (
			err   error
			once  sync.Once
			value *FeatureFlag
		)
		m.oldValue = func(ctx context.Context) (*FeatureFlag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeatureFlag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatureFlag sets the old FeatureFlag of the mutation.
func withFeatureFlag(node *FeatureFlag) featureflagOption {
	return func(m *FeatureFlagMutation) {
		m.oldValue = func(context.Context) (*FeatureFlag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureFlagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureFlagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeatureFlag entities.
func (m *FeatureFlagMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureFlagMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureFlagMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeatureFlag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *FeatureFlagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeatureFlagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeatureFlagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[featureflag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeatureFlagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[featureflag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeatureFlagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, featureflag.FieldDescription)
}

// SetIsActive sets the "is_active" field.
func (m *FeatureFlagMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *FeatureFlagMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *FeatureFlagMutation) ResetIsActive() {
	m.is_active = nil
}

// SetRolloutPercentage sets the "rollout_percentage" field.
func (m *FeatureFlagMutation) SetRolloutPercentage(i int) {
	m.rollout_percentage = &i
	m.addrollout_percentage = nil
}

// RolloutPercentage returns the value of the "rollout_percentage" field in the mutation.
func (m *FeatureFlagMutation) RolloutPercentage() (r int, exists bool) {
	v := m.rollout_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldRolloutPercentage returns the old "rollout_percentage" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldRolloutPercentage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRolloutPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRolloutPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRolloutPercentage: %w", err)
	}
	return oldValue.RolloutPercentage, nil
}

// AddRolloutPercentage adds i to the "rollout_percentage" field.
func (m *FeatureFlagMutation) AddRolloutPercentage(i int) {
	if m.addrollout_percentage != nil {
		*m.addrollout_percentage += i
	} else {
		m.addrollout_percentage = &i
	}
}

// AddedRolloutPercentage returns the value that was added to the "rollout_percentage" field in this mutation.
func (m *FeatureFlagMutation) AddedRolloutPercentage() (r int, exists bool) {
	v := m.addrollout_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ResetRolloutPercentage resets all changes to the "rollout_percentage" field.
func (m *FeatureFlagMutation) ResetRolloutPercentage() {
	m.rollout_percentage = nil
	m.addrollout_percentage = nil
}

// SetAllowedUserIds sets the "allowed_user_ids" field.
func (m *FeatureFlagMutation) SetAllowedUserIds(s []string) {
	m.allowed_user_ids = &s
	m.appendallowed_user_ids = nil
}

// AllowedUserIds returns the value of the "allowed_user_ids" field in the mutation.
func (m *FeatureFlagMutation) AllowedUserIds() (r []string, exists bool) {
	v := m.allowed_user_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedUserIds returns the old "allowed_user_ids" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldAllowedUserIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedUserIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedUserIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedUserIds: %w", err)
	}
	return oldValue.AllowedUserIds, nil
}

// AppendAllowedUserIds adds s to the "allowed_user_ids" field.
func (m *FeatureFlagMutation) AppendAllowedUserIds(s []string) {
	m.appendallowed_user_ids = append(m.appendallowed_user_ids, s...)
}

// AppendedAllowedUserIds returns the list of values that were appended to the "allowed_user_ids" field in this mutation.
func (m *FeatureFlagMutation) AppendedAllowedUserIds() ([]string, bool) {
	if len(m.appendallowed_user_ids) == 0 {
		return nil, false
	}
	return m.appendallowed_user_ids, true
}

// ResetAllowedUserIds resets all changes to the "allowed_user_ids" field.
func (m *FeatureFlagMutation) ResetAllowedUserIds() {
	m.allowed_user_ids = nil
	m.appendallowed_user_ids = nil
}

// SetAllowedRoles sets the "allowed_roles" field.
func (m *FeatureFlagMutation) SetAllowedRoles(s []string) {
	m.allowed_roles = &s
	m.appendallowed_roles = nil
}

// AllowedRoles returns the value of the "allowed_roles" field in the mutation.
func (m *FeatureFlagMutation) AllowedRoles() (r []string, exists bool) {
	v := m.allowed_roles
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedRoles returns the old "allowed_roles" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldAllowedRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedRoles: %w", err)
	}
	return oldValue.AllowedRoles, nil
}

// AppendAllowedRoles adds s to the "allowed_roles" field.
func (m *FeatureFlagMutation) AppendAllowedRoles(s []string) {
	m.appendallowed_roles = append(m.appendallowed_roles, s...)
}

// AppendedAllowedRoles returns the list of values that were appended to the "allowed_roles" field in this mutation.
func (m *FeatureFlagMutation) AppendedAllowedRoles() ([]string, bool) {
	if len(m.appendallowed_roles) == 0 {
		return nil, false
	}
	return m.appendallowed_roles, true
}

// ResetAllowedRoles resets all changes to the "allowed_roles" field.
func (m *FeatureFlagMutation) ResetAllowedRoles() {
	m.allowed_roles = nil
	m.appendallowed_roles = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureFlagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureFlagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureFlagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureFlagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureFlagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureFlagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the FeatureFlagMutation builder.
func (m *FeatureFlagMutation) Where(ps ...predicate.FeatureFlag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureFlagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureFlagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeatureFlag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureFlagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureFlagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeatureFlag).
func (m *FeatureFlagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureFlagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.description != nil {
		fields = append(fields, featureflag.FieldDescription)
	}
	if m.is_active != nil {
		fields = append(fields, featureflag.FieldIsActive)
	}
	if m.rollout_percentage != nil {
		fields = append(fields, featureflag.FieldRolloutPercentage)
	}
	if m.allowed_user_ids != nil {
		fields = append(fields, featureflag.FieldAllowedUserIds)
	}
	if m.allowed_roles != nil {
		fields = append(fields, featureflag.FieldAllowedRoles)
	}
	if m.created_at != nil {
		fields = append(fields, featureflag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, featureflag.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureFlagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featureflag.FieldDescription:
		return m.Description()
	case featureflag.FieldIsActive:
		return m.IsActive()
	case featureflag.FieldRolloutPercentage:
		return m.RolloutPercentage()
	case featureflag.FieldAllowedUserIds:
		return m.AllowedUserIds()
	case featureflag.FieldAllowedRoles:
		return m.AllowedRoles()
	case featureflag.FieldCreatedAt:
		return m.CreatedAt()
	case featureflag.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureFlagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featureflag.FieldDescription:
		return m.OldDescription(ctx)
	case featureflag.FieldIsActive:
		return m.OldIsActive(ctx)
	case featureflag.FieldRolloutPercentage:
		return m.OldRolloutPercentage(ctx)
	case featureflag.FieldAllowedUserIds:
		return m.OldAllowedUserIds(ctx)
	case featureflag.FieldAllowedRoles:
		return m.OldAllowedRoles(ctx)
	case featureflag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case featureflag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeatureFlag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureFlagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featureflag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case featureflag.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case featureflag.FieldRolloutPercentage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRolloutPercentage(v)
		return nil
	case featureflag.FieldAllowedUserIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedUserIds(v)
		return nil
	case featureflag.FieldAllowedRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedRoles(v)
		return nil
	case featureflag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case featureflag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureFlagMutation) AddedFields() []string {
	var fields []string
	if m.addrollout_percentage != nil {
		fields = append(fields, featureflag.FieldRolloutPercentage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureFlagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case featureflag.FieldRolloutPercentage:
		return m.AddedRolloutPercentage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureFlagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case featureflag.FieldRolloutPercentage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRolloutPercentage(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureFlagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featureflag.FieldDescription) {
		fields = append(fields, featureflag.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureFlagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureFlagMutation) ClearField(name string) error {
	switch name {
	case featureflag.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureFlagMutation) ResetField(name string) error {
	switch name {
	case featureflag.FieldDescription:
		m.ResetDescription()
		return nil
	case featureflag.FieldIsActive:
		m.ResetIsActive()
		return nil
	case featureflag.FieldRolloutPercentage:
		m.ResetRolloutPercentage()
		return nil
	case featureflag.FieldAllowedUserIds:
		m.ResetAllowedUserIds()
		return nil
	case featureflag.FieldAllowedRoles:
		m.ResetAllowedRoles()
		return nil
	case featureflag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case featureflag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureFlagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureFlagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureFlagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureFlagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureFlagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureFlagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureFlagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FeatureFlag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureFlagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FeatureFlag edge %s", name)
}

// FundraisingCampaignMutation represents an operation that mutates the FundraisingCampaign nodes in the graph.
type FundraisingCampaignMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	slug                   *string
	title                  *map[string]string
	description            *map[string]interface{}
	story                  *map[string]interface{}
	_type                  *string
	category               *string
	target_amount          *float64
	addtarget_amount       *float64
	current_amount         *float64
	addcurrent_amount      *float64
	currency               *string
	minimum_donation       *float64
	addminimum_donation    *float64
	start_date             *time.Time
	end_date               *time.Time
	is_active              *bool
	hero_image_url         *string
	video_url              *string
	gallery_images         *[]string
	appendgallery_images   []string
	manager_id             *string
	is_public              *bool
	allow_recurring        *bool
	donor_count            *int
	adddonor_count         *int
	share_count            *int
	addshare_count         *int
	view_count             *int
	addview_count          *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	program                *int
	clearedprogram         bool
	child_campaigns        map[int]struct{}
	removedchild_campaigns map[int]struct{}
	clearedchild_campaigns bool
	parent_campaign        *int
	clearedparent_campaign bool
	donations              map[int]struct{}
	removeddonations       map[int]struct{}
	cleareddonations       bool
	done                   bool
	oldValue               func(context.Context) (*FundraisingCampaign, error)
	predicates             []predicate.FundraisingCampaign
}

var _ ent.Mutation = (*FundraisingCampaignMutation)(nil)

// fundraisingcampaignOption allows management of the mutation configuration using functional options.
type fundraisingcampaignOption func(*FundraisingCampaignMutation)

// newFundraisingCampaignMutation creates new mutation for the FundraisingCampaign entity.
func newFundraisingCampaignMutation(c config, op Op, opts ...fundraisingcampaignOption) *FundraisingCampaignMutation {
	m := &FundraisingCampaignMutation{
		config:        c,
		op:            op,
		typ:           TypeFundraisingCampaign,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFundraisingCampaignID sets the ID field of the mutation.
func withFundraisingCampaignID(id int) fundraisingcampaignOption {
	return func(m *FundraisingCampaignMutation) {
		var (
			err   error
			once  sync.Once
			value *FundraisingCampaign
		)
		m.oldValue = func(ctx context.Context) (*FundraisingCampaign, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FundraisingCampaign.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFundraisingCampaign sets the old FundraisingCampaign of the mutation.
func withFundraisingCampaign(node *FundraisingCampaign) fundraisingcampaignOption {
	return func(m *FundraisingCampaignMutation) {
		m.oldValue = func(context.Context) (*FundraisingCampaign, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FundraisingCampaignMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FundraisingCampaignMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FundraisingCampaignMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FundraisingCampaignMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FundraisingCampaign.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *FundraisingCampaignMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *FundraisingCampaignMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *FundraisingCampaignMutation) ResetSlug() {
	m.slug = nil
}

// SetTitle sets the "title" field.
func (m *FundraisingCampaignMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *FundraisingCampaignMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *FundraisingCampaignMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *FundraisingCampaignMutation) SetDescription(value map[string]interface{}) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *FundraisingCampaignMutation) Description() (r map[string]interface{}, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldDescription(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FundraisingCampaignMutation) ResetDescription() {
	m.description = nil
}

// SetStory sets the "story" field.
func (m *FundraisingCampaignMutation) SetStory(value map[string]interface{}) {
	m.story = &value
}

// Story returns the value of the "story" field in the mutation.
func (m *FundraisingCampaignMutation) Story() (r map[string]interface{}, exists bool) {
	v := m.story
	if v == nil {
		return
	}
	return *v, true
}

// OldStory returns the old "story" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldStory(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStory: %w", err)
	}
	return oldValue.Story, nil
}

// ClearStory clears the value of the "story" field.
func (m *FundraisingCampaignMutation) ClearStory() {
	m.story = nil
	m.clearedFields[fundraisingcampaign.FieldStory] = struct{}{}
}

// StoryCleared returns if the "story" field was cleared in this mutation.
func (m *FundraisingCampaignMutation) StoryCleared() bool {
	_, ok := m.clearedFields[fundraisingcampaign.FieldStory]
	return ok
}

// ResetStory resets all changes to the "story" field.
func (m *FundraisingCampaignMutation) ResetStory() {
	m.story = nil
	delete(m.clearedFields, fundraisingcampaign.FieldStory)
}

// SetType sets the "type" field.
func (m *FundraisingCampaignMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FundraisingCampaignMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FundraisingCampaignMutation) ResetType() {
	m._type = nil
}

// SetCategory sets the "category" field.
func (m *FundraisingCampaignMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *FundraisingCampaignMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *FundraisingCampaignMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[fundraisingcampaign.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *FundraisingCampaignMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[fundraisingcampaign.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *FundraisingCampaignMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, fundraisingcampaign.FieldCategory)
}

// SetTargetAmount sets the "target_amount" field.
func (m *FundraisingCampaignMutation) SetTargetAmount(f float64) {
	m.target_amount = &f
	m.addtarget_amount = nil
}

// TargetAmount returns the value of the "target_amount" field in the mutation.
func (m *FundraisingCampaignMutation) TargetAmount() (r float64, exists bool) {
	v := m.target_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetAmount returns the old "target_amount" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldTargetAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetAmount: %w", err)
	}
	return oldValue.TargetAmount, nil
}

// AddTargetAmount adds f to the "target_amount" field.
func (m *FundraisingCampaignMutation) AddTargetAmount(f float64) {
	if m.addtarget_amount != nil {
		*m.addtarget_amount += f
	} else {
		m.addtarget_amount = &f
	}
}

// AddedTargetAmount returns the value that was added to the "target_amount" field in this mutation.
func (m *FundraisingCampaignMutation) AddedTargetAmount() (r float64, exists bool) {
	v := m.addtarget_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTargetAmount resets all changes to the "target_amount" field.
func (m *FundraisingCampaignMutation) ResetTargetAmount() {
	m.target_amount = nil
	m.addtarget_amount = nil
}

// SetCurrentAmount sets the "current_amount" field.
func (m *FundraisingCampaignMutation) SetCurrentAmount(f float64) {
	m.current_amount = &f
	m.addcurrent_amount = nil
}

// CurrentAmount returns the value of the "current_amount" field in the mutation.
func (m *FundraisingCampaignMutation) CurrentAmount() (r float64, exists bool) {
	v := m.current_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentAmount returns the old "current_amount" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldCurrentAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentAmount: %w", err)
	}
	return oldValue.CurrentAmount, nil
}

// AddCurrentAmount adds f to the "current_amount" field.
func (m *FundraisingCampaignMutation) AddCurrentAmount(f float64) {
	if m.addcurrent_amount != nil {
		*m.addcurrent_amount += f
	} else {
		m.addcurrent_amount = &f
	}
}

// AddedCurrentAmount returns the value that was added to the "current_amount" field in this mutation.
func (m *FundraisingCampaignMutation) AddedCurrentAmount() (r float64, exists bool) {
	v := m.addcurrent_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentAmount resets all changes to the "current_amount" field.
func (m *FundraisingCampaignMutation) ResetCurrentAmount() {
	m.current_amount = nil
	m.addcurrent_amount = nil
}

// SetCurrency sets the "currency" field.
func (m *FundraisingCampaignMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *FundraisingCampaignMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *FundraisingCampaignMutation) ResetCurrency() {
	m.currency = nil
}

// SetMinimumDonation sets the "minimum_donation" field.
func (m *FundraisingCampaignMutation) SetMinimumDonation(f float64) {
	m.minimum_donation = &f
	m.addminimum_donation = nil
}

// MinimumDonation returns the value of the "minimum_donation" field in the mutation.
func (m *FundraisingCampaignMutation) MinimumDonation() (r float64, exists bool) {
	v := m.minimum_donation
	if v == nil {
		return
	}
	return *v, true
}

// OldMinimumDonation returns the old "minimum_donation" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldMinimumDonation(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinimumDonation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinimumDonation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinimumDonation: %w", err)
	}
	return oldValue.MinimumDonation, nil
}

// AddMinimumDonation adds f to the "minimum_donation" field.
func (m *FundraisingCampaignMutation) AddMinimumDonation(f float64) {
	if m.addminimum_donation != nil {
		*m.addminimum_donation += f
	} else {
		m.addminimum_donation = &f
	}
}

// AddedMinimumDonation returns the value that was added to the "minimum_donation" field in this mutation.
func (m *FundraisingCampaignMutation) AddedMinimumDonation() (r float64, exists bool) {
	v := m.addminimum_donation
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinimumDonation clears the value of the "minimum_donation" field.
func (m *FundraisingCampaignMutation) ClearMinimumDonation() {
	m.minimum_donation = nil
	m.addminimum_donation = nil
	m.clearedFields[fundraisingcampaign.FieldMinimumDonation] = struct{}{}
}

// MinimumDonationCleared returns if the "minimum_donation" field was cleared in this mutation.
func (m *FundraisingCampaignMutation) MinimumDonationCleared() bool {
	_, ok := m.clearedFields[fundraisingcampaign.FieldMinimumDonation]
	return ok
}

// ResetMinimumDonation resets all changes to the "minimum_donation" field.
func (m *FundraisingCampaignMutation) ResetMinimumDonation() {
	m.minimum_donation = nil
	m.addminimum_donation = nil
	delete(m.clearedFields, fundraisingcampaign.FieldMinimumDonation)
}

// SetStartDate sets the "start_date" field.
func (m *FundraisingCampaignMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *FundraisingCampaignMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *FundraisingCampaignMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *FundraisingCampaignMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *FundraisingCampaignMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *FundraisingCampaignMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[fundraisingcampaign.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *FundraisingCampaignMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[fundraisingcampaign.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *FundraisingCampaignMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, fundraisingcampaign.FieldEndDate)
}

// SetIsActive sets the "is_active" field.
func (m *FundraisingCampaignMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *FundraisingCampaignMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *FundraisingCampaignMutation) ResetIsActive() {
	m.is_active = nil
}

// SetHeroImageURL sets the "hero_image_url" field.
func (m *FundraisingCampaignMutation) SetHeroImageURL(s string) {
	m.hero_image_url = &s
}

// HeroImageURL returns the value of the "hero_image_url" field in the mutation.
func (m *FundraisingCampaignMutation) HeroImageURL() (r string, exists bool) {
	v := m.hero_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHeroImageURL returns the old "hero_image_url" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldHeroImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeroImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeroImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeroImageURL: %w", err)
	}
	return oldValue.HeroImageURL, nil
}

// ClearHeroImageURL clears the value of the "hero_image_url" field.
func (m *FundraisingCampaignMutation) ClearHeroImageURL() {
	m.hero_image_url = nil
	m.clearedFields[fundraisingcampaign.FieldHeroImageURL] = struct{}{}
}

// HeroImageURLCleared returns if the "hero_image_url" field was cleared in this mutation.
func (m *FundraisingCampaignMutation) HeroImageURLCleared() bool {
	_, ok := m.clearedFields[fundraisingcampaign.FieldHeroImageURL]
	return ok
}

// ResetHeroImageURL resets all changes to the "hero_image_url" field.
func (m *FundraisingCampaignMutation) ResetHeroImageURL() {
	m.hero_image_url = nil
	delete(m.clearedFields, fundraisingcampaign.FieldHeroImageURL)
}

// SetVideoURL sets the "video_url" field.
func (m *FundraisingCampaignMutation) SetVideoURL(s string) {
	m.video_url = &s
}

// VideoURL returns the value of the "video_url" field in the mutation.
func (m *FundraisingCampaignMutation) VideoURL() (r string, exists bool) {
	v := m.video_url
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoURL returns the old "video_url" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldVideoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoURL: %w", err)
	}
	return oldValue.VideoURL, nil
}

// ClearVideoURL clears the value of the "video_url" field.
func (m *FundraisingCampaignMutation) ClearVideoURL() {
	m.video_url = nil
	m.clearedFields[fundraisingcampaign.FieldVideoURL] = struct{}{}
}

// VideoURLCleared returns if the "video_url" field was cleared in this mutation.
func (m *FundraisingCampaignMutation) VideoURLCleared() bool {
	_, ok := m.clearedFields[fundraisingcampaign.FieldVideoURL]
	return ok
}

// ResetVideoURL resets all changes to the "video_url" field.
func (m *FundraisingCampaignMutation) ResetVideoURL() {
	m.video_url = nil
	delete(m.clearedFields, fundraisingcampaign.FieldVideoURL)
}

// SetGalleryImages sets the "gallery_images" field.
func (m *FundraisingCampaignMutation) SetGalleryImages(s []string) {
	m.gallery_images = &s
	m.appendgallery_images = nil
}

// GalleryImages returns the value of the "gallery_images" field in the mutation.
func (m *FundraisingCampaignMutation) GalleryImages() (r []string, exists bool) {
	v := m.gallery_images
	if v == nil {
		return
	}
	return *v, true
}

// OldGalleryImages returns the old "gallery_images" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldGalleryImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGalleryImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGalleryImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGalleryImages: %w", err)
	}
	return oldValue.GalleryImages, nil
}

// AppendGalleryImages adds s to the "gallery_images" field.
func (m *FundraisingCampaignMutation) AppendGalleryImages(s []string) {
	m.appendgallery_images = append(m.appendgallery_images, s...)
}

// AppendedGalleryImages returns the list of values that were appended to the "gallery_images" field in this mutation.
func (m *FundraisingCampaignMutation) AppendedGalleryImages() ([]string, bool) {
	if len(m.appendgallery_images) == 0 {
		return nil, false
	}
	return m.appendgallery_images, true
}

// ResetGalleryImages resets all changes to the "gallery_images" field.
func (m *FundraisingCampaignMutation) ResetGalleryImages() {
	m.gallery_images = nil
	m.appendgallery_images = nil
}

// SetManagerID sets the "manager_id" field.
func (m *FundraisingCampaignMutation) SetManagerID(s string) {
	m.manager_id = &s
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *FundraisingCampaignMutation) ManagerID() (r string, exists bool) {
	v := m.manager_id
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldManagerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// ClearManagerID clears the value of the "manager_id" field.
func (m *FundraisingCampaignMutation) ClearManagerID() {
	m.manager_id = nil
	m.clearedFields[fundraisingcampaign.FieldManagerID] = struct{}{}
}

// ManagerIDCleared returns if the "manager_id" field was cleared in this mutation.
func (m *FundraisingCampaignMutation) ManagerIDCleared() bool {
	_, ok := m.clearedFields[fundraisingcampaign.FieldManagerID]
	return ok
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *FundraisingCampaignMutation) ResetManagerID() {
	m.manager_id = nil
	delete(m.clearedFields, fundraisingcampaign.FieldManagerID)
}

// SetIsPublic sets the "is_public" field.
func (m *FundraisingCampaignMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *FundraisingCampaignMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *FundraisingCampaignMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetAllowRecurring sets the "allow_recurring" field.
func (m *FundraisingCampaignMutation) SetAllowRecurring(b bool) {
	m.allow_recurring = &b
}

// AllowRecurring returns the value of the "allow_recurring" field in the mutation.
func (m *FundraisingCampaignMutation) AllowRecurring() (r bool, exists bool) {
	v := m.allow_recurring
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowRecurring returns the old "allow_recurring" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldAllowRecurring(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowRecurring is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowRecurring requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowRecurring: %w", err)
	}
	return oldValue.AllowRecurring, nil
}

// ResetAllowRecurring resets all changes to the "allow_recurring" field.
func (m *FundraisingCampaignMutation) ResetAllowRecurring() {
	m.allow_recurring = nil
}

// SetDonorCount sets the "donor_count" field.
func (m *FundraisingCampaignMutation) SetDonorCount(i int) {
	m.donor_count = &i
	m.adddonor_count = nil
}

// DonorCount returns the value of the "donor_count" field in the mutation.
func (m *FundraisingCampaignMutation) DonorCount() (r int, exists bool) {
	v := m.donor_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDonorCount returns the old "donor_count" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldDonorCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDonorCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDonorCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDonorCount: %w", err)
	}
	return oldValue.DonorCount, nil
}

// AddDonorCount adds i to the "donor_count" field.
func (m *FundraisingCampaignMutation) AddDonorCount(i int) {
	if m.adddonor_count != nil {
		*m.adddonor_count += i
	} else {
		m.adddonor_count = &i
	}
}

// AddedDonorCount returns the value that was added to the "donor_count" field in this mutation.
func (m *FundraisingCampaignMutation) AddedDonorCount() (r int, exists bool) {
	v := m.adddonor_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDonorCount resets all changes to the "donor_count" field.
func (m *FundraisingCampaignMutation) ResetDonorCount() {
	m.donor_count = nil
	m.adddonor_count = nil
}

// SetShareCount sets the "share_count" field.
func (m *FundraisingCampaignMutation) SetShareCount(i int) {
	m.share_count = &i
	m.addshare_count = nil
}

// ShareCount returns the value of the "share_count" field in the mutation.
func (m *FundraisingCampaignMutation) ShareCount() (r int, exists bool) {
	v := m.share_count
	if v == nil {
		return
	}
	return *v, true
}

// OldShareCount returns the old "share_count" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldShareCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShareCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShareCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShareCount: %w", err)
	}
	return oldValue.ShareCount, nil
}

// AddShareCount adds i to the "share_count" field.
func (m *FundraisingCampaignMutation) AddShareCount(i int) {
	if m.addshare_count != nil {
		*m.addshare_count += i
	} else {
		m.addshare_count = &i
	}
}

// AddedShareCount returns the value that was added to the "share_count" field in this mutation.
func (m *FundraisingCampaignMutation) AddedShareCount() (r int, exists bool) {
	v := m.addshare_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetShareCount resets all changes to the "share_count" field.
func (m *FundraisingCampaignMutation) ResetShareCount() {
	m.share_count = nil
	m.addshare_count = nil
}

// SetViewCount sets the "view_count" field.
func (m *FundraisingCampaignMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *FundraisingCampaignMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *FundraisingCampaignMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *FundraisingCampaignMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *FundraisingCampaignMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FundraisingCampaignMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FundraisingCampaignMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FundraisingCampaignMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FundraisingCampaignMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FundraisingCampaignMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FundraisingCampaign entity.
// If the FundraisingCampaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FundraisingCampaignMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FundraisingCampaignMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProgramID sets the "program" edge to the Program entity by id.
func (m *FundraisingCampaignMutation) SetProgramID(id int) {
	m.program = &id
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *FundraisingCampaignMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *FundraisingCampaignMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// ProgramID returns the "program" edge ID in the mutation.
func (m *FundraisingCampaignMutation) ProgramID() (id int, exists bool) {
	if m.program != nil {
		return *m.program, true
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgramID instead. It exists only for internal usage by the builders.
func (m *FundraisingCampaignMutation) ProgramIDs() (ids []int) {
	if id := m.program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *FundraisingCampaignMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
}

// AddChildCampaignIDs adds the "child_campaigns" edge to the FundraisingCampaign entity by ids.
func (m *FundraisingCampaignMutation) AddChildCampaignIDs(ids ...int) {
	if m.child_campaigns == nil {
		m.child_campaigns = make(map[int]struct{})
	}
	for i := range ids {
		m.child_campaigns[ids[i]] = struct{}{}
	}
}

// ClearChildCampaigns clears the "child_campaigns" edge to the FundraisingCampaign entity.
func (m *FundraisingCampaignMutation) ClearChildCampaigns() {
	m.clearedchild_campaigns = true
}

// ChildCampaignsCleared reports if the "child_campaigns" edge to the FundraisingCampaign entity was cleared.
func (m *FundraisingCampaignMutation) ChildCampaignsCleared() bool {
	return m.clearedchild_campaigns
}

// RemoveChildCampaignIDs removes the "child_campaigns" edge to the FundraisingCampaign entity by IDs.
func (m *FundraisingCampaignMutation) RemoveChildCampaignIDs(ids ...int) {
	if m.removedchild_campaigns == nil {
		m.removedchild_campaigns = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.child_campaigns, ids[i])
		m.removedchild_campaigns[ids[i]] = struct{}{}
	}
}

// RemovedChildCampaigns returns the removed IDs of the "child_campaigns" edge to the FundraisingCampaign entity.
func (m *FundraisingCampaignMutation) RemovedChildCampaignsIDs() (ids []int) {
	for id := range m.removedchild_campaigns {
		ids = append(ids, id)
	}
	return
}

// ChildCampaignsIDs returns the "child_campaigns" edge IDs in the mutation.
func (m *FundraisingCampaignMutation) ChildCampaignsIDs() (ids []int) {
	for id := range m.child_campaigns {
		ids = append(ids, id)
	}
	return
}

// ResetChildCampaigns resets all changes to the "child_campaigns" edge.
func (m *FundraisingCampaignMutation) ResetChildCampaigns() {
	m.child_campaigns = nil
	m.clearedchild_campaigns = false
	m.removedchild_campaigns = nil
}

// SetParentCampaignID sets the "parent_campaign" edge to the FundraisingCampaign entity by id.
func (m *FundraisingCampaignMutation) SetParentCampaignID(id int) {
	m.parent_campaign = &id
}

// ClearParentCampaign clears the "parent_campaign" edge to the FundraisingCampaign entity.
func (m *FundraisingCampaignMutation) ClearParentCampaign() {
	m.clearedparent_campaign = true
}

// ParentCampaignCleared reports if the "parent_campaign" edge to the FundraisingCampaign entity was cleared.
func (m *FundraisingCampaignMutation) ParentCampaignCleared() bool {
	return m.clearedparent_campaign
}

// ParentCampaignID returns the "parent_campaign" edge ID in the mutation.
func (m *FundraisingCampaignMutation) ParentCampaignID() (id int, exists bool) {
	if m.parent_campaign != nil {
		return *m.parent_campaign, true
	}
	return
}

// ParentCampaignIDs returns the "parent_campaign" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentCampaignID instead. It exists only for internal usage by the builders.
func (m *FundraisingCampaignMutation) ParentCampaignIDs() (ids []int) {
	if id := m.parent_campaign; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentCampaign resets all changes to the "parent_campaign" edge.
func (m *FundraisingCampaignMutation) ResetParentCampaign() {
	m.parent_campaign = nil
	m.clearedparent_campaign = false
}

// AddDonationIDs adds the "donations" edge to the Donation entity by ids.
func (m *FundraisingCampaignMutation) AddDonationIDs(ids ...int) {
	if m.donations == nil {
		m.donations = make(map[int]struct{})
	}
	for i := range ids {
		m.donations[ids[i]] = struct{}{}
	}
}

// ClearDonations clears the "donations" edge to the Donation entity.
func (m *FundraisingCampaignMutation) ClearDonations() {
	m.cleareddonations = true
}

// DonationsCleared reports if the "donations" edge to the Donation entity was cleared.
func (m *FundraisingCampaignMutation) DonationsCleared() bool {
	return m.cleareddonations
}

// RemoveDonationIDs removes the "donations" edge to the Donation entity by IDs.
func (m *FundraisingCampaignMutation) RemoveDonationIDs(ids ...int) {
	if m.removeddonations == nil {
		m.removeddonations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.donations, ids[i])
		m.removeddonations[ids[i]] = struct{}{}
	}
}

// RemovedDonations returns the removed IDs of the "donations" edge to the Donation entity.
func (m *FundraisingCampaignMutation) RemovedDonationsIDs() (ids []int) {
	for id := range m.removeddonations {
		ids = append(ids, id)
	}
	return
}

// DonationsIDs returns the "donations" edge IDs in the mutation.
func (m *FundraisingCampaignMutation) DonationsIDs() (ids []int) {
	for id := range m.donations {
		ids = append(ids, id)
	}
	return
}

// ResetDonations resets all changes to the "donations" edge.
func (m *FundraisingCampaignMutation) ResetDonations() {
	m.donations = nil
	m.cleareddonations = false
	m.removeddonations = nil
}

// Where appends a list predicates to the FundraisingCampaignMutation builder.
func (m *FundraisingCampaignMutation) Where(ps ...predicate.FundraisingCampaign) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FundraisingCampaignMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FundraisingCampaignMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FundraisingCampaign, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FundraisingCampaignMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FundraisingCampaignMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FundraisingCampaign).
func (m *FundraisingCampaignMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FundraisingCampaignMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.slug != nil {
		fields = append(fields, fundraisingcampaign.FieldSlug)
	}
	if m.title != nil {
		fields = append(fields, fundraisingcampaign.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, fundraisingcampaign.FieldDescription)
	}
	if m.story != nil {
		fields = append(fields, fundraisingcampaign.FieldStory)
	}
	if m._type != nil {
		fields = append(fields, fundraisingcampaign.FieldType)
	}
	if m.category != nil {
		fields = append(fields, fundraisingcampaign.FieldCategory)
	}
	if m.target_amount != nil {
		fields = append(fields, fundraisingcampaign.FieldTargetAmount)
	}
	if m.current_amount != nil {
		fields = append(fields, fundraisingcampaign.FieldCurrentAmount)
	}
	if m.currency != nil {
		fields = append(fields, fundraisingcampaign.FieldCurrency)
	}
	if m.minimum_donation != nil {
		fields = append(fields, fundraisingcampaign.FieldMinimumDonation)
	}
	if m.start_date != nil {
		fields = append(fields, fundraisingcampaign.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, fundraisingcampaign.FieldEndDate)
	}
	if m.is_active != nil {
		fields = append(fields, fundraisingcampaign.FieldIsActive)
	}
	if m.hero_image_url != nil {
		fields = append(fields, fundraisingcampaign.FieldHeroImageURL)
	}
	if m.video_url != nil {
		fields = append(fields, fundraisingcampaign.FieldVideoURL)
	}
	if m.gallery_images != nil {
		fields = append(fields, fundraisingcampaign.FieldGalleryImages)
	}
	if m.manager_id != nil {
		fields = append(fields, fundraisingcampaign.FieldManagerID)
	}
	if m.is_public != nil {
		fields = append(fields, fundraisingcampaign.FieldIsPublic)
	}
	if m.allow_recurring != nil {
		fields = append(fields, fundraisingcampaign.FieldAllowRecurring)
	}
	if m.donor_count != nil {
		fields = append(fields, fundraisingcampaign.FieldDonorCount)
	}
	if m.share_count != nil {
		fields = append(fields, fundraisingcampaign.FieldShareCount)
	}
	if m.view_count != nil {
		fields = append(fields, fundraisingcampaign.FieldViewCount)
	}
	if m.created_at != nil {
		fields = append(fields, fundraisingcampaign.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fundraisingcampaign.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FundraisingCampaignMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fundraisingcampaign.FieldSlug:
		return m.Slug()
	case fundraisingcampaign.FieldTitle:
		return m.Title()
	case fundraisingcampaign.FieldDescription:
		return m.Description()
	case fundraisingcampaign.FieldStory:
		return m.Story()
	case fundraisingcampaign.FieldType:
		return m.GetType()
	case fundraisingcampaign.FieldCategory:
		return m.Category()
	case fundraisingcampaign.FieldTargetAmount:
		return m.TargetAmount()
	case fundraisingcampaign.FieldCurrentAmount:
		return m.CurrentAmount()
	case fundraisingcampaign.FieldCurrency:
		return m.Currency()
	case fundraisingcampaign.FieldMinimumDonation:
		return m.MinimumDonation()
	case fundraisingcampaign.FieldStartDate:
		return m.StartDate()
	case fundraisingcampaign.FieldEndDate:
		return m.EndDate()
	case fundraisingcampaign.FieldIsActive:
		return m.IsActive()
	case fundraisingcampaign.FieldHeroImageURL:
		return m.HeroImageURL()
	case fundraisingcampaign.FieldVideoURL:
		return m.VideoURL()
	case fundraisingcampaign.FieldGalleryImages:
		return m.GalleryImages()
	case fundraisingcampaign.FieldManagerID:
		return m.ManagerID()
	case fundraisingcampaign.FieldIsPublic:
		return m.IsPublic()
	case fundraisingcampaign.FieldAllowRecurring:
		return m.AllowRecurring()
	case fundraisingcampaign.FieldDonorCount:
		return m.DonorCount()
	case fundraisingcampaign.FieldShareCount:
		return m.ShareCount()
	case fundraisingcampaign.FieldViewCount:
		return m.ViewCount()
	case fundraisingcampaign.FieldCreatedAt:
		return m.CreatedAt()
	case fundraisingcampaign.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FundraisingCampaignMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fundraisingcampaign.FieldSlug:
		return m.OldSlug(ctx)
	case fundraisingcampaign.FieldTitle:
		return m.OldTitle(ctx)
	case fundraisingcampaign.FieldDescription:
		return m.OldDescription(ctx)
	case fundraisingcampaign.FieldStory:
		return m.OldStory(ctx)
	case fundraisingcampaign.FieldType:
		return m.OldType(ctx)
	case fundraisingcampaign.FieldCategory:
		return m.OldCategory(ctx)
	case fundraisingcampaign.FieldTargetAmount:
		return m.OldTargetAmount(ctx)
	case fundraisingcampaign.FieldCurrentAmount:
		return m.OldCurrentAmount(ctx)
	case fundraisingcampaign.FieldCurrency:
		return m.OldCurrency(ctx)
	case fundraisingcampaign.FieldMinimumDonation:
		return m.OldMinimumDonation(ctx)
	case fundraisingcampaign.FieldStartDate:
		return m.OldStartDate(ctx)
	case fundraisingcampaign.FieldEndDate:
		return m.OldEndDate(ctx)
	case fundraisingcampaign.FieldIsActive:
		return m.OldIsActive(ctx)
	case fundraisingcampaign.FieldHeroImageURL:
		return m.OldHeroImageURL(ctx)
	case fundraisingcampaign.FieldVideoURL:
		return m.OldVideoURL(ctx)
	case fundraisingcampaign.FieldGalleryImages:
		return m.OldGalleryImages(ctx)
	case fundraisingcampaign.FieldManagerID:
		return m.OldManagerID(ctx)
	case fundraisingcampaign.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case fundraisingcampaign.FieldAllowRecurring:
		return m.OldAllowRecurring(ctx)
	case fundraisingcampaign.FieldDonorCount:
		return m.OldDonorCount(ctx)
	case fundraisingcampaign.FieldShareCount:
		return m.OldShareCount(ctx)
	case fundraisingcampaign.FieldViewCount:
		return m.OldViewCount(ctx)
	case fundraisingcampaign.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fundraisingcampaign.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FundraisingCampaign field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FundraisingCampaignMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fundraisingcampaign.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case fundraisingcampaign.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case fundraisingcampaign.FieldDescription:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case fundraisingcampaign.FieldStory:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStory(v)
		return nil
	case fundraisingcampaign.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case fundraisingcampaign.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case fundraisingcampaign.FieldTargetAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetAmount(v)
		return nil
	case fundraisingcampaign.FieldCurrentAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentAmount(v)
		return nil
	case fundraisingcampaign.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case fundraisingcampaign.FieldMinimumDonation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinimumDonation(v)
		return nil
	case fundraisingcampaign.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case fundraisingcampaign.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case fundraisingcampaign.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case fundraisingcampaign.FieldHeroImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeroImageURL(v)
		return nil
	case fundraisingcampaign.FieldVideoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoURL(v)
		return nil
	case fundraisingcampaign.FieldGalleryImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGalleryImages(v)
		return nil
	case fundraisingcampaign.FieldManagerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	case fundraisingcampaign.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case fundraisingcampaign.FieldAllowRecurring:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowRecurring(v)
		return nil
	case fundraisingcampaign.FieldDonorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDonorCount(v)
		return nil
	case fundraisingcampaign.FieldShareCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShareCount(v)
		return nil
	case fundraisingcampaign.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case fundraisingcampaign.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fundraisingcampaign.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FundraisingCampaign field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FundraisingCampaignMutation) AddedFields() []string {
	var fields []string
	if m.addtarget_amount != nil {
		fields = append(fields, fundraisingcampaign.FieldTargetAmount)
	}
	if m.addcurrent_amount != nil {
		fields = append(fields, fundraisingcampaign.FieldCurrentAmount)
	}
	if m.addminimum_donation != nil {
		fields = append(fields, fundraisingcampaign.FieldMinimumDonation)
	}
	if m.adddonor_count != nil {
		fields = append(fields, fundraisingcampaign.FieldDonorCount)
	}
	if m.addshare_count != nil {
		fields = append(fields, fundraisingcampaign.FieldShareCount)
	}
	if m.addview_count != nil {
		fields = append(fields, fundraisingcampaign.FieldViewCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FundraisingCampaignMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fundraisingcampaign.FieldTargetAmount:
		return m.AddedTargetAmount()
	case fundraisingcampaign.FieldCurrentAmount:
		return m.AddedCurrentAmount()
	case fundraisingcampaign.FieldMinimumDonation:
		return m.AddedMinimumDonation()
	case fundraisingcampaign.FieldDonorCount:
		return m.AddedDonorCount()
	case fundraisingcampaign.FieldShareCount:
		return m.AddedShareCount()
	case fundraisingcampaign.FieldViewCount:
		return m.AddedViewCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FundraisingCampaignMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fundraisingcampaign.FieldTargetAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetAmount(v)
		return nil
	case fundraisingcampaign.FieldCurrentAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentAmount(v)
		return nil
	case fundraisingcampaign.FieldMinimumDonation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinimumDonation(v)
		return nil
	case fundraisingcampaign.FieldDonorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDonorCount(v)
		return nil
	case fundraisingcampaign.FieldShareCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShareCount(v)
		return nil
	case fundraisingcampaign.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	}
	return fmt.Errorf("unknown FundraisingCampaign numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FundraisingCampaignMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fundraisingcampaign.FieldStory) {
		fields = append(fields, fundraisingcampaign.FieldStory)
	}
	if m.FieldCleared(fundraisingcampaign.FieldCategory) {
		fields = append(fields, fundraisingcampaign.FieldCategory)
	}
	if m.FieldCleared(fundraisingcampaign.FieldMinimumDonation) {
		fields = append(fields, fundraisingcampaign.FieldMinimumDonation)
	}
	if m.FieldCleared(fundraisingcampaign.FieldEndDate) {
		fields = append(fields, fundraisingcampaign.FieldEndDate)
	}
	if m.FieldCleared(fundraisingcampaign.FieldHeroImageURL) {
		fields = append(fields, fundraisingcampaign.FieldHeroImageURL)
	}
	if m.FieldCleared(fundraisingcampaign.FieldVideoURL) {
		fields = append(fields, fundraisingcampaign.FieldVideoURL)
	}
	if m.FieldCleared(fundraisingcampaign.FieldManagerID) {
		fields = append(fields, fundraisingcampaign.FieldManagerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FundraisingCampaignMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FundraisingCampaignMutation) ClearField(name string) error {
	switch name {
	case fundraisingcampaign.FieldStory:
		m.ClearStory()
		return nil
	case fundraisingcampaign.FieldCategory:
		m.ClearCategory()
		return nil
	case fundraisingcampaign.FieldMinimumDonation:
		m.ClearMinimumDonation()
		return nil
	case fundraisingcampaign.FieldEndDate:
		m.ClearEndDate()
		return nil
	case fundraisingcampaign.FieldHeroImageURL:
		m.ClearHeroImageURL()
		return nil
	case fundraisingcampaign.FieldVideoURL:
		m.ClearVideoURL()
		return nil
	case fundraisingcampaign.FieldManagerID:
		m.ClearManagerID()
		return nil
	}
	return fmt.Errorf("unknown FundraisingCampaign nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FundraisingCampaignMutation) ResetField(name string) error {
	switch name {
	case fundraisingcampaign.FieldSlug:
		m.ResetSlug()
		return nil
	case fundraisingcampaign.FieldTitle:
		m.ResetTitle()
		return nil
	case fundraisingcampaign.FieldDescription:
		m.ResetDescription()
		return nil
	case fundraisingcampaign.FieldStory:
		m.ResetStory()
		return nil
	case fundraisingcampaign.FieldType:
		m.ResetType()
		return nil
	case fundraisingcampaign.FieldCategory:
		m.ResetCategory()
		return nil
	case fundraisingcampaign.FieldTargetAmount:
		m.ResetTargetAmount()
		return nil
	case fundraisingcampaign.FieldCurrentAmount:
		m.ResetCurrentAmount()
		return nil
	case fundraisingcampaign.FieldCurrency:
		m.ResetCurrency()
		return nil
	case fundraisingcampaign.FieldMinimumDonation:
		m.ResetMinimumDonation()
		return nil
	case fundraisingcampaign.FieldStartDate:
		m.ResetStartDate()
		return nil
	case fundraisingcampaign.FieldEndDate:
		m.ResetEndDate()
		return nil
	case fundraisingcampaign.FieldIsActive:
		m.ResetIsActive()
		return nil
	case fundraisingcampaign.FieldHeroImageURL:
		m.ResetHeroImageURL()
		return nil
	case fundraisingcampaign.FieldVideoURL:
		m.ResetVideoURL()
		return nil
	case fundraisingcampaign.FieldGalleryImages:
		m.ResetGalleryImages()
		return nil
	case fundraisingcampaign.FieldManagerID:
		m.ResetManagerID()
		return nil
	case fundraisingcampaign.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case fundraisingcampaign.FieldAllowRecurring:
		m.ResetAllowRecurring()
		return nil
	case fundraisingcampaign.FieldDonorCount:
		m.ResetDonorCount()
		return nil
	case fundraisingcampaign.FieldShareCount:
		m.ResetShareCount()
		return nil
	case fundraisingcampaign.FieldViewCount:
		m.ResetViewCount()
		return nil
	case fundraisingcampaign.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fundraisingcampaign.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FundraisingCampaign field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FundraisingCampaignMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.program != nil {
		edges = append(edges, fundraisingcampaign.EdgeProgram)
	}
	if m.child_campaigns != nil {
		edges = append(edges, fundraisingcampaign.EdgeChildCampaigns)
	}
	if m.parent_campaign != nil {
		edges = append(edges, fundraisingcampaign.EdgeParentCampaign)
	}
	if m.donations != nil {
		edges = append(edges, fundraisingcampaign.EdgeDonations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FundraisingCampaignMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fundraisingcampaign.EdgeProgram:
		if id := m.program; id != nil {
			return []ent.Value{*id}
		}
	case fundraisingcampaign.EdgeChildCampaigns:
		ids := make([]ent.Value, 0, len(m.child_campaigns))
		for id := range m.child_campaigns {
			ids = append(ids, id)
		}
		return ids
	case fundraisingcampaign.EdgeParentCampaign:
		if id := m.parent_campaign; id != nil {
			return []ent.Value{*id}
		}
	case fundraisingcampaign.EdgeDonations:
		ids := make([]ent.Value, 0, len(m.donations))
		for id := range m.donations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FundraisingCampaignMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchild_campaigns != nil {
		edges = append(edges, fundraisingcampaign.EdgeChildCampaigns)
	}
	if m.removeddonations != nil {
		edges = append(edges, fundraisingcampaign.EdgeDonations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FundraisingCampaignMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case fundraisingcampaign.EdgeChildCampaigns:
		ids := make([]ent.Value, 0, len(m.removedchild_campaigns))
		for id := range m.removedchild_campaigns {
			ids = append(ids, id)
		}
		return ids
	case fundraisingcampaign.EdgeDonations:
		ids := make([]ent.Value, 0, len(m.removeddonations))
		for id := range m.removeddonations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FundraisingCampaignMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedprogram {
		edges = append(edges, fundraisingcampaign.EdgeProgram)
	}
	if m.clearedchild_campaigns {
		edges = append(edges, fundraisingcampaign.EdgeChildCampaigns)
	}
	if m.clearedparent_campaign {
		edges = append(edges, fundraisingcampaign.EdgeParentCampaign)
	}
	if m.cleareddonations {
		edges = append(edges, fundraisingcampaign.EdgeDonations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FundraisingCampaignMutation) EdgeCleared(name string) bool {
	switch name {
	case fundraisingcampaign.EdgeProgram:
		return m.clearedprogram
	case fundraisingcampaign.EdgeChildCampaigns:
		return m.clearedchild_campaigns
	case fundraisingcampaign.EdgeParentCampaign:
		return m.clearedparent_campaign
	case fundraisingcampaign.EdgeDonations:
		return m.cleareddonations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FundraisingCampaignMutation) ClearEdge(name string) error {
	switch name {
	case fundraisingcampaign.EdgeProgram:
		m.ClearProgram()
		return nil
	case fundraisingcampaign.EdgeParentCampaign:
		m.ClearParentCampaign()
		return nil
	}
	return fmt.Errorf("unknown FundraisingCampaign unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FundraisingCampaignMutation) ResetEdge(name string) error {
	switch name {
	case fundraisingcampaign.EdgeProgram:
		m.ResetProgram()
		return nil
	case fundraisingcampaign.EdgeChildCampaigns:
		m.ResetChildCampaigns()
		return nil
	case fundraisingcampaign.EdgeParentCampaign:
		m.ResetParentCampaign()
		return nil
	case fundraisingcampaign.EdgeDonations:
		m.ResetDonations()
		return nil
	}
	return fmt.Errorf("unknown FundraisingCampaign edge %s", name)
}

// GalleryImageMutation represents an operation that mutates the GalleryImage nodes in the graph.
type GalleryImageMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_order          *int
	add_order       *int
	image_url       *string
	image_width     *int
	addimage_width  *int
	image_height    *int
	addimage_height *int
	alt_text        *map[string]string
	caption         *map[string]string
	clearedFields   map[string]struct{}
	block           *int
	clearedblock    bool
	done            bool
	oldValue        func(context.Context) (*GalleryImage, error)
	predicates      []predicate.GalleryImage
}

var _ ent.Mutation = (*GalleryImageMutation)(nil)

// galleryimageOption allows management of the mutation configuration using functional options.
type galleryimageOption func(*GalleryImageMutation)

// newGalleryImageMutation creates new mutation for the GalleryImage entity.
func newGalleryImageMutation(c config, op Op, opts ...galleryimageOption) *GalleryImageMutation {
	m := &GalleryImageMutation{
		config:        c,
		op:            op,
		typ:           TypeGalleryImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGalleryImageID sets the ID field of the mutation.
func withGalleryImageID(id int) galleryimageOption {
	return func(m *GalleryImageMutation) {
		var (
			err   error
			once  sync.Once
			value *GalleryImage
		)
		m.oldValue = func(ctx context.Context) (*GalleryImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GalleryImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGalleryImage sets the old GalleryImage of the mutation.
func withGalleryImage(node *GalleryImage) galleryimageOption {
	return func(m *GalleryImageMutation) {
		m.oldValue = func(context.Context) (*GalleryImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GalleryImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GalleryImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GalleryImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GalleryImageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GalleryImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *GalleryImageMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *GalleryImageMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the GalleryImage entity.
// If the GalleryImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GalleryImageMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *GalleryImageMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *GalleryImageMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *GalleryImageMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetImageURL sets the "image_url" field.
func (m *GalleryImageMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *GalleryImageMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the GalleryImage entity.
// If the GalleryImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GalleryImageMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *GalleryImageMutation) ResetImageURL() {
	m.image_url = nil
}

// SetImageWidth sets the "image_width" field.
func (m *GalleryImageMutation) SetImageWidth(i int) {
	m.image_width = &i
	m.addimage_width = nil
}

// ImageWidth returns the value of the "image_width" field in the mutation.
func (m *GalleryImageMutation) ImageWidth() (r int, exists bool) {
	v := m.image_width
	if v == nil {
		return
	}
	return *v, true
}

// OldImageWidth returns the old "image_width" field's value of the GalleryImage entity.
// If the GalleryImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GalleryImageMutation) OldImageWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageWidth: %w", err)
	}
	return oldValue.ImageWidth, nil
}

// AddImageWidth adds i to the "image_width" field.
func (m *GalleryImageMutation) AddImageWidth(i int) {
	if m.addimage_width != nil {
		*m.addimage_width += i
	} else {
		m.addimage_width = &i
	}
}

// AddedImageWidth returns the value that was added to the "image_width" field in this mutation.
func (m *GalleryImageMutation) AddedImageWidth() (r int, exists bool) {
	v := m.addimage_width
	if v == nil {
		return
	}
	return *v, true
}

// ClearImageWidth clears the value of the "image_width" field.
func (m *GalleryImageMutation) ClearImageWidth() {
	m.image_width = nil
	m.addimage_width = nil
	m.clearedFields[galleryimage.FieldImageWidth] = struct{}{}
}

// ImageWidthCleared returns if the "image_width" field was cleared in this mutation.
func (m *GalleryImageMutation) ImageWidthCleared() bool {
	_, ok := m.clearedFields[galleryimage.FieldImageWidth]
	return ok
}

// ResetImageWidth resets all changes to the "image_width" field.
func (m *GalleryImageMutation) ResetImageWidth() {
	m.image_width = nil
	m.addimage_width = nil
	delete(m.clearedFields, galleryimage.FieldImageWidth)
}

// SetImageHeight sets the "image_height" field.
func (m *GalleryImageMutation) SetImageHeight(i int) {
	m.image_height = &i
	m.addimage_height = nil
}

// ImageHeight returns the value of the "image_height" field in the mutation.
func (m *GalleryImageMutation) ImageHeight() (r int, exists bool) {
	v := m.image_height
	if v == nil {
		return
	}
	return *v, true
}

// OldImageHeight returns the old "image_height" field's value of the GalleryImage entity.
// If the GalleryImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GalleryImageMutation) OldImageHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageHeight: %w", err)
	}
	return oldValue.ImageHeight, nil
}

// AddImageHeight adds i to the "image_height" field.
func (m *GalleryImageMutation) AddImageHeight(i int) {
	if m.addimage_height != nil {
		*m.addimage_height += i
	} else {
		m.addimage_height = &i
	}
}

// AddedImageHeight returns the value that was added to the "image_height" field in this mutation.
func (m *GalleryImageMutation) AddedImageHeight() (r int, exists bool) {
	v := m.addimage_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearImageHeight clears the value of the "image_height" field.
func (m *GalleryImageMutation) ClearImageHeight() {
	m.image_height = nil
	m.addimage_height = nil
	m.clearedFields[galleryimage.FieldImageHeight] = struct{}{}
}

// ImageHeightCleared returns if the "image_height" field was cleared in this mutation.
func (m *GalleryImageMutation) ImageHeightCleared() bool {
	_, ok := m.clearedFields[galleryimage.FieldImageHeight]
	return ok
}

// ResetImageHeight resets all changes to the "image_height" field.
func (m *GalleryImageMutation) ResetImageHeight() {
	m.image_height = nil
	m.addimage_height = nil
	delete(m.clearedFields, galleryimage.FieldImageHeight)
}

// SetAltText sets the "alt_text" field.
func (m *GalleryImageMutation) SetAltText(value map[string]string) {
	m.alt_text = &value
}

// AltText returns the value of the "alt_text" field in the mutation.
func (m *GalleryImageMutation) AltText() (r map[string]string, exists bool) {
	v := m.alt_text
	if v == nil {
		return
	}
	return *v, true
}

// OldAltText returns the old "alt_text" field's value of the GalleryImage entity.
// If the GalleryImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GalleryImageMutation) OldAltText(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAltText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAltText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltText: %w", err)
	}
	return oldValue.AltText, nil
}

// ResetAltText resets all changes to the "alt_text" field.
func (m *GalleryImageMutation) ResetAltText() {
	m.alt_text = nil
}

// SetCaption sets the "caption" field.
func (m *GalleryImageMutation) SetCaption(value map[string]string) {
	m.caption = &value
}

// Caption returns the value of the "caption" field in the mutation.
func (m *GalleryImageMutation) Caption() (r map[string]string, exists bool) {
	v := m.caption
	if v == nil {
		return
	}
	return *v, true
}

// OldCaption returns the old "caption" field's value of the GalleryImage entity.
// If the GalleryImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GalleryImageMutation) OldCaption(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaption: %w", err)
	}
	return oldValue.Caption, nil
}

// ClearCaption clears the value of the "caption" field.
func (m *GalleryImageMutation) ClearCaption() {
	m.caption = nil
	m.clearedFields[galleryimage.FieldCaption] = struct{}{}
}

// CaptionCleared returns if the "caption" field was cleared in this mutation.
func (m *GalleryImageMutation) CaptionCleared() bool {
	_, ok := m.clearedFields[galleryimage.FieldCaption]
	return ok
}

// ResetCaption resets all changes to the "caption" field.
func (m *GalleryImageMutation) ResetCaption() {
	m.caption = nil
	delete(m.clearedFields, galleryimage.FieldCaption)
}

// SetBlockID sets the "block" edge to the BlockGallery entity by id.
func (m *GalleryImageMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the BlockGallery entity.
func (m *GalleryImageMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the BlockGallery entity was cleared.
func (m *GalleryImageMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *GalleryImageMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *GalleryImageMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *GalleryImageMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// Where appends a list predicates to the GalleryImageMutation builder.
func (m *GalleryImageMutation) Where(ps ...predicate.GalleryImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GalleryImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GalleryImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GalleryImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GalleryImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GalleryImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GalleryImage).
func (m *GalleryImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GalleryImageMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._order != nil {
		fields = append(fields, galleryimage.FieldOrder)
	}
	if m.image_url != nil {
		fields = append(fields, galleryimage.FieldImageURL)
	}
	if m.image_width != nil {
		fields = append(fields, galleryimage.FieldImageWidth)
	}
	if m.image_height != nil {
		fields = append(fields, galleryimage.FieldImageHeight)
	}
	if m.alt_text != nil {
		fields = append(fields, galleryimage.FieldAltText)
	}
	if m.caption != nil {
		fields = append(fields, galleryimage.FieldCaption)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GalleryImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case galleryimage.FieldOrder:
		return m.Order()
	case galleryimage.FieldImageURL:
		return m.ImageURL()
	case galleryimage.FieldImageWidth:
		return m.ImageWidth()
	case galleryimage.FieldImageHeight:
		return m.ImageHeight()
	case galleryimage.FieldAltText:
		return m.AltText()
	case galleryimage.FieldCaption:
		return m.Caption()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GalleryImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case galleryimage.FieldOrder:
		return m.OldOrder(ctx)
	case galleryimage.FieldImageURL:
		return m.OldImageURL(ctx)
	case galleryimage.FieldImageWidth:
		return m.OldImageWidth(ctx)
	case galleryimage.FieldImageHeight:
		return m.OldImageHeight(ctx)
	case galleryimage.FieldAltText:
		return m.OldAltText(ctx)
	case galleryimage.FieldCaption:
		return m.OldCaption(ctx)
	}
	return nil, fmt.Errorf("unknown GalleryImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GalleryImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case galleryimage.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case galleryimage.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case galleryimage.FieldImageWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageWidth(v)
		return nil
	case galleryimage.FieldImageHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageHeight(v)
		return nil
	case galleryimage.FieldAltText:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltText(v)
		return nil
	case galleryimage.FieldCaption:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaption(v)
		return nil
	}
	return fmt.Errorf("unknown GalleryImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GalleryImageMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, galleryimage.FieldOrder)
	}
	if m.addimage_width != nil {
		fields = append(fields, galleryimage.FieldImageWidth)
	}
	if m.addimage_height != nil {
		fields = append(fields, galleryimage.FieldImageHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GalleryImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case galleryimage.FieldOrder:
		return m.AddedOrder()
	case galleryimage.FieldImageWidth:
		return m.AddedImageWidth()
	case galleryimage.FieldImageHeight:
		return m.AddedImageHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GalleryImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case galleryimage.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case galleryimage.FieldImageWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImageWidth(v)
		return nil
	case galleryimage.FieldImageHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImageHeight(v)
		return nil
	}
	return fmt.Errorf("unknown GalleryImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GalleryImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(galleryimage.FieldImageWidth) {
		fields = append(fields, galleryimage.FieldImageWidth)
	}
	if m.FieldCleared(galleryimage.FieldImageHeight) {
		fields = append(fields, galleryimage.FieldImageHeight)
	}
	if m.FieldCleared(galleryimage.FieldCaption) {
		fields = append(fields, galleryimage.FieldCaption)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GalleryImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GalleryImageMutation) ClearField(name string) error {
	switch name {
	case galleryimage.FieldImageWidth:
		m.ClearImageWidth()
		return nil
	case galleryimage.FieldImageHeight:
		m.ClearImageHeight()
		return nil
	case galleryimage.FieldCaption:
		m.ClearCaption()
		return nil
	}
	return fmt.Errorf("unknown GalleryImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GalleryImageMutation) ResetField(name string) error {
	switch name {
	case galleryimage.FieldOrder:
		m.ResetOrder()
		return nil
	case galleryimage.FieldImageURL:
		m.ResetImageURL()
		return nil
	case galleryimage.FieldImageWidth:
		m.ResetImageWidth()
		return nil
	case galleryimage.FieldImageHeight:
		m.ResetImageHeight()
		return nil
	case galleryimage.FieldAltText:
		m.ResetAltText()
		return nil
	case galleryimage.FieldCaption:
		m.ResetCaption()
		return nil
	}
	return fmt.Errorf("unknown GalleryImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GalleryImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.block != nil {
		edges = append(edges, galleryimage.EdgeBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GalleryImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case galleryimage.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GalleryImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GalleryImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GalleryImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblock {
		edges = append(edges, galleryimage.EdgeBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GalleryImageMutation) EdgeCleared(name string) bool {
	switch name {
	case galleryimage.EdgeBlock:
		return m.clearedblock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GalleryImageMutation) ClearEdge(name string) error {
	switch name {
	case galleryimage.EdgeBlock:
		m.ClearBlock()
		return nil
	}
	return fmt.Errorf("unknown GalleryImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GalleryImageMutation) ResetEdge(name string) error {
	switch name {
	case galleryimage.EdgeBlock:
		m.ResetBlock()
		return nil
	}
	return fmt.Errorf("unknown GalleryImage edge %s", name)
}

// GeneratedReportMutation represents an operation that mutates the GeneratedReport nodes in the graph.
type GeneratedReportMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	status                   *string
	format                   *generatedreport.Format
	file_url                 *string
	file_size                *int
	addfile_size             *int
	parameters               *map[string]interface{}
	delivery_method          *generatedreport.DeliveryMethod
	recipient_email          *string
	generated_at             *time.Time
	error                    *string
	metadata                 *map[string]interface{}
	clearedFields            map[string]struct{}
	report_definition        *int
	clearedreport_definition bool
	generator                *int
	clearedgenerator         bool
	job                      *int
	clearedjob               bool
	done                     bool
	oldValue                 func(context.Context) (*GeneratedReport, error)
	predicates               []predicate.GeneratedReport
}

var _ ent.Mutation = (*GeneratedReportMutation)(nil)

// generatedreportOption allows management of the mutation configuration using functional options.
type generatedreportOption func(*GeneratedReportMutation)

// newGeneratedReportMutation creates new mutation for the GeneratedReport entity.
func newGeneratedReportMutation(c config, op Op, opts ...generatedreportOption) *GeneratedReportMutation {
	m := &GeneratedReportMutation{
		config:        c,
		op:            op,
		typ:           TypeGeneratedReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGeneratedReportID sets the ID field of the mutation.
func withGeneratedReportID(id int) generatedreportOption {
	return func(m *GeneratedReportMutation) {
		var (
			err   error
			once  sync.Once
			value *GeneratedReport
		)
		m.oldValue = func(ctx context.Context) (*GeneratedReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GeneratedReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGeneratedReport sets the old GeneratedReport of the mutation.
func withGeneratedReport(node *GeneratedReport) generatedreportOption {
	return func(m *GeneratedReportMutation) {
		m.oldValue = func(context.Context) (*GeneratedReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GeneratedReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GeneratedReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GeneratedReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GeneratedReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GeneratedReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *GeneratedReportMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *GeneratedReportMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the GeneratedReport entity.
// If the GeneratedReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedReportMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GeneratedReportMutation) ResetStatus() {
	m.status = nil
}

// SetFormat sets the "format" field.
func (m *GeneratedReportMutation) SetFormat(ge generatedreport.Format) {
	m.format = &ge
}

// Format returns the value of the "format" field in the mutation.
func (m *GeneratedReportMutation) Format() (r generatedreport.Format, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the GeneratedReport entity.
// If the GeneratedReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedReportMutation) OldFormat(ctx context.Context) (v generatedreport.Format, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *GeneratedReportMutation) ResetFormat() {
	m.format = nil
}

// SetFileURL sets the "file_url" field.
func (m *GeneratedReportMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *GeneratedReportMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the GeneratedReport entity.
// If the GeneratedReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedReportMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ClearFileURL clears the value of the "file_url" field.
func (m *GeneratedReportMutation) ClearFileURL() {
	m.file_url = nil
	m.clearedFields[generatedreport.FieldFileURL] = struct{}{}
}

// FileURLCleared returns if the "file_url" field was cleared in this mutation.
func (m *GeneratedReportMutation) FileURLCleared() bool {
	_, ok := m.clearedFields[generatedreport.FieldFileURL]
	return ok
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *GeneratedReportMutation) ResetFileURL() {
	m.file_url = nil
	delete(m.clearedFields, generatedreport.FieldFileURL)
}

// SetFileSize sets the "file_size" field.
func (m *GeneratedReportMutation) SetFileSize(i int) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *GeneratedReportMutation) FileSize() (r int, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the GeneratedReport entity.
// If the GeneratedReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedReportMutation) OldFileSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *GeneratedReportMutation) AddFileSize(i int) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *GeneratedReportMutation) AddedFileSize() (r int, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileSize clears the value of the "file_size" field.
func (m *GeneratedReportMutation) ClearFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	m.clearedFields[generatedreport.FieldFileSize] = struct{}{}
}

// FileSizeCleared returns if the "file_size" field was cleared in this mutation.
func (m *GeneratedReportMutation) FileSizeCleared() bool {
	_, ok := m.clearedFields[generatedreport.FieldFileSize]
	return ok
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *GeneratedReportMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	delete(m.clearedFields, generatedreport.FieldFileSize)
}

// SetParameters sets the "parameters" field.
func (m *GeneratedReportMutation) SetParameters(value map[string]interface{}) {
	m.parameters = &value
}

// Parameters returns the value of the "parameters" field in the mutation.
func (m *GeneratedReportMutation) Parameters() (r map[string]interface{}, exists bool) {
	v := m.parameters
	if v == nil {
		return
	}
	return *v, true
}

// OldParameters returns the old "parameters" field's value of the GeneratedReport entity.
// If the GeneratedReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedReportMutation) OldParameters(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParameters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParameters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParameters: %w", err)
	}
	return oldValue.Parameters, nil
}

// ClearParameters clears the value of the "parameters" field.
func (m *GeneratedReportMutation) ClearParameters() {
	m.parameters = nil
	m.clearedFields[generatedreport.FieldParameters] = struct{}{}
}

// ParametersCleared returns if the "parameters" field was cleared in this mutation.
func (m *GeneratedReportMutation) ParametersCleared() bool {
	_, ok := m.clearedFields[generatedreport.FieldParameters]
	return ok
}

// ResetParameters resets all changes to the "parameters" field.
func (m *GeneratedReportMutation) ResetParameters() {
	m.parameters = nil
	delete(m.clearedFields, generatedreport.FieldParameters)
}

// SetDeliveryMethod sets the "delivery_method" field.
func (m *GeneratedReportMutation) SetDeliveryMethod(gm generatedreport.DeliveryMethod) {
	m.delivery_method = &gm
}

// DeliveryMethod returns the value of the "delivery_method" field in the mutation.
func (m *GeneratedReportMutation) DeliveryMethod() (r generatedreport.DeliveryMethod, exists bool) {
	v := m.delivery_method
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryMethod returns the old "delivery_method" field's value of the GeneratedReport entity.
// If the GeneratedReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedReportMutation) OldDeliveryMethod(ctx context.Context) (v generatedreport.DeliveryMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryMethod: %w", err)
	}
	return oldValue.DeliveryMethod, nil
}

// ResetDeliveryMethod resets all changes to the "delivery_method" field.
func (m *GeneratedReportMutation) ResetDeliveryMethod() {
	m.delivery_method = nil
}

// SetRecipientEmail sets the "recipient_email" field.
func (m *GeneratedReportMutation) SetRecipientEmail(s string) {
	m.recipient_email = &s
}

// RecipientEmail returns the value of the "recipient_email" field in the mutation.
func (m *GeneratedReportMutation) RecipientEmail() (r string, exists bool) {
	v := m.recipient_email
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipientEmail returns the old "recipient_email" field's value of the GeneratedReport entity.
// If the GeneratedReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedReportMutation) OldRecipientEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipientEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipientEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipientEmail: %w", err)
	}
	return oldValue.RecipientEmail, nil
}

// ClearRecipientEmail clears the value of the "recipient_email" field.
func (m *GeneratedReportMutation) ClearRecipientEmail() {
	m.recipient_email = nil
	m.clearedFields[generatedreport.FieldRecipientEmail] = struct{}{}
}

// RecipientEmailCleared returns if the "recipient_email" field was cleared in this mutation.
func (m *GeneratedReportMutation) RecipientEmailCleared() bool {
	_, ok := m.clearedFields[generatedreport.FieldRecipientEmail]
	return ok
}

// ResetRecipientEmail resets all changes to the "recipient_email" field.
func (m *GeneratedReportMutation) ResetRecipientEmail() {
	m.recipient_email = nil
	delete(m.clearedFields, generatedreport.FieldRecipientEmail)
}

// SetGeneratedAt sets the "generated_at" field.
func (m *GeneratedReportMutation) SetGeneratedAt(t time.Time) {
	m.generated_at = &t
}

// GeneratedAt returns the value of the "generated_at" field in the mutation.
func (m *GeneratedReportMutation) GeneratedAt() (r time.Time, exists bool) {
	v := m.generated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneratedAt returns the old "generated_at" field's value of the GeneratedReport entity.
// If the GeneratedReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedReportMutation) OldGeneratedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeneratedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeneratedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneratedAt: %w", err)
	}
	return oldValue.GeneratedAt, nil
}

// ResetGeneratedAt resets all changes to the "generated_at" field.
func (m *GeneratedReportMutation) ResetGeneratedAt() {
	m.generated_at = nil
}

// SetError sets the "error" field.
func (m *GeneratedReportMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *GeneratedReportMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the GeneratedReport entity.
// If the GeneratedReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedReportMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *GeneratedReportMutation) ClearError() {
	m.error = nil
	m.clearedFields[generatedreport.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *GeneratedReportMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[generatedreport.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *GeneratedReportMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, generatedreport.FieldError)
}

// SetMetadata sets the "metadata" field.
func (m *GeneratedReportMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *GeneratedReportMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the GeneratedReport entity.
// If the GeneratedReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneratedReportMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *GeneratedReportMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[generatedreport.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *GeneratedReportMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[generatedreport.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *GeneratedReportMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, generatedreport.FieldMetadata)
}

// SetReportDefinitionID sets the "report_definition" edge to the ReportDefinition entity by id.
func (m *GeneratedReportMutation) SetReportDefinitionID(id int) {
	m.report_definition = &id
}

// ClearReportDefinition clears the "report_definition" edge to the ReportDefinition entity.
func (m *GeneratedReportMutation) ClearReportDefinition() {
	m.clearedreport_definition = true
}

// ReportDefinitionCleared reports if the "report_definition" edge to the ReportDefinition entity was cleared.
func (m *GeneratedReportMutation) ReportDefinitionCleared() bool {
	return m.clearedreport_definition
}

// ReportDefinitionID returns the "report_definition" edge ID in the mutation.
func (m *GeneratedReportMutation) ReportDefinitionID() (id int, exists bool) {
	if m.report_definition != nil {
		return *m.report_definition, true
	}
	return
}

// ReportDefinitionIDs returns the "report_definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReportDefinitionID instead. It exists only for internal usage by the builders.
func (m *GeneratedReportMutation) ReportDefinitionIDs() (ids []int) {
	if id := m.report_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReportDefinition resets all changes to the "report_definition" edge.
func (m *GeneratedReportMutation) ResetReportDefinition() {
	m.report_definition = nil
	m.clearedreport_definition = false
}

// SetGeneratorID sets the "generator" edge to the User entity by id.
func (m *GeneratedReportMutation) SetGeneratorID(id int) {
	m.generator = &id
}

// ClearGenerator clears the "generator" edge to the User entity.
func (m *GeneratedReportMutation) ClearGenerator() {
	m.clearedgenerator = true
}

// GeneratorCleared reports if the "generator" edge to the User entity was cleared.
func (m *GeneratedReportMutation) GeneratorCleared() bool {
	return m.clearedgenerator
}

// GeneratorID returns the "generator" edge ID in the mutation.
func (m *GeneratedReportMutation) GeneratorID() (id int, exists bool) {
	if m.generator != nil {
		return *m.generator, true
	}
	return
}

// GeneratorIDs returns the "generator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GeneratorID instead. It exists only for internal usage by the builders.
func (m *GeneratedReportMutation) GeneratorIDs() (ids []int) {
	if id := m.generator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenerator resets all changes to the "generator" edge.
func (m *GeneratedReportMutation) ResetGenerator() {
	m.generator = nil
	m.clearedgenerator = false
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *GeneratedReportMutation) SetJobID(id int) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *GeneratedReportMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *GeneratedReportMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *GeneratedReportMutation) JobID() (id int, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *GeneratedReportMutation) JobIDs() (ids []int) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *GeneratedReportMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the GeneratedReportMutation builder.
func (m *GeneratedReportMutation) Where(ps ...predicate.GeneratedReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GeneratedReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GeneratedReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GeneratedReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GeneratedReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GeneratedReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GeneratedReport).
func (m *GeneratedReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GeneratedReportMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.status != nil {
		fields = append(fields, generatedreport.FieldStatus)
	}
	if m.format != nil {
		fields = append(fields, generatedreport.FieldFormat)
	}
	if m.file_url != nil {
		fields = append(fields, generatedreport.FieldFileURL)
	}
	if m.file_size != nil {
		fields = append(fields, generatedreport.FieldFileSize)
	}
	if m.parameters != nil {
		fields = append(fields, generatedreport.FieldParameters)
	}
	if m.delivery_method != nil {
		fields = append(fields, generatedreport.FieldDeliveryMethod)
	}
	if m.recipient_email != nil {
		fields = append(fields, generatedreport.FieldRecipientEmail)
	}
	if m.generated_at != nil {
		fields = append(fields, generatedreport.FieldGeneratedAt)
	}
	if m.error != nil {
		fields = append(fields, generatedreport.FieldError)
	}
	if m.metadata != nil {
		fields = append(fields, generatedreport.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GeneratedReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generatedreport.FieldStatus:
		return m.Status()
	case generatedreport.FieldFormat:
		return m.Format()
	case generatedreport.FieldFileURL:
		return m.FileURL()
	case generatedreport.FieldFileSize:
		return m.FileSize()
	case generatedreport.FieldParameters:
		return m.Parameters()
	case generatedreport.FieldDeliveryMethod:
		return m.DeliveryMethod()
	case generatedreport.FieldRecipientEmail:
		return m.RecipientEmail()
	case generatedreport.FieldGeneratedAt:
		return m.GeneratedAt()
	case generatedreport.FieldError:
		return m.Error()
	case generatedreport.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GeneratedReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generatedreport.FieldStatus:
		return m.OldStatus(ctx)
	case generatedreport.FieldFormat:
		return m.OldFormat(ctx)
	case generatedreport.FieldFileURL:
		return m.OldFileURL(ctx)
	case generatedreport.FieldFileSize:
		return m.OldFileSize(ctx)
	case generatedreport.FieldParameters:
		return m.OldParameters(ctx)
	case generatedreport.FieldDeliveryMethod:
		return m.OldDeliveryMethod(ctx)
	case generatedreport.FieldRecipientEmail:
		return m.OldRecipientEmail(ctx)
	case generatedreport.FieldGeneratedAt:
		return m.OldGeneratedAt(ctx)
	case generatedreport.FieldError:
		return m.OldError(ctx)
	case generatedreport.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown GeneratedReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneratedReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generatedreport.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case generatedreport.FieldFormat:
		v, ok := value.(generatedreport.Format)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case generatedreport.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	case generatedreport.FieldFileSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case generatedreport.FieldParameters:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParameters(v)
		return nil
	case generatedreport.FieldDeliveryMethod:
		v, ok := value.(generatedreport.DeliveryMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryMethod(v)
		return nil
	case generatedreport.FieldRecipientEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipientEmail(v)
		return nil
	case generatedreport.FieldGeneratedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneratedAt(v)
		return nil
	case generatedreport.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case generatedreport.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown GeneratedReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GeneratedReportMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, generatedreport.FieldFileSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GeneratedReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case generatedreport.FieldFileSize:
		return m.AddedFileSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneratedReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case generatedreport.FieldFileSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown GeneratedReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GeneratedReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generatedreport.FieldFileURL) {
		fields = append(fields, generatedreport.FieldFileURL)
	}
	if m.FieldCleared(generatedreport.FieldFileSize) {
		fields = append(fields, generatedreport.FieldFileSize)
	}
	if m.FieldCleared(generatedreport.FieldParameters) {
		fields = append(fields, generatedreport.FieldParameters)
	}
	if m.FieldCleared(generatedreport.FieldRecipientEmail) {
		fields = append(fields, generatedreport.FieldRecipientEmail)
	}
	if m.FieldCleared(generatedreport.FieldError) {
		fields = append(fields, generatedreport.FieldError)
	}
	if m.FieldCleared(generatedreport.FieldMetadata) {
		fields = append(fields, generatedreport.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GeneratedReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GeneratedReportMutation) ClearField(name string) error {
	switch name {
	case generatedreport.FieldFileURL:
		m.ClearFileURL()
		return nil
	case generatedreport.FieldFileSize:
		m.ClearFileSize()
		return nil
	case generatedreport.FieldParameters:
		m.ClearParameters()
		return nil
	case generatedreport.FieldRecipientEmail:
		m.ClearRecipientEmail()
		return nil
	case generatedreport.FieldError:
		m.ClearError()
		return nil
	case generatedreport.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown GeneratedReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GeneratedReportMutation) ResetField(name string) error {
	switch name {
	case generatedreport.FieldStatus:
		m.ResetStatus()
		return nil
	case generatedreport.FieldFormat:
		m.ResetFormat()
		return nil
	case generatedreport.FieldFileURL:
		m.ResetFileURL()
		return nil
	case generatedreport.FieldFileSize:
		m.ResetFileSize()
		return nil
	case generatedreport.FieldParameters:
		m.ResetParameters()
		return nil
	case generatedreport.FieldDeliveryMethod:
		m.ResetDeliveryMethod()
		return nil
	case generatedreport.FieldRecipientEmail:
		m.ResetRecipientEmail()
		return nil
	case generatedreport.FieldGeneratedAt:
		m.ResetGeneratedAt()
		return nil
	case generatedreport.FieldError:
		m.ResetError()
		return nil
	case generatedreport.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown GeneratedReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GeneratedReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.report_definition != nil {
		edges = append(edges, generatedreport.EdgeReportDefinition)
	}
	if m.generator != nil {
		edges = append(edges, generatedreport.EdgeGenerator)
	}
	if m.job != nil {
		edges = append(edges, generatedreport.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GeneratedReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generatedreport.EdgeReportDefinition:
		if id := m.report_definition; id != nil {
			return []ent.Value{*id}
		}
	case generatedreport.EdgeGenerator:
		if id := m.generator; id != nil {
			return []ent.Value{*id}
		}
	case generatedreport.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GeneratedReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GeneratedReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GeneratedReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedreport_definition {
		edges = append(edges, generatedreport.EdgeReportDefinition)
	}
	if m.clearedgenerator {
		edges = append(edges, generatedreport.EdgeGenerator)
	}
	if m.clearedjob {
		edges = append(edges, generatedreport.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GeneratedReportMutation) EdgeCleared(name string) bool {
	switch name {
	case generatedreport.EdgeReportDefinition:
		return m.clearedreport_definition
	case generatedreport.EdgeGenerator:
		return m.clearedgenerator
	case generatedreport.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GeneratedReportMutation) ClearEdge(name string) error {
	switch name {
	case generatedreport.EdgeReportDefinition:
		m.ClearReportDefinition()
		return nil
	case generatedreport.EdgeGenerator:
		m.ClearGenerator()
		return nil
	case generatedreport.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown GeneratedReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GeneratedReportMutation) ResetEdge(name string) error {
	switch name {
	case generatedreport.EdgeReportDefinition:
		m.ResetReportDefinition()
		return nil
	case generatedreport.EdgeGenerator:
		m.ResetGenerator()
		return nil
	case generatedreport.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown GeneratedReport edge %s", name)
}

// GrantMutation represents an operation that mutates the Grant nodes in the graph.
type GrantMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	grant_amount        *float64
	addgrant_amount     *float64
	start_date          *time.Time
	end_date            *time.Time
	status              *grant.Status
	goals               *[]string
	appendgoals         []string
	grant_reference     *string
	contact_person      *string
	contact_email       *string
	renewal_eligible    *bool
	next_review_date    *time.Time
	requires_matching   *bool
	matching_amount     *float64
	addmatching_amount  *float64
	restrictions        *[]string
	appendrestrictions  []string
	reporting_schedule  *map[string]string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	program             *int
	clearedprogram      bool
	reports             map[int]struct{}
	removedreports      map[int]struct{}
	clearedreports      bool
	done                bool
	oldValue            func(context.Context) (*Grant, error)
	predicates          []predicate.Grant
}

var _ ent.Mutation = (*GrantMutation)(nil)

// grantOption allows management of the mutation configuration using functional options.
type grantOption func(*GrantMutation)

// newGrantMutation creates new mutation for the Grant entity.
func newGrantMutation(c config, op Op, opts ...grantOption) *GrantMutation {
	m := &GrantMutation{
		config:        c,
		op:            op,
		typ:           TypeGrant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGrantID sets the ID field of the mutation.
func withGrantID(id int) grantOption {
	return func(m *GrantMutation) {
		var (
			err   error
			once  sync.Once
			value *Grant
		)
		m.oldValue = func(ctx context.Context) (*Grant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Grant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrant sets the old Grant of the mutation.
func withGrant(node *Grant) grantOption {
	return func(m *GrantMutation) {
		m.oldValue = func(context.Context) (*Grant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GrantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GrantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GrantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GrantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Grant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GrantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GrantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GrantMutation) ResetName() {
	m.name = nil
}

// SetGrantAmount sets the "grant_amount" field.
func (m *GrantMutation) SetGrantAmount(f float64) {
	m.grant_amount = &f
	m.addgrant_amount = nil
}

// GrantAmount returns the value of the "grant_amount" field in the mutation.
func (m *GrantMutation) GrantAmount() (r float64, exists bool) {
	v := m.grant_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantAmount returns the old "grant_amount" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldGrantAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantAmount: %w", err)
	}
	return oldValue.GrantAmount, nil
}

// AddGrantAmount adds f to the "grant_amount" field.
func (m *GrantMutation) AddGrantAmount(f float64) {
	if m.addgrant_amount != nil {
		*m.addgrant_amount += f
	} else {
		m.addgrant_amount = &f
	}
}

// AddedGrantAmount returns the value that was added to the "grant_amount" field in this mutation.
func (m *GrantMutation) AddedGrantAmount() (r float64, exists bool) {
	v := m.addgrant_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetGrantAmount resets all changes to the "grant_amount" field.
func (m *GrantMutation) ResetGrantAmount() {
	m.grant_amount = nil
	m.addgrant_amount = nil
}

// SetStartDate sets the "start_date" field.
func (m *GrantMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *GrantMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *GrantMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *GrantMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *GrantMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *GrantMutation) ResetEndDate() {
	m.end_date = nil
}

// SetStatus sets the "status" field.
func (m *GrantMutation) SetStatus(gr grant.Status) {
	m.status = &gr
}

// Status returns the value of the "status" field in the mutation.
func (m *GrantMutation) Status() (r grant.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldStatus(ctx context.Context) (v grant.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GrantMutation) ResetStatus() {
	m.status = nil
}

// SetGoals sets the "goals" field.
func (m *GrantMutation) SetGoals(s []string) {
	m.goals = &s
	m.appendgoals = nil
}

// Goals returns the value of the "goals" field in the mutation.
func (m *GrantMutation) Goals() (r []string, exists bool) {
	v := m.goals
	if v == nil {
		return
	}
	return *v, true
}

// OldGoals returns the old "goals" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldGoals(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoals: %w", err)
	}
	return oldValue.Goals, nil
}

// AppendGoals adds s to the "goals" field.
func (m *GrantMutation) AppendGoals(s []string) {
	m.appendgoals = append(m.appendgoals, s...)
}

// AppendedGoals returns the list of values that were appended to the "goals" field in this mutation.
func (m *GrantMutation) AppendedGoals() ([]string, bool) {
	if len(m.appendgoals) == 0 {
		return nil, false
	}
	return m.appendgoals, true
}

// ResetGoals resets all changes to the "goals" field.
func (m *GrantMutation) ResetGoals() {
	m.goals = nil
	m.appendgoals = nil
}

// SetGrantReference sets the "grant_reference" field.
func (m *GrantMutation) SetGrantReference(s string) {
	m.grant_reference = &s
}

// GrantReference returns the value of the "grant_reference" field in the mutation.
func (m *GrantMutation) GrantReference() (r string, exists bool) {
	v := m.grant_reference
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantReference returns the old "grant_reference" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldGrantReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantReference: %w", err)
	}
	return oldValue.GrantReference, nil
}

// ClearGrantReference clears the value of the "grant_reference" field.
func (m *GrantMutation) ClearGrantReference() {
	m.grant_reference = nil
	m.clearedFields[grant.FieldGrantReference] = struct{}{}
}

// GrantReferenceCleared returns if the "grant_reference" field was cleared in this mutation.
func (m *GrantMutation) GrantReferenceCleared() bool {
	_, ok := m.clearedFields[grant.FieldGrantReference]
	return ok
}

// ResetGrantReference resets all changes to the "grant_reference" field.
func (m *GrantMutation) ResetGrantReference() {
	m.grant_reference = nil
	delete(m.clearedFields, grant.FieldGrantReference)
}

// SetContactPerson sets the "contact_person" field.
func (m *GrantMutation) SetContactPerson(s string) {
	m.contact_person = &s
}

// ContactPerson returns the value of the "contact_person" field in the mutation.
func (m *GrantMutation) ContactPerson() (r string, exists bool) {
	v := m.contact_person
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPerson returns the old "contact_person" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldContactPerson(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPerson is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPerson requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPerson: %w", err)
	}
	return oldValue.ContactPerson, nil
}

// ClearContactPerson clears the value of the "contact_person" field.
func (m *GrantMutation) ClearContactPerson() {
	m.contact_person = nil
	m.clearedFields[grant.FieldContactPerson] = struct{}{}
}

// ContactPersonCleared returns if the "contact_person" field was cleared in this mutation.
func (m *GrantMutation) ContactPersonCleared() bool {
	_, ok := m.clearedFields[grant.FieldContactPerson]
	return ok
}

// ResetContactPerson resets all changes to the "contact_person" field.
func (m *GrantMutation) ResetContactPerson() {
	m.contact_person = nil
	delete(m.clearedFields, grant.FieldContactPerson)
}

// SetContactEmail sets the "contact_email" field.
func (m *GrantMutation) SetContactEmail(s string) {
	m.contact_email = &s
}

// ContactEmail returns the value of the "contact_email" field in the mutation.
func (m *GrantMutation) ContactEmail() (r string, exists bool) {
	v := m.contact_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactEmail returns the old "contact_email" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldContactEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactEmail: %w", err)
	}
	return oldValue.ContactEmail, nil
}

// ClearContactEmail clears the value of the "contact_email" field.
func (m *GrantMutation) ClearContactEmail() {
	m.contact_email = nil
	m.clearedFields[grant.FieldContactEmail] = struct{}{}
}

// ContactEmailCleared returns if the "contact_email" field was cleared in this mutation.
func (m *GrantMutation) ContactEmailCleared() bool {
	_, ok := m.clearedFields[grant.FieldContactEmail]
	return ok
}

// ResetContactEmail resets all changes to the "contact_email" field.
func (m *GrantMutation) ResetContactEmail() {
	m.contact_email = nil
	delete(m.clearedFields, grant.FieldContactEmail)
}

// SetRenewalEligible sets the "renewal_eligible" field.
func (m *GrantMutation) SetRenewalEligible(b bool) {
	m.renewal_eligible = &b
}

// RenewalEligible returns the value of the "renewal_eligible" field in the mutation.
func (m *GrantMutation) RenewalEligible() (r bool, exists bool) {
	v := m.renewal_eligible
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalEligible returns the old "renewal_eligible" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRenewalEligible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenewalEligible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenewalEligible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalEligible: %w", err)
	}
	return oldValue.RenewalEligible, nil
}

// ResetRenewalEligible resets all changes to the "renewal_eligible" field.
func (m *GrantMutation) ResetRenewalEligible() {
	m.renewal_eligible = nil
}

// SetNextReviewDate sets the "next_review_date" field.
func (m *GrantMutation) SetNextReviewDate(t time.Time) {
	m.next_review_date = &t
}

// NextReviewDate returns the value of the "next_review_date" field in the mutation.
func (m *GrantMutation) NextReviewDate() (r time.Time, exists bool) {
	v := m.next_review_date
	if v == nil {
		return
	}
	return *v, true
}

// OldNextReviewDate returns the old "next_review_date" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldNextReviewDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextReviewDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextReviewDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextReviewDate: %w", err)
	}
	return oldValue.NextReviewDate, nil
}

// ClearNextReviewDate clears the value of the "next_review_date" field.
func (m *GrantMutation) ClearNextReviewDate() {
	m.next_review_date = nil
	m.clearedFields[grant.FieldNextReviewDate] = struct{}{}
}

// NextReviewDateCleared returns if the "next_review_date" field was cleared in this mutation.
func (m *GrantMutation) NextReviewDateCleared() bool {
	_, ok := m.clearedFields[grant.FieldNextReviewDate]
	return ok
}

// ResetNextReviewDate resets all changes to the "next_review_date" field.
func (m *GrantMutation) ResetNextReviewDate() {
	m.next_review_date = nil
	delete(m.clearedFields, grant.FieldNextReviewDate)
}

// SetRequiresMatching sets the "requires_matching" field.
func (m *GrantMutation) SetRequiresMatching(b bool) {
	m.requires_matching = &b
}

// RequiresMatching returns the value of the "requires_matching" field in the mutation.
func (m *GrantMutation) RequiresMatching() (r bool, exists bool) {
	v := m.requires_matching
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresMatching returns the old "requires_matching" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRequiresMatching(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresMatching is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresMatching requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresMatching: %w", err)
	}
	return oldValue.RequiresMatching, nil
}

// ResetRequiresMatching resets all changes to the "requires_matching" field.
func (m *GrantMutation) ResetRequiresMatching() {
	m.requires_matching = nil
}

// SetMatchingAmount sets the "matching_amount" field.
func (m *GrantMutation) SetMatchingAmount(f float64) {
	m.matching_amount = &f
	m.addmatching_amount = nil
}

// MatchingAmount returns the value of the "matching_amount" field in the mutation.
func (m *GrantMutation) MatchingAmount() (r float64, exists bool) {
	v := m.matching_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchingAmount returns the old "matching_amount" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldMatchingAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchingAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchingAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchingAmount: %w", err)
	}
	return oldValue.MatchingAmount, nil
}

// AddMatchingAmount adds f to the "matching_amount" field.
func (m *GrantMutation) AddMatchingAmount(f float64) {
	if m.addmatching_amount != nil {
		*m.addmatching_amount += f
	} else {
		m.addmatching_amount = &f
	}
}

// AddedMatchingAmount returns the value that was added to the "matching_amount" field in this mutation.
func (m *GrantMutation) AddedMatchingAmount() (r float64, exists bool) {
	v := m.addmatching_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearMatchingAmount clears the value of the "matching_amount" field.
func (m *GrantMutation) ClearMatchingAmount() {
	m.matching_amount = nil
	m.addmatching_amount = nil
	m.clearedFields[grant.FieldMatchingAmount] = struct{}{}
}

// MatchingAmountCleared returns if the "matching_amount" field was cleared in this mutation.
func (m *GrantMutation) MatchingAmountCleared() bool {
	_, ok := m.clearedFields[grant.FieldMatchingAmount]
	return ok
}

// ResetMatchingAmount resets all changes to the "matching_amount" field.
func (m *GrantMutation) ResetMatchingAmount() {
	m.matching_amount = nil
	m.addmatching_amount = nil
	delete(m.clearedFields, grant.FieldMatchingAmount)
}

// SetRestrictions sets the "restrictions" field.
func (m *GrantMutation) SetRestrictions(s []string) {
	m.restrictions = &s
	m.appendrestrictions = nil
}

// Restrictions returns the value of the "restrictions" field in the mutation.
func (m *GrantMutation) Restrictions() (r []string, exists bool) {
	v := m.restrictions
	if v == nil {
		return
	}
	return *v, true
}

// OldRestrictions returns the old "restrictions" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldRestrictions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRestrictions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRestrictions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestrictions: %w", err)
	}
	return oldValue.Restrictions, nil
}

// AppendRestrictions adds s to the "restrictions" field.
func (m *GrantMutation) AppendRestrictions(s []string) {
	m.appendrestrictions = append(m.appendrestrictions, s...)
}

// AppendedRestrictions returns the list of values that were appended to the "restrictions" field in this mutation.
func (m *GrantMutation) AppendedRestrictions() ([]string, bool) {
	if len(m.appendrestrictions) == 0 {
		return nil, false
	}
	return m.appendrestrictions, true
}

// ClearRestrictions clears the value of the "restrictions" field.
func (m *GrantMutation) ClearRestrictions() {
	m.restrictions = nil
	m.appendrestrictions = nil
	m.clearedFields[grant.FieldRestrictions] = struct{}{}
}

// RestrictionsCleared returns if the "restrictions" field was cleared in this mutation.
func (m *GrantMutation) RestrictionsCleared() bool {
	_, ok := m.clearedFields[grant.FieldRestrictions]
	return ok
}

// ResetRestrictions resets all changes to the "restrictions" field.
func (m *GrantMutation) ResetRestrictions() {
	m.restrictions = nil
	m.appendrestrictions = nil
	delete(m.clearedFields, grant.FieldRestrictions)
}

// SetReportingSchedule sets the "reporting_schedule" field.
func (m *GrantMutation) SetReportingSchedule(value map[string]string) {
	m.reporting_schedule = &value
}

// ReportingSchedule returns the value of the "reporting_schedule" field in the mutation.
func (m *GrantMutation) ReportingSchedule() (r map[string]string, exists bool) {
	v := m.reporting_schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldReportingSchedule returns the old "reporting_schedule" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldReportingSchedule(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportingSchedule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportingSchedule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportingSchedule: %w", err)
	}
	return oldValue.ReportingSchedule, nil
}

// ClearReportingSchedule clears the value of the "reporting_schedule" field.
func (m *GrantMutation) ClearReportingSchedule() {
	m.reporting_schedule = nil
	m.clearedFields[grant.FieldReportingSchedule] = struct{}{}
}

// ReportingScheduleCleared returns if the "reporting_schedule" field was cleared in this mutation.
func (m *GrantMutation) ReportingScheduleCleared() bool {
	_, ok := m.clearedFields[grant.FieldReportingSchedule]
	return ok
}

// ResetReportingSchedule resets all changes to the "reporting_schedule" field.
func (m *GrantMutation) ResetReportingSchedule() {
	m.reporting_schedule = nil
	delete(m.clearedFields, grant.FieldReportingSchedule)
}

// SetCreatedAt sets the "created_at" field.
func (m *GrantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GrantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GrantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GrantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GrantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Grant entity.
// If the Grant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GrantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *GrantMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *GrantMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *GrantMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *GrantMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *GrantMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *GrantMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetProgramID sets the "program" edge to the Program entity by id.
func (m *GrantMutation) SetProgramID(id int) {
	m.program = &id
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *GrantMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *GrantMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// ProgramID returns the "program" edge ID in the mutation.
func (m *GrantMutation) ProgramID() (id int, exists bool) {
	if m.program != nil {
		return *m.program, true
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgramID instead. It exists only for internal usage by the builders.
func (m *GrantMutation) ProgramIDs() (ids []int) {
	if id := m.program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *GrantMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
}

// AddReportIDs adds the "reports" edge to the GrantReport entity by ids.
func (m *GrantMutation) AddReportIDs(ids ...int) {
	if m.reports == nil {
		m.reports = make(map[int]struct{})
	}
	for i := range ids {
		m.reports[ids[i]] = struct{}{}
	}
}

// ClearReports clears the "reports" edge to the GrantReport entity.
func (m *GrantMutation) ClearReports() {
	m.clearedreports = true
}

// ReportsCleared reports if the "reports" edge to the GrantReport entity was cleared.
func (m *GrantMutation) ReportsCleared() bool {
	return m.clearedreports
}

// RemoveReportIDs removes the "reports" edge to the GrantReport entity by IDs.
func (m *GrantMutation) RemoveReportIDs(ids ...int) {
	if m.removedreports == nil {
		m.removedreports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reports, ids[i])
		m.removedreports[ids[i]] = struct{}{}
	}
}

// RemovedReports returns the removed IDs of the "reports" edge to the GrantReport entity.
func (m *GrantMutation) RemovedReportsIDs() (ids []int) {
	for id := range m.removedreports {
		ids = append(ids, id)
	}
	return
}

// ReportsIDs returns the "reports" edge IDs in the mutation.
func (m *GrantMutation) ReportsIDs() (ids []int) {
	for id := range m.reports {
		ids = append(ids, id)
	}
	return
}

// ResetReports resets all changes to the "reports" edge.
func (m *GrantMutation) ResetReports() {
	m.reports = nil
	m.clearedreports = false
	m.removedreports = nil
}

// Where appends a list predicates to the GrantMutation builder.
func (m *GrantMutation) Where(ps ...predicate.Grant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GrantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GrantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Grant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GrantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GrantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Grant).
func (m *GrantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GrantMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.name != nil {
		fields = append(fields, grant.FieldName)
	}
	if m.grant_amount != nil {
		fields = append(fields, grant.FieldGrantAmount)
	}
	if m.start_date != nil {
		fields = append(fields, grant.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, grant.FieldEndDate)
	}
	if m.status != nil {
		fields = append(fields, grant.FieldStatus)
	}
	if m.goals != nil {
		fields = append(fields, grant.FieldGoals)
	}
	if m.grant_reference != nil {
		fields = append(fields, grant.FieldGrantReference)
	}
	if m.contact_person != nil {
		fields = append(fields, grant.FieldContactPerson)
	}
	if m.contact_email != nil {
		fields = append(fields, grant.FieldContactEmail)
	}
	if m.renewal_eligible != nil {
		fields = append(fields, grant.FieldRenewalEligible)
	}
	if m.next_review_date != nil {
		fields = append(fields, grant.FieldNextReviewDate)
	}
	if m.requires_matching != nil {
		fields = append(fields, grant.FieldRequiresMatching)
	}
	if m.matching_amount != nil {
		fields = append(fields, grant.FieldMatchingAmount)
	}
	if m.restrictions != nil {
		fields = append(fields, grant.FieldRestrictions)
	}
	if m.reporting_schedule != nil {
		fields = append(fields, grant.FieldReportingSchedule)
	}
	if m.created_at != nil {
		fields = append(fields, grant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, grant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GrantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grant.FieldName:
		return m.Name()
	case grant.FieldGrantAmount:
		return m.GrantAmount()
	case grant.FieldStartDate:
		return m.StartDate()
	case grant.FieldEndDate:
		return m.EndDate()
	case grant.FieldStatus:
		return m.Status()
	case grant.FieldGoals:
		return m.Goals()
	case grant.FieldGrantReference:
		return m.GrantReference()
	case grant.FieldContactPerson:
		return m.ContactPerson()
	case grant.FieldContactEmail:
		return m.ContactEmail()
	case grant.FieldRenewalEligible:
		return m.RenewalEligible()
	case grant.FieldNextReviewDate:
		return m.NextReviewDate()
	case grant.FieldRequiresMatching:
		return m.RequiresMatching()
	case grant.FieldMatchingAmount:
		return m.MatchingAmount()
	case grant.FieldRestrictions:
		return m.Restrictions()
	case grant.FieldReportingSchedule:
		return m.ReportingSchedule()
	case grant.FieldCreatedAt:
		return m.CreatedAt()
	case grant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GrantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grant.FieldName:
		return m.OldName(ctx)
	case grant.FieldGrantAmount:
		return m.OldGrantAmount(ctx)
	case grant.FieldStartDate:
		return m.OldStartDate(ctx)
	case grant.FieldEndDate:
		return m.OldEndDate(ctx)
	case grant.FieldStatus:
		return m.OldStatus(ctx)
	case grant.FieldGoals:
		return m.OldGoals(ctx)
	case grant.FieldGrantReference:
		return m.OldGrantReference(ctx)
	case grant.FieldContactPerson:
		return m.OldContactPerson(ctx)
	case grant.FieldContactEmail:
		return m.OldContactEmail(ctx)
	case grant.FieldRenewalEligible:
		return m.OldRenewalEligible(ctx)
	case grant.FieldNextReviewDate:
		return m.OldNextReviewDate(ctx)
	case grant.FieldRequiresMatching:
		return m.OldRequiresMatching(ctx)
	case grant.FieldMatchingAmount:
		return m.OldMatchingAmount(ctx)
	case grant.FieldRestrictions:
		return m.OldRestrictions(ctx)
	case grant.FieldReportingSchedule:
		return m.OldReportingSchedule(ctx)
	case grant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case grant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Grant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case grant.FieldGrantAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantAmount(v)
		return nil
	case grant.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case grant.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case grant.FieldStatus:
		v, ok := value.(grant.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case grant.FieldGoals:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoals(v)
		return nil
	case grant.FieldGrantReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantReference(v)
		return nil
	case grant.FieldContactPerson:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPerson(v)
		return nil
	case grant.FieldContactEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactEmail(v)
		return nil
	case grant.FieldRenewalEligible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalEligible(v)
		return nil
	case grant.FieldNextReviewDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextReviewDate(v)
		return nil
	case grant.FieldRequiresMatching:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresMatching(v)
		return nil
	case grant.FieldMatchingAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchingAmount(v)
		return nil
	case grant.FieldRestrictions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestrictions(v)
		return nil
	case grant.FieldReportingSchedule:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportingSchedule(v)
		return nil
	case grant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case grant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GrantMutation) AddedFields() []string {
	var fields []string
	if m.addgrant_amount != nil {
		fields = append(fields, grant.FieldGrantAmount)
	}
	if m.addmatching_amount != nil {
		fields = append(fields, grant.FieldMatchingAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GrantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case grant.FieldGrantAmount:
		return m.AddedGrantAmount()
	case grant.FieldMatchingAmount:
		return m.AddedMatchingAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case grant.FieldGrantAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrantAmount(v)
		return nil
	case grant.FieldMatchingAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMatchingAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Grant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GrantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(grant.FieldGrantReference) {
		fields = append(fields, grant.FieldGrantReference)
	}
	if m.FieldCleared(grant.FieldContactPerson) {
		fields = append(fields, grant.FieldContactPerson)
	}
	if m.FieldCleared(grant.FieldContactEmail) {
		fields = append(fields, grant.FieldContactEmail)
	}
	if m.FieldCleared(grant.FieldNextReviewDate) {
		fields = append(fields, grant.FieldNextReviewDate)
	}
	if m.FieldCleared(grant.FieldMatchingAmount) {
		fields = append(fields, grant.FieldMatchingAmount)
	}
	if m.FieldCleared(grant.FieldRestrictions) {
		fields = append(fields, grant.FieldRestrictions)
	}
	if m.FieldCleared(grant.FieldReportingSchedule) {
		fields = append(fields, grant.FieldReportingSchedule)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GrantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GrantMutation) ClearField(name string) error {
	switch name {
	case grant.FieldGrantReference:
		m.ClearGrantReference()
		return nil
	case grant.FieldContactPerson:
		m.ClearContactPerson()
		return nil
	case grant.FieldContactEmail:
		m.ClearContactEmail()
		return nil
	case grant.FieldNextReviewDate:
		m.ClearNextReviewDate()
		return nil
	case grant.FieldMatchingAmount:
		m.ClearMatchingAmount()
		return nil
	case grant.FieldRestrictions:
		m.ClearRestrictions()
		return nil
	case grant.FieldReportingSchedule:
		m.ClearReportingSchedule()
		return nil
	}
	return fmt.Errorf("unknown Grant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GrantMutation) ResetField(name string) error {
	switch name {
	case grant.FieldName:
		m.ResetName()
		return nil
	case grant.FieldGrantAmount:
		m.ResetGrantAmount()
		return nil
	case grant.FieldStartDate:
		m.ResetStartDate()
		return nil
	case grant.FieldEndDate:
		m.ResetEndDate()
		return nil
	case grant.FieldStatus:
		m.ResetStatus()
		return nil
	case grant.FieldGoals:
		m.ResetGoals()
		return nil
	case grant.FieldGrantReference:
		m.ResetGrantReference()
		return nil
	case grant.FieldContactPerson:
		m.ResetContactPerson()
		return nil
	case grant.FieldContactEmail:
		m.ResetContactEmail()
		return nil
	case grant.FieldRenewalEligible:
		m.ResetRenewalEligible()
		return nil
	case grant.FieldNextReviewDate:
		m.ResetNextReviewDate()
		return nil
	case grant.FieldRequiresMatching:
		m.ResetRequiresMatching()
		return nil
	case grant.FieldMatchingAmount:
		m.ResetMatchingAmount()
		return nil
	case grant.FieldRestrictions:
		m.ResetRestrictions()
		return nil
	case grant.FieldReportingSchedule:
		m.ResetReportingSchedule()
		return nil
	case grant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case grant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Grant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GrantMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.organization != nil {
		edges = append(edges, grant.EdgeOrganization)
	}
	if m.program != nil {
		edges = append(edges, grant.EdgeProgram)
	}
	if m.reports != nil {
		edges = append(edges, grant.EdgeReports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GrantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case grant.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case grant.EdgeProgram:
		if id := m.program; id != nil {
			return []ent.Value{*id}
		}
	case grant.EdgeReports:
		ids := make([]ent.Value, 0, len(m.reports))
		for id := range m.reports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GrantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreports != nil {
		edges = append(edges, grant.EdgeReports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GrantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case grant.EdgeReports:
		ids := make([]ent.Value, 0, len(m.removedreports))
		for id := range m.removedreports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GrantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedorganization {
		edges = append(edges, grant.EdgeOrganization)
	}
	if m.clearedprogram {
		edges = append(edges, grant.EdgeProgram)
	}
	if m.clearedreports {
		edges = append(edges, grant.EdgeReports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GrantMutation) EdgeCleared(name string) bool {
	switch name {
	case grant.EdgeOrganization:
		return m.clearedorganization
	case grant.EdgeProgram:
		return m.clearedprogram
	case grant.EdgeReports:
		return m.clearedreports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GrantMutation) ClearEdge(name string) error {
	switch name {
	case grant.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case grant.EdgeProgram:
		m.ClearProgram()
		return nil
	}
	return fmt.Errorf("unknown Grant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GrantMutation) ResetEdge(name string) error {
	switch name {
	case grant.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case grant.EdgeProgram:
		m.ResetProgram()
		return nil
	case grant.EdgeReports:
		m.ResetReports()
		return nil
	}
	return fmt.Errorf("unknown Grant edge %s", name)
}

// GrantReportMutation represents an operation that mutates the GrantReport nodes in the graph.
type GrantReportMutation struct {
	config
	op             Op
	typ            string
	id             *int
	title          *string
	due_date       *time.Time
	submitted_date *time.Time
	status         *grantreport.Status
	document_url   *string
	report_type    *string
	reviewed_by    *string
	reviewed_at    *time.Time
	feedback       *string
	is_approved    *bool
	next_due_date  *time.Time
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	grant          *int
	clearedgrant   bool
	done           bool
	oldValue       func(context.Context) (*GrantReport, error)
	predicates     []predicate.GrantReport
}

var _ ent.Mutation = (*GrantReportMutation)(nil)

// grantreportOption allows management of the mutation configuration using functional options.
type grantreportOption func(*GrantReportMutation)

// newGrantReportMutation creates new mutation for the GrantReport entity.
func newGrantReportMutation(c config, op Op, opts ...grantreportOption) *GrantReportMutation {
	m := &GrantReportMutation{
		config:        c,
		op:            op,
		typ:           TypeGrantReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGrantReportID sets the ID field of the mutation.
func withGrantReportID(id int) grantreportOption {
	return func(m *GrantReportMutation) {
		var (
			err   error
			once  sync.Once
			value *GrantReport
		)
		m.oldValue = func(ctx context.Context) (*GrantReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GrantReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrantReport sets the old GrantReport of the mutation.
func withGrantReport(node *GrantReport) grantreportOption {
	return func(m *GrantReportMutation) {
		m.oldValue = func(context.Context) (*GrantReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GrantReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GrantReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GrantReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GrantReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GrantReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *GrantReportMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GrantReportMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *GrantReportMutation) ResetTitle() {
	m.title = nil
}

// SetDueDate sets the "due_date" field.
func (m *GrantReportMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *GrantReportMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *GrantReportMutation) ResetDueDate() {
	m.due_date = nil
}

// SetSubmittedDate sets the "submitted_date" field.
func (m *GrantReportMutation) SetSubmittedDate(t time.Time) {
	m.submitted_date = &t
}

// SubmittedDate returns the value of the "submitted_date" field in the mutation.
func (m *GrantReportMutation) SubmittedDate() (r time.Time, exists bool) {
	v := m.submitted_date
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmittedDate returns the old "submitted_date" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldSubmittedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmittedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmittedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmittedDate: %w", err)
	}
	return oldValue.SubmittedDate, nil
}

// ClearSubmittedDate clears the value of the "submitted_date" field.
func (m *GrantReportMutation) ClearSubmittedDate() {
	m.submitted_date = nil
	m.clearedFields[grantreport.FieldSubmittedDate] = struct{}{}
}

// SubmittedDateCleared returns if the "submitted_date" field was cleared in this mutation.
func (m *GrantReportMutation) SubmittedDateCleared() bool {
	_, ok := m.clearedFields[grantreport.FieldSubmittedDate]
	return ok
}

// ResetSubmittedDate resets all changes to the "submitted_date" field.
func (m *GrantReportMutation) ResetSubmittedDate() {
	m.submitted_date = nil
	delete(m.clearedFields, grantreport.FieldSubmittedDate)
}

// SetStatus sets the "status" field.
func (m *GrantReportMutation) SetStatus(gr grantreport.Status) {
	m.status = &gr
}

// Status returns the value of the "status" field in the mutation.
func (m *GrantReportMutation) Status() (r grantreport.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldStatus(ctx context.Context) (v grantreport.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GrantReportMutation) ResetStatus() {
	m.status = nil
}

// SetDocumentURL sets the "document_url" field.
func (m *GrantReportMutation) SetDocumentURL(s string) {
	m.document_url = &s
}

// DocumentURL returns the value of the "document_url" field in the mutation.
func (m *GrantReportMutation) DocumentURL() (r string, exists bool) {
	v := m.document_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentURL returns the old "document_url" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldDocumentURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentURL: %w", err)
	}
	return oldValue.DocumentURL, nil
}

// ClearDocumentURL clears the value of the "document_url" field.
func (m *GrantReportMutation) ClearDocumentURL() {
	m.document_url = nil
	m.clearedFields[grantreport.FieldDocumentURL] = struct{}{}
}

// DocumentURLCleared returns if the "document_url" field was cleared in this mutation.
func (m *GrantReportMutation) DocumentURLCleared() bool {
	_, ok := m.clearedFields[grantreport.FieldDocumentURL]
	return ok
}

// ResetDocumentURL resets all changes to the "document_url" field.
func (m *GrantReportMutation) ResetDocumentURL() {
	m.document_url = nil
	delete(m.clearedFields, grantreport.FieldDocumentURL)
}

// SetReportType sets the "report_type" field.
func (m *GrantReportMutation) SetReportType(s string) {
	m.report_type = &s
}

// ReportType returns the value of the "report_type" field in the mutation.
func (m *GrantReportMutation) ReportType() (r string, exists bool) {
	v := m.report_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReportType returns the old "report_type" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldReportType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportType: %w", err)
	}
	return oldValue.ReportType, nil
}

// ResetReportType resets all changes to the "report_type" field.
func (m *GrantReportMutation) ResetReportType() {
	m.report_type = nil
}

// SetReviewedBy sets the "reviewed_by" field.
func (m *GrantReportMutation) SetReviewedBy(s string) {
	m.reviewed_by = &s
}

// ReviewedBy returns the value of the "reviewed_by" field in the mutation.
func (m *GrantReportMutation) ReviewedBy() (r string, exists bool) {
	v := m.reviewed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedBy returns the old "reviewed_by" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldReviewedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedBy: %w", err)
	}
	return oldValue.ReviewedBy, nil
}

// ClearReviewedBy clears the value of the "reviewed_by" field.
func (m *GrantReportMutation) ClearReviewedBy() {
	m.reviewed_by = nil
	m.clearedFields[grantreport.FieldReviewedBy] = struct{}{}
}

// ReviewedByCleared returns if the "reviewed_by" field was cleared in this mutation.
func (m *GrantReportMutation) ReviewedByCleared() bool {
	_, ok := m.clearedFields[grantreport.FieldReviewedBy]
	return ok
}

// ResetReviewedBy resets all changes to the "reviewed_by" field.
func (m *GrantReportMutation) ResetReviewedBy() {
	m.reviewed_by = nil
	delete(m.clearedFields, grantreport.FieldReviewedBy)
}

// SetReviewedAt sets the "reviewed_at" field.
func (m *GrantReportMutation) SetReviewedAt(t time.Time) {
	m.reviewed_at = &t
}

// ReviewedAt returns the value of the "reviewed_at" field in the mutation.
func (m *GrantReportMutation) ReviewedAt() (r time.Time, exists bool) {
	v := m.reviewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedAt returns the old "reviewed_at" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldReviewedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedAt: %w", err)
	}
	return oldValue.ReviewedAt, nil
}

// ClearReviewedAt clears the value of the "reviewed_at" field.
func (m *GrantReportMutation) ClearReviewedAt() {
	m.reviewed_at = nil
	m.clearedFields[grantreport.FieldReviewedAt] = struct{}{}
}

// ReviewedAtCleared returns if the "reviewed_at" field was cleared in this mutation.
func (m *GrantReportMutation) ReviewedAtCleared() bool {
	_, ok := m.clearedFields[grantreport.FieldReviewedAt]
	return ok
}

// ResetReviewedAt resets all changes to the "reviewed_at" field.
func (m *GrantReportMutation) ResetReviewedAt() {
	m.reviewed_at = nil
	delete(m.clearedFields, grantreport.FieldReviewedAt)
}

// SetFeedback sets the "feedback" field.
func (m *GrantReportMutation) SetFeedback(s string) {
	m.feedback = &s
}

// Feedback returns the value of the "feedback" field in the mutation.
func (m *GrantReportMutation) Feedback() (r string, exists bool) {
	v := m.feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedback returns the old "feedback" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedback: %w", err)
	}
	return oldValue.Feedback, nil
}

// ClearFeedback clears the value of the "feedback" field.
func (m *GrantReportMutation) ClearFeedback() {
	m.feedback = nil
	m.clearedFields[grantreport.FieldFeedback] = struct{}{}
}

// FeedbackCleared returns if the "feedback" field was cleared in this mutation.
func (m *GrantReportMutation) FeedbackCleared() bool {
	_, ok := m.clearedFields[grantreport.FieldFeedback]
	return ok
}

// ResetFeedback resets all changes to the "feedback" field.
func (m *GrantReportMutation) ResetFeedback() {
	m.feedback = nil
	delete(m.clearedFields, grantreport.FieldFeedback)
}

// SetIsApproved sets the "is_approved" field.
func (m *GrantReportMutation) SetIsApproved(b bool) {
	m.is_approved = &b
}

// IsApproved returns the value of the "is_approved" field in the mutation.
func (m *GrantReportMutation) IsApproved() (r bool, exists bool) {
	v := m.is_approved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsApproved returns the old "is_approved" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldIsApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsApproved: %w", err)
	}
	return oldValue.IsApproved, nil
}

// ResetIsApproved resets all changes to the "is_approved" field.
func (m *GrantReportMutation) ResetIsApproved() {
	m.is_approved = nil
}

// SetNextDueDate sets the "next_due_date" field.
func (m *GrantReportMutation) SetNextDueDate(t time.Time) {
	m.next_due_date = &t
}

// NextDueDate returns the value of the "next_due_date" field in the mutation.
func (m *GrantReportMutation) NextDueDate() (r time.Time, exists bool) {
	v := m.next_due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldNextDueDate returns the old "next_due_date" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldNextDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextDueDate: %w", err)
	}
	return oldValue.NextDueDate, nil
}

// ClearNextDueDate clears the value of the "next_due_date" field.
func (m *GrantReportMutation) ClearNextDueDate() {
	m.next_due_date = nil
	m.clearedFields[grantreport.FieldNextDueDate] = struct{}{}
}

// NextDueDateCleared returns if the "next_due_date" field was cleared in this mutation.
func (m *GrantReportMutation) NextDueDateCleared() bool {
	_, ok := m.clearedFields[grantreport.FieldNextDueDate]
	return ok
}

// ResetNextDueDate resets all changes to the "next_due_date" field.
func (m *GrantReportMutation) ResetNextDueDate() {
	m.next_due_date = nil
	delete(m.clearedFields, grantreport.FieldNextDueDate)
}

// SetCreatedAt sets the "created_at" field.
func (m *GrantReportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GrantReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GrantReportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GrantReportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GrantReportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GrantReport entity.
// If the GrantReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GrantReportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GrantReportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGrantID sets the "grant" edge to the Grant entity by id.
func (m *GrantReportMutation) SetGrantID(id int) {
	m.grant = &id
}

// ClearGrant clears the "grant" edge to the Grant entity.
func (m *GrantReportMutation) ClearGrant() {
	m.clearedgrant = true
}

// GrantCleared reports if the "grant" edge to the Grant entity was cleared.
func (m *GrantReportMutation) GrantCleared() bool {
	return m.clearedgrant
}

// GrantID returns the "grant" edge ID in the mutation.
func (m *GrantReportMutation) GrantID() (id int, exists bool) {
	if m.grant != nil {
		return *m.grant, true
	}
	return
}

// GrantIDs returns the "grant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GrantID instead. It exists only for internal usage by the builders.
func (m *GrantReportMutation) GrantIDs() (ids []int) {
	if id := m.grant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGrant resets all changes to the "grant" edge.
func (m *GrantReportMutation) ResetGrant() {
	m.grant = nil
	m.clearedgrant = false
}

// Where appends a list predicates to the GrantReportMutation builder.
func (m *GrantReportMutation) Where(ps ...predicate.GrantReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GrantReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GrantReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GrantReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GrantReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GrantReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GrantReport).
func (m *GrantReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GrantReportMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.title != nil {
		fields = append(fields, grantreport.FieldTitle)
	}
	if m.due_date != nil {
		fields = append(fields, grantreport.FieldDueDate)
	}
	if m.submitted_date != nil {
		fields = append(fields, grantreport.FieldSubmittedDate)
	}
	if m.status != nil {
		fields = append(fields, grantreport.FieldStatus)
	}
	if m.document_url != nil {
		fields = append(fields, grantreport.FieldDocumentURL)
	}
	if m.report_type != nil {
		fields = append(fields, grantreport.FieldReportType)
	}
	if m.reviewed_by != nil {
		fields = append(fields, grantreport.FieldReviewedBy)
	}
	if m.reviewed_at != nil {
		fields = append(fields, grantreport.FieldReviewedAt)
	}
	if m.feedback != nil {
		fields = append(fields, grantreport.FieldFeedback)
	}
	if m.is_approved != nil {
		fields = append(fields, grantreport.FieldIsApproved)
	}
	if m.next_due_date != nil {
		fields = append(fields, grantreport.FieldNextDueDate)
	}
	if m.created_at != nil {
		fields = append(fields, grantreport.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, grantreport.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GrantReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grantreport.FieldTitle:
		return m.Title()
	case grantreport.FieldDueDate:
		return m.DueDate()
	case grantreport.FieldSubmittedDate:
		return m.SubmittedDate()
	case grantreport.FieldStatus:
		return m.Status()
	case grantreport.FieldDocumentURL:
		return m.DocumentURL()
	case grantreport.FieldReportType:
		return m.ReportType()
	case grantreport.FieldReviewedBy:
		return m.ReviewedBy()
	case grantreport.FieldReviewedAt:
		return m.ReviewedAt()
	case grantreport.FieldFeedback:
		return m.Feedback()
	case grantreport.FieldIsApproved:
		return m.IsApproved()
	case grantreport.FieldNextDueDate:
		return m.NextDueDate()
	case grantreport.FieldCreatedAt:
		return m.CreatedAt()
	case grantreport.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GrantReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grantreport.FieldTitle:
		return m.OldTitle(ctx)
	case grantreport.FieldDueDate:
		return m.OldDueDate(ctx)
	case grantreport.FieldSubmittedDate:
		return m.OldSubmittedDate(ctx)
	case grantreport.FieldStatus:
		return m.OldStatus(ctx)
	case grantreport.FieldDocumentURL:
		return m.OldDocumentURL(ctx)
	case grantreport.FieldReportType:
		return m.OldReportType(ctx)
	case grantreport.FieldReviewedBy:
		return m.OldReviewedBy(ctx)
	case grantreport.FieldReviewedAt:
		return m.OldReviewedAt(ctx)
	case grantreport.FieldFeedback:
		return m.OldFeedback(ctx)
	case grantreport.FieldIsApproved:
		return m.OldIsApproved(ctx)
	case grantreport.FieldNextDueDate:
		return m.OldNextDueDate(ctx)
	case grantreport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case grantreport.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GrantReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grantreport.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case grantreport.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case grantreport.FieldSubmittedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmittedDate(v)
		return nil
	case grantreport.FieldStatus:
		v, ok := value.(grantreport.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case grantreport.FieldDocumentURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentURL(v)
		return nil
	case grantreport.FieldReportType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportType(v)
		return nil
	case grantreport.FieldReviewedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedBy(v)
		return nil
	case grantreport.FieldReviewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedAt(v)
		return nil
	case grantreport.FieldFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedback(v)
		return nil
	case grantreport.FieldIsApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsApproved(v)
		return nil
	case grantreport.FieldNextDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextDueDate(v)
		return nil
	case grantreport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case grantreport.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GrantReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GrantReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GrantReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GrantReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GrantReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GrantReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(grantreport.FieldSubmittedDate) {
		fields = append(fields, grantreport.FieldSubmittedDate)
	}
	if m.FieldCleared(grantreport.FieldDocumentURL) {
		fields = append(fields, grantreport.FieldDocumentURL)
	}
	if m.FieldCleared(grantreport.FieldReviewedBy) {
		fields = append(fields, grantreport.FieldReviewedBy)
	}
	if m.FieldCleared(grantreport.FieldReviewedAt) {
		fields = append(fields, grantreport.FieldReviewedAt)
	}
	if m.FieldCleared(grantreport.FieldFeedback) {
		fields = append(fields, grantreport.FieldFeedback)
	}
	if m.FieldCleared(grantreport.FieldNextDueDate) {
		fields = append(fields, grantreport.FieldNextDueDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GrantReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GrantReportMutation) ClearField(name string) error {
	switch name {
	case grantreport.FieldSubmittedDate:
		m.ClearSubmittedDate()
		return nil
	case grantreport.FieldDocumentURL:
		m.ClearDocumentURL()
		return nil
	case grantreport.FieldReviewedBy:
		m.ClearReviewedBy()
		return nil
	case grantreport.FieldReviewedAt:
		m.ClearReviewedAt()
		return nil
	case grantreport.FieldFeedback:
		m.ClearFeedback()
		return nil
	case grantreport.FieldNextDueDate:
		m.ClearNextDueDate()
		return nil
	}
	return fmt.Errorf("unknown GrantReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GrantReportMutation) ResetField(name string) error {
	switch name {
	case grantreport.FieldTitle:
		m.ResetTitle()
		return nil
	case grantreport.FieldDueDate:
		m.ResetDueDate()
		return nil
	case grantreport.FieldSubmittedDate:
		m.ResetSubmittedDate()
		return nil
	case grantreport.FieldStatus:
		m.ResetStatus()
		return nil
	case grantreport.FieldDocumentURL:
		m.ResetDocumentURL()
		return nil
	case grantreport.FieldReportType:
		m.ResetReportType()
		return nil
	case grantreport.FieldReviewedBy:
		m.ResetReviewedBy()
		return nil
	case grantreport.FieldReviewedAt:
		m.ResetReviewedAt()
		return nil
	case grantreport.FieldFeedback:
		m.ResetFeedback()
		return nil
	case grantreport.FieldIsApproved:
		m.ResetIsApproved()
		return nil
	case grantreport.FieldNextDueDate:
		m.ResetNextDueDate()
		return nil
	case grantreport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case grantreport.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GrantReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GrantReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.grant != nil {
		edges = append(edges, grantreport.EdgeGrant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GrantReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case grantreport.EdgeGrant:
		if id := m.grant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GrantReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GrantReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GrantReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgrant {
		edges = append(edges, grantreport.EdgeGrant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GrantReportMutation) EdgeCleared(name string) bool {
	switch name {
	case grantreport.EdgeGrant:
		return m.clearedgrant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GrantReportMutation) ClearEdge(name string) error {
	switch name {
	case grantreport.EdgeGrant:
		m.ClearGrant()
		return nil
	}
	return fmt.Errorf("unknown GrantReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GrantReportMutation) ResetEdge(name string) error {
	switch name {
	case grantreport.EdgeGrant:
		m.ResetGrant()
		return nil
	}
	return fmt.Errorf("unknown GrantReport edge %s", name)
}

// ImpactDataPointMutation represents an operation that mutates the ImpactDataPoint nodes in the graph.
type ImpactDataPointMutation struct {
	config
	op            Op
	typ           string
	id            *int
	value         *float64
	addvalue      *float64
	recorded_at   *time.Time
	recorded_by   *string
	period        *string
	notes         *string
	source        *string
	is_verified   *bool
	verified_by   *string
	verified_at   *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	metric        *int
	clearedmetric bool
	done          bool
	oldValue      func(context.Context) (*ImpactDataPoint, error)
	predicates    []predicate.ImpactDataPoint
}

var _ ent.Mutation = (*ImpactDataPointMutation)(nil)

// impactdatapointOption allows management of the mutation configuration using functional options.
type impactdatapointOption func(*ImpactDataPointMutation)

// newImpactDataPointMutation creates new mutation for the ImpactDataPoint entity.
func newImpactDataPointMutation(c config, op Op, opts ...impactdatapointOption) *ImpactDataPointMutation {
	m := &ImpactDataPointMutation{
		config:        c,
		op:            op,
		typ:           TypeImpactDataPoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImpactDataPointID sets the ID field of the mutation.
func withImpactDataPointID(id int) impactdatapointOption {
	return func(m *ImpactDataPointMutation) {
		var (
			err   error
			once  sync.Once
			value *ImpactDataPoint
		)
		m.oldValue = func(ctx context.Context) (*ImpactDataPoint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImpactDataPoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImpactDataPoint sets the old ImpactDataPoint of the mutation.
func withImpactDataPoint(node *ImpactDataPoint) impactdatapointOption {
	return func(m *ImpactDataPointMutation) {
		m.oldValue = func(context.Context) (*ImpactDataPoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImpactDataPointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImpactDataPointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImpactDataPointMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImpactDataPointMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImpactDataPoint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *ImpactDataPointMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *ImpactDataPointMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the ImpactDataPoint entity.
// If the ImpactDataPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactDataPointMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *ImpactDataPointMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *ImpactDataPointMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *ImpactDataPointMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetRecordedAt sets the "recorded_at" field.
func (m *ImpactDataPointMutation) SetRecordedAt(t time.Time) {
	m.recorded_at = &t
}

// RecordedAt returns the value of the "recorded_at" field in the mutation.
func (m *ImpactDataPointMutation) RecordedAt() (r time.Time, exists bool) {
	v := m.recorded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordedAt returns the old "recorded_at" field's value of the ImpactDataPoint entity.
// If the ImpactDataPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactDataPointMutation) OldRecordedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordedAt: %w", err)
	}
	return oldValue.RecordedAt, nil
}

// ResetRecordedAt resets all changes to the "recorded_at" field.
func (m *ImpactDataPointMutation) ResetRecordedAt() {
	m.recorded_at = nil
}

// SetRecordedBy sets the "recorded_by" field.
func (m *ImpactDataPointMutation) SetRecordedBy(s string) {
	m.recorded_by = &s
}

// RecordedBy returns the value of the "recorded_by" field in the mutation.
func (m *ImpactDataPointMutation) RecordedBy() (r string, exists bool) {
	v := m.recorded_by
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordedBy returns the old "recorded_by" field's value of the ImpactDataPoint entity.
// If the ImpactDataPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactDataPointMutation) OldRecordedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordedBy: %w", err)
	}
	return oldValue.RecordedBy, nil
}

// ClearRecordedBy clears the value of the "recorded_by" field.
func (m *ImpactDataPointMutation) ClearRecordedBy() {
	m.recorded_by = nil
	m.clearedFields[impactdatapoint.FieldRecordedBy] = struct{}{}
}

// RecordedByCleared returns if the "recorded_by" field was cleared in this mutation.
func (m *ImpactDataPointMutation) RecordedByCleared() bool {
	_, ok := m.clearedFields[impactdatapoint.FieldRecordedBy]
	return ok
}

// ResetRecordedBy resets all changes to the "recorded_by" field.
func (m *ImpactDataPointMutation) ResetRecordedBy() {
	m.recorded_by = nil
	delete(m.clearedFields, impactdatapoint.FieldRecordedBy)
}

// SetPeriod sets the "period" field.
func (m *ImpactDataPointMutation) SetPeriod(s string) {
	m.period = &s
}

// Period returns the value of the "period" field in the mutation.
func (m *ImpactDataPointMutation) Period() (r string, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the ImpactDataPoint entity.
// If the ImpactDataPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactDataPointMutation) OldPeriod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// ClearPeriod clears the value of the "period" field.
func (m *ImpactDataPointMutation) ClearPeriod() {
	m.period = nil
	m.clearedFields[impactdatapoint.FieldPeriod] = struct{}{}
}

// PeriodCleared returns if the "period" field was cleared in this mutation.
func (m *ImpactDataPointMutation) PeriodCleared() bool {
	_, ok := m.clearedFields[impactdatapoint.FieldPeriod]
	return ok
}

// ResetPeriod resets all changes to the "period" field.
func (m *ImpactDataPointMutation) ResetPeriod() {
	m.period = nil
	delete(m.clearedFields, impactdatapoint.FieldPeriod)
}

// SetNotes sets the "notes" field.
func (m *ImpactDataPointMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ImpactDataPointMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ImpactDataPoint entity.
// If the ImpactDataPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactDataPointMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ImpactDataPointMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[impactdatapoint.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ImpactDataPointMutation) NotesCleared() bool {
	_, ok := m.clearedFields[impactdatapoint.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ImpactDataPointMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, impactdatapoint.FieldNotes)
}

// SetSource sets the "source" field.
func (m *ImpactDataPointMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ImpactDataPointMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the ImpactDataPoint entity.
// If the ImpactDataPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactDataPointMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *ImpactDataPointMutation) ClearSource() {
	m.source = nil
	m.clearedFields[impactdatapoint.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *ImpactDataPointMutation) SourceCleared() bool {
	_, ok := m.clearedFields[impactdatapoint.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *ImpactDataPointMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, impactdatapoint.FieldSource)
}

// SetIsVerified sets the "is_verified" field.
func (m *ImpactDataPointMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *ImpactDataPointMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the ImpactDataPoint entity.
// If the ImpactDataPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactDataPointMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *ImpactDataPointMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetVerifiedBy sets the "verified_by" field.
func (m *ImpactDataPointMutation) SetVerifiedBy(s string) {
	m.verified_by = &s
}

// VerifiedBy returns the value of the "verified_by" field in the mutation.
func (m *ImpactDataPointMutation) VerifiedBy() (r string, exists bool) {
	v := m.verified_by
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedBy returns the old "verified_by" field's value of the ImpactDataPoint entity.
// If the ImpactDataPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactDataPointMutation) OldVerifiedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedBy: %w", err)
	}
	return oldValue.VerifiedBy, nil
}

// ClearVerifiedBy clears the value of the "verified_by" field.
func (m *ImpactDataPointMutation) ClearVerifiedBy() {
	m.verified_by = nil
	m.clearedFields[impactdatapoint.FieldVerifiedBy] = struct{}{}
}

// VerifiedByCleared returns if the "verified_by" field was cleared in this mutation.
func (m *ImpactDataPointMutation) VerifiedByCleared() bool {
	_, ok := m.clearedFields[impactdatapoint.FieldVerifiedBy]
	return ok
}

// ResetVerifiedBy resets all changes to the "verified_by" field.
func (m *ImpactDataPointMutation) ResetVerifiedBy() {
	m.verified_by = nil
	delete(m.clearedFields, impactdatapoint.FieldVerifiedBy)
}

// SetVerifiedAt sets the "verified_at" field.
func (m *ImpactDataPointMutation) SetVerifiedAt(t time.Time) {
	m.verified_at = &t
}

// VerifiedAt returns the value of the "verified_at" field in the mutation.
func (m *ImpactDataPointMutation) VerifiedAt() (r time.Time, exists bool) {
	v := m.verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedAt returns the old "verified_at" field's value of the ImpactDataPoint entity.
// If the ImpactDataPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactDataPointMutation) OldVerifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedAt: %w", err)
	}
	return oldValue.VerifiedAt, nil
}

// ClearVerifiedAt clears the value of the "verified_at" field.
func (m *ImpactDataPointMutation) ClearVerifiedAt() {
	m.verified_at = nil
	m.clearedFields[impactdatapoint.FieldVerifiedAt] = struct{}{}
}

// VerifiedAtCleared returns if the "verified_at" field was cleared in this mutation.
func (m *ImpactDataPointMutation) VerifiedAtCleared() bool {
	_, ok := m.clearedFields[impactdatapoint.FieldVerifiedAt]
	return ok
}

// ResetVerifiedAt resets all changes to the "verified_at" field.
func (m *ImpactDataPointMutation) ResetVerifiedAt() {
	m.verified_at = nil
	delete(m.clearedFields, impactdatapoint.FieldVerifiedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ImpactDataPointMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImpactDataPointMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ImpactDataPoint entity.
// If the ImpactDataPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactDataPointMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImpactDataPointMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImpactDataPointMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImpactDataPointMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ImpactDataPoint entity.
// If the ImpactDataPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactDataPointMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImpactDataPointMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMetricID sets the "metric" edge to the ImpactMetric entity by id.
func (m *ImpactDataPointMutation) SetMetricID(id int) {
	m.metric = &id
}

// ClearMetric clears the "metric" edge to the ImpactMetric entity.
func (m *ImpactDataPointMutation) ClearMetric() {
	m.clearedmetric = true
}

// MetricCleared reports if the "metric" edge to the ImpactMetric entity was cleared.
func (m *ImpactDataPointMutation) MetricCleared() bool {
	return m.clearedmetric
}

// MetricID returns the "metric" edge ID in the mutation.
func (m *ImpactDataPointMutation) MetricID() (id int, exists bool) {
	if m.metric != nil {
		return *m.metric, true
	}
	return
}

// MetricIDs returns the "metric" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetricID instead. It exists only for internal usage by the builders.
func (m *ImpactDataPointMutation) MetricIDs() (ids []int) {
	if id := m.metric; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetric resets all changes to the "metric" edge.
func (m *ImpactDataPointMutation) ResetMetric() {
	m.metric = nil
	m.clearedmetric = false
}

// Where appends a list predicates to the ImpactDataPointMutation builder.
func (m *ImpactDataPointMutation) Where(ps ...predicate.ImpactDataPoint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImpactDataPointMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImpactDataPointMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImpactDataPoint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImpactDataPointMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImpactDataPointMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImpactDataPoint).
func (m *ImpactDataPointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImpactDataPointMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.value != nil {
		fields = append(fields, impactdatapoint.FieldValue)
	}
	if m.recorded_at != nil {
		fields = append(fields, impactdatapoint.FieldRecordedAt)
	}
	if m.recorded_by != nil {
		fields = append(fields, impactdatapoint.FieldRecordedBy)
	}
	if m.period != nil {
		fields = append(fields, impactdatapoint.FieldPeriod)
	}
	if m.notes != nil {
		fields = append(fields, impactdatapoint.FieldNotes)
	}
	if m.source != nil {
		fields = append(fields, impactdatapoint.FieldSource)
	}
	if m.is_verified != nil {
		fields = append(fields, impactdatapoint.FieldIsVerified)
	}
	if m.verified_by != nil {
		fields = append(fields, impactdatapoint.FieldVerifiedBy)
	}
	if m.verified_at != nil {
		fields = append(fields, impactdatapoint.FieldVerifiedAt)
	}
	if m.created_at != nil {
		fields = append(fields, impactdatapoint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, impactdatapoint.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImpactDataPointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case impactdatapoint.FieldValue:
		return m.Value()
	case impactdatapoint.FieldRecordedAt:
		return m.RecordedAt()
	case impactdatapoint.FieldRecordedBy:
		return m.RecordedBy()
	case impactdatapoint.FieldPeriod:
		return m.Period()
	case impactdatapoint.FieldNotes:
		return m.Notes()
	case impactdatapoint.FieldSource:
		return m.Source()
	case impactdatapoint.FieldIsVerified:
		return m.IsVerified()
	case impactdatapoint.FieldVerifiedBy:
		return m.VerifiedBy()
	case impactdatapoint.FieldVerifiedAt:
		return m.VerifiedAt()
	case impactdatapoint.FieldCreatedAt:
		return m.CreatedAt()
	case impactdatapoint.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImpactDataPointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case impactdatapoint.FieldValue:
		return m.OldValue(ctx)
	case impactdatapoint.FieldRecordedAt:
		return m.OldRecordedAt(ctx)
	case impactdatapoint.FieldRecordedBy:
		return m.OldRecordedBy(ctx)
	case impactdatapoint.FieldPeriod:
		return m.OldPeriod(ctx)
	case impactdatapoint.FieldNotes:
		return m.OldNotes(ctx)
	case impactdatapoint.FieldSource:
		return m.OldSource(ctx)
	case impactdatapoint.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case impactdatapoint.FieldVerifiedBy:
		return m.OldVerifiedBy(ctx)
	case impactdatapoint.FieldVerifiedAt:
		return m.OldVerifiedAt(ctx)
	case impactdatapoint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case impactdatapoint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ImpactDataPoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImpactDataPointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case impactdatapoint.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case impactdatapoint.FieldRecordedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordedAt(v)
		return nil
	case impactdatapoint.FieldRecordedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordedBy(v)
		return nil
	case impactdatapoint.FieldPeriod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case impactdatapoint.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case impactdatapoint.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case impactdatapoint.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case impactdatapoint.FieldVerifiedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedBy(v)
		return nil
	case impactdatapoint.FieldVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedAt(v)
		return nil
	case impactdatapoint.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case impactdatapoint.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ImpactDataPoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImpactDataPointMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, impactdatapoint.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImpactDataPointMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case impactdatapoint.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImpactDataPointMutation) AddField(name string, value ent.Value) error {
	switch name {
	case impactdatapoint.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown ImpactDataPoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImpactDataPointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(impactdatapoint.FieldRecordedBy) {
		fields = append(fields, impactdatapoint.FieldRecordedBy)
	}
	if m.FieldCleared(impactdatapoint.FieldPeriod) {
		fields = append(fields, impactdatapoint.FieldPeriod)
	}
	if m.FieldCleared(impactdatapoint.FieldNotes) {
		fields = append(fields, impactdatapoint.FieldNotes)
	}
	if m.FieldCleared(impactdatapoint.FieldSource) {
		fields = append(fields, impactdatapoint.FieldSource)
	}
	if m.FieldCleared(impactdatapoint.FieldVerifiedBy) {
		fields = append(fields, impactdatapoint.FieldVerifiedBy)
	}
	if m.FieldCleared(impactdatapoint.FieldVerifiedAt) {
		fields = append(fields, impactdatapoint.FieldVerifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImpactDataPointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImpactDataPointMutation) ClearField(name string) error {
	switch name {
	case impactdatapoint.FieldRecordedBy:
		m.ClearRecordedBy()
		return nil
	case impactdatapoint.FieldPeriod:
		m.ClearPeriod()
		return nil
	case impactdatapoint.FieldNotes:
		m.ClearNotes()
		return nil
	case impactdatapoint.FieldSource:
		m.ClearSource()
		return nil
	case impactdatapoint.FieldVerifiedBy:
		m.ClearVerifiedBy()
		return nil
	case impactdatapoint.FieldVerifiedAt:
		m.ClearVerifiedAt()
		return nil
	}
	return fmt.Errorf("unknown ImpactDataPoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImpactDataPointMutation) ResetField(name string) error {
	switch name {
	case impactdatapoint.FieldValue:
		m.ResetValue()
		return nil
	case impactdatapoint.FieldRecordedAt:
		m.ResetRecordedAt()
		return nil
	case impactdatapoint.FieldRecordedBy:
		m.ResetRecordedBy()
		return nil
	case impactdatapoint.FieldPeriod:
		m.ResetPeriod()
		return nil
	case impactdatapoint.FieldNotes:
		m.ResetNotes()
		return nil
	case impactdatapoint.FieldSource:
		m.ResetSource()
		return nil
	case impactdatapoint.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case impactdatapoint.FieldVerifiedBy:
		m.ResetVerifiedBy()
		return nil
	case impactdatapoint.FieldVerifiedAt:
		m.ResetVerifiedAt()
		return nil
	case impactdatapoint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case impactdatapoint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ImpactDataPoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImpactDataPointMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.metric != nil {
		edges = append(edges, impactdatapoint.EdgeMetric)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImpactDataPointMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case impactdatapoint.EdgeMetric:
		if id := m.metric; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImpactDataPointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImpactDataPointMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImpactDataPointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmetric {
		edges = append(edges, impactdatapoint.EdgeMetric)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImpactDataPointMutation) EdgeCleared(name string) bool {
	switch name {
	case impactdatapoint.EdgeMetric:
		return m.clearedmetric
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImpactDataPointMutation) ClearEdge(name string) error {
	switch name {
	case impactdatapoint.EdgeMetric:
		m.ClearMetric()
		return nil
	}
	return fmt.Errorf("unknown ImpactDataPoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImpactDataPointMutation) ResetEdge(name string) error {
	switch name {
	case impactdatapoint.EdgeMetric:
		m.ResetMetric()
		return nil
	}
	return fmt.Errorf("unknown ImpactDataPoint edge %s", name)
}

// ImpactMetricMutation represents an operation that mutates the ImpactMetric nodes in the graph.
type ImpactMetricMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *map[string]string
	_type              *impactmetric.Type
	unit               *string
	target_value       *float64
	addtarget_value    *float64
	current_value      *float64
	addcurrent_value   *float64
	target_date        *time.Time
	calculation_method *string
	is_auto_calculated *bool
	last_calculated    *time.Time
	display_order      *int
	adddisplay_order   *int
	is_public          *bool
	show_on_dashboard  *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	program            *int
	clearedprogram     bool
	data_points        map[int]struct{}
	removeddata_points map[int]struct{}
	cleareddata_points bool
	done               bool
	oldValue           func(context.Context) (*ImpactMetric, error)
	predicates         []predicate.ImpactMetric
}

var _ ent.Mutation = (*ImpactMetricMutation)(nil)

// impactmetricOption allows management of the mutation configuration using functional options.
type impactmetricOption func(*ImpactMetricMutation)

// newImpactMetricMutation creates new mutation for the ImpactMetric entity.
func newImpactMetricMutation(c config, op Op, opts ...impactmetricOption) *ImpactMetricMutation {
	m := &ImpactMetricMutation{
		config:        c,
		op:            op,
		typ:           TypeImpactMetric,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImpactMetricID sets the ID field of the mutation.
func withImpactMetricID(id int) impactmetricOption {
	return func(m *ImpactMetricMutation) {
		var (
			err   error
			once  sync.Once
			value *ImpactMetric
		)
		m.oldValue = func(ctx context.Context) (*ImpactMetric, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImpactMetric.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImpactMetric sets the old ImpactMetric of the mutation.
func withImpactMetric(node *ImpactMetric) impactmetricOption {
	return func(m *ImpactMetricMutation) {
		m.oldValue = func(context.Context) (*ImpactMetric, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImpactMetricMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImpactMetricMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImpactMetricMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImpactMetricMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImpactMetric.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ImpactMetricMutation) SetName(value map[string]string) {
	m.name = &value
}

// Name returns the value of the "name" field in the mutation.
func (m *ImpactMetricMutation) Name() (r map[string]string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldName(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImpactMetricMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *ImpactMetricMutation) SetType(i impactmetric.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ImpactMetricMutation) GetType() (r impactmetric.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldType(ctx context.Context) (v impactmetric.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ImpactMetricMutation) ResetType() {
	m._type = nil
}

// SetUnit sets the "unit" field.
func (m *ImpactMetricMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *ImpactMetricMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *ImpactMetricMutation) ResetUnit() {
	m.unit = nil
}

// SetTargetValue sets the "target_value" field.
func (m *ImpactMetricMutation) SetTargetValue(f float64) {
	m.target_value = &f
	m.addtarget_value = nil
}

// TargetValue returns the value of the "target_value" field in the mutation.
func (m *ImpactMetricMutation) TargetValue() (r float64, exists bool) {
	v := m.target_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetValue returns the old "target_value" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldTargetValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetValue: %w", err)
	}
	return oldValue.TargetValue, nil
}

// AddTargetValue adds f to the "target_value" field.
func (m *ImpactMetricMutation) AddTargetValue(f float64) {
	if m.addtarget_value != nil {
		*m.addtarget_value += f
	} else {
		m.addtarget_value = &f
	}
}

// AddedTargetValue returns the value that was added to the "target_value" field in this mutation.
func (m *ImpactMetricMutation) AddedTargetValue() (r float64, exists bool) {
	v := m.addtarget_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearTargetValue clears the value of the "target_value" field.
func (m *ImpactMetricMutation) ClearTargetValue() {
	m.target_value = nil
	m.addtarget_value = nil
	m.clearedFields[impactmetric.FieldTargetValue] = struct{}{}
}

// TargetValueCleared returns if the "target_value" field was cleared in this mutation.
func (m *ImpactMetricMutation) TargetValueCleared() bool {
	_, ok := m.clearedFields[impactmetric.FieldTargetValue]
	return ok
}

// ResetTargetValue resets all changes to the "target_value" field.
func (m *ImpactMetricMutation) ResetTargetValue() {
	m.target_value = nil
	m.addtarget_value = nil
	delete(m.clearedFields, impactmetric.FieldTargetValue)
}

// SetCurrentValue sets the "current_value" field.
func (m *ImpactMetricMutation) SetCurrentValue(f float64) {
	m.current_value = &f
	m.addcurrent_value = nil
}

// CurrentValue returns the value of the "current_value" field in the mutation.
func (m *ImpactMetricMutation) CurrentValue() (r float64, exists bool) {
	v := m.current_value
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentValue returns the old "current_value" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldCurrentValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentValue: %w", err)
	}
	return oldValue.CurrentValue, nil
}

// AddCurrentValue adds f to the "current_value" field.
func (m *ImpactMetricMutation) AddCurrentValue(f float64) {
	if m.addcurrent_value != nil {
		*m.addcurrent_value += f
	} else {
		m.addcurrent_value = &f
	}
}

// AddedCurrentValue returns the value that was added to the "current_value" field in this mutation.
func (m *ImpactMetricMutation) AddedCurrentValue() (r float64, exists bool) {
	v := m.addcurrent_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentValue resets all changes to the "current_value" field.
func (m *ImpactMetricMutation) ResetCurrentValue() {
	m.current_value = nil
	m.addcurrent_value = nil
}

// SetTargetDate sets the "target_date" field.
func (m *ImpactMetricMutation) SetTargetDate(t time.Time) {
	m.target_date = &t
}

// TargetDate returns the value of the "target_date" field in the mutation.
func (m *ImpactMetricMutation) TargetDate() (r time.Time, exists bool) {
	v := m.target_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetDate returns the old "target_date" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldTargetDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetDate: %w", err)
	}
	return oldValue.TargetDate, nil
}

// ClearTargetDate clears the value of the "target_date" field.
func (m *ImpactMetricMutation) ClearTargetDate() {
	m.target_date = nil
	m.clearedFields[impactmetric.FieldTargetDate] = struct{}{}
}

// TargetDateCleared returns if the "target_date" field was cleared in this mutation.
func (m *ImpactMetricMutation) TargetDateCleared() bool {
	_, ok := m.clearedFields[impactmetric.FieldTargetDate]
	return ok
}

// ResetTargetDate resets all changes to the "target_date" field.
func (m *ImpactMetricMutation) ResetTargetDate() {
	m.target_date = nil
	delete(m.clearedFields, impactmetric.FieldTargetDate)
}

// SetCalculationMethod sets the "calculation_method" field.
func (m *ImpactMetricMutation) SetCalculationMethod(s string) {
	m.calculation_method = &s
}

// CalculationMethod returns the value of the "calculation_method" field in the mutation.
func (m *ImpactMetricMutation) CalculationMethod() (r string, exists bool) {
	v := m.calculation_method
	if v == nil {
		return
	}
	return *v, true
}

// OldCalculationMethod returns the old "calculation_method" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldCalculationMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalculationMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalculationMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalculationMethod: %w", err)
	}
	return oldValue.CalculationMethod, nil
}

// ClearCalculationMethod clears the value of the "calculation_method" field.
func (m *ImpactMetricMutation) ClearCalculationMethod() {
	m.calculation_method = nil
	m.clearedFields[impactmetric.FieldCalculationMethod] = struct{}{}
}

// CalculationMethodCleared returns if the "calculation_method" field was cleared in this mutation.
func (m *ImpactMetricMutation) CalculationMethodCleared() bool {
	_, ok := m.clearedFields[impactmetric.FieldCalculationMethod]
	return ok
}

// ResetCalculationMethod resets all changes to the "calculation_method" field.
func (m *ImpactMetricMutation) ResetCalculationMethod() {
	m.calculation_method = nil
	delete(m.clearedFields, impactmetric.FieldCalculationMethod)
}

// SetIsAutoCalculated sets the "is_auto_calculated" field.
func (m *ImpactMetricMutation) SetIsAutoCalculated(b bool) {
	m.is_auto_calculated = &b
}

// IsAutoCalculated returns the value of the "is_auto_calculated" field in the mutation.
func (m *ImpactMetricMutation) IsAutoCalculated() (r bool, exists bool) {
	v := m.is_auto_calculated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutoCalculated returns the old "is_auto_calculated" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldIsAutoCalculated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAutoCalculated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAutoCalculated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutoCalculated: %w", err)
	}
	return oldValue.IsAutoCalculated, nil
}

// ResetIsAutoCalculated resets all changes to the "is_auto_calculated" field.
func (m *ImpactMetricMutation) ResetIsAutoCalculated() {
	m.is_auto_calculated = nil
}

// SetLastCalculated sets the "last_calculated" field.
func (m *ImpactMetricMutation) SetLastCalculated(t time.Time) {
	m.last_calculated = &t
}

// LastCalculated returns the value of the "last_calculated" field in the mutation.
func (m *ImpactMetricMutation) LastCalculated() (r time.Time, exists bool) {
	v := m.last_calculated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastCalculated returns the old "last_calculated" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldLastCalculated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastCalculated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastCalculated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastCalculated: %w", err)
	}
	return oldValue.LastCalculated, nil
}

// ClearLastCalculated clears the value of the "last_calculated" field.
func (m *ImpactMetricMutation) ClearLastCalculated() {
	m.last_calculated = nil
	m.clearedFields[impactmetric.FieldLastCalculated] = struct{}{}
}

// LastCalculatedCleared returns if the "last_calculated" field was cleared in this mutation.
func (m *ImpactMetricMutation) LastCalculatedCleared() bool {
	_, ok := m.clearedFields[impactmetric.FieldLastCalculated]
	return ok
}

// ResetLastCalculated resets all changes to the "last_calculated" field.
func (m *ImpactMetricMutation) ResetLastCalculated() {
	m.last_calculated = nil
	delete(m.clearedFields, impactmetric.FieldLastCalculated)
}

// SetDisplayOrder sets the "display_order" field.
func (m *ImpactMetricMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *ImpactMetricMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *ImpactMetricMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *ImpactMetricMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *ImpactMetricMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetIsPublic sets the "is_public" field.
func (m *ImpactMetricMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *ImpactMetricMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *ImpactMetricMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetShowOnDashboard sets the "show_on_dashboard" field.
func (m *ImpactMetricMutation) SetShowOnDashboard(b bool) {
	m.show_on_dashboard = &b
}

// ShowOnDashboard returns the value of the "show_on_dashboard" field in the mutation.
func (m *ImpactMetricMutation) ShowOnDashboard() (r bool, exists bool) {
	v := m.show_on_dashboard
	if v == nil {
		return
	}
	return *v, true
}

// OldShowOnDashboard returns the old "show_on_dashboard" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldShowOnDashboard(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowOnDashboard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowOnDashboard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowOnDashboard: %w", err)
	}
	return oldValue.ShowOnDashboard, nil
}

// ResetShowOnDashboard resets all changes to the "show_on_dashboard" field.
func (m *ImpactMetricMutation) ResetShowOnDashboard() {
	m.show_on_dashboard = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ImpactMetricMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImpactMetricMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImpactMetricMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImpactMetricMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImpactMetricMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ImpactMetric entity.
// If the ImpactMetric object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImpactMetricMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImpactMetricMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProgramID sets the "program" edge to the Program entity by id.
func (m *ImpactMetricMutation) SetProgramID(id int) {
	m.program = &id
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *ImpactMetricMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *ImpactMetricMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// ProgramID returns the "program" edge ID in the mutation.
func (m *ImpactMetricMutation) ProgramID() (id int, exists bool) {
	if m.program != nil {
		return *m.program, true
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgramID instead. It exists only for internal usage by the builders.
func (m *ImpactMetricMutation) ProgramIDs() (ids []int) {
	if id := m.program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *ImpactMetricMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
}

// AddDataPointIDs adds the "data_points" edge to the ImpactDataPoint entity by ids.
func (m *ImpactMetricMutation) AddDataPointIDs(ids ...int) {
	if m.data_points == nil {
		m.data_points = make(map[int]struct{})
	}
	for i := range ids {
		m.data_points[ids[i]] = struct{}{}
	}
}

// ClearDataPoints clears the "data_points" edge to the ImpactDataPoint entity.
func (m *ImpactMetricMutation) ClearDataPoints() {
	m.cleareddata_points = true
}

// DataPointsCleared reports if the "data_points" edge to the ImpactDataPoint entity was cleared.
func (m *ImpactMetricMutation) DataPointsCleared() bool {
	return m.cleareddata_points
}

// RemoveDataPointIDs removes the "data_points" edge to the ImpactDataPoint entity by IDs.
func (m *ImpactMetricMutation) RemoveDataPointIDs(ids ...int) {
	if m.removeddata_points == nil {
		m.removeddata_points = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.data_points, ids[i])
		m.removeddata_points[ids[i]] = struct{}{}
	}
}

// RemovedDataPoints returns the removed IDs of the "data_points" edge to the ImpactDataPoint entity.
func (m *ImpactMetricMutation) RemovedDataPointsIDs() (ids []int) {
	for id := range m.removeddata_points {
		ids = append(ids, id)
	}
	return
}

// DataPointsIDs returns the "data_points" edge IDs in the mutation.
func (m *ImpactMetricMutation) DataPointsIDs() (ids []int) {
	for id := range m.data_points {
		ids = append(ids, id)
	}
	return
}

// ResetDataPoints resets all changes to the "data_points" edge.
func (m *ImpactMetricMutation) ResetDataPoints() {
	m.data_points = nil
	m.cleareddata_points = false
	m.removeddata_points = nil
}

// Where appends a list predicates to the ImpactMetricMutation builder.
func (m *ImpactMetricMutation) Where(ps ...predicate.ImpactMetric) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImpactMetricMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImpactMetricMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImpactMetric, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImpactMetricMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImpactMetricMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImpactMetric).
func (m *ImpactMetricMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImpactMetricMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, impactmetric.FieldName)
	}
	if m._type != nil {
		fields = append(fields, impactmetric.FieldType)
	}
	if m.unit != nil {
		fields = append(fields, impactmetric.FieldUnit)
	}
	if m.target_value != nil {
		fields = append(fields, impactmetric.FieldTargetValue)
	}
	if m.current_value != nil {
		fields = append(fields, impactmetric.FieldCurrentValue)
	}
	if m.target_date != nil {
		fields = append(fields, impactmetric.FieldTargetDate)
	}
	if m.calculation_method != nil {
		fields = append(fields, impactmetric.FieldCalculationMethod)
	}
	if m.is_auto_calculated != nil {
		fields = append(fields, impactmetric.FieldIsAutoCalculated)
	}
	if m.last_calculated != nil {
		fields = append(fields, impactmetric.FieldLastCalculated)
	}
	if m.display_order != nil {
		fields = append(fields, impactmetric.FieldDisplayOrder)
	}
	if m.is_public != nil {
		fields = append(fields, impactmetric.FieldIsPublic)
	}
	if m.show_on_dashboard != nil {
		fields = append(fields, impactmetric.FieldShowOnDashboard)
	}
	if m.created_at != nil {
		fields = append(fields, impactmetric.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, impactmetric.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImpactMetricMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case impactmetric.FieldName:
		return m.Name()
	case impactmetric.FieldType:
		return m.GetType()
	case impactmetric.FieldUnit:
		return m.Unit()
	case impactmetric.FieldTargetValue:
		return m.TargetValue()
	case impactmetric.FieldCurrentValue:
		return m.CurrentValue()
	case impactmetric.FieldTargetDate:
		return m.TargetDate()
	case impactmetric.FieldCalculationMethod:
		return m.CalculationMethod()
	case impactmetric.FieldIsAutoCalculated:
		return m.IsAutoCalculated()
	case impactmetric.FieldLastCalculated:
		return m.LastCalculated()
	case impactmetric.FieldDisplayOrder:
		return m.DisplayOrder()
	case impactmetric.FieldIsPublic:
		return m.IsPublic()
	case impactmetric.FieldShowOnDashboard:
		return m.ShowOnDashboard()
	case impactmetric.FieldCreatedAt:
		return m.CreatedAt()
	case impactmetric.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImpactMetricMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case impactmetric.FieldName:
		return m.OldName(ctx)
	case impactmetric.FieldType:
		return m.OldType(ctx)
	case impactmetric.FieldUnit:
		return m.OldUnit(ctx)
	case impactmetric.FieldTargetValue:
		return m.OldTargetValue(ctx)
	case impactmetric.FieldCurrentValue:
		return m.OldCurrentValue(ctx)
	case impactmetric.FieldTargetDate:
		return m.OldTargetDate(ctx)
	case impactmetric.FieldCalculationMethod:
		return m.OldCalculationMethod(ctx)
	case impactmetric.FieldIsAutoCalculated:
		return m.OldIsAutoCalculated(ctx)
	case impactmetric.FieldLastCalculated:
		return m.OldLastCalculated(ctx)
	case impactmetric.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case impactmetric.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case impactmetric.FieldShowOnDashboard:
		return m.OldShowOnDashboard(ctx)
	case impactmetric.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case impactmetric.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ImpactMetric field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImpactMetricMutation) SetField(name string, value ent.Value) error {
	switch name {
	case impactmetric.FieldName:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case impactmetric.FieldType:
		v, ok := value.(impactmetric.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case impactmetric.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case impactmetric.FieldTargetValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetValue(v)
		return nil
	case impactmetric.FieldCurrentValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentValue(v)
		return nil
	case impactmetric.FieldTargetDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetDate(v)
		return nil
	case impactmetric.FieldCalculationMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalculationMethod(v)
		return nil
	case impactmetric.FieldIsAutoCalculated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutoCalculated(v)
		return nil
	case impactmetric.FieldLastCalculated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastCalculated(v)
		return nil
	case impactmetric.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case impactmetric.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case impactmetric.FieldShowOnDashboard:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowOnDashboard(v)
		return nil
	case impactmetric.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case impactmetric.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ImpactMetric field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImpactMetricMutation) AddedFields() []string {
	var fields []string
	if m.addtarget_value != nil {
		fields = append(fields, impactmetric.FieldTargetValue)
	}
	if m.addcurrent_value != nil {
		fields = append(fields, impactmetric.FieldCurrentValue)
	}
	if m.adddisplay_order != nil {
		fields = append(fields, impactmetric.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImpactMetricMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case impactmetric.FieldTargetValue:
		return m.AddedTargetValue()
	case impactmetric.FieldCurrentValue:
		return m.AddedCurrentValue()
	case impactmetric.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImpactMetricMutation) AddField(name string, value ent.Value) error {
	switch name {
	case impactmetric.FieldTargetValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetValue(v)
		return nil
	case impactmetric.FieldCurrentValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentValue(v)
		return nil
	case impactmetric.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ImpactMetric numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImpactMetricMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(impactmetric.FieldTargetValue) {
		fields = append(fields, impactmetric.FieldTargetValue)
	}
	if m.FieldCleared(impactmetric.FieldTargetDate) {
		fields = append(fields, impactmetric.FieldTargetDate)
	}
	if m.FieldCleared(impactmetric.FieldCalculationMethod) {
		fields = append(fields, impactmetric.FieldCalculationMethod)
	}
	if m.FieldCleared(impactmetric.FieldLastCalculated) {
		fields = append(fields, impactmetric.FieldLastCalculated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImpactMetricMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImpactMetricMutation) ClearField(name string) error {
	switch name {
	case impactmetric.FieldTargetValue:
		m.ClearTargetValue()
		return nil
	case impactmetric.FieldTargetDate:
		m.ClearTargetDate()
		return nil
	case impactmetric.FieldCalculationMethod:
		m.ClearCalculationMethod()
		return nil
	case impactmetric.FieldLastCalculated:
		m.ClearLastCalculated()
		return nil
	}
	return fmt.Errorf("unknown ImpactMetric nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImpactMetricMutation) ResetField(name string) error {
	switch name {
	case impactmetric.FieldName:
		m.ResetName()
		return nil
	case impactmetric.FieldType:
		m.ResetType()
		return nil
	case impactmetric.FieldUnit:
		m.ResetUnit()
		return nil
	case impactmetric.FieldTargetValue:
		m.ResetTargetValue()
		return nil
	case impactmetric.FieldCurrentValue:
		m.ResetCurrentValue()
		return nil
	case impactmetric.FieldTargetDate:
		m.ResetTargetDate()
		return nil
	case impactmetric.FieldCalculationMethod:
		m.ResetCalculationMethod()
		return nil
	case impactmetric.FieldIsAutoCalculated:
		m.ResetIsAutoCalculated()
		return nil
	case impactmetric.FieldLastCalculated:
		m.ResetLastCalculated()
		return nil
	case impactmetric.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case impactmetric.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case impactmetric.FieldShowOnDashboard:
		m.ResetShowOnDashboard()
		return nil
	case impactmetric.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case impactmetric.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ImpactMetric field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImpactMetricMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.program != nil {
		edges = append(edges, impactmetric.EdgeProgram)
	}
	if m.data_points != nil {
		edges = append(edges, impactmetric.EdgeDataPoints)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImpactMetricMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case impactmetric.EdgeProgram:
		if id := m.program; id != nil {
			return []ent.Value{*id}
		}
	case impactmetric.EdgeDataPoints:
		ids := make([]ent.Value, 0, len(m.data_points))
		for id := range m.data_points {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImpactMetricMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddata_points != nil {
		edges = append(edges, impactmetric.EdgeDataPoints)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImpactMetricMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case impactmetric.EdgeDataPoints:
		ids := make([]ent.Value, 0, len(m.removeddata_points))
		for id := range m.removeddata_points {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImpactMetricMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprogram {
		edges = append(edges, impactmetric.EdgeProgram)
	}
	if m.cleareddata_points {
		edges = append(edges, impactmetric.EdgeDataPoints)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImpactMetricMutation) EdgeCleared(name string) bool {
	switch name {
	case impactmetric.EdgeProgram:
		return m.clearedprogram
	case impactmetric.EdgeDataPoints:
		return m.cleareddata_points
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImpactMetricMutation) ClearEdge(name string) error {
	switch name {
	case impactmetric.EdgeProgram:
		m.ClearProgram()
		return nil
	}
	return fmt.Errorf("unknown ImpactMetric unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImpactMetricMutation) ResetEdge(name string) error {
	switch name {
	case impactmetric.EdgeProgram:
		m.ResetProgram()
		return nil
	case impactmetric.EdgeDataPoints:
		m.ResetDataPoints()
		return nil
	}
	return fmt.Errorf("unknown ImpactMetric edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_type             *string
	status            *job.Status
	payload           *map[string]interface{}
	result            *map[string]interface{}
	error             *string
	inngest_run_id    *string
	scheduled_for     *time.Time
	priority          *int
	addpriority       *int
	max_retries       *int
	addmax_retries    *int
	created_at        *time.Time
	updated_at        *time.Time
	started_at        *time.Time
	completed_at      *time.Time
	metadata          *map[string]interface{}
	clearedFields     map[string]struct{}
	user              *int
	cleareduser       bool
	logs              map[int]struct{}
	removedlogs       map[int]struct{}
	clearedlogs       bool
	dependents        map[int]struct{}
	removeddependents map[int]struct{}
	cleareddependents bool
	depends_on        *int
	cleareddepends_on bool
	reports           map[int]struct{}
	removedreports    map[int]struct{}
	clearedreports    bool
	done              bool
	oldValue          func(context.Context) (*Job, error)
	predicates        []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id int) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *JobMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *JobMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *JobMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *JobMutation) SetStatus(j job.Status) {
	m.status = &j
}

// Status returns the value of the "status" field in the mutation.
func (m *JobMutation) Status() (r job.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldStatus(ctx context.Context) (v job.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JobMutation) ResetStatus() {
	m.status = nil
}

// SetPayload sets the "payload" field.
func (m *JobMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *JobMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *JobMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[job.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *JobMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[job.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *JobMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, job.FieldPayload)
}

// SetResult sets the "result" field.
func (m *JobMutation) SetResult(value map[string]interface{}) {
	m.result = &value
}

// Result returns the value of the "result" field in the mutation.
func (m *JobMutation) Result() (r map[string]interface{}, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldResult(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *JobMutation) ClearResult() {
	m.result = nil
	m.clearedFields[job.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *JobMutation) ResultCleared() bool {
	_, ok := m.clearedFields[job.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *JobMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, job.FieldResult)
}

// SetError sets the "error" field.
func (m *JobMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *JobMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *JobMutation) ClearError() {
	m.error = nil
	m.clearedFields[job.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *JobMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[job.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *JobMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, job.FieldError)
}

// SetInngestRunID sets the "inngest_run_id" field.
func (m *JobMutation) SetInngestRunID(s string) {
	m.inngest_run_id = &s
}

// InngestRunID returns the value of the "inngest_run_id" field in the mutation.
func (m *JobMutation) InngestRunID() (r string, exists bool) {
	v := m.inngest_run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInngestRunID returns the old "inngest_run_id" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldInngestRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInngestRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInngestRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInngestRunID: %w", err)
	}
	return oldValue.InngestRunID, nil
}

// ClearInngestRunID clears the value of the "inngest_run_id" field.
func (m *JobMutation) ClearInngestRunID() {
	m.inngest_run_id = nil
	m.clearedFields[job.FieldInngestRunID] = struct{}{}
}

// InngestRunIDCleared returns if the "inngest_run_id" field was cleared in this mutation.
func (m *JobMutation) InngestRunIDCleared() bool {
	_, ok := m.clearedFields[job.FieldInngestRunID]
	return ok
}

// ResetInngestRunID resets all changes to the "inngest_run_id" field.
func (m *JobMutation) ResetInngestRunID() {
	m.inngest_run_id = nil
	delete(m.clearedFields, job.FieldInngestRunID)
}

// SetScheduledFor sets the "scheduled_for" field.
func (m *JobMutation) SetScheduledFor(t time.Time) {
	m.scheduled_for = &t
}

// ScheduledFor returns the value of the "scheduled_for" field in the mutation.
func (m *JobMutation) ScheduledFor() (r time.Time, exists bool) {
	v := m.scheduled_for
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledFor returns the old "scheduled_for" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldScheduledFor(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledFor: %w", err)
	}
	return oldValue.ScheduledFor, nil
}

// ClearScheduledFor clears the value of the "scheduled_for" field.
func (m *JobMutation) ClearScheduledFor() {
	m.scheduled_for = nil
	m.clearedFields[job.FieldScheduledFor] = struct{}{}
}

// ScheduledForCleared returns if the "scheduled_for" field was cleared in this mutation.
func (m *JobMutation) ScheduledForCleared() bool {
	_, ok := m.clearedFields[job.FieldScheduledFor]
	return ok
}

// ResetScheduledFor resets all changes to the "scheduled_for" field.
func (m *JobMutation) ResetScheduledFor() {
	m.scheduled_for = nil
	delete(m.clearedFields, job.FieldScheduledFor)
}

// SetPriority sets the "priority" field.
func (m *JobMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *JobMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *JobMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *JobMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *JobMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetMaxRetries sets the "max_retries" field.
func (m *JobMutation) SetMaxRetries(i int) {
	m.max_retries = &i
	m.addmax_retries = nil
}

// MaxRetries returns the value of the "max_retries" field in the mutation.
func (m *JobMutation) MaxRetries() (r int, exists bool) {
	v := m.max_retries
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRetries returns the old "max_retries" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldMaxRetries(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxRetries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxRetries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRetries: %w", err)
	}
	return oldValue.MaxRetries, nil
}

// AddMaxRetries adds i to the "max_retries" field.
func (m *JobMutation) AddMaxRetries(i int) {
	if m.addmax_retries != nil {
		*m.addmax_retries += i
	} else {
		m.addmax_retries = &i
	}
}

// AddedMaxRetries returns the value that was added to the "max_retries" field in this mutation.
func (m *JobMutation) AddedMaxRetries() (r int, exists bool) {
	v := m.addmax_retries
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxRetries resets all changes to the "max_retries" field.
func (m *JobMutation) ResetMaxRetries() {
	m.max_retries = nil
	m.addmax_retries = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStartedAt sets the "started_at" field.
func (m *JobMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *JobMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *JobMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[job.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *JobMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[job.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *JobMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, job.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *JobMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *JobMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *JobMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[job.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *JobMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[job.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *JobMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, job.FieldCompletedAt)
}

// SetMetadata sets the "metadata" field.
func (m *JobMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *JobMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *JobMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[job.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *JobMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[job.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *JobMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, job.FieldMetadata)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *JobMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *JobMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *JobMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *JobMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *JobMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *JobMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddLogIDs adds the "logs" edge to the JobLog entity by ids.
func (m *JobMutation) AddLogIDs(ids ...int) {
	if m.logs == nil {
		m.logs = make(map[int]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the JobLog entity.
func (m *JobMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the JobLog entity was cleared.
func (m *JobMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the JobLog entity by IDs.
func (m *JobMutation) RemoveLogIDs(ids ...int) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the JobLog entity.
func (m *JobMutation) RemovedLogsIDs() (ids []int) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *JobMutation) LogsIDs() (ids []int) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *JobMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// AddDependentIDs adds the "dependents" edge to the Job entity by ids.
func (m *JobMutation) AddDependentIDs(ids ...int) {
	if m.dependents == nil {
		m.dependents = make(map[int]struct{})
	}
	for i := range ids {
		m.dependents[ids[i]] = struct{}{}
	}
}

// ClearDependents clears the "dependents" edge to the Job entity.
func (m *JobMutation) ClearDependents() {
	m.cleareddependents = true
}

// DependentsCleared reports if the "dependents" edge to the Job entity was cleared.
func (m *JobMutation) DependentsCleared() bool {
	return m.cleareddependents
}

// RemoveDependentIDs removes the "dependents" edge to the Job entity by IDs.
func (m *JobMutation) RemoveDependentIDs(ids ...int) {
	if m.removeddependents == nil {
		m.removeddependents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dependents, ids[i])
		m.removeddependents[ids[i]] = struct{}{}
	}
}

// RemovedDependents returns the removed IDs of the "dependents" edge to the Job entity.
func (m *JobMutation) RemovedDependentsIDs() (ids []int) {
	for id := range m.removeddependents {
		ids = append(ids, id)
	}
	return
}

// DependentsIDs returns the "dependents" edge IDs in the mutation.
func (m *JobMutation) DependentsIDs() (ids []int) {
	for id := range m.dependents {
		ids = append(ids, id)
	}
	return
}

// ResetDependents resets all changes to the "dependents" edge.
func (m *JobMutation) ResetDependents() {
	m.dependents = nil
	m.cleareddependents = false
	m.removeddependents = nil
}

// SetDependsOnID sets the "depends_on" edge to the Job entity by id.
func (m *JobMutation) SetDependsOnID(id int) {
	m.depends_on = &id
}

// ClearDependsOn clears the "depends_on" edge to the Job entity.
func (m *JobMutation) ClearDependsOn() {
	m.cleareddepends_on = true
}

// DependsOnCleared reports if the "depends_on" edge to the Job entity was cleared.
func (m *JobMutation) DependsOnCleared() bool {
	return m.cleareddepends_on
}

// DependsOnID returns the "depends_on" edge ID in the mutation.
func (m *JobMutation) DependsOnID() (id int, exists bool) {
	if m.depends_on != nil {
		return *m.depends_on, true
	}
	return
}

// DependsOnIDs returns the "depends_on" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependsOnID instead. It exists only for internal usage by the builders.
func (m *JobMutation) DependsOnIDs() (ids []int) {
	if id := m.depends_on; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependsOn resets all changes to the "depends_on" edge.
func (m *JobMutation) ResetDependsOn() {
	m.depends_on = nil
	m.cleareddepends_on = false
}

// AddReportIDs adds the "reports" edge to the GeneratedReport entity by ids.
func (m *JobMutation) AddReportIDs(ids ...int) {
	if m.reports == nil {
		m.reports = make(map[int]struct{})
	}
	for i := range ids {
		m.reports[ids[i]] = struct{}{}
	}
}

// ClearReports clears the "reports" edge to the GeneratedReport entity.
func (m *JobMutation) ClearReports() {
	m.clearedreports = true
}

// ReportsCleared reports if the "reports" edge to the GeneratedReport entity was cleared.
func (m *JobMutation) ReportsCleared() bool {
	return m.clearedreports
}

// RemoveReportIDs removes the "reports" edge to the GeneratedReport entity by IDs.
func (m *JobMutation) RemoveReportIDs(ids ...int) {
	if m.removedreports == nil {
		m.removedreports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reports, ids[i])
		m.removedreports[ids[i]] = struct{}{}
	}
}

// RemovedReports returns the removed IDs of the "reports" edge to the GeneratedReport entity.
func (m *JobMutation) RemovedReportsIDs() (ids []int) {
	for id := range m.removedreports {
		ids = append(ids, id)
	}
	return
}

// ReportsIDs returns the "reports" edge IDs in the mutation.
func (m *JobMutation) ReportsIDs() (ids []int) {
	for id := range m.reports {
		ids = append(ids, id)
	}
	return
}

// ResetReports resets all changes to the "reports" edge.
func (m *JobMutation) ResetReports() {
	m.reports = nil
	m.clearedreports = false
	m.removedreports = nil
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Job, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m._type != nil {
		fields = append(fields, job.FieldType)
	}
	if m.status != nil {
		fields = append(fields, job.FieldStatus)
	}
	if m.payload != nil {
		fields = append(fields, job.FieldPayload)
	}
	if m.result != nil {
		fields = append(fields, job.FieldResult)
	}
	if m.error != nil {
		fields = append(fields, job.FieldError)
	}
	if m.inngest_run_id != nil {
		fields = append(fields, job.FieldInngestRunID)
	}
	if m.scheduled_for != nil {
		fields = append(fields, job.FieldScheduledFor)
	}
	if m.priority != nil {
		fields = append(fields, job.FieldPriority)
	}
	if m.max_retries != nil {
		fields = append(fields, job.FieldMaxRetries)
	}
	if m.created_at != nil {
		fields = append(fields, job.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, job.FieldUpdatedAt)
	}
	if m.started_at != nil {
		fields = append(fields, job.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, job.FieldCompletedAt)
	}
	if m.metadata != nil {
		fields = append(fields, job.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldType:
		return m.GetType()
	case job.FieldStatus:
		return m.Status()
	case job.FieldPayload:
		return m.Payload()
	case job.FieldResult:
		return m.Result()
	case job.FieldError:
		return m.Error()
	case job.FieldInngestRunID:
		return m.InngestRunID()
	case job.FieldScheduledFor:
		return m.ScheduledFor()
	case job.FieldPriority:
		return m.Priority()
	case job.FieldMaxRetries:
		return m.MaxRetries()
	case job.FieldCreatedAt:
		return m.CreatedAt()
	case job.FieldUpdatedAt:
		return m.UpdatedAt()
	case job.FieldStartedAt:
		return m.StartedAt()
	case job.FieldCompletedAt:
		return m.CompletedAt()
	case job.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldType:
		return m.OldType(ctx)
	case job.FieldStatus:
		return m.OldStatus(ctx)
	case job.FieldPayload:
		return m.OldPayload(ctx)
	case job.FieldResult:
		return m.OldResult(ctx)
	case job.FieldError:
		return m.OldError(ctx)
	case job.FieldInngestRunID:
		return m.OldInngestRunID(ctx)
	case job.FieldScheduledFor:
		return m.OldScheduledFor(ctx)
	case job.FieldPriority:
		return m.OldPriority(ctx)
	case job.FieldMaxRetries:
		return m.OldMaxRetries(ctx)
	case job.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case job.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case job.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case job.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case job.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case job.FieldStatus:
		v, ok := value.(job.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case job.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case job.FieldResult:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case job.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case job.FieldInngestRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInngestRunID(v)
		return nil
	case job.FieldScheduledFor:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledFor(v)
		return nil
	case job.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case job.FieldMaxRetries:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRetries(v)
		return nil
	case job.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case job.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case job.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case job.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case job.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, job.FieldPriority)
	}
	if m.addmax_retries != nil {
		fields = append(fields, job.FieldMaxRetries)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case job.FieldPriority:
		return m.AddedPriority()
	case job.FieldMaxRetries:
		return m.AddedMaxRetries()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case job.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case job.FieldMaxRetries:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRetries(v)
		return nil
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(job.FieldPayload) {
		fields = append(fields, job.FieldPayload)
	}
	if m.FieldCleared(job.FieldResult) {
		fields = append(fields, job.FieldResult)
	}
	if m.FieldCleared(job.FieldError) {
		fields = append(fields, job.FieldError)
	}
	if m.FieldCleared(job.FieldInngestRunID) {
		fields = append(fields, job.FieldInngestRunID)
	}
	if m.FieldCleared(job.FieldScheduledFor) {
		fields = append(fields, job.FieldScheduledFor)
	}
	if m.FieldCleared(job.FieldStartedAt) {
		fields = append(fields, job.FieldStartedAt)
	}
	if m.FieldCleared(job.FieldCompletedAt) {
		fields = append(fields, job.FieldCompletedAt)
	}
	if m.FieldCleared(job.FieldMetadata) {
		fields = append(fields, job.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	switch name {
	case job.FieldPayload:
		m.ClearPayload()
		return nil
	case job.FieldResult:
		m.ClearResult()
		return nil
	case job.FieldError:
		m.ClearError()
		return nil
	case job.FieldInngestRunID:
		m.ClearInngestRunID()
		return nil
	case job.FieldScheduledFor:
		m.ClearScheduledFor()
		return nil
	case job.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case job.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case job.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldType:
		m.ResetType()
		return nil
	case job.FieldStatus:
		m.ResetStatus()
		return nil
	case job.FieldPayload:
		m.ResetPayload()
		return nil
	case job.FieldResult:
		m.ResetResult()
		return nil
	case job.FieldError:
		m.ResetError()
		return nil
	case job.FieldInngestRunID:
		m.ResetInngestRunID()
		return nil
	case job.FieldScheduledFor:
		m.ResetScheduledFor()
		return nil
	case job.FieldPriority:
		m.ResetPriority()
		return nil
	case job.FieldMaxRetries:
		m.ResetMaxRetries()
		return nil
	case job.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case job.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case job.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case job.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case job.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, job.EdgeUser)
	}
	if m.logs != nil {
		edges = append(edges, job.EdgeLogs)
	}
	if m.dependents != nil {
		edges = append(edges, job.EdgeDependents)
	}
	if m.depends_on != nil {
		edges = append(edges, job.EdgeDependsOn)
	}
	if m.reports != nil {
		edges = append(edges, job.EdgeReports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.dependents))
		for id := range m.dependents {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeDependsOn:
		if id := m.depends_on; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeReports:
		ids := make([]ent.Value, 0, len(m.reports))
		for id := range m.reports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedlogs != nil {
		edges = append(edges, job.EdgeLogs)
	}
	if m.removeddependents != nil {
		edges = append(edges, job.EdgeDependents)
	}
	if m.removedreports != nil {
		edges = append(edges, job.EdgeReports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeDependents:
		ids := make([]ent.Value, 0, len(m.removeddependents))
		for id := range m.removeddependents {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeReports:
		ids := make([]ent.Value, 0, len(m.removedreports))
		for id := range m.removedreports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, job.EdgeUser)
	}
	if m.clearedlogs {
		edges = append(edges, job.EdgeLogs)
	}
	if m.cleareddependents {
		edges = append(edges, job.EdgeDependents)
	}
	if m.cleareddepends_on {
		edges = append(edges, job.EdgeDependsOn)
	}
	if m.clearedreports {
		edges = append(edges, job.EdgeReports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	switch name {
	case job.EdgeUser:
		return m.cleareduser
	case job.EdgeLogs:
		return m.clearedlogs
	case job.EdgeDependents:
		return m.cleareddependents
	case job.EdgeDependsOn:
		return m.cleareddepends_on
	case job.EdgeReports:
		return m.clearedreports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	switch name {
	case job.EdgeUser:
		m.ClearUser()
		return nil
	case job.EdgeDependsOn:
		m.ClearDependsOn()
		return nil
	}
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	switch name {
	case job.EdgeUser:
		m.ResetUser()
		return nil
	case job.EdgeLogs:
		m.ResetLogs()
		return nil
	case job.EdgeDependents:
		m.ResetDependents()
		return nil
	case job.EdgeDependsOn:
		m.ResetDependsOn()
		return nil
	case job.EdgeReports:
		m.ResetReports()
		return nil
	}
	return fmt.Errorf("unknown Job edge %s", name)
}

// JobLogMutation represents an operation that mutates the JobLog nodes in the graph.
type JobLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	status        *joblog.Status
	message       *string
	metadata      *map[string]interface{}
	created_at    *time.Time
	clearedFields map[string]struct{}
	job           *int
	clearedjob    bool
	done          bool
	oldValue      func(context.Context) (*JobLog, error)
	predicates    []predicate.JobLog
}

var _ ent.Mutation = (*JobLogMutation)(nil)

// joblogOption allows management of the mutation configuration using functional options.
type joblogOption func(*JobLogMutation)

// newJobLogMutation creates new mutation for the JobLog entity.
func newJobLogMutation(c config, op Op, opts ...joblogOption) *JobLogMutation {
	m := &JobLogMutation{
		config:        c,
		op:            op,
		typ:           TypeJobLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobLogID sets the ID field of the mutation.
func withJobLogID(id int) joblogOption {
	return func(m *JobLogMutation) {
		var (
			err   error
			once  sync.Once
			value *JobLog
		)
		m.oldValue = func(ctx context.Context) (*JobLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobLog sets the old JobLog of the mutation.
func withJobLog(node *JobLog) joblogOption {
	return func(m *JobLogMutation) {
		m.oldValue = func(context.Context) (*JobLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *JobLogMutation) SetStatus(j joblog.Status) {
	m.status = &j
}

// Status returns the value of the "status" field in the mutation.
func (m *JobLogMutation) Status() (r joblog.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the JobLog entity.
// If the JobLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLogMutation) OldStatus(ctx context.Context) (v joblog.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JobLogMutation) ResetStatus() {
	m.status = nil
}

// SetMessage sets the "message" field.
func (m *JobLogMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *JobLogMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the JobLog entity.
// If the JobLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLogMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *JobLogMutation) ResetMessage() {
	m.message = nil
}

// SetMetadata sets the "metadata" field.
func (m *JobLogMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *JobLogMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the JobLog entity.
// If the JobLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLogMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *JobLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[joblog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *JobLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[joblog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *JobLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, joblog.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *JobLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobLog entity.
// If the JobLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *JobLogMutation) SetJobID(id int) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *JobLogMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *JobLogMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *JobLogMutation) JobID() (id int, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobLogMutation) JobIDs() (ids []int) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobLogMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the JobLogMutation builder.
func (m *JobLogMutation) Where(ps ...predicate.JobLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobLog).
func (m *JobLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobLogMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.status != nil {
		fields = append(fields, joblog.FieldStatus)
	}
	if m.message != nil {
		fields = append(fields, joblog.FieldMessage)
	}
	if m.metadata != nil {
		fields = append(fields, joblog.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, joblog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case joblog.FieldStatus:
		return m.Status()
	case joblog.FieldMessage:
		return m.Message()
	case joblog.FieldMetadata:
		return m.Metadata()
	case joblog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case joblog.FieldStatus:
		return m.OldStatus(ctx)
	case joblog.FieldMessage:
		return m.OldMessage(ctx)
	case joblog.FieldMetadata:
		return m.OldMetadata(ctx)
	case joblog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case joblog.FieldStatus:
		v, ok := value.(joblog.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case joblog.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case joblog.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case joblog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(joblog.FieldMetadata) {
		fields = append(fields, joblog.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobLogMutation) ClearField(name string) error {
	switch name {
	case joblog.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown JobLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobLogMutation) ResetField(name string) error {
	switch name {
	case joblog.FieldStatus:
		m.ResetStatus()
		return nil
	case joblog.FieldMessage:
		m.ResetMessage()
		return nil
	case joblog.FieldMetadata:
		m.ResetMetadata()
		return nil
	case joblog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job != nil {
		edges = append(edges, joblog.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case joblog.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob {
		edges = append(edges, joblog.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobLogMutation) EdgeCleared(name string) bool {
	switch name {
	case joblog.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobLogMutation) ClearEdge(name string) error {
	switch name {
	case joblog.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown JobLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobLogMutation) ResetEdge(name string) error {
	switch name {
	case joblog.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown JobLog edge %s", name)
}

// MentorshipRequestMutation represents an operation that mutates the MentorshipRequest nodes in the graph.
type MentorshipRequestMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	status                *mentorshiprequest.Status
	goals                 *[]string
	appendgoals           []string
	preferences           *map[string]string
	duration              *string
	matched_at            *time.Time
	matched_by            *string
	match_reason          *string
	sessions_completed    *int
	addsessions_completed *int
	last_session_date     *time.Time
	next_session_date     *time.Time
	completion_notes      *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	requester             *int
	clearedrequester      bool
	mentor                *int
	clearedmentor         bool
	sessions              map[int]struct{}
	removedsessions       map[int]struct{}
	clearedsessions       bool
	done                  bool
	oldValue              func(context.Context) (*MentorshipRequest, error)
	predicates            []predicate.MentorshipRequest
}

var _ ent.Mutation = (*MentorshipRequestMutation)(nil)

// mentorshiprequestOption allows management of the mutation configuration using functional options.
type mentorshiprequestOption func(*MentorshipRequestMutation)

// newMentorshipRequestMutation creates new mutation for the MentorshipRequest entity.
func newMentorshipRequestMutation(c config, op Op, opts ...mentorshiprequestOption) *MentorshipRequestMutation {
	m := &MentorshipRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeMentorshipRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMentorshipRequestID sets the ID field of the mutation.
func withMentorshipRequestID(id int) mentorshiprequestOption {
	return func(m *MentorshipRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *MentorshipRequest
		)
		m.oldValue = func(ctx context.Context) (*MentorshipRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MentorshipRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMentorshipRequest sets the old MentorshipRequest of the mutation.
func withMentorshipRequest(node *MentorshipRequest) mentorshiprequestOption {
	return func(m *MentorshipRequestMutation) {
		m.oldValue = func(context.Context) (*MentorshipRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MentorshipRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MentorshipRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MentorshipRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MentorshipRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MentorshipRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *MentorshipRequestMutation) SetStatus(value mentorshiprequest.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MentorshipRequestMutation) Status() (r mentorshiprequest.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldStatus(ctx context.Context) (v mentorshiprequest.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MentorshipRequestMutation) ResetStatus() {
	m.status = nil
}

// SetGoals sets the "goals" field.
func (m *MentorshipRequestMutation) SetGoals(s []string) {
	m.goals = &s
	m.appendgoals = nil
}

// Goals returns the value of the "goals" field in the mutation.
func (m *MentorshipRequestMutation) Goals() (r []string, exists bool) {
	v := m.goals
	if v == nil {
		return
	}
	return *v, true
}

// OldGoals returns the old "goals" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldGoals(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoals: %w", err)
	}
	return oldValue.Goals, nil
}

// AppendGoals adds s to the "goals" field.
func (m *MentorshipRequestMutation) AppendGoals(s []string) {
	m.appendgoals = append(m.appendgoals, s...)
}

// AppendedGoals returns the list of values that were appended to the "goals" field in this mutation.
func (m *MentorshipRequestMutation) AppendedGoals() ([]string, bool) {
	if len(m.appendgoals) == 0 {
		return nil, false
	}
	return m.appendgoals, true
}

// ResetGoals resets all changes to the "goals" field.
func (m *MentorshipRequestMutation) ResetGoals() {
	m.goals = nil
	m.appendgoals = nil
}

// SetPreferences sets the "preferences" field.
func (m *MentorshipRequestMutation) SetPreferences(value map[string]string) {
	m.preferences = &value
}

// Preferences returns the value of the "preferences" field in the mutation.
func (m *MentorshipRequestMutation) Preferences() (r map[string]string, exists bool) {
	v := m.preferences
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferences returns the old "preferences" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldPreferences(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferences: %w", err)
	}
	return oldValue.Preferences, nil
}

// ResetPreferences resets all changes to the "preferences" field.
func (m *MentorshipRequestMutation) ResetPreferences() {
	m.preferences = nil
}

// SetDuration sets the "duration" field.
func (m *MentorshipRequestMutation) SetDuration(s string) {
	m.duration = &s
}

// Duration returns the value of the "duration" field in the mutation.
func (m *MentorshipRequestMutation) Duration() (r string, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ResetDuration resets all changes to the "duration" field.
func (m *MentorshipRequestMutation) ResetDuration() {
	m.duration = nil
}

// SetMatchedAt sets the "matched_at" field.
func (m *MentorshipRequestMutation) SetMatchedAt(t time.Time) {
	m.matched_at = &t
}

// MatchedAt returns the value of the "matched_at" field in the mutation.
func (m *MentorshipRequestMutation) MatchedAt() (r time.Time, exists bool) {
	v := m.matched_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchedAt returns the old "matched_at" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldMatchedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchedAt: %w", err)
	}
	return oldValue.MatchedAt, nil
}

// ClearMatchedAt clears the value of the "matched_at" field.
func (m *MentorshipRequestMutation) ClearMatchedAt() {
	m.matched_at = nil
	m.clearedFields[mentorshiprequest.FieldMatchedAt] = struct{}{}
}

// MatchedAtCleared returns if the "matched_at" field was cleared in this mutation.
func (m *MentorshipRequestMutation) MatchedAtCleared() bool {
	_, ok := m.clearedFields[mentorshiprequest.FieldMatchedAt]
	return ok
}

// ResetMatchedAt resets all changes to the "matched_at" field.
func (m *MentorshipRequestMutation) ResetMatchedAt() {
	m.matched_at = nil
	delete(m.clearedFields, mentorshiprequest.FieldMatchedAt)
}

// SetMatchedBy sets the "matched_by" field.
func (m *MentorshipRequestMutation) SetMatchedBy(s string) {
	m.matched_by = &s
}

// MatchedBy returns the value of the "matched_by" field in the mutation.
func (m *MentorshipRequestMutation) MatchedBy() (r string, exists bool) {
	v := m.matched_by
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchedBy returns the old "matched_by" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldMatchedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchedBy: %w", err)
	}
	return oldValue.MatchedBy, nil
}

// ClearMatchedBy clears the value of the "matched_by" field.
func (m *MentorshipRequestMutation) ClearMatchedBy() {
	m.matched_by = nil
	m.clearedFields[mentorshiprequest.FieldMatchedBy] = struct{}{}
}

// MatchedByCleared returns if the "matched_by" field was cleared in this mutation.
func (m *MentorshipRequestMutation) MatchedByCleared() bool {
	_, ok := m.clearedFields[mentorshiprequest.FieldMatchedBy]
	return ok
}

// ResetMatchedBy resets all changes to the "matched_by" field.
func (m *MentorshipRequestMutation) ResetMatchedBy() {
	m.matched_by = nil
	delete(m.clearedFields, mentorshiprequest.FieldMatchedBy)
}

// SetMatchReason sets the "match_reason" field.
func (m *MentorshipRequestMutation) SetMatchReason(s string) {
	m.match_reason = &s
}

// MatchReason returns the value of the "match_reason" field in the mutation.
func (m *MentorshipRequestMutation) MatchReason() (r string, exists bool) {
	v := m.match_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchReason returns the old "match_reason" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldMatchReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchReason: %w", err)
	}
	return oldValue.MatchReason, nil
}

// ClearMatchReason clears the value of the "match_reason" field.
func (m *MentorshipRequestMutation) ClearMatchReason() {
	m.match_reason = nil
	m.clearedFields[mentorshiprequest.FieldMatchReason] = struct{}{}
}

// MatchReasonCleared returns if the "match_reason" field was cleared in this mutation.
func (m *MentorshipRequestMutation) MatchReasonCleared() bool {
	_, ok := m.clearedFields[mentorshiprequest.FieldMatchReason]
	return ok
}

// ResetMatchReason resets all changes to the "match_reason" field.
func (m *MentorshipRequestMutation) ResetMatchReason() {
	m.match_reason = nil
	delete(m.clearedFields, mentorshiprequest.FieldMatchReason)
}

// SetSessionsCompleted sets the "sessions_completed" field.
func (m *MentorshipRequestMutation) SetSessionsCompleted(i int) {
	m.sessions_completed = &i
	m.addsessions_completed = nil
}

// SessionsCompleted returns the value of the "sessions_completed" field in the mutation.
func (m *MentorshipRequestMutation) SessionsCompleted() (r int, exists bool) {
	v := m.sessions_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionsCompleted returns the old "sessions_completed" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldSessionsCompleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionsCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionsCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionsCompleted: %w", err)
	}
	return oldValue.SessionsCompleted, nil
}

// AddSessionsCompleted adds i to the "sessions_completed" field.
func (m *MentorshipRequestMutation) AddSessionsCompleted(i int) {
	if m.addsessions_completed != nil {
		*m.addsessions_completed += i
	} else {
		m.addsessions_completed = &i
	}
}

// AddedSessionsCompleted returns the value that was added to the "sessions_completed" field in this mutation.
func (m *MentorshipRequestMutation) AddedSessionsCompleted() (r int, exists bool) {
	v := m.addsessions_completed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSessionsCompleted resets all changes to the "sessions_completed" field.
func (m *MentorshipRequestMutation) ResetSessionsCompleted() {
	m.sessions_completed = nil
	m.addsessions_completed = nil
}

// SetLastSessionDate sets the "last_session_date" field.
func (m *MentorshipRequestMutation) SetLastSessionDate(t time.Time) {
	m.last_session_date = &t
}

// LastSessionDate returns the value of the "last_session_date" field in the mutation.
func (m *MentorshipRequestMutation) LastSessionDate() (r time.Time, exists bool) {
	v := m.last_session_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSessionDate returns the old "last_session_date" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldLastSessionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSessionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSessionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSessionDate: %w", err)
	}
	return oldValue.LastSessionDate, nil
}

// ClearLastSessionDate clears the value of the "last_session_date" field.
func (m *MentorshipRequestMutation) ClearLastSessionDate() {
	m.last_session_date = nil
	m.clearedFields[mentorshiprequest.FieldLastSessionDate] = struct{}{}
}

// LastSessionDateCleared returns if the "last_session_date" field was cleared in this mutation.
func (m *MentorshipRequestMutation) LastSessionDateCleared() bool {
	_, ok := m.clearedFields[mentorshiprequest.FieldLastSessionDate]
	return ok
}

// ResetLastSessionDate resets all changes to the "last_session_date" field.
func (m *MentorshipRequestMutation) ResetLastSessionDate() {
	m.last_session_date = nil
	delete(m.clearedFields, mentorshiprequest.FieldLastSessionDate)
}

// SetNextSessionDate sets the "next_session_date" field.
func (m *MentorshipRequestMutation) SetNextSessionDate(t time.Time) {
	m.next_session_date = &t
}

// NextSessionDate returns the value of the "next_session_date" field in the mutation.
func (m *MentorshipRequestMutation) NextSessionDate() (r time.Time, exists bool) {
	v := m.next_session_date
	if v == nil {
		return
	}
	return *v, true
}

// OldNextSessionDate returns the old "next_session_date" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldNextSessionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextSessionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextSessionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextSessionDate: %w", err)
	}
	return oldValue.NextSessionDate, nil
}

// ClearNextSessionDate clears the value of the "next_session_date" field.
func (m *MentorshipRequestMutation) ClearNextSessionDate() {
	m.next_session_date = nil
	m.clearedFields[mentorshiprequest.FieldNextSessionDate] = struct{}{}
}

// NextSessionDateCleared returns if the "next_session_date" field was cleared in this mutation.
func (m *MentorshipRequestMutation) NextSessionDateCleared() bool {
	_, ok := m.clearedFields[mentorshiprequest.FieldNextSessionDate]
	return ok
}

// ResetNextSessionDate resets all changes to the "next_session_date" field.
func (m *MentorshipRequestMutation) ResetNextSessionDate() {
	m.next_session_date = nil
	delete(m.clearedFields, mentorshiprequest.FieldNextSessionDate)
}

// SetCompletionNotes sets the "completion_notes" field.
func (m *MentorshipRequestMutation) SetCompletionNotes(s string) {
	m.completion_notes = &s
}

// CompletionNotes returns the value of the "completion_notes" field in the mutation.
func (m *MentorshipRequestMutation) CompletionNotes() (r string, exists bool) {
	v := m.completion_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionNotes returns the old "completion_notes" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldCompletionNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionNotes: %w", err)
	}
	return oldValue.CompletionNotes, nil
}

// ClearCompletionNotes clears the value of the "completion_notes" field.
func (m *MentorshipRequestMutation) ClearCompletionNotes() {
	m.completion_notes = nil
	m.clearedFields[mentorshiprequest.FieldCompletionNotes] = struct{}{}
}

// CompletionNotesCleared returns if the "completion_notes" field was cleared in this mutation.
func (m *MentorshipRequestMutation) CompletionNotesCleared() bool {
	_, ok := m.clearedFields[mentorshiprequest.FieldCompletionNotes]
	return ok
}

// ResetCompletionNotes resets all changes to the "completion_notes" field.
func (m *MentorshipRequestMutation) ResetCompletionNotes() {
	m.completion_notes = nil
	delete(m.clearedFields, mentorshiprequest.FieldCompletionNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *MentorshipRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MentorshipRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MentorshipRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MentorshipRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MentorshipRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MentorshipRequest entity.
// If the MentorshipRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MentorshipRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRequesterID sets the "requester" edge to the User entity by id.
func (m *MentorshipRequestMutation) SetRequesterID(id int) {
	m.requester = &id
}

// ClearRequester clears the "requester" edge to the User entity.
func (m *MentorshipRequestMutation) ClearRequester() {
	m.clearedrequester = true
}

// RequesterCleared reports if the "requester" edge to the User entity was cleared.
func (m *MentorshipRequestMutation) RequesterCleared() bool {
	return m.clearedrequester
}

// RequesterID returns the "requester" edge ID in the mutation.
func (m *MentorshipRequestMutation) RequesterID() (id int, exists bool) {
	if m.requester != nil {
		return *m.requester, true
	}
	return
}

// RequesterIDs returns the "requester" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequesterID instead. It exists only for internal usage by the builders.
func (m *MentorshipRequestMutation) RequesterIDs() (ids []int) {
	if id := m.requester; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequester resets all changes to the "requester" edge.
func (m *MentorshipRequestMutation) ResetRequester() {
	m.requester = nil
	m.clearedrequester = false
}

// SetMentorID sets the "mentor" edge to the User entity by id.
func (m *MentorshipRequestMutation) SetMentorID(id int) {
	m.mentor = &id
}

// ClearMentor clears the "mentor" edge to the User entity.
func (m *MentorshipRequestMutation) ClearMentor() {
	m.clearedmentor = true
}

// MentorCleared reports if the "mentor" edge to the User entity was cleared.
func (m *MentorshipRequestMutation) MentorCleared() bool {
	return m.clearedmentor
}

// MentorID returns the "mentor" edge ID in the mutation.
func (m *MentorshipRequestMutation) MentorID() (id int, exists bool) {
	if m.mentor != nil {
		return *m.mentor, true
	}
	return
}

// MentorIDs returns the "mentor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MentorID instead. It exists only for internal usage by the builders.
func (m *MentorshipRequestMutation) MentorIDs() (ids []int) {
	if id := m.mentor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMentor resets all changes to the "mentor" edge.
func (m *MentorshipRequestMutation) ResetMentor() {
	m.mentor = nil
	m.clearedmentor = false
}

// AddSessionIDs adds the "sessions" edge to the MentorshipSession entity by ids.
func (m *MentorshipRequestMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the MentorshipSession entity.
func (m *MentorshipRequestMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the MentorshipSession entity was cleared.
func (m *MentorshipRequestMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the MentorshipSession entity by IDs.
func (m *MentorshipRequestMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the MentorshipSession entity.
func (m *MentorshipRequestMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *MentorshipRequestMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *MentorshipRequestMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// Where appends a list predicates to the MentorshipRequestMutation builder.
func (m *MentorshipRequestMutation) Where(ps ...predicate.MentorshipRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MentorshipRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MentorshipRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MentorshipRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MentorshipRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MentorshipRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MentorshipRequest).
func (m *MentorshipRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MentorshipRequestMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.status != nil {
		fields = append(fields, mentorshiprequest.FieldStatus)
	}
	if m.goals != nil {
		fields = append(fields, mentorshiprequest.FieldGoals)
	}
	if m.preferences != nil {
		fields = append(fields, mentorshiprequest.FieldPreferences)
	}
	if m.duration != nil {
		fields = append(fields, mentorshiprequest.FieldDuration)
	}
	if m.matched_at != nil {
		fields = append(fields, mentorshiprequest.FieldMatchedAt)
	}
	if m.matched_by != nil {
		fields = append(fields, mentorshiprequest.FieldMatchedBy)
	}
	if m.match_reason != nil {
		fields = append(fields, mentorshiprequest.FieldMatchReason)
	}
	if m.sessions_completed != nil {
		fields = append(fields, mentorshiprequest.FieldSessionsCompleted)
	}
	if m.last_session_date != nil {
		fields = append(fields, mentorshiprequest.FieldLastSessionDate)
	}
	if m.next_session_date != nil {
		fields = append(fields, mentorshiprequest.FieldNextSessionDate)
	}
	if m.completion_notes != nil {
		fields = append(fields, mentorshiprequest.FieldCompletionNotes)
	}
	if m.created_at != nil {
		fields = append(fields, mentorshiprequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mentorshiprequest.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MentorshipRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mentorshiprequest.FieldStatus:
		return m.Status()
	case mentorshiprequest.FieldGoals:
		return m.Goals()
	case mentorshiprequest.FieldPreferences:
		return m.Preferences()
	case mentorshiprequest.FieldDuration:
		return m.Duration()
	case mentorshiprequest.FieldMatchedAt:
		return m.MatchedAt()
	case mentorshiprequest.FieldMatchedBy:
		return m.MatchedBy()
	case mentorshiprequest.FieldMatchReason:
		return m.MatchReason()
	case mentorshiprequest.FieldSessionsCompleted:
		return m.SessionsCompleted()
	case mentorshiprequest.FieldLastSessionDate:
		return m.LastSessionDate()
	case mentorshiprequest.FieldNextSessionDate:
		return m.NextSessionDate()
	case mentorshiprequest.FieldCompletionNotes:
		return m.CompletionNotes()
	case mentorshiprequest.FieldCreatedAt:
		return m.CreatedAt()
	case mentorshiprequest.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MentorshipRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mentorshiprequest.FieldStatus:
		return m.OldStatus(ctx)
	case mentorshiprequest.FieldGoals:
		return m.OldGoals(ctx)
	case mentorshiprequest.FieldPreferences:
		return m.OldPreferences(ctx)
	case mentorshiprequest.FieldDuration:
		return m.OldDuration(ctx)
	case mentorshiprequest.FieldMatchedAt:
		return m.OldMatchedAt(ctx)
	case mentorshiprequest.FieldMatchedBy:
		return m.OldMatchedBy(ctx)
	case mentorshiprequest.FieldMatchReason:
		return m.OldMatchReason(ctx)
	case mentorshiprequest.FieldSessionsCompleted:
		return m.OldSessionsCompleted(ctx)
	case mentorshiprequest.FieldLastSessionDate:
		return m.OldLastSessionDate(ctx)
	case mentorshiprequest.FieldNextSessionDate:
		return m.OldNextSessionDate(ctx)
	case mentorshiprequest.FieldCompletionNotes:
		return m.OldCompletionNotes(ctx)
	case mentorshiprequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mentorshiprequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MentorshipRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentorshipRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mentorshiprequest.FieldStatus:
		v, ok := value.(mentorshiprequest.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case mentorshiprequest.FieldGoals:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoals(v)
		return nil
	case mentorshiprequest.FieldPreferences:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferences(v)
		return nil
	case mentorshiprequest.FieldDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case mentorshiprequest.FieldMatchedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchedAt(v)
		return nil
	case mentorshiprequest.FieldMatchedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchedBy(v)
		return nil
	case mentorshiprequest.FieldMatchReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchReason(v)
		return nil
	case mentorshiprequest.FieldSessionsCompleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionsCompleted(v)
		return nil
	case mentorshiprequest.FieldLastSessionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSessionDate(v)
		return nil
	case mentorshiprequest.FieldNextSessionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextSessionDate(v)
		return nil
	case mentorshiprequest.FieldCompletionNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionNotes(v)
		return nil
	case mentorshiprequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mentorshiprequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MentorshipRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MentorshipRequestMutation) AddedFields() []string {
	var fields []string
	if m.addsessions_completed != nil {
		fields = append(fields, mentorshiprequest.FieldSessionsCompleted)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MentorshipRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mentorshiprequest.FieldSessionsCompleted:
		return m.AddedSessionsCompleted()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentorshipRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mentorshiprequest.FieldSessionsCompleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionsCompleted(v)
		return nil
	}
	return fmt.Errorf("unknown MentorshipRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MentorshipRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mentorshiprequest.FieldMatchedAt) {
		fields = append(fields, mentorshiprequest.FieldMatchedAt)
	}
	if m.FieldCleared(mentorshiprequest.FieldMatchedBy) {
		fields = append(fields, mentorshiprequest.FieldMatchedBy)
	}
	if m.FieldCleared(mentorshiprequest.FieldMatchReason) {
		fields = append(fields, mentorshiprequest.FieldMatchReason)
	}
	if m.FieldCleared(mentorshiprequest.FieldLastSessionDate) {
		fields = append(fields, mentorshiprequest.FieldLastSessionDate)
	}
	if m.FieldCleared(mentorshiprequest.FieldNextSessionDate) {
		fields = append(fields, mentorshiprequest.FieldNextSessionDate)
	}
	if m.FieldCleared(mentorshiprequest.FieldCompletionNotes) {
		fields = append(fields, mentorshiprequest.FieldCompletionNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MentorshipRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MentorshipRequestMutation) ClearField(name string) error {
	switch name {
	case mentorshiprequest.FieldMatchedAt:
		m.ClearMatchedAt()
		return nil
	case mentorshiprequest.FieldMatchedBy:
		m.ClearMatchedBy()
		return nil
	case mentorshiprequest.FieldMatchReason:
		m.ClearMatchReason()
		return nil
	case mentorshiprequest.FieldLastSessionDate:
		m.ClearLastSessionDate()
		return nil
	case mentorshiprequest.FieldNextSessionDate:
		m.ClearNextSessionDate()
		return nil
	case mentorshiprequest.FieldCompletionNotes:
		m.ClearCompletionNotes()
		return nil
	}
	return fmt.Errorf("unknown MentorshipRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MentorshipRequestMutation) ResetField(name string) error {
	switch name {
	case mentorshiprequest.FieldStatus:
		m.ResetStatus()
		return nil
	case mentorshiprequest.FieldGoals:
		m.ResetGoals()
		return nil
	case mentorshiprequest.FieldPreferences:
		m.ResetPreferences()
		return nil
	case mentorshiprequest.FieldDuration:
		m.ResetDuration()
		return nil
	case mentorshiprequest.FieldMatchedAt:
		m.ResetMatchedAt()
		return nil
	case mentorshiprequest.FieldMatchedBy:
		m.ResetMatchedBy()
		return nil
	case mentorshiprequest.FieldMatchReason:
		m.ResetMatchReason()
		return nil
	case mentorshiprequest.FieldSessionsCompleted:
		m.ResetSessionsCompleted()
		return nil
	case mentorshiprequest.FieldLastSessionDate:
		m.ResetLastSessionDate()
		return nil
	case mentorshiprequest.FieldNextSessionDate:
		m.ResetNextSessionDate()
		return nil
	case mentorshiprequest.FieldCompletionNotes:
		m.ResetCompletionNotes()
		return nil
	case mentorshiprequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mentorshiprequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MentorshipRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MentorshipRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.requester != nil {
		edges = append(edges, mentorshiprequest.EdgeRequester)
	}
	if m.mentor != nil {
		edges = append(edges, mentorshiprequest.EdgeMentor)
	}
	if m.sessions != nil {
		edges = append(edges, mentorshiprequest.EdgeSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MentorshipRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mentorshiprequest.EdgeRequester:
		if id := m.requester; id != nil {
			return []ent.Value{*id}
		}
	case mentorshiprequest.EdgeMentor:
		if id := m.mentor; id != nil {
			return []ent.Value{*id}
		}
	case mentorshiprequest.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MentorshipRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsessions != nil {
		edges = append(edges, mentorshiprequest.EdgeSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MentorshipRequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mentorshiprequest.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MentorshipRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrequester {
		edges = append(edges, mentorshiprequest.EdgeRequester)
	}
	if m.clearedmentor {
		edges = append(edges, mentorshiprequest.EdgeMentor)
	}
	if m.clearedsessions {
		edges = append(edges, mentorshiprequest.EdgeSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MentorshipRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case mentorshiprequest.EdgeRequester:
		return m.clearedrequester
	case mentorshiprequest.EdgeMentor:
		return m.clearedmentor
	case mentorshiprequest.EdgeSessions:
		return m.clearedsessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MentorshipRequestMutation) ClearEdge(name string) error {
	switch name {
	case mentorshiprequest.EdgeRequester:
		m.ClearRequester()
		return nil
	case mentorshiprequest.EdgeMentor:
		m.ClearMentor()
		return nil
	}
	return fmt.Errorf("unknown MentorshipRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MentorshipRequestMutation) ResetEdge(name string) error {
	switch name {
	case mentorshiprequest.EdgeRequester:
		m.ResetRequester()
		return nil
	case mentorshiprequest.EdgeMentor:
		m.ResetMentor()
		return nil
	case mentorshiprequest.EdgeSessions:
		m.ResetSessions()
		return nil
	}
	return fmt.Errorf("unknown MentorshipRequest edge %s", name)
}

// MentorshipSessionMutation represents an operation that mutates the MentorshipSession nodes in the graph.
type MentorshipSessionMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	scheduled_at              *time.Time
	duration                  *int
	addduration               *int
	format                    *string
	status                    *string
	notes                     *string
	action_items              *[]string
	appendaction_items        []string
	mentor_rating             *int
	addmentor_rating          *int
	mentee_rating             *int
	addmentee_rating          *int
	mentor_feedback           *string
	mentee_feedback           *string
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	mentorship_request        *int
	clearedmentorship_request bool
	agenda                    *int
	clearedagenda             bool
	done                      bool
	oldValue                  func(context.Context) (*MentorshipSession, error)
	predicates                []predicate.MentorshipSession
}

var _ ent.Mutation = (*MentorshipSessionMutation)(nil)

// mentorshipsessionOption allows management of the mutation configuration using functional options.
type mentorshipsessionOption func(*MentorshipSessionMutation)

// newMentorshipSessionMutation creates new mutation for the MentorshipSession entity.
func newMentorshipSessionMutation(c config, op Op, opts ...mentorshipsessionOption) *MentorshipSessionMutation {
	m := &MentorshipSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeMentorshipSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMentorshipSessionID sets the ID field of the mutation.
func withMentorshipSessionID(id int) mentorshipsessionOption {
	return func(m *MentorshipSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *MentorshipSession
		)
		m.oldValue = func(ctx context.Context) (*MentorshipSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MentorshipSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMentorshipSession sets the old MentorshipSession of the mutation.
func withMentorshipSession(node *MentorshipSession) mentorshipsessionOption {
	return func(m *MentorshipSessionMutation) {
		m.oldValue = func(context.Context) (*MentorshipSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MentorshipSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MentorshipSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MentorshipSessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MentorshipSessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MentorshipSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScheduledAt sets the "scheduled_at" field.
func (m *MentorshipSessionMutation) SetScheduledAt(t time.Time) {
	m.scheduled_at = &t
}

// ScheduledAt returns the value of the "scheduled_at" field in the mutation.
func (m *MentorshipSessionMutation) ScheduledAt() (r time.Time, exists bool) {
	v := m.scheduled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledAt returns the old "scheduled_at" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldScheduledAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledAt: %w", err)
	}
	return oldValue.ScheduledAt, nil
}

// ResetScheduledAt resets all changes to the "scheduled_at" field.
func (m *MentorshipSessionMutation) ResetScheduledAt() {
	m.scheduled_at = nil
}

// SetDuration sets the "duration" field.
func (m *MentorshipSessionMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *MentorshipSessionMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *MentorshipSessionMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *MentorshipSessionMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *MentorshipSessionMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetFormat sets the "format" field.
func (m *MentorshipSessionMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *MentorshipSessionMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *MentorshipSessionMutation) ResetFormat() {
	m.format = nil
}

// SetStatus sets the "status" field.
func (m *MentorshipSessionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *MentorshipSessionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MentorshipSessionMutation) ResetStatus() {
	m.status = nil
}

// SetNotes sets the "notes" field.
func (m *MentorshipSessionMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *MentorshipSessionMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *MentorshipSessionMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[mentorshipsession.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *MentorshipSessionMutation) NotesCleared() bool {
	_, ok := m.clearedFields[mentorshipsession.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *MentorshipSessionMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, mentorshipsession.FieldNotes)
}

// SetActionItems sets the "action_items" field.
func (m *MentorshipSessionMutation) SetActionItems(s []string) {
	m.action_items = &s
	m.appendaction_items = nil
}

// ActionItems returns the value of the "action_items" field in the mutation.
func (m *MentorshipSessionMutation) ActionItems() (r []string, exists bool) {
	v := m.action_items
	if v == nil {
		return
	}
	return *v, true
}

// OldActionItems returns the old "action_items" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldActionItems(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionItems: %w", err)
	}
	return oldValue.ActionItems, nil
}

// AppendActionItems adds s to the "action_items" field.
func (m *MentorshipSessionMutation) AppendActionItems(s []string) {
	m.appendaction_items = append(m.appendaction_items, s...)
}

// AppendedActionItems returns the list of values that were appended to the "action_items" field in this mutation.
func (m *MentorshipSessionMutation) AppendedActionItems() ([]string, bool) {
	if len(m.appendaction_items) == 0 {
		return nil, false
	}
	return m.appendaction_items, true
}

// ClearActionItems clears the value of the "action_items" field.
func (m *MentorshipSessionMutation) ClearActionItems() {
	m.action_items = nil
	m.appendaction_items = nil
	m.clearedFields[mentorshipsession.FieldActionItems] = struct{}{}
}

// ActionItemsCleared returns if the "action_items" field was cleared in this mutation.
func (m *MentorshipSessionMutation) ActionItemsCleared() bool {
	_, ok := m.clearedFields[mentorshipsession.FieldActionItems]
	return ok
}

// ResetActionItems resets all changes to the "action_items" field.
func (m *MentorshipSessionMutation) ResetActionItems() {
	m.action_items = nil
	m.appendaction_items = nil
	delete(m.clearedFields, mentorshipsession.FieldActionItems)
}

// SetMentorRating sets the "mentor_rating" field.
func (m *MentorshipSessionMutation) SetMentorRating(i int) {
	m.mentor_rating = &i
	m.addmentor_rating = nil
}

// MentorRating returns the value of the "mentor_rating" field in the mutation.
func (m *MentorshipSessionMutation) MentorRating() (r int, exists bool) {
	v := m.mentor_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldMentorRating returns the old "mentor_rating" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldMentorRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMentorRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMentorRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMentorRating: %w", err)
	}
	return oldValue.MentorRating, nil
}

// AddMentorRating adds i to the "mentor_rating" field.
func (m *MentorshipSessionMutation) AddMentorRating(i int) {
	if m.addmentor_rating != nil {
		*m.addmentor_rating += i
	} else {
		m.addmentor_rating = &i
	}
}

// AddedMentorRating returns the value that was added to the "mentor_rating" field in this mutation.
func (m *MentorshipSessionMutation) AddedMentorRating() (r int, exists bool) {
	v := m.addmentor_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearMentorRating clears the value of the "mentor_rating" field.
func (m *MentorshipSessionMutation) ClearMentorRating() {
	m.mentor_rating = nil
	m.addmentor_rating = nil
	m.clearedFields[mentorshipsession.FieldMentorRating] = struct{}{}
}

// MentorRatingCleared returns if the "mentor_rating" field was cleared in this mutation.
func (m *MentorshipSessionMutation) MentorRatingCleared() bool {
	_, ok := m.clearedFields[mentorshipsession.FieldMentorRating]
	return ok
}

// ResetMentorRating resets all changes to the "mentor_rating" field.
func (m *MentorshipSessionMutation) ResetMentorRating() {
	m.mentor_rating = nil
	m.addmentor_rating = nil
	delete(m.clearedFields, mentorshipsession.FieldMentorRating)
}

// SetMenteeRating sets the "mentee_rating" field.
func (m *MentorshipSessionMutation) SetMenteeRating(i int) {
	m.mentee_rating = &i
	m.addmentee_rating = nil
}

// MenteeRating returns the value of the "mentee_rating" field in the mutation.
func (m *MentorshipSessionMutation) MenteeRating() (r int, exists bool) {
	v := m.mentee_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldMenteeRating returns the old "mentee_rating" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldMenteeRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenteeRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenteeRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenteeRating: %w", err)
	}
	return oldValue.MenteeRating, nil
}

// AddMenteeRating adds i to the "mentee_rating" field.
func (m *MentorshipSessionMutation) AddMenteeRating(i int) {
	if m.addmentee_rating != nil {
		*m.addmentee_rating += i
	} else {
		m.addmentee_rating = &i
	}
}

// AddedMenteeRating returns the value that was added to the "mentee_rating" field in this mutation.
func (m *MentorshipSessionMutation) AddedMenteeRating() (r int, exists bool) {
	v := m.addmentee_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearMenteeRating clears the value of the "mentee_rating" field.
func (m *MentorshipSessionMutation) ClearMenteeRating() {
	m.mentee_rating = nil
	m.addmentee_rating = nil
	m.clearedFields[mentorshipsession.FieldMenteeRating] = struct{}{}
}

// MenteeRatingCleared returns if the "mentee_rating" field was cleared in this mutation.
func (m *MentorshipSessionMutation) MenteeRatingCleared() bool {
	_, ok := m.clearedFields[mentorshipsession.FieldMenteeRating]
	return ok
}

// ResetMenteeRating resets all changes to the "mentee_rating" field.
func (m *MentorshipSessionMutation) ResetMenteeRating() {
	m.mentee_rating = nil
	m.addmentee_rating = nil
	delete(m.clearedFields, mentorshipsession.FieldMenteeRating)
}

// SetMentorFeedback sets the "mentor_feedback" field.
func (m *MentorshipSessionMutation) SetMentorFeedback(s string) {
	m.mentor_feedback = &s
}

// MentorFeedback returns the value of the "mentor_feedback" field in the mutation.
func (m *MentorshipSessionMutation) MentorFeedback() (r string, exists bool) {
	v := m.mentor_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldMentorFeedback returns the old "mentor_feedback" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldMentorFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMentorFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMentorFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMentorFeedback: %w", err)
	}
	return oldValue.MentorFeedback, nil
}

// ClearMentorFeedback clears the value of the "mentor_feedback" field.
func (m *MentorshipSessionMutation) ClearMentorFeedback() {
	m.mentor_feedback = nil
	m.clearedFields[mentorshipsession.FieldMentorFeedback] = struct{}{}
}

// MentorFeedbackCleared returns if the "mentor_feedback" field was cleared in this mutation.
func (m *MentorshipSessionMutation) MentorFeedbackCleared() bool {
	_, ok := m.clearedFields[mentorshipsession.FieldMentorFeedback]
	return ok
}

// ResetMentorFeedback resets all changes to the "mentor_feedback" field.
func (m *MentorshipSessionMutation) ResetMentorFeedback() {
	m.mentor_feedback = nil
	delete(m.clearedFields, mentorshipsession.FieldMentorFeedback)
}

// SetMenteeFeedback sets the "mentee_feedback" field.
func (m *MentorshipSessionMutation) SetMenteeFeedback(s string) {
	m.mentee_feedback = &s
}

// MenteeFeedback returns the value of the "mentee_feedback" field in the mutation.
func (m *MentorshipSessionMutation) MenteeFeedback() (r string, exists bool) {
	v := m.mentee_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldMenteeFeedback returns the old "mentee_feedback" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldMenteeFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenteeFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenteeFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenteeFeedback: %w", err)
	}
	return oldValue.MenteeFeedback, nil
}

// ClearMenteeFeedback clears the value of the "mentee_feedback" field.
func (m *MentorshipSessionMutation) ClearMenteeFeedback() {
	m.mentee_feedback = nil
	m.clearedFields[mentorshipsession.FieldMenteeFeedback] = struct{}{}
}

// MenteeFeedbackCleared returns if the "mentee_feedback" field was cleared in this mutation.
func (m *MentorshipSessionMutation) MenteeFeedbackCleared() bool {
	_, ok := m.clearedFields[mentorshipsession.FieldMenteeFeedback]
	return ok
}

// ResetMenteeFeedback resets all changes to the "mentee_feedback" field.
func (m *MentorshipSessionMutation) ResetMenteeFeedback() {
	m.mentee_feedback = nil
	delete(m.clearedFields, mentorshipsession.FieldMenteeFeedback)
}

// SetCreatedAt sets the "created_at" field.
func (m *MentorshipSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MentorshipSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MentorshipSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MentorshipSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MentorshipSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MentorshipSession entity.
// If the MentorshipSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MentorshipSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MentorshipSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMentorshipRequestID sets the "mentorship_request" edge to the MentorshipRequest entity by id.
func (m *MentorshipSessionMutation) SetMentorshipRequestID(id int) {
	m.mentorship_request = &id
}

// ClearMentorshipRequest clears the "mentorship_request" edge to the MentorshipRequest entity.
func (m *MentorshipSessionMutation) ClearMentorshipRequest() {
	m.clearedmentorship_request = true
}

// MentorshipRequestCleared reports if the "mentorship_request" edge to the MentorshipRequest entity was cleared.
func (m *MentorshipSessionMutation) MentorshipRequestCleared() bool {
	return m.clearedmentorship_request
}

// MentorshipRequestID returns the "mentorship_request" edge ID in the mutation.
func (m *MentorshipSessionMutation) MentorshipRequestID() (id int, exists bool) {
	if m.mentorship_request != nil {
		return *m.mentorship_request, true
	}
	return
}

// MentorshipRequestIDs returns the "mentorship_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MentorshipRequestID instead. It exists only for internal usage by the builders.
func (m *MentorshipSessionMutation) MentorshipRequestIDs() (ids []int) {
	if id := m.mentorship_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMentorshipRequest resets all changes to the "mentorship_request" edge.
func (m *MentorshipSessionMutation) ResetMentorshipRequest() {
	m.mentorship_request = nil
	m.clearedmentorship_request = false
}

// SetAgendaID sets the "agenda" edge to the Agenda entity by id.
func (m *MentorshipSessionMutation) SetAgendaID(id int) {
	m.agenda = &id
}

// ClearAgenda clears the "agenda" edge to the Agenda entity.
func (m *MentorshipSessionMutation) ClearAgenda() {
	m.clearedagenda = true
}

// AgendaCleared reports if the "agenda" edge to the Agenda entity was cleared.
func (m *MentorshipSessionMutation) AgendaCleared() bool {
	return m.clearedagenda
}

// AgendaID returns the "agenda" edge ID in the mutation.
func (m *MentorshipSessionMutation) AgendaID() (id int, exists bool) {
	if m.agenda != nil {
		return *m.agenda, true
	}
	return
}

// AgendaIDs returns the "agenda" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgendaID instead. It exists only for internal usage by the builders.
func (m *MentorshipSessionMutation) AgendaIDs() (ids []int) {
	if id := m.agenda; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgenda resets all changes to the "agenda" edge.
func (m *MentorshipSessionMutation) ResetAgenda() {
	m.agenda = nil
	m.clearedagenda = false
}

// Where appends a list predicates to the MentorshipSessionMutation builder.
func (m *MentorshipSessionMutation) Where(ps ...predicate.MentorshipSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MentorshipSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MentorshipSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MentorshipSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MentorshipSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MentorshipSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MentorshipSession).
func (m *MentorshipSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MentorshipSessionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.scheduled_at != nil {
		fields = append(fields, mentorshipsession.FieldScheduledAt)
	}
	if m.duration != nil {
		fields = append(fields, mentorshipsession.FieldDuration)
	}
	if m.format != nil {
		fields = append(fields, mentorshipsession.FieldFormat)
	}
	if m.status != nil {
		fields = append(fields, mentorshipsession.FieldStatus)
	}
	if m.notes != nil {
		fields = append(fields, mentorshipsession.FieldNotes)
	}
	if m.action_items != nil {
		fields = append(fields, mentorshipsession.FieldActionItems)
	}
	if m.mentor_rating != nil {
		fields = append(fields, mentorshipsession.FieldMentorRating)
	}
	if m.mentee_rating != nil {
		fields = append(fields, mentorshipsession.FieldMenteeRating)
	}
	if m.mentor_feedback != nil {
		fields = append(fields, mentorshipsession.FieldMentorFeedback)
	}
	if m.mentee_feedback != nil {
		fields = append(fields, mentorshipsession.FieldMenteeFeedback)
	}
	if m.created_at != nil {
		fields = append(fields, mentorshipsession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mentorshipsession.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MentorshipSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mentorshipsession.FieldScheduledAt:
		return m.ScheduledAt()
	case mentorshipsession.FieldDuration:
		return m.Duration()
	case mentorshipsession.FieldFormat:
		return m.Format()
	case mentorshipsession.FieldStatus:
		return m.Status()
	case mentorshipsession.FieldNotes:
		return m.Notes()
	case mentorshipsession.FieldActionItems:
		return m.ActionItems()
	case mentorshipsession.FieldMentorRating:
		return m.MentorRating()
	case mentorshipsession.FieldMenteeRating:
		return m.MenteeRating()
	case mentorshipsession.FieldMentorFeedback:
		return m.MentorFeedback()
	case mentorshipsession.FieldMenteeFeedback:
		return m.MenteeFeedback()
	case mentorshipsession.FieldCreatedAt:
		return m.CreatedAt()
	case mentorshipsession.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MentorshipSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mentorshipsession.FieldScheduledAt:
		return m.OldScheduledAt(ctx)
	case mentorshipsession.FieldDuration:
		return m.OldDuration(ctx)
	case mentorshipsession.FieldFormat:
		return m.OldFormat(ctx)
	case mentorshipsession.FieldStatus:
		return m.OldStatus(ctx)
	case mentorshipsession.FieldNotes:
		return m.OldNotes(ctx)
	case mentorshipsession.FieldActionItems:
		return m.OldActionItems(ctx)
	case mentorshipsession.FieldMentorRating:
		return m.OldMentorRating(ctx)
	case mentorshipsession.FieldMenteeRating:
		return m.OldMenteeRating(ctx)
	case mentorshipsession.FieldMentorFeedback:
		return m.OldMentorFeedback(ctx)
	case mentorshipsession.FieldMenteeFeedback:
		return m.OldMenteeFeedback(ctx)
	case mentorshipsession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mentorshipsession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MentorshipSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentorshipSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mentorshipsession.FieldScheduledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledAt(v)
		return nil
	case mentorshipsession.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case mentorshipsession.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case mentorshipsession.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case mentorshipsession.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case mentorshipsession.FieldActionItems:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionItems(v)
		return nil
	case mentorshipsession.FieldMentorRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMentorRating(v)
		return nil
	case mentorshipsession.FieldMenteeRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenteeRating(v)
		return nil
	case mentorshipsession.FieldMentorFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMentorFeedback(v)
		return nil
	case mentorshipsession.FieldMenteeFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenteeFeedback(v)
		return nil
	case mentorshipsession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mentorshipsession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MentorshipSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MentorshipSessionMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, mentorshipsession.FieldDuration)
	}
	if m.addmentor_rating != nil {
		fields = append(fields, mentorshipsession.FieldMentorRating)
	}
	if m.addmentee_rating != nil {
		fields = append(fields, mentorshipsession.FieldMenteeRating)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MentorshipSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mentorshipsession.FieldDuration:
		return m.AddedDuration()
	case mentorshipsession.FieldMentorRating:
		return m.AddedMentorRating()
	case mentorshipsession.FieldMenteeRating:
		return m.AddedMenteeRating()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MentorshipSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mentorshipsession.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case mentorshipsession.FieldMentorRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMentorRating(v)
		return nil
	case mentorshipsession.FieldMenteeRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenteeRating(v)
		return nil
	}
	return fmt.Errorf("unknown MentorshipSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MentorshipSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mentorshipsession.FieldNotes) {
		fields = append(fields, mentorshipsession.FieldNotes)
	}
	if m.FieldCleared(mentorshipsession.FieldActionItems) {
		fields = append(fields, mentorshipsession.FieldActionItems)
	}
	if m.FieldCleared(mentorshipsession.FieldMentorRating) {
		fields = append(fields, mentorshipsession.FieldMentorRating)
	}
	if m.FieldCleared(mentorshipsession.FieldMenteeRating) {
		fields = append(fields, mentorshipsession.FieldMenteeRating)
	}
	if m.FieldCleared(mentorshipsession.FieldMentorFeedback) {
		fields = append(fields, mentorshipsession.FieldMentorFeedback)
	}
	if m.FieldCleared(mentorshipsession.FieldMenteeFeedback) {
		fields = append(fields, mentorshipsession.FieldMenteeFeedback)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MentorshipSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MentorshipSessionMutation) ClearField(name string) error {
	switch name {
	case mentorshipsession.FieldNotes:
		m.ClearNotes()
		return nil
	case mentorshipsession.FieldActionItems:
		m.ClearActionItems()
		return nil
	case mentorshipsession.FieldMentorRating:
		m.ClearMentorRating()
		return nil
	case mentorshipsession.FieldMenteeRating:
		m.ClearMenteeRating()
		return nil
	case mentorshipsession.FieldMentorFeedback:
		m.ClearMentorFeedback()
		return nil
	case mentorshipsession.FieldMenteeFeedback:
		m.ClearMenteeFeedback()
		return nil
	}
	return fmt.Errorf("unknown MentorshipSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MentorshipSessionMutation) ResetField(name string) error {
	switch name {
	case mentorshipsession.FieldScheduledAt:
		m.ResetScheduledAt()
		return nil
	case mentorshipsession.FieldDuration:
		m.ResetDuration()
		return nil
	case mentorshipsession.FieldFormat:
		m.ResetFormat()
		return nil
	case mentorshipsession.FieldStatus:
		m.ResetStatus()
		return nil
	case mentorshipsession.FieldNotes:
		m.ResetNotes()
		return nil
	case mentorshipsession.FieldActionItems:
		m.ResetActionItems()
		return nil
	case mentorshipsession.FieldMentorRating:
		m.ResetMentorRating()
		return nil
	case mentorshipsession.FieldMenteeRating:
		m.ResetMenteeRating()
		return nil
	case mentorshipsession.FieldMentorFeedback:
		m.ResetMentorFeedback()
		return nil
	case mentorshipsession.FieldMenteeFeedback:
		m.ResetMenteeFeedback()
		return nil
	case mentorshipsession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mentorshipsession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MentorshipSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MentorshipSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mentorship_request != nil {
		edges = append(edges, mentorshipsession.EdgeMentorshipRequest)
	}
	if m.agenda != nil {
		edges = append(edges, mentorshipsession.EdgeAgenda)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MentorshipSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mentorshipsession.EdgeMentorshipRequest:
		if id := m.mentorship_request; id != nil {
			return []ent.Value{*id}
		}
	case mentorshipsession.EdgeAgenda:
		if id := m.agenda; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MentorshipSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MentorshipSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MentorshipSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmentorship_request {
		edges = append(edges, mentorshipsession.EdgeMentorshipRequest)
	}
	if m.clearedagenda {
		edges = append(edges, mentorshipsession.EdgeAgenda)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MentorshipSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case mentorshipsession.EdgeMentorshipRequest:
		return m.clearedmentorship_request
	case mentorshipsession.EdgeAgenda:
		return m.clearedagenda
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MentorshipSessionMutation) ClearEdge(name string) error {
	switch name {
	case mentorshipsession.EdgeMentorshipRequest:
		m.ClearMentorshipRequest()
		return nil
	case mentorshipsession.EdgeAgenda:
		m.ClearAgenda()
		return nil
	}
	return fmt.Errorf("unknown MentorshipSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MentorshipSessionMutation) ResetEdge(name string) error {
	switch name {
	case mentorshipsession.EdgeMentorshipRequest:
		m.ResetMentorshipRequest()
		return nil
	case mentorshipsession.EdgeAgenda:
		m.ResetAgenda()
		return nil
	}
	return fmt.Errorf("unknown MentorshipSession edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	content             *string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	conversation        *int
	clearedconversation bool
	sender              *int
	clearedsender       bool
	done                bool
	oldValue            func(context.Context) (*Message, error)
	predicates          []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConversationID sets the "conversation" edge to the Conversation entity by id.
func (m *MessageMutation) SetConversationID(id int) {
	m.conversation = &id
}

// ClearConversation clears the "conversation" edge to the Conversation entity.
func (m *MessageMutation) ClearConversation() {
	m.clearedconversation = true
}

// ConversationCleared reports if the "conversation" edge to the Conversation entity was cleared.
func (m *MessageMutation) ConversationCleared() bool {
	return m.clearedconversation
}

// ConversationID returns the "conversation" edge ID in the mutation.
func (m *MessageMutation) ConversationID() (id int, exists bool) {
	if m.conversation != nil {
		return *m.conversation, true
	}
	return
}

// ConversationIDs returns the "conversation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConversationID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ConversationIDs() (ids []int) {
	if id := m.conversation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConversation resets all changes to the "conversation" edge.
func (m *MessageMutation) ResetConversation() {
	m.conversation = nil
	m.clearedconversation = false
}

// SetSenderID sets the "sender" edge to the User entity by id.
func (m *MessageMutation) SetSenderID(id int) {
	m.sender = &id
}

// ClearSender clears the "sender" edge to the User entity.
func (m *MessageMutation) ClearSender() {
	m.clearedsender = true
}

// SenderCleared reports if the "sender" edge to the User entity was cleared.
func (m *MessageMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderID returns the "sender" edge ID in the mutation.
func (m *MessageMutation) SenderID() (id int, exists bool) {
	if m.sender != nil {
		return *m.sender, true
	}
	return
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) SenderIDs() (ids []int) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *MessageMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldContent:
		return m.Content()
	case message.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.conversation != nil {
		edges = append(edges, message.EdgeConversation)
	}
	if m.sender != nil {
		edges = append(edges, message.EdgeSender)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeConversation:
		if id := m.conversation; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedconversation {
		edges = append(edges, message.EdgeConversation)
	}
	if m.clearedsender {
		edges = append(edges, message.EdgeSender)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeConversation:
		return m.clearedconversation
	case message.EdgeSender:
		return m.clearedsender
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ClearConversation()
		return nil
	case message.EdgeSender:
		m.ClearSender()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeConversation:
		m.ResetConversation()
		return nil
	case message.EdgeSender:
		m.ResetSender()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// NewsArticleMutation represents an operation that mutates the NewsArticle nodes in the graph.
type NewsArticleMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	slug               *string
	title              *map[string]string
	content            *map[string]interface{}
	excerpt            *map[string]string
	featured_image_url *string
	status             *newsarticle.Status
	published_at       *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	author             *int
	clearedauthor      bool
	done               bool
	oldValue           func(context.Context) (*NewsArticle, error)
	predicates         []predicate.NewsArticle
}

var _ ent.Mutation = (*NewsArticleMutation)(nil)

// newsarticleOption allows management of the mutation configuration using functional options.
type newsarticleOption func(*NewsArticleMutation)

// newNewsArticleMutation creates new mutation for the NewsArticle entity.
func newNewsArticleMutation(c config, op Op, opts ...newsarticleOption) *NewsArticleMutation {
	m := &NewsArticleMutation{
		config:        c,
		op:            op,
		typ:           TypeNewsArticle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNewsArticleID sets the ID field of the mutation.
func withNewsArticleID(id int) newsarticleOption {
	return func(m *NewsArticleMutation) {
		var (
			err   error
			once  sync.Once
			value *NewsArticle
		)
		m.oldValue = func(ctx context.Context) (*NewsArticle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NewsArticle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNewsArticle sets the old NewsArticle of the mutation.
func withNewsArticle(node *NewsArticle) newsarticleOption {
	return func(m *NewsArticleMutation) {
		m.oldValue = func(context.Context) (*NewsArticle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NewsArticleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NewsArticleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NewsArticleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NewsArticleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NewsArticle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *NewsArticleMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *NewsArticleMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the NewsArticle entity.
// If the NewsArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NewsArticleMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *NewsArticleMutation) ResetSlug() {
	m.slug = nil
}

// SetTitle sets the "title" field.
func (m *NewsArticleMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *NewsArticleMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the NewsArticle entity.
// If the NewsArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NewsArticleMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *NewsArticleMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *NewsArticleMutation) SetContent(value map[string]interface{}) {
	m.content = &value
}

// Content returns the value of the "content" field in the mutation.
func (m *NewsArticleMutation) Content() (r map[string]interface{}, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the NewsArticle entity.
// If the NewsArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NewsArticleMutation) OldContent(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *NewsArticleMutation) ResetContent() {
	m.content = nil
}

// SetExcerpt sets the "excerpt" field.
func (m *NewsArticleMutation) SetExcerpt(value map[string]string) {
	m.excerpt = &value
}

// Excerpt returns the value of the "excerpt" field in the mutation.
func (m *NewsArticleMutation) Excerpt() (r map[string]string, exists bool) {
	v := m.excerpt
	if v == nil {
		return
	}
	return *v, true
}

// OldExcerpt returns the old "excerpt" field's value of the NewsArticle entity.
// If the NewsArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NewsArticleMutation) OldExcerpt(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcerpt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcerpt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcerpt: %w", err)
	}
	return oldValue.Excerpt, nil
}

// ClearExcerpt clears the value of the "excerpt" field.
func (m *NewsArticleMutation) ClearExcerpt() {
	m.excerpt = nil
	m.clearedFields[newsarticle.FieldExcerpt] = struct{}{}
}

// ExcerptCleared returns if the "excerpt" field was cleared in this mutation.
func (m *NewsArticleMutation) ExcerptCleared() bool {
	_, ok := m.clearedFields[newsarticle.FieldExcerpt]
	return ok
}

// ResetExcerpt resets all changes to the "excerpt" field.
func (m *NewsArticleMutation) ResetExcerpt() {
	m.excerpt = nil
	delete(m.clearedFields, newsarticle.FieldExcerpt)
}

// SetFeaturedImageURL sets the "featured_image_url" field.
func (m *NewsArticleMutation) SetFeaturedImageURL(s string) {
	m.featured_image_url = &s
}

// FeaturedImageURL returns the value of the "featured_image_url" field in the mutation.
func (m *NewsArticleMutation) FeaturedImageURL() (r string, exists bool) {
	v := m.featured_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFeaturedImageURL returns the old "featured_image_url" field's value of the NewsArticle entity.
// If the NewsArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NewsArticleMutation) OldFeaturedImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeaturedImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeaturedImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeaturedImageURL: %w", err)
	}
	return oldValue.FeaturedImageURL, nil
}

// ClearFeaturedImageURL clears the value of the "featured_image_url" field.
func (m *NewsArticleMutation) ClearFeaturedImageURL() {
	m.featured_image_url = nil
	m.clearedFields[newsarticle.FieldFeaturedImageURL] = struct{}{}
}

// FeaturedImageURLCleared returns if the "featured_image_url" field was cleared in this mutation.
func (m *NewsArticleMutation) FeaturedImageURLCleared() bool {
	_, ok := m.clearedFields[newsarticle.FieldFeaturedImageURL]
	return ok
}

// ResetFeaturedImageURL resets all changes to the "featured_image_url" field.
func (m *NewsArticleMutation) ResetFeaturedImageURL() {
	m.featured_image_url = nil
	delete(m.clearedFields, newsarticle.FieldFeaturedImageURL)
}

// SetStatus sets the "status" field.
func (m *NewsArticleMutation) SetStatus(n newsarticle.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NewsArticleMutation) Status() (r newsarticle.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NewsArticle entity.
// If the NewsArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NewsArticleMutation) OldStatus(ctx context.Context) (v newsarticle.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NewsArticleMutation) ResetStatus() {
	m.status = nil
}

// SetPublishedAt sets the "published_at" field.
func (m *NewsArticleMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *NewsArticleMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the NewsArticle entity.
// If the NewsArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NewsArticleMutation) OldPublishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *NewsArticleMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[newsarticle.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *NewsArticleMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[newsarticle.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *NewsArticleMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, newsarticle.FieldPublishedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *NewsArticleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NewsArticleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NewsArticle entity.
// If the NewsArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NewsArticleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NewsArticleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NewsArticleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NewsArticleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NewsArticle entity.
// If the NewsArticle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NewsArticleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NewsArticleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *NewsArticleMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *NewsArticleMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *NewsArticleMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *NewsArticleMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *NewsArticleMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *NewsArticleMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// Where appends a list predicates to the NewsArticleMutation builder.
func (m *NewsArticleMutation) Where(ps ...predicate.NewsArticle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NewsArticleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NewsArticleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NewsArticle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NewsArticleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NewsArticleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NewsArticle).
func (m *NewsArticleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NewsArticleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.slug != nil {
		fields = append(fields, newsarticle.FieldSlug)
	}
	if m.title != nil {
		fields = append(fields, newsarticle.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, newsarticle.FieldContent)
	}
	if m.excerpt != nil {
		fields = append(fields, newsarticle.FieldExcerpt)
	}
	if m.featured_image_url != nil {
		fields = append(fields, newsarticle.FieldFeaturedImageURL)
	}
	if m.status != nil {
		fields = append(fields, newsarticle.FieldStatus)
	}
	if m.published_at != nil {
		fields = append(fields, newsarticle.FieldPublishedAt)
	}
	if m.created_at != nil {
		fields = append(fields, newsarticle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, newsarticle.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NewsArticleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case newsarticle.FieldSlug:
		return m.Slug()
	case newsarticle.FieldTitle:
		return m.Title()
	case newsarticle.FieldContent:
		return m.Content()
	case newsarticle.FieldExcerpt:
		return m.Excerpt()
	case newsarticle.FieldFeaturedImageURL:
		return m.FeaturedImageURL()
	case newsarticle.FieldStatus:
		return m.Status()
	case newsarticle.FieldPublishedAt:
		return m.PublishedAt()
	case newsarticle.FieldCreatedAt:
		return m.CreatedAt()
	case newsarticle.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NewsArticleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case newsarticle.FieldSlug:
		return m.OldSlug(ctx)
	case newsarticle.FieldTitle:
		return m.OldTitle(ctx)
	case newsarticle.FieldContent:
		return m.OldContent(ctx)
	case newsarticle.FieldExcerpt:
		return m.OldExcerpt(ctx)
	case newsarticle.FieldFeaturedImageURL:
		return m.OldFeaturedImageURL(ctx)
	case newsarticle.FieldStatus:
		return m.OldStatus(ctx)
	case newsarticle.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case newsarticle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case newsarticle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NewsArticle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NewsArticleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case newsarticle.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case newsarticle.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case newsarticle.FieldContent:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case newsarticle.FieldExcerpt:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcerpt(v)
		return nil
	case newsarticle.FieldFeaturedImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeaturedImageURL(v)
		return nil
	case newsarticle.FieldStatus:
		v, ok := value.(newsarticle.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case newsarticle.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case newsarticle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case newsarticle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NewsArticle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NewsArticleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NewsArticleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NewsArticleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NewsArticle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NewsArticleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(newsarticle.FieldExcerpt) {
		fields = append(fields, newsarticle.FieldExcerpt)
	}
	if m.FieldCleared(newsarticle.FieldFeaturedImageURL) {
		fields = append(fields, newsarticle.FieldFeaturedImageURL)
	}
	if m.FieldCleared(newsarticle.FieldPublishedAt) {
		fields = append(fields, newsarticle.FieldPublishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NewsArticleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NewsArticleMutation) ClearField(name string) error {
	switch name {
	case newsarticle.FieldExcerpt:
		m.ClearExcerpt()
		return nil
	case newsarticle.FieldFeaturedImageURL:
		m.ClearFeaturedImageURL()
		return nil
	case newsarticle.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	}
	return fmt.Errorf("unknown NewsArticle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NewsArticleMutation) ResetField(name string) error {
	switch name {
	case newsarticle.FieldSlug:
		m.ResetSlug()
		return nil
	case newsarticle.FieldTitle:
		m.ResetTitle()
		return nil
	case newsarticle.FieldContent:
		m.ResetContent()
		return nil
	case newsarticle.FieldExcerpt:
		m.ResetExcerpt()
		return nil
	case newsarticle.FieldFeaturedImageURL:
		m.ResetFeaturedImageURL()
		return nil
	case newsarticle.FieldStatus:
		m.ResetStatus()
		return nil
	case newsarticle.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case newsarticle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case newsarticle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown NewsArticle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NewsArticleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.author != nil {
		edges = append(edges, newsarticle.EdgeAuthor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NewsArticleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case newsarticle.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NewsArticleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NewsArticleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NewsArticleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedauthor {
		edges = append(edges, newsarticle.EdgeAuthor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NewsArticleMutation) EdgeCleared(name string) bool {
	switch name {
	case newsarticle.EdgeAuthor:
		return m.clearedauthor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NewsArticleMutation) ClearEdge(name string) error {
	switch name {
	case newsarticle.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown NewsArticle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NewsArticleMutation) ResetEdge(name string) error {
	switch name {
	case newsarticle.EdgeAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown NewsArticle edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	website             *string
	logo_url            *string
	description         *string
	industry            *string
	size                *string
	contact_email       *string
	contact_phone       *string
	address             *map[string]string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	partnerships        map[int]struct{}
	removedpartnerships map[int]struct{}
	clearedpartnerships bool
	grants              map[int]struct{}
	removedgrants       map[int]struct{}
	clearedgrants       bool
	user                *int
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*Organization, error)
	predicates          []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetWebsite sets the "website" field.
func (m *OrganizationMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *OrganizationMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *OrganizationMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[organization.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *OrganizationMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[organization.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *OrganizationMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, organization.FieldWebsite)
}

// SetLogoURL sets the "logo_url" field.
func (m *OrganizationMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *OrganizationMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *OrganizationMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[organization.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *OrganizationMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *OrganizationMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, organization.FieldLogoURL)
}

// SetDescription sets the "description" field.
func (m *OrganizationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrganizationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrganizationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[organization.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrganizationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[organization.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrganizationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, organization.FieldDescription)
}

// SetIndustry sets the "industry" field.
func (m *OrganizationMutation) SetIndustry(s string) {
	m.industry = &s
}

// Industry returns the value of the "industry" field in the mutation.
func (m *OrganizationMutation) Industry() (r string, exists bool) {
	v := m.industry
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustry returns the old "industry" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldIndustry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustry: %w", err)
	}
	return oldValue.Industry, nil
}

// ClearIndustry clears the value of the "industry" field.
func (m *OrganizationMutation) ClearIndustry() {
	m.industry = nil
	m.clearedFields[organization.FieldIndustry] = struct{}{}
}

// IndustryCleared returns if the "industry" field was cleared in this mutation.
func (m *OrganizationMutation) IndustryCleared() bool {
	_, ok := m.clearedFields[organization.FieldIndustry]
	return ok
}

// ResetIndustry resets all changes to the "industry" field.
func (m *OrganizationMutation) ResetIndustry() {
	m.industry = nil
	delete(m.clearedFields, organization.FieldIndustry)
}

// SetSize sets the "size" field.
func (m *OrganizationMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *OrganizationMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ClearSize clears the value of the "size" field.
func (m *OrganizationMutation) ClearSize() {
	m.size = nil
	m.clearedFields[organization.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *OrganizationMutation) SizeCleared() bool {
	_, ok := m.clearedFields[organization.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *OrganizationMutation) ResetSize() {
	m.size = nil
	delete(m.clearedFields, organization.FieldSize)
}

// SetContactEmail sets the "contact_email" field.
func (m *OrganizationMutation) SetContactEmail(s string) {
	m.contact_email = &s
}

// ContactEmail returns the value of the "contact_email" field in the mutation.
func (m *OrganizationMutation) ContactEmail() (r string, exists bool) {
	v := m.contact_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactEmail returns the old "contact_email" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldContactEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactEmail: %w", err)
	}
	return oldValue.ContactEmail, nil
}

// ClearContactEmail clears the value of the "contact_email" field.
func (m *OrganizationMutation) ClearContactEmail() {
	m.contact_email = nil
	m.clearedFields[organization.FieldContactEmail] = struct{}{}
}

// ContactEmailCleared returns if the "contact_email" field was cleared in this mutation.
func (m *OrganizationMutation) ContactEmailCleared() bool {
	_, ok := m.clearedFields[organization.FieldContactEmail]
	return ok
}

// ResetContactEmail resets all changes to the "contact_email" field.
func (m *OrganizationMutation) ResetContactEmail() {
	m.contact_email = nil
	delete(m.clearedFields, organization.FieldContactEmail)
}

// SetContactPhone sets the "contact_phone" field.
func (m *OrganizationMutation) SetContactPhone(s string) {
	m.contact_phone = &s
}

// ContactPhone returns the value of the "contact_phone" field in the mutation.
func (m *OrganizationMutation) ContactPhone() (r string, exists bool) {
	v := m.contact_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPhone returns the old "contact_phone" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldContactPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPhone: %w", err)
	}
	return oldValue.ContactPhone, nil
}

// ClearContactPhone clears the value of the "contact_phone" field.
func (m *OrganizationMutation) ClearContactPhone() {
	m.contact_phone = nil
	m.clearedFields[organization.FieldContactPhone] = struct{}{}
}

// ContactPhoneCleared returns if the "contact_phone" field was cleared in this mutation.
func (m *OrganizationMutation) ContactPhoneCleared() bool {
	_, ok := m.clearedFields[organization.FieldContactPhone]
	return ok
}

// ResetContactPhone resets all changes to the "contact_phone" field.
func (m *OrganizationMutation) ResetContactPhone() {
	m.contact_phone = nil
	delete(m.clearedFields, organization.FieldContactPhone)
}

// SetAddress sets the "address" field.
func (m *OrganizationMutation) SetAddress(value map[string]string) {
	m.address = &value
}

// Address returns the value of the "address" field in the mutation.
func (m *OrganizationMutation) Address() (r map[string]string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldAddress(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *OrganizationMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[organization.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *OrganizationMutation) AddressCleared() bool {
	_, ok := m.clearedFields[organization.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *OrganizationMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, organization.FieldAddress)
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddPartnershipIDs adds the "partnerships" edge to the Partnership entity by ids.
func (m *OrganizationMutation) AddPartnershipIDs(ids ...int) {
	if m.partnerships == nil {
		m.partnerships = make(map[int]struct{})
	}
	for i := range ids {
		m.partnerships[ids[i]] = struct{}{}
	}
}

// ClearPartnerships clears the "partnerships" edge to the Partnership entity.
func (m *OrganizationMutation) ClearPartnerships() {
	m.clearedpartnerships = true
}

// PartnershipsCleared reports if the "partnerships" edge to the Partnership entity was cleared.
func (m *OrganizationMutation) PartnershipsCleared() bool {
	return m.clearedpartnerships
}

// RemovePartnershipIDs removes the "partnerships" edge to the Partnership entity by IDs.
func (m *OrganizationMutation) RemovePartnershipIDs(ids ...int) {
	if m.removedpartnerships == nil {
		m.removedpartnerships = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.partnerships, ids[i])
		m.removedpartnerships[ids[i]] = struct{}{}
	}
}

// RemovedPartnerships returns the removed IDs of the "partnerships" edge to the Partnership entity.
func (m *OrganizationMutation) RemovedPartnershipsIDs() (ids []int) {
	for id := range m.removedpartnerships {
		ids = append(ids, id)
	}
	return
}

// PartnershipsIDs returns the "partnerships" edge IDs in the mutation.
func (m *OrganizationMutation) PartnershipsIDs() (ids []int) {
	for id := range m.partnerships {
		ids = append(ids, id)
	}
	return
}

// ResetPartnerships resets all changes to the "partnerships" edge.
func (m *OrganizationMutation) ResetPartnerships() {
	m.partnerships = nil
	m.clearedpartnerships = false
	m.removedpartnerships = nil
}

// AddGrantIDs adds the "grants" edge to the Grant entity by ids.
func (m *OrganizationMutation) AddGrantIDs(ids ...int) {
	if m.grants == nil {
		m.grants = make(map[int]struct{})
	}
	for i := range ids {
		m.grants[ids[i]] = struct{}{}
	}
}

// ClearGrants clears the "grants" edge to the Grant entity.
func (m *OrganizationMutation) ClearGrants() {
	m.clearedgrants = true
}

// GrantsCleared reports if the "grants" edge to the Grant entity was cleared.
func (m *OrganizationMutation) GrantsCleared() bool {
	return m.clearedgrants
}

// RemoveGrantIDs removes the "grants" edge to the Grant entity by IDs.
func (m *OrganizationMutation) RemoveGrantIDs(ids ...int) {
	if m.removedgrants == nil {
		m.removedgrants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.grants, ids[i])
		m.removedgrants[ids[i]] = struct{}{}
	}
}

// RemovedGrants returns the removed IDs of the "grants" edge to the Grant entity.
func (m *OrganizationMutation) RemovedGrantsIDs() (ids []int) {
	for id := range m.removedgrants {
		ids = append(ids, id)
	}
	return
}

// GrantsIDs returns the "grants" edge IDs in the mutation.
func (m *OrganizationMutation) GrantsIDs() (ids []int) {
	for id := range m.grants {
		ids = append(ids, id)
	}
	return
}

// ResetGrants resets all changes to the "grants" edge.
func (m *OrganizationMutation) ResetGrants() {
	m.grants = nil
	m.clearedgrants = false
	m.removedgrants = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *OrganizationMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrganizationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrganizationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *OrganizationMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrganizationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.website != nil {
		fields = append(fields, organization.FieldWebsite)
	}
	if m.logo_url != nil {
		fields = append(fields, organization.FieldLogoURL)
	}
	if m.description != nil {
		fields = append(fields, organization.FieldDescription)
	}
	if m.industry != nil {
		fields = append(fields, organization.FieldIndustry)
	}
	if m.size != nil {
		fields = append(fields, organization.FieldSize)
	}
	if m.contact_email != nil {
		fields = append(fields, organization.FieldContactEmail)
	}
	if m.contact_phone != nil {
		fields = append(fields, organization.FieldContactPhone)
	}
	if m.address != nil {
		fields = append(fields, organization.FieldAddress)
	}
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldName:
		return m.Name()
	case organization.FieldWebsite:
		return m.Website()
	case organization.FieldLogoURL:
		return m.LogoURL()
	case organization.FieldDescription:
		return m.Description()
	case organization.FieldIndustry:
		return m.Industry()
	case organization.FieldSize:
		return m.Size()
	case organization.FieldContactEmail:
		return m.ContactEmail()
	case organization.FieldContactPhone:
		return m.ContactPhone()
	case organization.FieldAddress:
		return m.Address()
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldWebsite:
		return m.OldWebsite(ctx)
	case organization.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case organization.FieldDescription:
		return m.OldDescription(ctx)
	case organization.FieldIndustry:
		return m.OldIndustry(ctx)
	case organization.FieldSize:
		return m.OldSize(ctx)
	case organization.FieldContactEmail:
		return m.OldContactEmail(ctx)
	case organization.FieldContactPhone:
		return m.OldContactPhone(ctx)
	case organization.FieldAddress:
		return m.OldAddress(ctx)
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case organization.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case organization.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case organization.FieldIndustry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustry(v)
		return nil
	case organization.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case organization.FieldContactEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactEmail(v)
		return nil
	case organization.FieldContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPhone(v)
		return nil
	case organization.FieldAddress:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldWebsite) {
		fields = append(fields, organization.FieldWebsite)
	}
	if m.FieldCleared(organization.FieldLogoURL) {
		fields = append(fields, organization.FieldLogoURL)
	}
	if m.FieldCleared(organization.FieldDescription) {
		fields = append(fields, organization.FieldDescription)
	}
	if m.FieldCleared(organization.FieldIndustry) {
		fields = append(fields, organization.FieldIndustry)
	}
	if m.FieldCleared(organization.FieldSize) {
		fields = append(fields, organization.FieldSize)
	}
	if m.FieldCleared(organization.FieldContactEmail) {
		fields = append(fields, organization.FieldContactEmail)
	}
	if m.FieldCleared(organization.FieldContactPhone) {
		fields = append(fields, organization.FieldContactPhone)
	}
	if m.FieldCleared(organization.FieldAddress) {
		fields = append(fields, organization.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldWebsite:
		m.ClearWebsite()
		return nil
	case organization.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	case organization.FieldDescription:
		m.ClearDescription()
		return nil
	case organization.FieldIndustry:
		m.ClearIndustry()
		return nil
	case organization.FieldSize:
		m.ClearSize()
		return nil
	case organization.FieldContactEmail:
		m.ClearContactEmail()
		return nil
	case organization.FieldContactPhone:
		m.ClearContactPhone()
		return nil
	case organization.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldWebsite:
		m.ResetWebsite()
		return nil
	case organization.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case organization.FieldDescription:
		m.ResetDescription()
		return nil
	case organization.FieldIndustry:
		m.ResetIndustry()
		return nil
	case organization.FieldSize:
		m.ResetSize()
		return nil
	case organization.FieldContactEmail:
		m.ResetContactEmail()
		return nil
	case organization.FieldContactPhone:
		m.ResetContactPhone()
		return nil
	case organization.FieldAddress:
		m.ResetAddress()
		return nil
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.partnerships != nil {
		edges = append(edges, organization.EdgePartnerships)
	}
	if m.grants != nil {
		edges = append(edges, organization.EdgeGrants)
	}
	if m.user != nil {
		edges = append(edges, organization.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgePartnerships:
		ids := make([]ent.Value, 0, len(m.partnerships))
		for id := range m.partnerships {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeGrants:
		ids := make([]ent.Value, 0, len(m.grants))
		for id := range m.grants {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpartnerships != nil {
		edges = append(edges, organization.EdgePartnerships)
	}
	if m.removedgrants != nil {
		edges = append(edges, organization.EdgeGrants)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgePartnerships:
		ids := make([]ent.Value, 0, len(m.removedpartnerships))
		for id := range m.removedpartnerships {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeGrants:
		ids := make([]ent.Value, 0, len(m.removedgrants))
		for id := range m.removedgrants {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpartnerships {
		edges = append(edges, organization.EdgePartnerships)
	}
	if m.clearedgrants {
		edges = append(edges, organization.EdgeGrants)
	}
	if m.cleareduser {
		edges = append(edges, organization.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgePartnerships:
		return m.clearedpartnerships
	case organization.EdgeGrants:
		return m.clearedgrants
	case organization.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgePartnerships:
		m.ResetPartnerships()
		return nil
	case organization.EdgeGrants:
		m.ResetGrants()
		return nil
	case organization.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// PageMutation represents an operation that mutates the Page nodes in the graph.
type PageMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	slug               *string
	title              *map[string]string
	status             *page.Status
	published_at       *time.Time
	layout             *string
	is_homepage        *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	child_pages        map[int]struct{}
	removedchild_pages map[int]struct{}
	clearedchild_pages bool
	parent_page        *int
	clearedparent_page bool
	blocks             map[int]struct{}
	removedblocks      map[int]struct{}
	clearedblocks      bool
	seo                *int
	clearedseo         bool
	done               bool
	oldValue           func(context.Context) (*Page, error)
	predicates         []predicate.Page
}

var _ ent.Mutation = (*PageMutation)(nil)

// pageOption allows management of the mutation configuration using functional options.
type pageOption func(*PageMutation)

// newPageMutation creates new mutation for the Page entity.
func newPageMutation(c config, op Op, opts ...pageOption) *PageMutation {
	m := &PageMutation{
		config:        c,
		op:            op,
		typ:           TypePage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPageID sets the ID field of the mutation.
func withPageID(id int) pageOption {
	return func(m *PageMutation) {
		var (
			err   error
			once  sync.Once
			value *Page
		)
		m.oldValue = func(ctx context.Context) (*Page, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Page.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPage sets the old Page of the mutation.
func withPage(node *Page) pageOption {
	return func(m *PageMutation) {
		m.oldValue = func(context.Context) (*Page, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Page.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *PageMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PageMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *PageMutation) ResetSlug() {
	m.slug = nil
}

// SetTitle sets the "title" field.
func (m *PageMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *PageMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PageMutation) ResetTitle() {
	m.title = nil
}

// SetStatus sets the "status" field.
func (m *PageMutation) SetStatus(pa page.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PageMutation) Status() (r page.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldStatus(ctx context.Context) (v page.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PageMutation) ResetStatus() {
	m.status = nil
}

// SetPublishedAt sets the "published_at" field.
func (m *PageMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *PageMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldPublishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *PageMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[page.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *PageMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[page.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *PageMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, page.FieldPublishedAt)
}

// SetLayout sets the "layout" field.
func (m *PageMutation) SetLayout(s string) {
	m.layout = &s
}

// Layout returns the value of the "layout" field in the mutation.
func (m *PageMutation) Layout() (r string, exists bool) {
	v := m.layout
	if v == nil {
		return
	}
	return *v, true
}

// OldLayout returns the old "layout" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldLayout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayout: %w", err)
	}
	return oldValue.Layout, nil
}

// ResetLayout resets all changes to the "layout" field.
func (m *PageMutation) ResetLayout() {
	m.layout = nil
}

// SetIsHomepage sets the "is_homepage" field.
func (m *PageMutation) SetIsHomepage(b bool) {
	m.is_homepage = &b
}

// IsHomepage returns the value of the "is_homepage" field in the mutation.
func (m *PageMutation) IsHomepage() (r bool, exists bool) {
	v := m.is_homepage
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHomepage returns the old "is_homepage" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldIsHomepage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHomepage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHomepage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHomepage: %w", err)
	}
	return oldValue.IsHomepage, nil
}

// ResetIsHomepage resets all changes to the "is_homepage" field.
func (m *PageMutation) ResetIsHomepage() {
	m.is_homepage = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Page entity.
// If the Page object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddChildPageIDs adds the "child_pages" edge to the Page entity by ids.
func (m *PageMutation) AddChildPageIDs(ids ...int) {
	if m.child_pages == nil {
		m.child_pages = make(map[int]struct{})
	}
	for i := range ids {
		m.child_pages[ids[i]] = struct{}{}
	}
}

// ClearChildPages clears the "child_pages" edge to the Page entity.
func (m *PageMutation) ClearChildPages() {
	m.clearedchild_pages = true
}

// ChildPagesCleared reports if the "child_pages" edge to the Page entity was cleared.
func (m *PageMutation) ChildPagesCleared() bool {
	return m.clearedchild_pages
}

// RemoveChildPageIDs removes the "child_pages" edge to the Page entity by IDs.
func (m *PageMutation) RemoveChildPageIDs(ids ...int) {
	if m.removedchild_pages == nil {
		m.removedchild_pages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.child_pages, ids[i])
		m.removedchild_pages[ids[i]] = struct{}{}
	}
}

// RemovedChildPages returns the removed IDs of the "child_pages" edge to the Page entity.
func (m *PageMutation) RemovedChildPagesIDs() (ids []int) {
	for id := range m.removedchild_pages {
		ids = append(ids, id)
	}
	return
}

// ChildPagesIDs returns the "child_pages" edge IDs in the mutation.
func (m *PageMutation) ChildPagesIDs() (ids []int) {
	for id := range m.child_pages {
		ids = append(ids, id)
	}
	return
}

// ResetChildPages resets all changes to the "child_pages" edge.
func (m *PageMutation) ResetChildPages() {
	m.child_pages = nil
	m.clearedchild_pages = false
	m.removedchild_pages = nil
}

// SetParentPageID sets the "parent_page" edge to the Page entity by id.
func (m *PageMutation) SetParentPageID(id int) {
	m.parent_page = &id
}

// ClearParentPage clears the "parent_page" edge to the Page entity.
func (m *PageMutation) ClearParentPage() {
	m.clearedparent_page = true
}

// ParentPageCleared reports if the "parent_page" edge to the Page entity was cleared.
func (m *PageMutation) ParentPageCleared() bool {
	return m.clearedparent_page
}

// ParentPageID returns the "parent_page" edge ID in the mutation.
func (m *PageMutation) ParentPageID() (id int, exists bool) {
	if m.parent_page != nil {
		return *m.parent_page, true
	}
	return
}

// ParentPageIDs returns the "parent_page" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentPageID instead. It exists only for internal usage by the builders.
func (m *PageMutation) ParentPageIDs() (ids []int) {
	if id := m.parent_page; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentPage resets all changes to the "parent_page" edge.
func (m *PageMutation) ResetParentPage() {
	m.parent_page = nil
	m.clearedparent_page = false
}

// AddBlockIDs adds the "blocks" edge to the ContentBlock entity by ids.
func (m *PageMutation) AddBlockIDs(ids ...int) {
	if m.blocks == nil {
		m.blocks = make(map[int]struct{})
	}
	for i := range ids {
		m.blocks[ids[i]] = struct{}{}
	}
}

// ClearBlocks clears the "blocks" edge to the ContentBlock entity.
func (m *PageMutation) ClearBlocks() {
	m.clearedblocks = true
}

// BlocksCleared reports if the "blocks" edge to the ContentBlock entity was cleared.
func (m *PageMutation) BlocksCleared() bool {
	return m.clearedblocks
}

// RemoveBlockIDs removes the "blocks" edge to the ContentBlock entity by IDs.
func (m *PageMutation) RemoveBlockIDs(ids ...int) {
	if m.removedblocks == nil {
		m.removedblocks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.blocks, ids[i])
		m.removedblocks[ids[i]] = struct{}{}
	}
}

// RemovedBlocks returns the removed IDs of the "blocks" edge to the ContentBlock entity.
func (m *PageMutation) RemovedBlocksIDs() (ids []int) {
	for id := range m.removedblocks {
		ids = append(ids, id)
	}
	return
}

// BlocksIDs returns the "blocks" edge IDs in the mutation.
func (m *PageMutation) BlocksIDs() (ids []int) {
	for id := range m.blocks {
		ids = append(ids, id)
	}
	return
}

// ResetBlocks resets all changes to the "blocks" edge.
func (m *PageMutation) ResetBlocks() {
	m.blocks = nil
	m.clearedblocks = false
	m.removedblocks = nil
}

// SetSeoID sets the "seo" edge to the SeoConfig entity by id.
func (m *PageMutation) SetSeoID(id int) {
	m.seo = &id
}

// ClearSeo clears the "seo" edge to the SeoConfig entity.
func (m *PageMutation) ClearSeo() {
	m.clearedseo = true
}

// SeoCleared reports if the "seo" edge to the SeoConfig entity was cleared.
func (m *PageMutation) SeoCleared() bool {
	return m.clearedseo
}

// SeoID returns the "seo" edge ID in the mutation.
func (m *PageMutation) SeoID() (id int, exists bool) {
	if m.seo != nil {
		return *m.seo, true
	}
	return
}

// SeoIDs returns the "seo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeoID instead. It exists only for internal usage by the builders.
func (m *PageMutation) SeoIDs() (ids []int) {
	if id := m.seo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeo resets all changes to the "seo" edge.
func (m *PageMutation) ResetSeo() {
	m.seo = nil
	m.clearedseo = false
}

// Where appends a list predicates to the PageMutation builder.
func (m *PageMutation) Where(ps ...predicate.Page) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Page, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Page).
func (m *PageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PageMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.slug != nil {
		fields = append(fields, page.FieldSlug)
	}
	if m.title != nil {
		fields = append(fields, page.FieldTitle)
	}
	if m.status != nil {
		fields = append(fields, page.FieldStatus)
	}
	if m.published_at != nil {
		fields = append(fields, page.FieldPublishedAt)
	}
	if m.layout != nil {
		fields = append(fields, page.FieldLayout)
	}
	if m.is_homepage != nil {
		fields = append(fields, page.FieldIsHomepage)
	}
	if m.created_at != nil {
		fields = append(fields, page.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, page.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case page.FieldSlug:
		return m.Slug()
	case page.FieldTitle:
		return m.Title()
	case page.FieldStatus:
		return m.Status()
	case page.FieldPublishedAt:
		return m.PublishedAt()
	case page.FieldLayout:
		return m.Layout()
	case page.FieldIsHomepage:
		return m.IsHomepage()
	case page.FieldCreatedAt:
		return m.CreatedAt()
	case page.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case page.FieldSlug:
		return m.OldSlug(ctx)
	case page.FieldTitle:
		return m.OldTitle(ctx)
	case page.FieldStatus:
		return m.OldStatus(ctx)
	case page.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case page.FieldLayout:
		return m.OldLayout(ctx)
	case page.FieldIsHomepage:
		return m.OldIsHomepage(ctx)
	case page.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case page.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Page field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case page.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case page.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case page.FieldStatus:
		v, ok := value.(page.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case page.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case page.FieldLayout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayout(v)
		return nil
	case page.FieldIsHomepage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHomepage(v)
		return nil
	case page.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case page.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Page field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Page numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(page.FieldPublishedAt) {
		fields = append(fields, page.FieldPublishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PageMutation) ClearField(name string) error {
	switch name {
	case page.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	}
	return fmt.Errorf("unknown Page nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PageMutation) ResetField(name string) error {
	switch name {
	case page.FieldSlug:
		m.ResetSlug()
		return nil
	case page.FieldTitle:
		m.ResetTitle()
		return nil
	case page.FieldStatus:
		m.ResetStatus()
		return nil
	case page.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case page.FieldLayout:
		m.ResetLayout()
		return nil
	case page.FieldIsHomepage:
		m.ResetIsHomepage()
		return nil
	case page.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case page.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Page field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PageMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.child_pages != nil {
		edges = append(edges, page.EdgeChildPages)
	}
	if m.parent_page != nil {
		edges = append(edges, page.EdgeParentPage)
	}
	if m.blocks != nil {
		edges = append(edges, page.EdgeBlocks)
	}
	if m.seo != nil {
		edges = append(edges, page.EdgeSeo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case page.EdgeChildPages:
		ids := make([]ent.Value, 0, len(m.child_pages))
		for id := range m.child_pages {
			ids = append(ids, id)
		}
		return ids
	case page.EdgeParentPage:
		if id := m.parent_page; id != nil {
			return []ent.Value{*id}
		}
	case page.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.blocks))
		for id := range m.blocks {
			ids = append(ids, id)
		}
		return ids
	case page.EdgeSeo:
		if id := m.seo; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchild_pages != nil {
		edges = append(edges, page.EdgeChildPages)
	}
	if m.removedblocks != nil {
		edges = append(edges, page.EdgeBlocks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case page.EdgeChildPages:
		ids := make([]ent.Value, 0, len(m.removedchild_pages))
		for id := range m.removedchild_pages {
			ids = append(ids, id)
		}
		return ids
	case page.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.removedblocks))
		for id := range m.removedblocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedchild_pages {
		edges = append(edges, page.EdgeChildPages)
	}
	if m.clearedparent_page {
		edges = append(edges, page.EdgeParentPage)
	}
	if m.clearedblocks {
		edges = append(edges, page.EdgeBlocks)
	}
	if m.clearedseo {
		edges = append(edges, page.EdgeSeo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PageMutation) EdgeCleared(name string) bool {
	switch name {
	case page.EdgeChildPages:
		return m.clearedchild_pages
	case page.EdgeParentPage:
		return m.clearedparent_page
	case page.EdgeBlocks:
		return m.clearedblocks
	case page.EdgeSeo:
		return m.clearedseo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PageMutation) ClearEdge(name string) error {
	switch name {
	case page.EdgeParentPage:
		m.ClearParentPage()
		return nil
	case page.EdgeSeo:
		m.ClearSeo()
		return nil
	}
	return fmt.Errorf("unknown Page unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PageMutation) ResetEdge(name string) error {
	switch name {
	case page.EdgeChildPages:
		m.ResetChildPages()
		return nil
	case page.EdgeParentPage:
		m.ResetParentPage()
		return nil
	case page.EdgeBlocks:
		m.ResetBlocks()
		return nil
	case page.EdgeSeo:
		m.ResetSeo()
		return nil
	}
	return fmt.Errorf("unknown Page edge %s", name)
}

// PartnerLogoItemMutation represents an operation that mutates the PartnerLogoItem nodes in the graph.
type PartnerLogoItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_order        *int
	add_order     *int
	name          *string
	logo_url      *string
	website       *string
	clearedFields map[string]struct{}
	block         *int
	clearedblock  bool
	done          bool
	oldValue      func(context.Context) (*PartnerLogoItem, error)
	predicates    []predicate.PartnerLogoItem
}

var _ ent.Mutation = (*PartnerLogoItemMutation)(nil)

// partnerlogoitemOption allows management of the mutation configuration using functional options.
type partnerlogoitemOption func(*PartnerLogoItemMutation)

// newPartnerLogoItemMutation creates new mutation for the PartnerLogoItem entity.
func newPartnerLogoItemMutation(c config, op Op, opts ...partnerlogoitemOption) *PartnerLogoItemMutation {
	m := &PartnerLogoItemMutation{
		config:        c,
		op:            op,
		typ:           TypePartnerLogoItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnerLogoItemID sets the ID field of the mutation.
func withPartnerLogoItemID(id int) partnerlogoitemOption {
	return func(m *PartnerLogoItemMutation) {
		var (
			err   error
			once  sync.Once
			value *PartnerLogoItem
		)
		m.oldValue = func(ctx context.Context) (*PartnerLogoItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartnerLogoItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartnerLogoItem sets the old PartnerLogoItem of the mutation.
func withPartnerLogoItem(node *PartnerLogoItem) partnerlogoitemOption {
	return func(m *PartnerLogoItemMutation) {
		m.oldValue = func(context.Context) (*PartnerLogoItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnerLogoItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnerLogoItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnerLogoItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnerLogoItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PartnerLogoItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *PartnerLogoItemMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *PartnerLogoItemMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the PartnerLogoItem entity.
// If the PartnerLogoItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerLogoItemMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *PartnerLogoItemMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *PartnerLogoItemMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *PartnerLogoItemMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetName sets the "name" field.
func (m *PartnerLogoItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PartnerLogoItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PartnerLogoItem entity.
// If the PartnerLogoItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerLogoItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PartnerLogoItemMutation) ResetName() {
	m.name = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *PartnerLogoItemMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *PartnerLogoItemMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the PartnerLogoItem entity.
// If the PartnerLogoItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerLogoItemMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *PartnerLogoItemMutation) ResetLogoURL() {
	m.logo_url = nil
}

// SetWebsite sets the "website" field.
func (m *PartnerLogoItemMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *PartnerLogoItemMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the PartnerLogoItem entity.
// If the PartnerLogoItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerLogoItemMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *PartnerLogoItemMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[partnerlogoitem.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *PartnerLogoItemMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[partnerlogoitem.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *PartnerLogoItemMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, partnerlogoitem.FieldWebsite)
}

// SetBlockID sets the "block" edge to the BlockPartnerLogos entity by id.
func (m *PartnerLogoItemMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the BlockPartnerLogos entity.
func (m *PartnerLogoItemMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the BlockPartnerLogos entity was cleared.
func (m *PartnerLogoItemMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *PartnerLogoItemMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *PartnerLogoItemMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *PartnerLogoItemMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// Where appends a list predicates to the PartnerLogoItemMutation builder.
func (m *PartnerLogoItemMutation) Where(ps ...predicate.PartnerLogoItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnerLogoItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnerLogoItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PartnerLogoItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnerLogoItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnerLogoItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PartnerLogoItem).
func (m *PartnerLogoItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnerLogoItemMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._order != nil {
		fields = append(fields, partnerlogoitem.FieldOrder)
	}
	if m.name != nil {
		fields = append(fields, partnerlogoitem.FieldName)
	}
	if m.logo_url != nil {
		fields = append(fields, partnerlogoitem.FieldLogoURL)
	}
	if m.website != nil {
		fields = append(fields, partnerlogoitem.FieldWebsite)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnerLogoItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partnerlogoitem.FieldOrder:
		return m.Order()
	case partnerlogoitem.FieldName:
		return m.Name()
	case partnerlogoitem.FieldLogoURL:
		return m.LogoURL()
	case partnerlogoitem.FieldWebsite:
		return m.Website()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnerLogoItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partnerlogoitem.FieldOrder:
		return m.OldOrder(ctx)
	case partnerlogoitem.FieldName:
		return m.OldName(ctx)
	case partnerlogoitem.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case partnerlogoitem.FieldWebsite:
		return m.OldWebsite(ctx)
	}
	return nil, fmt.Errorf("unknown PartnerLogoItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerLogoItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partnerlogoitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case partnerlogoitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case partnerlogoitem.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case partnerlogoitem.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	}
	return fmt.Errorf("unknown PartnerLogoItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnerLogoItemMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, partnerlogoitem.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnerLogoItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case partnerlogoitem.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerLogoItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case partnerlogoitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown PartnerLogoItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnerLogoItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(partnerlogoitem.FieldWebsite) {
		fields = append(fields, partnerlogoitem.FieldWebsite)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnerLogoItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnerLogoItemMutation) ClearField(name string) error {
	switch name {
	case partnerlogoitem.FieldWebsite:
		m.ClearWebsite()
		return nil
	}
	return fmt.Errorf("unknown PartnerLogoItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnerLogoItemMutation) ResetField(name string) error {
	switch name {
	case partnerlogoitem.FieldOrder:
		m.ResetOrder()
		return nil
	case partnerlogoitem.FieldName:
		m.ResetName()
		return nil
	case partnerlogoitem.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case partnerlogoitem.FieldWebsite:
		m.ResetWebsite()
		return nil
	}
	return fmt.Errorf("unknown PartnerLogoItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnerLogoItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.block != nil {
		edges = append(edges, partnerlogoitem.EdgeBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnerLogoItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partnerlogoitem.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnerLogoItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnerLogoItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnerLogoItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblock {
		edges = append(edges, partnerlogoitem.EdgeBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnerLogoItemMutation) EdgeCleared(name string) bool {
	switch name {
	case partnerlogoitem.EdgeBlock:
		return m.clearedblock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnerLogoItemMutation) ClearEdge(name string) error {
	switch name {
	case partnerlogoitem.EdgeBlock:
		m.ClearBlock()
		return nil
	}
	return fmt.Errorf("unknown PartnerLogoItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnerLogoItemMutation) ResetEdge(name string) error {
	switch name {
	case partnerlogoitem.EdgeBlock:
		m.ResetBlock()
		return nil
	}
	return fmt.Errorf("unknown PartnerLogoItem edge %s", name)
}

// PartnershipMutation represents an operation that mutates the Partnership nodes in the graph.
type PartnershipMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	slug                    *string
	name                    *map[string]string
	_type                   *partnership.Type
	status                  *partnership.Status
	description             *map[string]interface{}
	value                   *float64
	addvalue                *float64
	currency                *string
	start_date              *time.Time
	end_date                *time.Time
	renewal_date            *time.Time
	benefits                *[]string
	appendbenefits          []string
	deliverables            *[]string
	appenddeliverables      []string
	requirements            *[]string
	appendrequirements      []string
	last_contact            *time.Time
	next_follow_up          *time.Time
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	organization            *int
	clearedorganization     bool
	manager                 *int
	clearedmanager          bool
	primary_contacts        map[int]struct{}
	removedprimary_contacts map[int]struct{}
	clearedprimary_contacts bool
	reports                 map[int]struct{}
	removedreports          map[int]struct{}
	clearedreports          bool
	interactions            map[int]struct{}
	removedinteractions     map[int]struct{}
	clearedinteractions     bool
	renewals                map[int]struct{}
	removedrenewals         map[int]struct{}
	clearedrenewals         bool
	brand_benefits          map[int]struct{}
	removedbrand_benefits   map[int]struct{}
	clearedbrand_benefits   bool
	done                    bool
	oldValue                func(context.Context) (*Partnership, error)
	predicates              []predicate.Partnership
}

var _ ent.Mutation = (*PartnershipMutation)(nil)

// partnershipOption allows management of the mutation configuration using functional options.
type partnershipOption func(*PartnershipMutation)

// newPartnershipMutation creates new mutation for the Partnership entity.
func newPartnershipMutation(c config, op Op, opts ...partnershipOption) *PartnershipMutation {
	m := &PartnershipMutation{
		config:        c,
		op:            op,
		typ:           TypePartnership,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnershipID sets the ID field of the mutation.
func withPartnershipID(id int) partnershipOption {
	return func(m *PartnershipMutation) {
		var (
			err   error
			once  sync.Once
			value *Partnership
		)
		m.oldValue = func(ctx context.Context) (*Partnership, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Partnership.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartnership sets the old Partnership of the mutation.
func withPartnership(node *Partnership) partnershipOption {
	return func(m *PartnershipMutation) {
		m.oldValue = func(context.Context) (*Partnership, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnershipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnershipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnershipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnershipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Partnership.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *PartnershipMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PartnershipMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *PartnershipMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *PartnershipMutation) SetName(value map[string]string) {
	m.name = &value
}

// Name returns the value of the "name" field in the mutation.
func (m *PartnershipMutation) Name() (r map[string]string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldName(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PartnershipMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *PartnershipMutation) SetType(pa partnership.Type) {
	m._type = &pa
}

// GetType returns the value of the "type" field in the mutation.
func (m *PartnershipMutation) GetType() (r partnership.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldType(ctx context.Context) (v partnership.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PartnershipMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *PartnershipMutation) SetStatus(pa partnership.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PartnershipMutation) Status() (r partnership.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldStatus(ctx context.Context) (v partnership.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PartnershipMutation) ResetStatus() {
	m.status = nil
}

// SetDescription sets the "description" field.
func (m *PartnershipMutation) SetDescription(value map[string]interface{}) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *PartnershipMutation) Description() (r map[string]interface{}, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldDescription(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PartnershipMutation) ResetDescription() {
	m.description = nil
}

// SetValue sets the "value" field.
func (m *PartnershipMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *PartnershipMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *PartnershipMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *PartnershipMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ClearValue clears the value of the "value" field.
func (m *PartnershipMutation) ClearValue() {
	m.value = nil
	m.addvalue = nil
	m.clearedFields[partnership.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *PartnershipMutation) ValueCleared() bool {
	_, ok := m.clearedFields[partnership.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *PartnershipMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
	delete(m.clearedFields, partnership.FieldValue)
}

// SetCurrency sets the "currency" field.
func (m *PartnershipMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PartnershipMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PartnershipMutation) ResetCurrency() {
	m.currency = nil
}

// SetStartDate sets the "start_date" field.
func (m *PartnershipMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *PartnershipMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *PartnershipMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[partnership.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *PartnershipMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[partnership.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *PartnershipMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, partnership.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *PartnershipMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *PartnershipMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *PartnershipMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[partnership.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *PartnershipMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[partnership.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *PartnershipMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, partnership.FieldEndDate)
}

// SetRenewalDate sets the "renewal_date" field.
func (m *PartnershipMutation) SetRenewalDate(t time.Time) {
	m.renewal_date = &t
}

// RenewalDate returns the value of the "renewal_date" field in the mutation.
func (m *PartnershipMutation) RenewalDate() (r time.Time, exists bool) {
	v := m.renewal_date
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalDate returns the old "renewal_date" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldRenewalDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenewalDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenewalDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalDate: %w", err)
	}
	return oldValue.RenewalDate, nil
}

// ClearRenewalDate clears the value of the "renewal_date" field.
func (m *PartnershipMutation) ClearRenewalDate() {
	m.renewal_date = nil
	m.clearedFields[partnership.FieldRenewalDate] = struct{}{}
}

// RenewalDateCleared returns if the "renewal_date" field was cleared in this mutation.
func (m *PartnershipMutation) RenewalDateCleared() bool {
	_, ok := m.clearedFields[partnership.FieldRenewalDate]
	return ok
}

// ResetRenewalDate resets all changes to the "renewal_date" field.
func (m *PartnershipMutation) ResetRenewalDate() {
	m.renewal_date = nil
	delete(m.clearedFields, partnership.FieldRenewalDate)
}

// SetBenefits sets the "benefits" field.
func (m *PartnershipMutation) SetBenefits(s []string) {
	m.benefits = &s
	m.appendbenefits = nil
}

// Benefits returns the value of the "benefits" field in the mutation.
func (m *PartnershipMutation) Benefits() (r []string, exists bool) {
	v := m.benefits
	if v == nil {
		return
	}
	return *v, true
}

// OldBenefits returns the old "benefits" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldBenefits(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBenefits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBenefits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBenefits: %w", err)
	}
	return oldValue.Benefits, nil
}

// AppendBenefits adds s to the "benefits" field.
func (m *PartnershipMutation) AppendBenefits(s []string) {
	m.appendbenefits = append(m.appendbenefits, s...)
}

// AppendedBenefits returns the list of values that were appended to the "benefits" field in this mutation.
func (m *PartnershipMutation) AppendedBenefits() ([]string, bool) {
	if len(m.appendbenefits) == 0 {
		return nil, false
	}
	return m.appendbenefits, true
}

// ResetBenefits resets all changes to the "benefits" field.
func (m *PartnershipMutation) ResetBenefits() {
	m.benefits = nil
	m.appendbenefits = nil
}

// SetDeliverables sets the "deliverables" field.
func (m *PartnershipMutation) SetDeliverables(s []string) {
	m.deliverables = &s
	m.appenddeliverables = nil
}

// Deliverables returns the value of the "deliverables" field in the mutation.
func (m *PartnershipMutation) Deliverables() (r []string, exists bool) {
	v := m.deliverables
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliverables returns the old "deliverables" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldDeliverables(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliverables is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliverables requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliverables: %w", err)
	}
	return oldValue.Deliverables, nil
}

// AppendDeliverables adds s to the "deliverables" field.
func (m *PartnershipMutation) AppendDeliverables(s []string) {
	m.appenddeliverables = append(m.appenddeliverables, s...)
}

// AppendedDeliverables returns the list of values that were appended to the "deliverables" field in this mutation.
func (m *PartnershipMutation) AppendedDeliverables() ([]string, bool) {
	if len(m.appenddeliverables) == 0 {
		return nil, false
	}
	return m.appenddeliverables, true
}

// ResetDeliverables resets all changes to the "deliverables" field.
func (m *PartnershipMutation) ResetDeliverables() {
	m.deliverables = nil
	m.appenddeliverables = nil
}

// SetRequirements sets the "requirements" field.
func (m *PartnershipMutation) SetRequirements(s []string) {
	m.requirements = &s
	m.appendrequirements = nil
}

// Requirements returns the value of the "requirements" field in the mutation.
func (m *PartnershipMutation) Requirements() (r []string, exists bool) {
	v := m.requirements
	if v == nil {
		return
	}
	return *v, true
}

// OldRequirements returns the old "requirements" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldRequirements(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequirements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequirements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequirements: %w", err)
	}
	return oldValue.Requirements, nil
}

// AppendRequirements adds s to the "requirements" field.
func (m *PartnershipMutation) AppendRequirements(s []string) {
	m.appendrequirements = append(m.appendrequirements, s...)
}

// AppendedRequirements returns the list of values that were appended to the "requirements" field in this mutation.
func (m *PartnershipMutation) AppendedRequirements() ([]string, bool) {
	if len(m.appendrequirements) == 0 {
		return nil, false
	}
	return m.appendrequirements, true
}

// ResetRequirements resets all changes to the "requirements" field.
func (m *PartnershipMutation) ResetRequirements() {
	m.requirements = nil
	m.appendrequirements = nil
}

// SetLastContact sets the "last_contact" field.
func (m *PartnershipMutation) SetLastContact(t time.Time) {
	m.last_contact = &t
}

// LastContact returns the value of the "last_contact" field in the mutation.
func (m *PartnershipMutation) LastContact() (r time.Time, exists bool) {
	v := m.last_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldLastContact returns the old "last_contact" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldLastContact(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastContact: %w", err)
	}
	return oldValue.LastContact, nil
}

// ClearLastContact clears the value of the "last_contact" field.
func (m *PartnershipMutation) ClearLastContact() {
	m.last_contact = nil
	m.clearedFields[partnership.FieldLastContact] = struct{}{}
}

// LastContactCleared returns if the "last_contact" field was cleared in this mutation.
func (m *PartnershipMutation) LastContactCleared() bool {
	_, ok := m.clearedFields[partnership.FieldLastContact]
	return ok
}

// ResetLastContact resets all changes to the "last_contact" field.
func (m *PartnershipMutation) ResetLastContact() {
	m.last_contact = nil
	delete(m.clearedFields, partnership.FieldLastContact)
}

// SetNextFollowUp sets the "next_follow_up" field.
func (m *PartnershipMutation) SetNextFollowUp(t time.Time) {
	m.next_follow_up = &t
}

// NextFollowUp returns the value of the "next_follow_up" field in the mutation.
func (m *PartnershipMutation) NextFollowUp() (r time.Time, exists bool) {
	v := m.next_follow_up
	if v == nil {
		return
	}
	return *v, true
}

// OldNextFollowUp returns the old "next_follow_up" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldNextFollowUp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextFollowUp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextFollowUp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextFollowUp: %w", err)
	}
	return oldValue.NextFollowUp, nil
}

// ClearNextFollowUp clears the value of the "next_follow_up" field.
func (m *PartnershipMutation) ClearNextFollowUp() {
	m.next_follow_up = nil
	m.clearedFields[partnership.FieldNextFollowUp] = struct{}{}
}

// NextFollowUpCleared returns if the "next_follow_up" field was cleared in this mutation.
func (m *PartnershipMutation) NextFollowUpCleared() bool {
	_, ok := m.clearedFields[partnership.FieldNextFollowUp]
	return ok
}

// ResetNextFollowUp resets all changes to the "next_follow_up" field.
func (m *PartnershipMutation) ResetNextFollowUp() {
	m.next_follow_up = nil
	delete(m.clearedFields, partnership.FieldNextFollowUp)
}

// SetCreatedAt sets the "created_at" field.
func (m *PartnershipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartnershipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartnershipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartnershipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartnershipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Partnership entity.
// If the Partnership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartnershipMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *PartnershipMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *PartnershipMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *PartnershipMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *PartnershipMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *PartnershipMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *PartnershipMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetManagerID sets the "manager" edge to the User entity by id.
func (m *PartnershipMutation) SetManagerID(id int) {
	m.manager = &id
}

// ClearManager clears the "manager" edge to the User entity.
func (m *PartnershipMutation) ClearManager() {
	m.clearedmanager = true
}

// ManagerCleared reports if the "manager" edge to the User entity was cleared.
func (m *PartnershipMutation) ManagerCleared() bool {
	return m.clearedmanager
}

// ManagerID returns the "manager" edge ID in the mutation.
func (m *PartnershipMutation) ManagerID() (id int, exists bool) {
	if m.manager != nil {
		return *m.manager, true
	}
	return
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *PartnershipMutation) ManagerIDs() (ids []int) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *PartnershipMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// AddPrimaryContactIDs adds the "primary_contacts" edge to the User entity by ids.
func (m *PartnershipMutation) AddPrimaryContactIDs(ids ...int) {
	if m.primary_contacts == nil {
		m.primary_contacts = make(map[int]struct{})
	}
	for i := range ids {
		m.primary_contacts[ids[i]] = struct{}{}
	}
}

// ClearPrimaryContacts clears the "primary_contacts" edge to the User entity.
func (m *PartnershipMutation) ClearPrimaryContacts() {
	m.clearedprimary_contacts = true
}

// PrimaryContactsCleared reports if the "primary_contacts" edge to the User entity was cleared.
func (m *PartnershipMutation) PrimaryContactsCleared() bool {
	return m.clearedprimary_contacts
}

// RemovePrimaryContactIDs removes the "primary_contacts" edge to the User entity by IDs.
func (m *PartnershipMutation) RemovePrimaryContactIDs(ids ...int) {
	if m.removedprimary_contacts == nil {
		m.removedprimary_contacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.primary_contacts, ids[i])
		m.removedprimary_contacts[ids[i]] = struct{}{}
	}
}

// RemovedPrimaryContacts returns the removed IDs of the "primary_contacts" edge to the User entity.
func (m *PartnershipMutation) RemovedPrimaryContactsIDs() (ids []int) {
	for id := range m.removedprimary_contacts {
		ids = append(ids, id)
	}
	return
}

// PrimaryContactsIDs returns the "primary_contacts" edge IDs in the mutation.
func (m *PartnershipMutation) PrimaryContactsIDs() (ids []int) {
	for id := range m.primary_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetPrimaryContacts resets all changes to the "primary_contacts" edge.
func (m *PartnershipMutation) ResetPrimaryContacts() {
	m.primary_contacts = nil
	m.clearedprimary_contacts = false
	m.removedprimary_contacts = nil
}

// AddReportIDs adds the "reports" edge to the PartnershipReport entity by ids.
func (m *PartnershipMutation) AddReportIDs(ids ...int) {
	if m.reports == nil {
		m.reports = make(map[int]struct{})
	}
	for i := range ids {
		m.reports[ids[i]] = struct{}{}
	}
}

// ClearReports clears the "reports" edge to the PartnershipReport entity.
func (m *PartnershipMutation) ClearReports() {
	m.clearedreports = true
}

// ReportsCleared reports if the "reports" edge to the PartnershipReport entity was cleared.
func (m *PartnershipMutation) ReportsCleared() bool {
	return m.clearedreports
}

// RemoveReportIDs removes the "reports" edge to the PartnershipReport entity by IDs.
func (m *PartnershipMutation) RemoveReportIDs(ids ...int) {
	if m.removedreports == nil {
		m.removedreports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reports, ids[i])
		m.removedreports[ids[i]] = struct{}{}
	}
}

// RemovedReports returns the removed IDs of the "reports" edge to the PartnershipReport entity.
func (m *PartnershipMutation) RemovedReportsIDs() (ids []int) {
	for id := range m.removedreports {
		ids = append(ids, id)
	}
	return
}

// ReportsIDs returns the "reports" edge IDs in the mutation.
func (m *PartnershipMutation) ReportsIDs() (ids []int) {
	for id := range m.reports {
		ids = append(ids, id)
	}
	return
}

// ResetReports resets all changes to the "reports" edge.
func (m *PartnershipMutation) ResetReports() {
	m.reports = nil
	m.clearedreports = false
	m.removedreports = nil
}

// AddInteractionIDs adds the "interactions" edge to the PartnershipInteraction entity by ids.
func (m *PartnershipMutation) AddInteractionIDs(ids ...int) {
	if m.interactions == nil {
		m.interactions = make(map[int]struct{})
	}
	for i := range ids {
		m.interactions[ids[i]] = struct{}{}
	}
}

// ClearInteractions clears the "interactions" edge to the PartnershipInteraction entity.
func (m *PartnershipMutation) ClearInteractions() {
	m.clearedinteractions = true
}

// InteractionsCleared reports if the "interactions" edge to the PartnershipInteraction entity was cleared.
func (m *PartnershipMutation) InteractionsCleared() bool {
	return m.clearedinteractions
}

// RemoveInteractionIDs removes the "interactions" edge to the PartnershipInteraction entity by IDs.
func (m *PartnershipMutation) RemoveInteractionIDs(ids ...int) {
	if m.removedinteractions == nil {
		m.removedinteractions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.interactions, ids[i])
		m.removedinteractions[ids[i]] = struct{}{}
	}
}

// RemovedInteractions returns the removed IDs of the "interactions" edge to the PartnershipInteraction entity.
func (m *PartnershipMutation) RemovedInteractionsIDs() (ids []int) {
	for id := range m.removedinteractions {
		ids = append(ids, id)
	}
	return
}

// InteractionsIDs returns the "interactions" edge IDs in the mutation.
func (m *PartnershipMutation) InteractionsIDs() (ids []int) {
	for id := range m.interactions {
		ids = append(ids, id)
	}
	return
}

// ResetInteractions resets all changes to the "interactions" edge.
func (m *PartnershipMutation) ResetInteractions() {
	m.interactions = nil
	m.clearedinteractions = false
	m.removedinteractions = nil
}

// AddRenewalIDs adds the "renewals" edge to the PartnershipRenewal entity by ids.
func (m *PartnershipMutation) AddRenewalIDs(ids ...int) {
	if m.renewals == nil {
		m.renewals = make(map[int]struct{})
	}
	for i := range ids {
		m.renewals[ids[i]] = struct{}{}
	}
}

// ClearRenewals clears the "renewals" edge to the PartnershipRenewal entity.
func (m *PartnershipMutation) ClearRenewals() {
	m.clearedrenewals = true
}

// RenewalsCleared reports if the "renewals" edge to the PartnershipRenewal entity was cleared.
func (m *PartnershipMutation) RenewalsCleared() bool {
	return m.clearedrenewals
}

// RemoveRenewalIDs removes the "renewals" edge to the PartnershipRenewal entity by IDs.
func (m *PartnershipMutation) RemoveRenewalIDs(ids ...int) {
	if m.removedrenewals == nil {
		m.removedrenewals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.renewals, ids[i])
		m.removedrenewals[ids[i]] = struct{}{}
	}
}

// RemovedRenewals returns the removed IDs of the "renewals" edge to the PartnershipRenewal entity.
func (m *PartnershipMutation) RemovedRenewalsIDs() (ids []int) {
	for id := range m.removedrenewals {
		ids = append(ids, id)
	}
	return
}

// RenewalsIDs returns the "renewals" edge IDs in the mutation.
func (m *PartnershipMutation) RenewalsIDs() (ids []int) {
	for id := range m.renewals {
		ids = append(ids, id)
	}
	return
}

// ResetRenewals resets all changes to the "renewals" edge.
func (m *PartnershipMutation) ResetRenewals() {
	m.renewals = nil
	m.clearedrenewals = false
	m.removedrenewals = nil
}

// AddBrandBenefitIDs adds the "brand_benefits" edge to the BrandBenefit entity by ids.
func (m *PartnershipMutation) AddBrandBenefitIDs(ids ...int) {
	if m.brand_benefits == nil {
		m.brand_benefits = make(map[int]struct{})
	}
	for i := range ids {
		m.brand_benefits[ids[i]] = struct{}{}
	}
}

// ClearBrandBenefits clears the "brand_benefits" edge to the BrandBenefit entity.
func (m *PartnershipMutation) ClearBrandBenefits() {
	m.clearedbrand_benefits = true
}

// BrandBenefitsCleared reports if the "brand_benefits" edge to the BrandBenefit entity was cleared.
func (m *PartnershipMutation) BrandBenefitsCleared() bool {
	return m.clearedbrand_benefits
}

// RemoveBrandBenefitIDs removes the "brand_benefits" edge to the BrandBenefit entity by IDs.
func (m *PartnershipMutation) RemoveBrandBenefitIDs(ids ...int) {
	if m.removedbrand_benefits == nil {
		m.removedbrand_benefits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.brand_benefits, ids[i])
		m.removedbrand_benefits[ids[i]] = struct{}{}
	}
}

// RemovedBrandBenefits returns the removed IDs of the "brand_benefits" edge to the BrandBenefit entity.
func (m *PartnershipMutation) RemovedBrandBenefitsIDs() (ids []int) {
	for id := range m.removedbrand_benefits {
		ids = append(ids, id)
	}
	return
}

// BrandBenefitsIDs returns the "brand_benefits" edge IDs in the mutation.
func (m *PartnershipMutation) BrandBenefitsIDs() (ids []int) {
	for id := range m.brand_benefits {
		ids = append(ids, id)
	}
	return
}

// ResetBrandBenefits resets all changes to the "brand_benefits" edge.
func (m *PartnershipMutation) ResetBrandBenefits() {
	m.brand_benefits = nil
	m.clearedbrand_benefits = false
	m.removedbrand_benefits = nil
}

// Where appends a list predicates to the PartnershipMutation builder.
func (m *PartnershipMutation) Where(ps ...predicate.Partnership) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnershipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnershipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Partnership, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnershipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnershipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Partnership).
func (m *PartnershipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnershipMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.slug != nil {
		fields = append(fields, partnership.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, partnership.FieldName)
	}
	if m._type != nil {
		fields = append(fields, partnership.FieldType)
	}
	if m.status != nil {
		fields = append(fields, partnership.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, partnership.FieldDescription)
	}
	if m.value != nil {
		fields = append(fields, partnership.FieldValue)
	}
	if m.currency != nil {
		fields = append(fields, partnership.FieldCurrency)
	}
	if m.start_date != nil {
		fields = append(fields, partnership.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, partnership.FieldEndDate)
	}
	if m.renewal_date != nil {
		fields = append(fields, partnership.FieldRenewalDate)
	}
	if m.benefits != nil {
		fields = append(fields, partnership.FieldBenefits)
	}
	if m.deliverables != nil {
		fields = append(fields, partnership.FieldDeliverables)
	}
	if m.requirements != nil {
		fields = append(fields, partnership.FieldRequirements)
	}
	if m.last_contact != nil {
		fields = append(fields, partnership.FieldLastContact)
	}
	if m.next_follow_up != nil {
		fields = append(fields, partnership.FieldNextFollowUp)
	}
	if m.created_at != nil {
		fields = append(fields, partnership.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, partnership.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnershipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partnership.FieldSlug:
		return m.Slug()
	case partnership.FieldName:
		return m.Name()
	case partnership.FieldType:
		return m.GetType()
	case partnership.FieldStatus:
		return m.Status()
	case partnership.FieldDescription:
		return m.Description()
	case partnership.FieldValue:
		return m.Value()
	case partnership.FieldCurrency:
		return m.Currency()
	case partnership.FieldStartDate:
		return m.StartDate()
	case partnership.FieldEndDate:
		return m.EndDate()
	case partnership.FieldRenewalDate:
		return m.RenewalDate()
	case partnership.FieldBenefits:
		return m.Benefits()
	case partnership.FieldDeliverables:
		return m.Deliverables()
	case partnership.FieldRequirements:
		return m.Requirements()
	case partnership.FieldLastContact:
		return m.LastContact()
	case partnership.FieldNextFollowUp:
		return m.NextFollowUp()
	case partnership.FieldCreatedAt:
		return m.CreatedAt()
	case partnership.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnershipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partnership.FieldSlug:
		return m.OldSlug(ctx)
	case partnership.FieldName:
		return m.OldName(ctx)
	case partnership.FieldType:
		return m.OldType(ctx)
	case partnership.FieldStatus:
		return m.OldStatus(ctx)
	case partnership.FieldDescription:
		return m.OldDescription(ctx)
	case partnership.FieldValue:
		return m.OldValue(ctx)
	case partnership.FieldCurrency:
		return m.OldCurrency(ctx)
	case partnership.FieldStartDate:
		return m.OldStartDate(ctx)
	case partnership.FieldEndDate:
		return m.OldEndDate(ctx)
	case partnership.FieldRenewalDate:
		return m.OldRenewalDate(ctx)
	case partnership.FieldBenefits:
		return m.OldBenefits(ctx)
	case partnership.FieldDeliverables:
		return m.OldDeliverables(ctx)
	case partnership.FieldRequirements:
		return m.OldRequirements(ctx)
	case partnership.FieldLastContact:
		return m.OldLastContact(ctx)
	case partnership.FieldNextFollowUp:
		return m.OldNextFollowUp(ctx)
	case partnership.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case partnership.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Partnership field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnershipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partnership.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case partnership.FieldName:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case partnership.FieldType:
		v, ok := value.(partnership.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case partnership.FieldStatus:
		v, ok := value.(partnership.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case partnership.FieldDescription:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case partnership.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case partnership.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case partnership.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case partnership.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case partnership.FieldRenewalDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalDate(v)
		return nil
	case partnership.FieldBenefits:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBenefits(v)
		return nil
	case partnership.FieldDeliverables:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliverables(v)
		return nil
	case partnership.FieldRequirements:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequirements(v)
		return nil
	case partnership.FieldLastContact:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastContact(v)
		return nil
	case partnership.FieldNextFollowUp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextFollowUp(v)
		return nil
	case partnership.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case partnership.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Partnership field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnershipMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, partnership.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnershipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case partnership.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnershipMutation) AddField(name string, value ent.Value) error {
	switch name {
	case partnership.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown Partnership numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnershipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(partnership.FieldValue) {
		fields = append(fields, partnership.FieldValue)
	}
	if m.FieldCleared(partnership.FieldStartDate) {
		fields = append(fields, partnership.FieldStartDate)
	}
	if m.FieldCleared(partnership.FieldEndDate) {
		fields = append(fields, partnership.FieldEndDate)
	}
	if m.FieldCleared(partnership.FieldRenewalDate) {
		fields = append(fields, partnership.FieldRenewalDate)
	}
	if m.FieldCleared(partnership.FieldLastContact) {
		fields = append(fields, partnership.FieldLastContact)
	}
	if m.FieldCleared(partnership.FieldNextFollowUp) {
		fields = append(fields, partnership.FieldNextFollowUp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnershipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnershipMutation) ClearField(name string) error {
	switch name {
	case partnership.FieldValue:
		m.ClearValue()
		return nil
	case partnership.FieldStartDate:
		m.ClearStartDate()
		return nil
	case partnership.FieldEndDate:
		m.ClearEndDate()
		return nil
	case partnership.FieldRenewalDate:
		m.ClearRenewalDate()
		return nil
	case partnership.FieldLastContact:
		m.ClearLastContact()
		return nil
	case partnership.FieldNextFollowUp:
		m.ClearNextFollowUp()
		return nil
	}
	return fmt.Errorf("unknown Partnership nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnershipMutation) ResetField(name string) error {
	switch name {
	case partnership.FieldSlug:
		m.ResetSlug()
		return nil
	case partnership.FieldName:
		m.ResetName()
		return nil
	case partnership.FieldType:
		m.ResetType()
		return nil
	case partnership.FieldStatus:
		m.ResetStatus()
		return nil
	case partnership.FieldDescription:
		m.ResetDescription()
		return nil
	case partnership.FieldValue:
		m.ResetValue()
		return nil
	case partnership.FieldCurrency:
		m.ResetCurrency()
		return nil
	case partnership.FieldStartDate:
		m.ResetStartDate()
		return nil
	case partnership.FieldEndDate:
		m.ResetEndDate()
		return nil
	case partnership.FieldRenewalDate:
		m.ResetRenewalDate()
		return nil
	case partnership.FieldBenefits:
		m.ResetBenefits()
		return nil
	case partnership.FieldDeliverables:
		m.ResetDeliverables()
		return nil
	case partnership.FieldRequirements:
		m.ResetRequirements()
		return nil
	case partnership.FieldLastContact:
		m.ResetLastContact()
		return nil
	case partnership.FieldNextFollowUp:
		m.ResetNextFollowUp()
		return nil
	case partnership.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case partnership.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Partnership field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnershipMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.organization != nil {
		edges = append(edges, partnership.EdgeOrganization)
	}
	if m.manager != nil {
		edges = append(edges, partnership.EdgeManager)
	}
	if m.primary_contacts != nil {
		edges = append(edges, partnership.EdgePrimaryContacts)
	}
	if m.reports != nil {
		edges = append(edges, partnership.EdgeReports)
	}
	if m.interactions != nil {
		edges = append(edges, partnership.EdgeInteractions)
	}
	if m.renewals != nil {
		edges = append(edges, partnership.EdgeRenewals)
	}
	if m.brand_benefits != nil {
		edges = append(edges, partnership.EdgeBrandBenefits)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnershipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partnership.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case partnership.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	case partnership.EdgePrimaryContacts:
		ids := make([]ent.Value, 0, len(m.primary_contacts))
		for id := range m.primary_contacts {
			ids = append(ids, id)
		}
		return ids
	case partnership.EdgeReports:
		ids := make([]ent.Value, 0, len(m.reports))
		for id := range m.reports {
			ids = append(ids, id)
		}
		return ids
	case partnership.EdgeInteractions:
		ids := make([]ent.Value, 0, len(m.interactions))
		for id := range m.interactions {
			ids = append(ids, id)
		}
		return ids
	case partnership.EdgeRenewals:
		ids := make([]ent.Value, 0, len(m.renewals))
		for id := range m.renewals {
			ids = append(ids, id)
		}
		return ids
	case partnership.EdgeBrandBenefits:
		ids := make([]ent.Value, 0, len(m.brand_benefits))
		for id := range m.brand_benefits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnershipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedprimary_contacts != nil {
		edges = append(edges, partnership.EdgePrimaryContacts)
	}
	if m.removedreports != nil {
		edges = append(edges, partnership.EdgeReports)
	}
	if m.removedinteractions != nil {
		edges = append(edges, partnership.EdgeInteractions)
	}
	if m.removedrenewals != nil {
		edges = append(edges, partnership.EdgeRenewals)
	}
	if m.removedbrand_benefits != nil {
		edges = append(edges, partnership.EdgeBrandBenefits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnershipMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case partnership.EdgePrimaryContacts:
		ids := make([]ent.Value, 0, len(m.removedprimary_contacts))
		for id := range m.removedprimary_contacts {
			ids = append(ids, id)
		}
		return ids
	case partnership.EdgeReports:
		ids := make([]ent.Value, 0, len(m.removedreports))
		for id := range m.removedreports {
			ids = append(ids, id)
		}
		return ids
	case partnership.EdgeInteractions:
		ids := make([]ent.Value, 0, len(m.removedinteractions))
		for id := range m.removedinteractions {
			ids = append(ids, id)
		}
		return ids
	case partnership.EdgeRenewals:
		ids := make([]ent.Value, 0, len(m.removedrenewals))
		for id := range m.removedrenewals {
			ids = append(ids, id)
		}
		return ids
	case partnership.EdgeBrandBenefits:
		ids := make([]ent.Value, 0, len(m.removedbrand_benefits))
		for id := range m.removedbrand_benefits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnershipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedorganization {
		edges = append(edges, partnership.EdgeOrganization)
	}
	if m.clearedmanager {
		edges = append(edges, partnership.EdgeManager)
	}
	if m.clearedprimary_contacts {
		edges = append(edges, partnership.EdgePrimaryContacts)
	}
	if m.clearedreports {
		edges = append(edges, partnership.EdgeReports)
	}
	if m.clearedinteractions {
		edges = append(edges, partnership.EdgeInteractions)
	}
	if m.clearedrenewals {
		edges = append(edges, partnership.EdgeRenewals)
	}
	if m.clearedbrand_benefits {
		edges = append(edges, partnership.EdgeBrandBenefits)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnershipMutation) EdgeCleared(name string) bool {
	switch name {
	case partnership.EdgeOrganization:
		return m.clearedorganization
	case partnership.EdgeManager:
		return m.clearedmanager
	case partnership.EdgePrimaryContacts:
		return m.clearedprimary_contacts
	case partnership.EdgeReports:
		return m.clearedreports
	case partnership.EdgeInteractions:
		return m.clearedinteractions
	case partnership.EdgeRenewals:
		return m.clearedrenewals
	case partnership.EdgeBrandBenefits:
		return m.clearedbrand_benefits
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnershipMutation) ClearEdge(name string) error {
	switch name {
	case partnership.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case partnership.EdgeManager:
		m.ClearManager()
		return nil
	}
	return fmt.Errorf("unknown Partnership unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnershipMutation) ResetEdge(name string) error {
	switch name {
	case partnership.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case partnership.EdgeManager:
		m.ResetManager()
		return nil
	case partnership.EdgePrimaryContacts:
		m.ResetPrimaryContacts()
		return nil
	case partnership.EdgeReports:
		m.ResetReports()
		return nil
	case partnership.EdgeInteractions:
		m.ResetInteractions()
		return nil
	case partnership.EdgeRenewals:
		m.ResetRenewals()
		return nil
	case partnership.EdgeBrandBenefits:
		m.ResetBrandBenefits()
		return nil
	}
	return fmt.Errorf("unknown Partnership edge %s", name)
}

// PartnershipInteractionMutation represents an operation that mutates the PartnershipInteraction nodes in the graph.
type PartnershipInteractionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	interaction_type   *string
	subject            *string
	summary            *string
	interacted_at      *time.Time
	attendees          *[]string
	appendattendees    []string
	follow_up_required *bool
	follow_up_date     *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	partnership        *int
	clearedpartnership bool
	done               bool
	oldValue           func(context.Context) (*PartnershipInteraction, error)
	predicates         []predicate.PartnershipInteraction
}

var _ ent.Mutation = (*PartnershipInteractionMutation)(nil)

// partnershipinteractionOption allows management of the mutation configuration using functional options.
type partnershipinteractionOption func(*PartnershipInteractionMutation)

// newPartnershipInteractionMutation creates new mutation for the PartnershipInteraction entity.
func newPartnershipInteractionMutation(c config, op Op, opts ...partnershipinteractionOption) *PartnershipInteractionMutation {
	m := &PartnershipInteractionMutation{
		config:        c,
		op:            op,
		typ:           TypePartnershipInteraction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnershipInteractionID sets the ID field of the mutation.
func withPartnershipInteractionID(id int) partnershipinteractionOption {
	return func(m *PartnershipInteractionMutation) {
		var (
			err   error
			once  sync.Once
			value *PartnershipInteraction
		)
		m.oldValue = func(ctx context.Context) (*PartnershipInteraction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartnershipInteraction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartnershipInteraction sets the old PartnershipInteraction of the mutation.
func withPartnershipInteraction(node *PartnershipInteraction) partnershipinteractionOption {
	return func(m *PartnershipInteractionMutation) {
		m.oldValue = func(context.Context) (*PartnershipInteraction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnershipInteractionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnershipInteractionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnershipInteractionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnershipInteractionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PartnershipInteraction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInteractionType sets the "interaction_type" field.
func (m *PartnershipInteractionMutation) SetInteractionType(s string) {
	m.interaction_type = &s
}

// InteractionType returns the value of the "interaction_type" field in the mutation.
func (m *PartnershipInteractionMutation) InteractionType() (r string, exists bool) {
	v := m.interaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInteractionType returns the old "interaction_type" field's value of the PartnershipInteraction entity.
// If the PartnershipInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipInteractionMutation) OldInteractionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInteractionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInteractionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInteractionType: %w", err)
	}
	return oldValue.InteractionType, nil
}

// ResetInteractionType resets all changes to the "interaction_type" field.
func (m *PartnershipInteractionMutation) ResetInteractionType() {
	m.interaction_type = nil
}

// SetSubject sets the "subject" field.
func (m *PartnershipInteractionMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *PartnershipInteractionMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the PartnershipInteraction entity.
// If the PartnershipInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipInteractionMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *PartnershipInteractionMutation) ResetSubject() {
	m.subject = nil
}

// SetSummary sets the "summary" field.
func (m *PartnershipInteractionMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *PartnershipInteractionMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the PartnershipInteraction entity.
// If the PartnershipInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipInteractionMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *PartnershipInteractionMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[partnershipinteraction.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *PartnershipInteractionMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[partnershipinteraction.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *PartnershipInteractionMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, partnershipinteraction.FieldSummary)
}

// SetInteractedAt sets the "interacted_at" field.
func (m *PartnershipInteractionMutation) SetInteractedAt(t time.Time) {
	m.interacted_at = &t
}

// InteractedAt returns the value of the "interacted_at" field in the mutation.
func (m *PartnershipInteractionMutation) InteractedAt() (r time.Time, exists bool) {
	v := m.interacted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInteractedAt returns the old "interacted_at" field's value of the PartnershipInteraction entity.
// If the PartnershipInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipInteractionMutation) OldInteractedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInteractedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInteractedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInteractedAt: %w", err)
	}
	return oldValue.InteractedAt, nil
}

// ResetInteractedAt resets all changes to the "interacted_at" field.
func (m *PartnershipInteractionMutation) ResetInteractedAt() {
	m.interacted_at = nil
}

// SetAttendees sets the "attendees" field.
func (m *PartnershipInteractionMutation) SetAttendees(s []string) {
	m.attendees = &s
	m.appendattendees = nil
}

// Attendees returns the value of the "attendees" field in the mutation.
func (m *PartnershipInteractionMutation) Attendees() (r []string, exists bool) {
	v := m.attendees
	if v == nil {
		return
	}
	return *v, true
}

// OldAttendees returns the old "attendees" field's value of the PartnershipInteraction entity.
// If the PartnershipInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipInteractionMutation) OldAttendees(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttendees is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttendees requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttendees: %w", err)
	}
	return oldValue.Attendees, nil
}

// AppendAttendees adds s to the "attendees" field.
func (m *PartnershipInteractionMutation) AppendAttendees(s []string) {
	m.appendattendees = append(m.appendattendees, s...)
}

// AppendedAttendees returns the list of values that were appended to the "attendees" field in this mutation.
func (m *PartnershipInteractionMutation) AppendedAttendees() ([]string, bool) {
	if len(m.appendattendees) == 0 {
		return nil, false
	}
	return m.appendattendees, true
}

// ResetAttendees resets all changes to the "attendees" field.
func (m *PartnershipInteractionMutation) ResetAttendees() {
	m.attendees = nil
	m.appendattendees = nil
}

// SetFollowUpRequired sets the "follow_up_required" field.
func (m *PartnershipInteractionMutation) SetFollowUpRequired(b bool) {
	m.follow_up_required = &b
}

// FollowUpRequired returns the value of the "follow_up_required" field in the mutation.
func (m *PartnershipInteractionMutation) FollowUpRequired() (r bool, exists bool) {
	v := m.follow_up_required
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowUpRequired returns the old "follow_up_required" field's value of the PartnershipInteraction entity.
// If the PartnershipInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipInteractionMutation) OldFollowUpRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowUpRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowUpRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowUpRequired: %w", err)
	}
	return oldValue.FollowUpRequired, nil
}

// ResetFollowUpRequired resets all changes to the "follow_up_required" field.
func (m *PartnershipInteractionMutation) ResetFollowUpRequired() {
	m.follow_up_required = nil
}

// SetFollowUpDate sets the "follow_up_date" field.
func (m *PartnershipInteractionMutation) SetFollowUpDate(t time.Time) {
	m.follow_up_date = &t
}

// FollowUpDate returns the value of the "follow_up_date" field in the mutation.
func (m *PartnershipInteractionMutation) FollowUpDate() (r time.Time, exists bool) {
	v := m.follow_up_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowUpDate returns the old "follow_up_date" field's value of the PartnershipInteraction entity.
// If the PartnershipInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipInteractionMutation) OldFollowUpDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowUpDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowUpDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowUpDate: %w", err)
	}
	return oldValue.FollowUpDate, nil
}

// ClearFollowUpDate clears the value of the "follow_up_date" field.
func (m *PartnershipInteractionMutation) ClearFollowUpDate() {
	m.follow_up_date = nil
	m.clearedFields[partnershipinteraction.FieldFollowUpDate] = struct{}{}
}

// FollowUpDateCleared returns if the "follow_up_date" field was cleared in this mutation.
func (m *PartnershipInteractionMutation) FollowUpDateCleared() bool {
	_, ok := m.clearedFields[partnershipinteraction.FieldFollowUpDate]
	return ok
}

// ResetFollowUpDate resets all changes to the "follow_up_date" field.
func (m *PartnershipInteractionMutation) ResetFollowUpDate() {
	m.follow_up_date = nil
	delete(m.clearedFields, partnershipinteraction.FieldFollowUpDate)
}

// SetCreatedAt sets the "created_at" field.
func (m *PartnershipInteractionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartnershipInteractionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PartnershipInteraction entity.
// If the PartnershipInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipInteractionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartnershipInteractionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartnershipInteractionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartnershipInteractionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PartnershipInteraction entity.
// If the PartnershipInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipInteractionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartnershipInteractionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPartnershipID sets the "partnership" edge to the Partnership entity by id.
func (m *PartnershipInteractionMutation) SetPartnershipID(id int) {
	m.partnership = &id
}

// ClearPartnership clears the "partnership" edge to the Partnership entity.
func (m *PartnershipInteractionMutation) ClearPartnership() {
	m.clearedpartnership = true
}

// PartnershipCleared reports if the "partnership" edge to the Partnership entity was cleared.
func (m *PartnershipInteractionMutation) PartnershipCleared() bool {
	return m.clearedpartnership
}

// PartnershipID returns the "partnership" edge ID in the mutation.
func (m *PartnershipInteractionMutation) PartnershipID() (id int, exists bool) {
	if m.partnership != nil {
		return *m.partnership, true
	}
	return
}

// PartnershipIDs returns the "partnership" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnershipID instead. It exists only for internal usage by the builders.
func (m *PartnershipInteractionMutation) PartnershipIDs() (ids []int) {
	if id := m.partnership; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartnership resets all changes to the "partnership" edge.
func (m *PartnershipInteractionMutation) ResetPartnership() {
	m.partnership = nil
	m.clearedpartnership = false
}

// Where appends a list predicates to the PartnershipInteractionMutation builder.
func (m *PartnershipInteractionMutation) Where(ps ...predicate.PartnershipInteraction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnershipInteractionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnershipInteractionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PartnershipInteraction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnershipInteractionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnershipInteractionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PartnershipInteraction).
func (m *PartnershipInteractionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnershipInteractionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.interaction_type != nil {
		fields = append(fields, partnershipinteraction.FieldInteractionType)
	}
	if m.subject != nil {
		fields = append(fields, partnershipinteraction.FieldSubject)
	}
	if m.summary != nil {
		fields = append(fields, partnershipinteraction.FieldSummary)
	}
	if m.interacted_at != nil {
		fields = append(fields, partnershipinteraction.FieldInteractedAt)
	}
	if m.attendees != nil {
		fields = append(fields, partnershipinteraction.FieldAttendees)
	}
	if m.follow_up_required != nil {
		fields = append(fields, partnershipinteraction.FieldFollowUpRequired)
	}
	if m.follow_up_date != nil {
		fields = append(fields, partnershipinteraction.FieldFollowUpDate)
	}
	if m.created_at != nil {
		fields = append(fields, partnershipinteraction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, partnershipinteraction.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnershipInteractionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partnershipinteraction.FieldInteractionType:
		return m.InteractionType()
	case partnershipinteraction.FieldSubject:
		return m.Subject()
	case partnershipinteraction.FieldSummary:
		return m.Summary()
	case partnershipinteraction.FieldInteractedAt:
		return m.InteractedAt()
	case partnershipinteraction.FieldAttendees:
		return m.Attendees()
	case partnershipinteraction.FieldFollowUpRequired:
		return m.FollowUpRequired()
	case partnershipinteraction.FieldFollowUpDate:
		return m.FollowUpDate()
	case partnershipinteraction.FieldCreatedAt:
		return m.CreatedAt()
	case partnershipinteraction.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnershipInteractionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partnershipinteraction.FieldInteractionType:
		return m.OldInteractionType(ctx)
	case partnershipinteraction.FieldSubject:
		return m.OldSubject(ctx)
	case partnershipinteraction.FieldSummary:
		return m.OldSummary(ctx)
	case partnershipinteraction.FieldInteractedAt:
		return m.OldInteractedAt(ctx)
	case partnershipinteraction.FieldAttendees:
		return m.OldAttendees(ctx)
	case partnershipinteraction.FieldFollowUpRequired:
		return m.OldFollowUpRequired(ctx)
	case partnershipinteraction.FieldFollowUpDate:
		return m.OldFollowUpDate(ctx)
	case partnershipinteraction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case partnershipinteraction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PartnershipInteraction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnershipInteractionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partnershipinteraction.FieldInteractionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInteractionType(v)
		return nil
	case partnershipinteraction.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case partnershipinteraction.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case partnershipinteraction.FieldInteractedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInteractedAt(v)
		return nil
	case partnershipinteraction.FieldAttendees:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttendees(v)
		return nil
	case partnershipinteraction.FieldFollowUpRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowUpRequired(v)
		return nil
	case partnershipinteraction.FieldFollowUpDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowUpDate(v)
		return nil
	case partnershipinteraction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case partnershipinteraction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PartnershipInteraction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnershipInteractionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnershipInteractionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnershipInteractionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PartnershipInteraction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnershipInteractionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(partnershipinteraction.FieldSummary) {
		fields = append(fields, partnershipinteraction.FieldSummary)
	}
	if m.FieldCleared(partnershipinteraction.FieldFollowUpDate) {
		fields = append(fields, partnershipinteraction.FieldFollowUpDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnershipInteractionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnershipInteractionMutation) ClearField(name string) error {
	switch name {
	case partnershipinteraction.FieldSummary:
		m.ClearSummary()
		return nil
	case partnershipinteraction.FieldFollowUpDate:
		m.ClearFollowUpDate()
		return nil
	}
	return fmt.Errorf("unknown PartnershipInteraction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnershipInteractionMutation) ResetField(name string) error {
	switch name {
	case partnershipinteraction.FieldInteractionType:
		m.ResetInteractionType()
		return nil
	case partnershipinteraction.FieldSubject:
		m.ResetSubject()
		return nil
	case partnershipinteraction.FieldSummary:
		m.ResetSummary()
		return nil
	case partnershipinteraction.FieldInteractedAt:
		m.ResetInteractedAt()
		return nil
	case partnershipinteraction.FieldAttendees:
		m.ResetAttendees()
		return nil
	case partnershipinteraction.FieldFollowUpRequired:
		m.ResetFollowUpRequired()
		return nil
	case partnershipinteraction.FieldFollowUpDate:
		m.ResetFollowUpDate()
		return nil
	case partnershipinteraction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case partnershipinteraction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PartnershipInteraction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnershipInteractionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.partnership != nil {
		edges = append(edges, partnershipinteraction.EdgePartnership)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnershipInteractionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partnershipinteraction.EdgePartnership:
		if id := m.partnership; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnershipInteractionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnershipInteractionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnershipInteractionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpartnership {
		edges = append(edges, partnershipinteraction.EdgePartnership)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnershipInteractionMutation) EdgeCleared(name string) bool {
	switch name {
	case partnershipinteraction.EdgePartnership:
		return m.clearedpartnership
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnershipInteractionMutation) ClearEdge(name string) error {
	switch name {
	case partnershipinteraction.EdgePartnership:
		m.ClearPartnership()
		return nil
	}
	return fmt.Errorf("unknown PartnershipInteraction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnershipInteractionMutation) ResetEdge(name string) error {
	switch name {
	case partnershipinteraction.EdgePartnership:
		m.ResetPartnership()
		return nil
	}
	return fmt.Errorf("unknown PartnershipInteraction edge %s", name)
}

// PartnershipRenewalMutation represents an operation that mutates the PartnershipRenewal nodes in the graph.
type PartnershipRenewalMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	previous_end_date  *time.Time
	new_end_date       *time.Time
	renewal_value      *float64
	addrenewal_value   *float64
	renewal_terms      *map[string]interface{}
	negotiated_by      *string
	approved_by        *string
	approved_at        *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	partnership        *int
	clearedpartnership bool
	done               bool
	oldValue           func(context.Context) (*PartnershipRenewal, error)
	predicates         []predicate.PartnershipRenewal
}

var _ ent.Mutation = (*PartnershipRenewalMutation)(nil)

// partnershiprenewalOption allows management of the mutation configuration using functional options.
type partnershiprenewalOption func(*PartnershipRenewalMutation)

// newPartnershipRenewalMutation creates new mutation for the PartnershipRenewal entity.
func newPartnershipRenewalMutation(c config, op Op, opts ...partnershiprenewalOption) *PartnershipRenewalMutation {
	m := &PartnershipRenewalMutation{
		config:        c,
		op:            op,
		typ:           TypePartnershipRenewal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnershipRenewalID sets the ID field of the mutation.
func withPartnershipRenewalID(id int) partnershiprenewalOption {
	return func(m *PartnershipRenewalMutation) {
		var (
			err   error
			once  sync.Once
			value *PartnershipRenewal
		)
		m.oldValue = func(ctx context.Context) (*PartnershipRenewal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartnershipRenewal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartnershipRenewal sets the old PartnershipRenewal of the mutation.
func withPartnershipRenewal(node *PartnershipRenewal) partnershiprenewalOption {
	return func(m *PartnershipRenewalMutation) {
		m.oldValue = func(context.Context) (*PartnershipRenewal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnershipRenewalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnershipRenewalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnershipRenewalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnershipRenewalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PartnershipRenewal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPreviousEndDate sets the "previous_end_date" field.
func (m *PartnershipRenewalMutation) SetPreviousEndDate(t time.Time) {
	m.previous_end_date = &t
}

// PreviousEndDate returns the value of the "previous_end_date" field in the mutation.
func (m *PartnershipRenewalMutation) PreviousEndDate() (r time.Time, exists bool) {
	v := m.previous_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousEndDate returns the old "previous_end_date" field's value of the PartnershipRenewal entity.
// If the PartnershipRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipRenewalMutation) OldPreviousEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousEndDate: %w", err)
	}
	return oldValue.PreviousEndDate, nil
}

// ResetPreviousEndDate resets all changes to the "previous_end_date" field.
func (m *PartnershipRenewalMutation) ResetPreviousEndDate() {
	m.previous_end_date = nil
}

// SetNewEndDate sets the "new_end_date" field.
func (m *PartnershipRenewalMutation) SetNewEndDate(t time.Time) {
	m.new_end_date = &t
}

// NewEndDate returns the value of the "new_end_date" field in the mutation.
func (m *PartnershipRenewalMutation) NewEndDate() (r time.Time, exists bool) {
	v := m.new_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldNewEndDate returns the old "new_end_date" field's value of the PartnershipRenewal entity.
// If the PartnershipRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipRenewalMutation) OldNewEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewEndDate: %w", err)
	}
	return oldValue.NewEndDate, nil
}

// ResetNewEndDate resets all changes to the "new_end_date" field.
func (m *PartnershipRenewalMutation) ResetNewEndDate() {
	m.new_end_date = nil
}

// SetRenewalValue sets the "renewal_value" field.
func (m *PartnershipRenewalMutation) SetRenewalValue(f float64) {
	m.renewal_value = &f
	m.addrenewal_value = nil
}

// RenewalValue returns the value of the "renewal_value" field in the mutation.
func (m *PartnershipRenewalMutation) RenewalValue() (r float64, exists bool) {
	v := m.renewal_value
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalValue returns the old "renewal_value" field's value of the PartnershipRenewal entity.
// If the PartnershipRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipRenewalMutation) OldRenewalValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenewalValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenewalValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalValue: %w", err)
	}
	return oldValue.RenewalValue, nil
}

// AddRenewalValue adds f to the "renewal_value" field.
func (m *PartnershipRenewalMutation) AddRenewalValue(f float64) {
	if m.addrenewal_value != nil {
		*m.addrenewal_value += f
	} else {
		m.addrenewal_value = &f
	}
}

// AddedRenewalValue returns the value that was added to the "renewal_value" field in this mutation.
func (m *PartnershipRenewalMutation) AddedRenewalValue() (r float64, exists bool) {
	v := m.addrenewal_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearRenewalValue clears the value of the "renewal_value" field.
func (m *PartnershipRenewalMutation) ClearRenewalValue() {
	m.renewal_value = nil
	m.addrenewal_value = nil
	m.clearedFields[partnershiprenewal.FieldRenewalValue] = struct{}{}
}

// RenewalValueCleared returns if the "renewal_value" field was cleared in this mutation.
func (m *PartnershipRenewalMutation) RenewalValueCleared() bool {
	_, ok := m.clearedFields[partnershiprenewal.FieldRenewalValue]
	return ok
}

// ResetRenewalValue resets all changes to the "renewal_value" field.
func (m *PartnershipRenewalMutation) ResetRenewalValue() {
	m.renewal_value = nil
	m.addrenewal_value = nil
	delete(m.clearedFields, partnershiprenewal.FieldRenewalValue)
}

// SetRenewalTerms sets the "renewal_terms" field.
func (m *PartnershipRenewalMutation) SetRenewalTerms(value map[string]interface{}) {
	m.renewal_terms = &value
}

// RenewalTerms returns the value of the "renewal_terms" field in the mutation.
func (m *PartnershipRenewalMutation) RenewalTerms() (r map[string]interface{}, exists bool) {
	v := m.renewal_terms
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalTerms returns the old "renewal_terms" field's value of the PartnershipRenewal entity.
// If the PartnershipRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipRenewalMutation) OldRenewalTerms(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenewalTerms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenewalTerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalTerms: %w", err)
	}
	return oldValue.RenewalTerms, nil
}

// ClearRenewalTerms clears the value of the "renewal_terms" field.
func (m *PartnershipRenewalMutation) ClearRenewalTerms() {
	m.renewal_terms = nil
	m.clearedFields[partnershiprenewal.FieldRenewalTerms] = struct{}{}
}

// RenewalTermsCleared returns if the "renewal_terms" field was cleared in this mutation.
func (m *PartnershipRenewalMutation) RenewalTermsCleared() bool {
	_, ok := m.clearedFields[partnershiprenewal.FieldRenewalTerms]
	return ok
}

// ResetRenewalTerms resets all changes to the "renewal_terms" field.
func (m *PartnershipRenewalMutation) ResetRenewalTerms() {
	m.renewal_terms = nil
	delete(m.clearedFields, partnershiprenewal.FieldRenewalTerms)
}

// SetNegotiatedBy sets the "negotiated_by" field.
func (m *PartnershipRenewalMutation) SetNegotiatedBy(s string) {
	m.negotiated_by = &s
}

// NegotiatedBy returns the value of the "negotiated_by" field in the mutation.
func (m *PartnershipRenewalMutation) NegotiatedBy() (r string, exists bool) {
	v := m.negotiated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldNegotiatedBy returns the old "negotiated_by" field's value of the PartnershipRenewal entity.
// If the PartnershipRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipRenewalMutation) OldNegotiatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNegotiatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNegotiatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNegotiatedBy: %w", err)
	}
	return oldValue.NegotiatedBy, nil
}

// ClearNegotiatedBy clears the value of the "negotiated_by" field.
func (m *PartnershipRenewalMutation) ClearNegotiatedBy() {
	m.negotiated_by = nil
	m.clearedFields[partnershiprenewal.FieldNegotiatedBy] = struct{}{}
}

// NegotiatedByCleared returns if the "negotiated_by" field was cleared in this mutation.
func (m *PartnershipRenewalMutation) NegotiatedByCleared() bool {
	_, ok := m.clearedFields[partnershiprenewal.FieldNegotiatedBy]
	return ok
}

// ResetNegotiatedBy resets all changes to the "negotiated_by" field.
func (m *PartnershipRenewalMutation) ResetNegotiatedBy() {
	m.negotiated_by = nil
	delete(m.clearedFields, partnershiprenewal.FieldNegotiatedBy)
}

// SetApprovedBy sets the "approved_by" field.
func (m *PartnershipRenewalMutation) SetApprovedBy(s string) {
	m.approved_by = &s
}

// ApprovedBy returns the value of the "approved_by" field in the mutation.
func (m *PartnershipRenewalMutation) ApprovedBy() (r string, exists bool) {
	v := m.approved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedBy returns the old "approved_by" field's value of the PartnershipRenewal entity.
// If the PartnershipRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipRenewalMutation) OldApprovedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedBy: %w", err)
	}
	return oldValue.ApprovedBy, nil
}

// ClearApprovedBy clears the value of the "approved_by" field.
func (m *PartnershipRenewalMutation) ClearApprovedBy() {
	m.approved_by = nil
	m.clearedFields[partnershiprenewal.FieldApprovedBy] = struct{}{}
}

// ApprovedByCleared returns if the "approved_by" field was cleared in this mutation.
func (m *PartnershipRenewalMutation) ApprovedByCleared() bool {
	_, ok := m.clearedFields[partnershiprenewal.FieldApprovedBy]
	return ok
}

// ResetApprovedBy resets all changes to the "approved_by" field.
func (m *PartnershipRenewalMutation) ResetApprovedBy() {
	m.approved_by = nil
	delete(m.clearedFields, partnershiprenewal.FieldApprovedBy)
}

// SetApprovedAt sets the "approved_at" field.
func (m *PartnershipRenewalMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *PartnershipRenewalMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the PartnershipRenewal entity.
// If the PartnershipRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipRenewalMutation) OldApprovedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *PartnershipRenewalMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[partnershiprenewal.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *PartnershipRenewalMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[partnershiprenewal.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *PartnershipRenewalMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, partnershiprenewal.FieldApprovedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PartnershipRenewalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartnershipRenewalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PartnershipRenewal entity.
// If the PartnershipRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipRenewalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartnershipRenewalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartnershipRenewalMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartnershipRenewalMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PartnershipRenewal entity.
// If the PartnershipRenewal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipRenewalMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartnershipRenewalMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPartnershipID sets the "partnership" edge to the Partnership entity by id.
func (m *PartnershipRenewalMutation) SetPartnershipID(id int) {
	m.partnership = &id
}

// ClearPartnership clears the "partnership" edge to the Partnership entity.
func (m *PartnershipRenewalMutation) ClearPartnership() {
	m.clearedpartnership = true
}

// PartnershipCleared reports if the "partnership" edge to the Partnership entity was cleared.
func (m *PartnershipRenewalMutation) PartnershipCleared() bool {
	return m.clearedpartnership
}

// PartnershipID returns the "partnership" edge ID in the mutation.
func (m *PartnershipRenewalMutation) PartnershipID() (id int, exists bool) {
	if m.partnership != nil {
		return *m.partnership, true
	}
	return
}

// PartnershipIDs returns the "partnership" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnershipID instead. It exists only for internal usage by the builders.
func (m *PartnershipRenewalMutation) PartnershipIDs() (ids []int) {
	if id := m.partnership; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartnership resets all changes to the "partnership" edge.
func (m *PartnershipRenewalMutation) ResetPartnership() {
	m.partnership = nil
	m.clearedpartnership = false
}

// Where appends a list predicates to the PartnershipRenewalMutation builder.
func (m *PartnershipRenewalMutation) Where(ps ...predicate.PartnershipRenewal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnershipRenewalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnershipRenewalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PartnershipRenewal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnershipRenewalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnershipRenewalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PartnershipRenewal).
func (m *PartnershipRenewalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnershipRenewalMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.previous_end_date != nil {
		fields = append(fields, partnershiprenewal.FieldPreviousEndDate)
	}
	if m.new_end_date != nil {
		fields = append(fields, partnershiprenewal.FieldNewEndDate)
	}
	if m.renewal_value != nil {
		fields = append(fields, partnershiprenewal.FieldRenewalValue)
	}
	if m.renewal_terms != nil {
		fields = append(fields, partnershiprenewal.FieldRenewalTerms)
	}
	if m.negotiated_by != nil {
		fields = append(fields, partnershiprenewal.FieldNegotiatedBy)
	}
	if m.approved_by != nil {
		fields = append(fields, partnershiprenewal.FieldApprovedBy)
	}
	if m.approved_at != nil {
		fields = append(fields, partnershiprenewal.FieldApprovedAt)
	}
	if m.created_at != nil {
		fields = append(fields, partnershiprenewal.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, partnershiprenewal.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnershipRenewalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partnershiprenewal.FieldPreviousEndDate:
		return m.PreviousEndDate()
	case partnershiprenewal.FieldNewEndDate:
		return m.NewEndDate()
	case partnershiprenewal.FieldRenewalValue:
		return m.RenewalValue()
	case partnershiprenewal.FieldRenewalTerms:
		return m.RenewalTerms()
	case partnershiprenewal.FieldNegotiatedBy:
		return m.NegotiatedBy()
	case partnershiprenewal.FieldApprovedBy:
		return m.ApprovedBy()
	case partnershiprenewal.FieldApprovedAt:
		return m.ApprovedAt()
	case partnershiprenewal.FieldCreatedAt:
		return m.CreatedAt()
	case partnershiprenewal.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnershipRenewalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partnershiprenewal.FieldPreviousEndDate:
		return m.OldPreviousEndDate(ctx)
	case partnershiprenewal.FieldNewEndDate:
		return m.OldNewEndDate(ctx)
	case partnershiprenewal.FieldRenewalValue:
		return m.OldRenewalValue(ctx)
	case partnershiprenewal.FieldRenewalTerms:
		return m.OldRenewalTerms(ctx)
	case partnershiprenewal.FieldNegotiatedBy:
		return m.OldNegotiatedBy(ctx)
	case partnershiprenewal.FieldApprovedBy:
		return m.OldApprovedBy(ctx)
	case partnershiprenewal.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case partnershiprenewal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case partnershiprenewal.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PartnershipRenewal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnershipRenewalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partnershiprenewal.FieldPreviousEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousEndDate(v)
		return nil
	case partnershiprenewal.FieldNewEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewEndDate(v)
		return nil
	case partnershiprenewal.FieldRenewalValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalValue(v)
		return nil
	case partnershiprenewal.FieldRenewalTerms:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalTerms(v)
		return nil
	case partnershiprenewal.FieldNegotiatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNegotiatedBy(v)
		return nil
	case partnershiprenewal.FieldApprovedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedBy(v)
		return nil
	case partnershiprenewal.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case partnershiprenewal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case partnershiprenewal.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PartnershipRenewal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnershipRenewalMutation) AddedFields() []string {
	var fields []string
	if m.addrenewal_value != nil {
		fields = append(fields, partnershiprenewal.FieldRenewalValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnershipRenewalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case partnershiprenewal.FieldRenewalValue:
		return m.AddedRenewalValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnershipRenewalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case partnershiprenewal.FieldRenewalValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRenewalValue(v)
		return nil
	}
	return fmt.Errorf("unknown PartnershipRenewal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnershipRenewalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(partnershiprenewal.FieldRenewalValue) {
		fields = append(fields, partnershiprenewal.FieldRenewalValue)
	}
	if m.FieldCleared(partnershiprenewal.FieldRenewalTerms) {
		fields = append(fields, partnershiprenewal.FieldRenewalTerms)
	}
	if m.FieldCleared(partnershiprenewal.FieldNegotiatedBy) {
		fields = append(fields, partnershiprenewal.FieldNegotiatedBy)
	}
	if m.FieldCleared(partnershiprenewal.FieldApprovedBy) {
		fields = append(fields, partnershiprenewal.FieldApprovedBy)
	}
	if m.FieldCleared(partnershiprenewal.FieldApprovedAt) {
		fields = append(fields, partnershiprenewal.FieldApprovedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnershipRenewalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnershipRenewalMutation) ClearField(name string) error {
	switch name {
	case partnershiprenewal.FieldRenewalValue:
		m.ClearRenewalValue()
		return nil
	case partnershiprenewal.FieldRenewalTerms:
		m.ClearRenewalTerms()
		return nil
	case partnershiprenewal.FieldNegotiatedBy:
		m.ClearNegotiatedBy()
		return nil
	case partnershiprenewal.FieldApprovedBy:
		m.ClearApprovedBy()
		return nil
	case partnershiprenewal.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	}
	return fmt.Errorf("unknown PartnershipRenewal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnershipRenewalMutation) ResetField(name string) error {
	switch name {
	case partnershiprenewal.FieldPreviousEndDate:
		m.ResetPreviousEndDate()
		return nil
	case partnershiprenewal.FieldNewEndDate:
		m.ResetNewEndDate()
		return nil
	case partnershiprenewal.FieldRenewalValue:
		m.ResetRenewalValue()
		return nil
	case partnershiprenewal.FieldRenewalTerms:
		m.ResetRenewalTerms()
		return nil
	case partnershiprenewal.FieldNegotiatedBy:
		m.ResetNegotiatedBy()
		return nil
	case partnershiprenewal.FieldApprovedBy:
		m.ResetApprovedBy()
		return nil
	case partnershiprenewal.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case partnershiprenewal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case partnershiprenewal.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PartnershipRenewal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnershipRenewalMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.partnership != nil {
		edges = append(edges, partnershiprenewal.EdgePartnership)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnershipRenewalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partnershiprenewal.EdgePartnership:
		if id := m.partnership; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnershipRenewalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnershipRenewalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnershipRenewalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpartnership {
		edges = append(edges, partnershiprenewal.EdgePartnership)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnershipRenewalMutation) EdgeCleared(name string) bool {
	switch name {
	case partnershiprenewal.EdgePartnership:
		return m.clearedpartnership
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnershipRenewalMutation) ClearEdge(name string) error {
	switch name {
	case partnershiprenewal.EdgePartnership:
		m.ClearPartnership()
		return nil
	}
	return fmt.Errorf("unknown PartnershipRenewal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnershipRenewalMutation) ResetEdge(name string) error {
	switch name {
	case partnershiprenewal.EdgePartnership:
		m.ResetPartnership()
		return nil
	}
	return fmt.Errorf("unknown PartnershipRenewal edge %s", name)
}

// PartnershipReportMutation represents an operation that mutates the PartnershipReport nodes in the graph.
type PartnershipReportMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	report_period      *string
	generated_at       *time.Time
	generated_by       *string
	impact_metrics     *map[string]interface{}
	outcomes           *[]string
	appendoutcomes     []string
	feedback           *[]string
	appendfeedback     []string
	report_url         *string
	presentation_url   *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	partnership        *int
	clearedpartnership bool
	done               bool
	oldValue           func(context.Context) (*PartnershipReport, error)
	predicates         []predicate.PartnershipReport
}

var _ ent.Mutation = (*PartnershipReportMutation)(nil)

// partnershipreportOption allows management of the mutation configuration using functional options.
type partnershipreportOption func(*PartnershipReportMutation)

// newPartnershipReportMutation creates new mutation for the PartnershipReport entity.
func newPartnershipReportMutation(c config, op Op, opts ...partnershipreportOption) *PartnershipReportMutation {
	m := &PartnershipReportMutation{
		config:        c,
		op:            op,
		typ:           TypePartnershipReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnershipReportID sets the ID field of the mutation.
func withPartnershipReportID(id int) partnershipreportOption {
	return func(m *PartnershipReportMutation) {
		var (
			err   error
			once  sync.Once
			value *PartnershipReport
		)
		m.oldValue = func(ctx context.Context) (*PartnershipReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartnershipReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartnershipReport sets the old PartnershipReport of the mutation.
func withPartnershipReport(node *PartnershipReport) partnershipreportOption {
	return func(m *PartnershipReportMutation) {
		m.oldValue = func(context.Context) (*PartnershipReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnershipReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnershipReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnershipReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnershipReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PartnershipReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReportPeriod sets the "report_period" field.
func (m *PartnershipReportMutation) SetReportPeriod(s string) {
	m.report_period = &s
}

// ReportPeriod returns the value of the "report_period" field in the mutation.
func (m *PartnershipReportMutation) ReportPeriod() (r string, exists bool) {
	v := m.report_period
	if v == nil {
		return
	}
	return *v, true
}

// OldReportPeriod returns the old "report_period" field's value of the PartnershipReport entity.
// If the PartnershipReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipReportMutation) OldReportPeriod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportPeriod: %w", err)
	}
	return oldValue.ReportPeriod, nil
}

// ResetReportPeriod resets all changes to the "report_period" field.
func (m *PartnershipReportMutation) ResetReportPeriod() {
	m.report_period = nil
}

// SetGeneratedAt sets the "generated_at" field.
func (m *PartnershipReportMutation) SetGeneratedAt(t time.Time) {
	m.generated_at = &t
}

// GeneratedAt returns the value of the "generated_at" field in the mutation.
func (m *PartnershipReportMutation) GeneratedAt() (r time.Time, exists bool) {
	v := m.generated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneratedAt returns the old "generated_at" field's value of the PartnershipReport entity.
// If the PartnershipReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipReportMutation) OldGeneratedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeneratedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeneratedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneratedAt: %w", err)
	}
	return oldValue.GeneratedAt, nil
}

// ResetGeneratedAt resets all changes to the "generated_at" field.
func (m *PartnershipReportMutation) ResetGeneratedAt() {
	m.generated_at = nil
}

// SetGeneratedBy sets the "generated_by" field.
func (m *PartnershipReportMutation) SetGeneratedBy(s string) {
	m.generated_by = &s
}

// GeneratedBy returns the value of the "generated_by" field in the mutation.
func (m *PartnershipReportMutation) GeneratedBy() (r string, exists bool) {
	v := m.generated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneratedBy returns the old "generated_by" field's value of the PartnershipReport entity.
// If the PartnershipReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipReportMutation) OldGeneratedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeneratedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeneratedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneratedBy: %w", err)
	}
	return oldValue.GeneratedBy, nil
}

// ClearGeneratedBy clears the value of the "generated_by" field.
func (m *PartnershipReportMutation) ClearGeneratedBy() {
	m.generated_by = nil
	m.clearedFields[partnershipreport.FieldGeneratedBy] = struct{}{}
}

// GeneratedByCleared returns if the "generated_by" field was cleared in this mutation.
func (m *PartnershipReportMutation) GeneratedByCleared() bool {
	_, ok := m.clearedFields[partnershipreport.FieldGeneratedBy]
	return ok
}

// ResetGeneratedBy resets all changes to the "generated_by" field.
func (m *PartnershipReportMutation) ResetGeneratedBy() {
	m.generated_by = nil
	delete(m.clearedFields, partnershipreport.FieldGeneratedBy)
}

// SetImpactMetrics sets the "impact_metrics" field.
func (m *PartnershipReportMutation) SetImpactMetrics(value map[string]interface{}) {
	m.impact_metrics = &value
}

// ImpactMetrics returns the value of the "impact_metrics" field in the mutation.
func (m *PartnershipReportMutation) ImpactMetrics() (r map[string]interface{}, exists bool) {
	v := m.impact_metrics
	if v == nil {
		return
	}
	return *v, true
}

// OldImpactMetrics returns the old "impact_metrics" field's value of the PartnershipReport entity.
// If the PartnershipReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipReportMutation) OldImpactMetrics(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpactMetrics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpactMetrics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpactMetrics: %w", err)
	}
	return oldValue.ImpactMetrics, nil
}

// ResetImpactMetrics resets all changes to the "impact_metrics" field.
func (m *PartnershipReportMutation) ResetImpactMetrics() {
	m.impact_metrics = nil
}

// SetOutcomes sets the "outcomes" field.
func (m *PartnershipReportMutation) SetOutcomes(s []string) {
	m.outcomes = &s
	m.appendoutcomes = nil
}

// Outcomes returns the value of the "outcomes" field in the mutation.
func (m *PartnershipReportMutation) Outcomes() (r []string, exists bool) {
	v := m.outcomes
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomes returns the old "outcomes" field's value of the PartnershipReport entity.
// If the PartnershipReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipReportMutation) OldOutcomes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomes: %w", err)
	}
	return oldValue.Outcomes, nil
}

// AppendOutcomes adds s to the "outcomes" field.
func (m *PartnershipReportMutation) AppendOutcomes(s []string) {
	m.appendoutcomes = append(m.appendoutcomes, s...)
}

// AppendedOutcomes returns the list of values that were appended to the "outcomes" field in this mutation.
func (m *PartnershipReportMutation) AppendedOutcomes() ([]string, bool) {
	if len(m.appendoutcomes) == 0 {
		return nil, false
	}
	return m.appendoutcomes, true
}

// ResetOutcomes resets all changes to the "outcomes" field.
func (m *PartnershipReportMutation) ResetOutcomes() {
	m.outcomes = nil
	m.appendoutcomes = nil
}

// SetFeedback sets the "feedback" field.
func (m *PartnershipReportMutation) SetFeedback(s []string) {
	m.feedback = &s
	m.appendfeedback = nil
}

// Feedback returns the value of the "feedback" field in the mutation.
func (m *PartnershipReportMutation) Feedback() (r []string, exists bool) {
	v := m.feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedback returns the old "feedback" field's value of the PartnershipReport entity.
// If the PartnershipReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipReportMutation) OldFeedback(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedback: %w", err)
	}
	return oldValue.Feedback, nil
}

// AppendFeedback adds s to the "feedback" field.
func (m *PartnershipReportMutation) AppendFeedback(s []string) {
	m.appendfeedback = append(m.appendfeedback, s...)
}

// AppendedFeedback returns the list of values that were appended to the "feedback" field in this mutation.
func (m *PartnershipReportMutation) AppendedFeedback() ([]string, bool) {
	if len(m.appendfeedback) == 0 {
		return nil, false
	}
	return m.appendfeedback, true
}

// ResetFeedback resets all changes to the "feedback" field.
func (m *PartnershipReportMutation) ResetFeedback() {
	m.feedback = nil
	m.appendfeedback = nil
}

// SetReportURL sets the "report_url" field.
func (m *PartnershipReportMutation) SetReportURL(s string) {
	m.report_url = &s
}

// ReportURL returns the value of the "report_url" field in the mutation.
func (m *PartnershipReportMutation) ReportURL() (r string, exists bool) {
	v := m.report_url
	if v == nil {
		return
	}
	return *v, true
}

// OldReportURL returns the old "report_url" field's value of the PartnershipReport entity.
// If the PartnershipReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipReportMutation) OldReportURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportURL: %w", err)
	}
	return oldValue.ReportURL, nil
}

// ClearReportURL clears the value of the "report_url" field.
func (m *PartnershipReportMutation) ClearReportURL() {
	m.report_url = nil
	m.clearedFields[partnershipreport.FieldReportURL] = struct{}{}
}

// ReportURLCleared returns if the "report_url" field was cleared in this mutation.
func (m *PartnershipReportMutation) ReportURLCleared() bool {
	_, ok := m.clearedFields[partnershipreport.FieldReportURL]
	return ok
}

// ResetReportURL resets all changes to the "report_url" field.
func (m *PartnershipReportMutation) ResetReportURL() {
	m.report_url = nil
	delete(m.clearedFields, partnershipreport.FieldReportURL)
}

// SetPresentationURL sets the "presentation_url" field.
func (m *PartnershipReportMutation) SetPresentationURL(s string) {
	m.presentation_url = &s
}

// PresentationURL returns the value of the "presentation_url" field in the mutation.
func (m *PartnershipReportMutation) PresentationURL() (r string, exists bool) {
	v := m.presentation_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPresentationURL returns the old "presentation_url" field's value of the PartnershipReport entity.
// If the PartnershipReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipReportMutation) OldPresentationURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPresentationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPresentationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPresentationURL: %w", err)
	}
	return oldValue.PresentationURL, nil
}

// ClearPresentationURL clears the value of the "presentation_url" field.
func (m *PartnershipReportMutation) ClearPresentationURL() {
	m.presentation_url = nil
	m.clearedFields[partnershipreport.FieldPresentationURL] = struct{}{}
}

// PresentationURLCleared returns if the "presentation_url" field was cleared in this mutation.
func (m *PartnershipReportMutation) PresentationURLCleared() bool {
	_, ok := m.clearedFields[partnershipreport.FieldPresentationURL]
	return ok
}

// ResetPresentationURL resets all changes to the "presentation_url" field.
func (m *PartnershipReportMutation) ResetPresentationURL() {
	m.presentation_url = nil
	delete(m.clearedFields, partnershipreport.FieldPresentationURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *PartnershipReportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartnershipReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PartnershipReport entity.
// If the PartnershipReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartnershipReportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartnershipReportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartnershipReportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PartnershipReport entity.
// If the PartnershipReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnershipReportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartnershipReportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPartnershipID sets the "partnership" edge to the Partnership entity by id.
func (m *PartnershipReportMutation) SetPartnershipID(id int) {
	m.partnership = &id
}

// ClearPartnership clears the "partnership" edge to the Partnership entity.
func (m *PartnershipReportMutation) ClearPartnership() {
	m.clearedpartnership = true
}

// PartnershipCleared reports if the "partnership" edge to the Partnership entity was cleared.
func (m *PartnershipReportMutation) PartnershipCleared() bool {
	return m.clearedpartnership
}

// PartnershipID returns the "partnership" edge ID in the mutation.
func (m *PartnershipReportMutation) PartnershipID() (id int, exists bool) {
	if m.partnership != nil {
		return *m.partnership, true
	}
	return
}

// PartnershipIDs returns the "partnership" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnershipID instead. It exists only for internal usage by the builders.
func (m *PartnershipReportMutation) PartnershipIDs() (ids []int) {
	if id := m.partnership; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartnership resets all changes to the "partnership" edge.
func (m *PartnershipReportMutation) ResetPartnership() {
	m.partnership = nil
	m.clearedpartnership = false
}

// Where appends a list predicates to the PartnershipReportMutation builder.
func (m *PartnershipReportMutation) Where(ps ...predicate.PartnershipReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnershipReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnershipReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PartnershipReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnershipReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnershipReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PartnershipReport).
func (m *PartnershipReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnershipReportMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.report_period != nil {
		fields = append(fields, partnershipreport.FieldReportPeriod)
	}
	if m.generated_at != nil {
		fields = append(fields, partnershipreport.FieldGeneratedAt)
	}
	if m.generated_by != nil {
		fields = append(fields, partnershipreport.FieldGeneratedBy)
	}
	if m.impact_metrics != nil {
		fields = append(fields, partnershipreport.FieldImpactMetrics)
	}
	if m.outcomes != nil {
		fields = append(fields, partnershipreport.FieldOutcomes)
	}
	if m.feedback != nil {
		fields = append(fields, partnershipreport.FieldFeedback)
	}
	if m.report_url != nil {
		fields = append(fields, partnershipreport.FieldReportURL)
	}
	if m.presentation_url != nil {
		fields = append(fields, partnershipreport.FieldPresentationURL)
	}
	if m.created_at != nil {
		fields = append(fields, partnershipreport.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, partnershipreport.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnershipReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partnershipreport.FieldReportPeriod:
		return m.ReportPeriod()
	case partnershipreport.FieldGeneratedAt:
		return m.GeneratedAt()
	case partnershipreport.FieldGeneratedBy:
		return m.GeneratedBy()
	case partnershipreport.FieldImpactMetrics:
		return m.ImpactMetrics()
	case partnershipreport.FieldOutcomes:
		return m.Outcomes()
	case partnershipreport.FieldFeedback:
		return m.Feedback()
	case partnershipreport.FieldReportURL:
		return m.ReportURL()
	case partnershipreport.FieldPresentationURL:
		return m.PresentationURL()
	case partnershipreport.FieldCreatedAt:
		return m.CreatedAt()
	case partnershipreport.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnershipReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partnershipreport.FieldReportPeriod:
		return m.OldReportPeriod(ctx)
	case partnershipreport.FieldGeneratedAt:
		return m.OldGeneratedAt(ctx)
	case partnershipreport.FieldGeneratedBy:
		return m.OldGeneratedBy(ctx)
	case partnershipreport.FieldImpactMetrics:
		return m.OldImpactMetrics(ctx)
	case partnershipreport.FieldOutcomes:
		return m.OldOutcomes(ctx)
	case partnershipreport.FieldFeedback:
		return m.OldFeedback(ctx)
	case partnershipreport.FieldReportURL:
		return m.OldReportURL(ctx)
	case partnershipreport.FieldPresentationURL:
		return m.OldPresentationURL(ctx)
	case partnershipreport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case partnershipreport.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PartnershipReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnershipReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partnershipreport.FieldReportPeriod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportPeriod(v)
		return nil
	case partnershipreport.FieldGeneratedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneratedAt(v)
		return nil
	case partnershipreport.FieldGeneratedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneratedBy(v)
		return nil
	case partnershipreport.FieldImpactMetrics:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpactMetrics(v)
		return nil
	case partnershipreport.FieldOutcomes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomes(v)
		return nil
	case partnershipreport.FieldFeedback:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedback(v)
		return nil
	case partnershipreport.FieldReportURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportURL(v)
		return nil
	case partnershipreport.FieldPresentationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPresentationURL(v)
		return nil
	case partnershipreport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case partnershipreport.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PartnershipReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnershipReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnershipReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnershipReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PartnershipReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnershipReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(partnershipreport.FieldGeneratedBy) {
		fields = append(fields, partnershipreport.FieldGeneratedBy)
	}
	if m.FieldCleared(partnershipreport.FieldReportURL) {
		fields = append(fields, partnershipreport.FieldReportURL)
	}
	if m.FieldCleared(partnershipreport.FieldPresentationURL) {
		fields = append(fields, partnershipreport.FieldPresentationURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnershipReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnershipReportMutation) ClearField(name string) error {
	switch name {
	case partnershipreport.FieldGeneratedBy:
		m.ClearGeneratedBy()
		return nil
	case partnershipreport.FieldReportURL:
		m.ClearReportURL()
		return nil
	case partnershipreport.FieldPresentationURL:
		m.ClearPresentationURL()
		return nil
	}
	return fmt.Errorf("unknown PartnershipReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnershipReportMutation) ResetField(name string) error {
	switch name {
	case partnershipreport.FieldReportPeriod:
		m.ResetReportPeriod()
		return nil
	case partnershipreport.FieldGeneratedAt:
		m.ResetGeneratedAt()
		return nil
	case partnershipreport.FieldGeneratedBy:
		m.ResetGeneratedBy()
		return nil
	case partnershipreport.FieldImpactMetrics:
		m.ResetImpactMetrics()
		return nil
	case partnershipreport.FieldOutcomes:
		m.ResetOutcomes()
		return nil
	case partnershipreport.FieldFeedback:
		m.ResetFeedback()
		return nil
	case partnershipreport.FieldReportURL:
		m.ResetReportURL()
		return nil
	case partnershipreport.FieldPresentationURL:
		m.ResetPresentationURL()
		return nil
	case partnershipreport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case partnershipreport.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PartnershipReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnershipReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.partnership != nil {
		edges = append(edges, partnershipreport.EdgePartnership)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnershipReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partnershipreport.EdgePartnership:
		if id := m.partnership; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnershipReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnershipReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnershipReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpartnership {
		edges = append(edges, partnershipreport.EdgePartnership)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnershipReportMutation) EdgeCleared(name string) bool {
	switch name {
	case partnershipreport.EdgePartnership:
		return m.clearedpartnership
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnershipReportMutation) ClearEdge(name string) error {
	switch name {
	case partnershipreport.EdgePartnership:
		m.ClearPartnership()
		return nil
	}
	return fmt.Errorf("unknown PartnershipReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnershipReportMutation) ResetEdge(name string) error {
	switch name {
	case partnershipreport.EdgePartnership:
		m.ResetPartnership()
		return nil
	}
	return fmt.Errorf("unknown PartnershipReport edge %s", name)
}

// PasswordHistoryMutation represents an operation that mutates the PasswordHistory nodes in the graph.
type PasswordHistoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	hashed_password *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*PasswordHistory, error)
	predicates      []predicate.PasswordHistory
}

var _ ent.Mutation = (*PasswordHistoryMutation)(nil)

// passwordhistoryOption allows management of the mutation configuration using functional options.
type passwordhistoryOption func(*PasswordHistoryMutation)

// newPasswordHistoryMutation creates new mutation for the PasswordHistory entity.
func newPasswordHistoryMutation(c config, op Op, opts ...passwordhistoryOption) *PasswordHistoryMutation {
	m := &PasswordHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypePasswordHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordHistoryID sets the ID field of the mutation.
func withPasswordHistoryID(id int) passwordhistoryOption {
	return func(m *PasswordHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PasswordHistory
		)
		m.oldValue = func(ctx context.Context) (*PasswordHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PasswordHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasswordHistory sets the old PasswordHistory of the mutation.
func withPasswordHistory(node *PasswordHistory) passwordhistoryOption {
	return func(m *PasswordHistoryMutation) {
		m.oldValue = func(context.Context) (*PasswordHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PasswordHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHashedPassword sets the "hashed_password" field.
func (m *PasswordHistoryMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *PasswordHistoryMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the PasswordHistory entity.
// If the PasswordHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordHistoryMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *PasswordHistoryMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PasswordHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PasswordHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PasswordHistory entity.
// If the PasswordHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PasswordHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PasswordHistoryMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasswordHistoryMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasswordHistoryMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PasswordHistoryMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasswordHistoryMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasswordHistoryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasswordHistoryMutation builder.
func (m *PasswordHistoryMutation) Where(ps ...predicate.PasswordHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PasswordHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PasswordHistory).
func (m *PasswordHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordHistoryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.hashed_password != nil {
		fields = append(fields, passwordhistory.FieldHashedPassword)
	}
	if m.created_at != nil {
		fields = append(fields, passwordhistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passwordhistory.FieldHashedPassword:
		return m.HashedPassword()
	case passwordhistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passwordhistory.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case passwordhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PasswordHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passwordhistory.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case passwordhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PasswordHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PasswordHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PasswordHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordHistoryMutation) ResetField(name string) error {
	switch name {
	case passwordhistory.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case passwordhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PasswordHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passwordhistory.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passwordhistory.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passwordhistory.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case passwordhistory.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordHistoryMutation) ClearEdge(name string) error {
	switch name {
	case passwordhistory.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordHistoryMutation) ResetEdge(name string) error {
	switch name {
	case passwordhistory.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordHistory edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	resource      *string
	action        *string
	clearedFields map[string]struct{}
	roles         map[int]struct{}
	removedroles  map[int]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResource sets the "resource" field.
func (m *PermissionMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *PermissionMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ResetResource resets all changes to the "resource" field.
func (m *PermissionMutation) ResetResource() {
	m.resource = nil
}

// SetAction sets the "action" field.
func (m *PermissionMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *PermissionMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *PermissionMutation) ResetAction() {
	m.action = nil
}

// AddRoleIDs adds the "roles" edge to the RolePermission entity by ids.
func (m *PermissionMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the RolePermission entity.
func (m *PermissionMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the RolePermission entity was cleared.
func (m *PermissionMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the RolePermission entity by IDs.
func (m *PermissionMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the RolePermission entity.
func (m *PermissionMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *PermissionMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *PermissionMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.resource != nil {
		fields = append(fields, permission.FieldResource)
	}
	if m.action != nil {
		fields = append(fields, permission.FieldAction)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldResource:
		return m.Resource()
	case permission.FieldAction:
		return m.Action()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldResource:
		return m.OldResource(ctx)
	case permission.FieldAction:
		return m.OldAction(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case permission.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldResource:
		m.ResetResource()
		return nil
	case permission.FieldAction:
		m.ResetAction()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedroles {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// ProgramMutation represents an operation that mutates the Program nodes in the graph.
type ProgramMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	slug                           *string
	name                           *map[string]string
	description                    *map[string]interface{}
	tagline                        *map[string]string
	status                         *program.Status
	start_date                     *time.Time
	end_date                       *time.Time
	hero_image_url                 *string
	thumbnail_url                  *string
	video_thumbnail_url            *string
	media_gallery                  *[]string
	appendmedia_gallery            []string
	tags                           *[]string
	appendtags                     []string
	metrics                        *[]map[string]interface{}
	appendmetrics                  []map[string]interface{}
	curriculum                     *[]map[string]interface{}
	appendcurriculum               []map[string]interface{}
	eligibility_criteria           *[]map[string]interface{}
	appendeligibility_criteria     []map[string]interface{}
	application_steps              *[]map[string]interface{}
	appendapplication_steps        []map[string]interface{}
	duration                       *string
	capacity                       *int
	addcapacity                    *int
	application_deadline           *time.Time
	requirements                   *[]string
	appendrequirements             []string
	min_age                        *int
	addmin_age                     *int
	max_age                        *int
	addmax_age                     *int
	required_docs                  *[]string
	appendrequired_docs            []string
	cost                           *float64
	addcost                        *float64
	currency                       *string
	rules                          *[]string
	appendrules                    []string
	steps                          *[]map[string]interface{}
	appendsteps                    []map[string]interface{}
	required_skills                *[]string
	appendrequired_skills          []string
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	category                       *int
	clearedcategory                bool
	enrolments                     map[int]struct{}
	removedenrolments              map[int]struct{}
	clearedenrolments              bool
	participants                   map[int]struct{}
	removedparticipants            map[int]struct{}
	clearedparticipants            bool
	created_by                     *int
	clearedcreated_by              bool
	updated_by                     *int
	clearedupdated_by              bool
	program_card_items             map[int]struct{}
	removedprogram_card_items      map[int]struct{}
	clearedprogram_card_items      bool
	events                         map[int]struct{}
	removedevents                  map[int]struct{}
	clearedevents                  bool
	success_stories                map[int]struct{}
	removedsuccess_stories         map[int]struct{}
	clearedsuccess_stories         bool
	volunteer_opportunities        map[int]struct{}
	removedvolunteer_opportunities map[int]struct{}
	clearedvolunteer_opportunities bool
	fundraising_campaigns          map[int]struct{}
	removedfundraising_campaigns   map[int]struct{}
	clearedfundraising_campaigns   bool
	donations                      map[int]struct{}
	removeddonations               map[int]struct{}
	cleareddonations               bool
	grants                         map[int]struct{}
	removedgrants                  map[int]struct{}
	clearedgrants                  bool
	site_visits                    map[int]struct{}
	removedsite_visits             map[int]struct{}
	clearedsite_visits             bool
	impact_metrics                 map[int]struct{}
	removedimpact_metrics          map[int]struct{}
	clearedimpact_metrics          bool
	done                           bool
	oldValue                       func(context.Context) (*Program, error)
	predicates                     []predicate.Program
}

var _ ent.Mutation = (*ProgramMutation)(nil)

// programOption allows management of the mutation configuration using functional options.
type programOption func(*ProgramMutation)

// newProgramMutation creates new mutation for the Program entity.
func newProgramMutation(c config, op Op, opts ...programOption) *ProgramMutation {
	m := &ProgramMutation{
		config:        c,
		op:            op,
		typ:           TypeProgram,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProgramID sets the ID field of the mutation.
func withProgramID(id int) programOption {
	return func(m *ProgramMutation) {
		var (
			err   error
			once  sync.Once
			value *Program
		)
		m.oldValue = func(ctx context.Context) (*Program, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Program.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProgram sets the old Program of the mutation.
func withProgram(node *Program) programOption {
	return func(m *ProgramMutation) {
		m.oldValue = func(context.Context) (*Program, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProgramMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProgramMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProgramMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProgramMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Program.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *ProgramMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ProgramMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ProgramMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *ProgramMutation) SetName(value map[string]string) {
	m.name = &value
}

// Name returns the value of the "name" field in the mutation.
func (m *ProgramMutation) Name() (r map[string]string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldName(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProgramMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProgramMutation) SetDescription(value map[string]interface{}) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *ProgramMutation) Description() (r map[string]interface{}, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldDescription(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProgramMutation) ResetDescription() {
	m.description = nil
}

// SetTagline sets the "tagline" field.
func (m *ProgramMutation) SetTagline(value map[string]string) {
	m.tagline = &value
}

// Tagline returns the value of the "tagline" field in the mutation.
func (m *ProgramMutation) Tagline() (r map[string]string, exists bool) {
	v := m.tagline
	if v == nil {
		return
	}
	return *v, true
}

// OldTagline returns the old "tagline" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldTagline(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagline: %w", err)
	}
	return oldValue.Tagline, nil
}

// ResetTagline resets all changes to the "tagline" field.
func (m *ProgramMutation) ResetTagline() {
	m.tagline = nil
}

// SetStatus sets the "status" field.
func (m *ProgramMutation) SetStatus(pr program.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProgramMutation) Status() (r program.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldStatus(ctx context.Context) (v program.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProgramMutation) ResetStatus() {
	m.status = nil
}

// SetStartDate sets the "start_date" field.
func (m *ProgramMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProgramMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ProgramMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[program.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ProgramMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[program.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProgramMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, program.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ProgramMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProgramMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProgramMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[program.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProgramMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[program.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProgramMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, program.FieldEndDate)
}

// SetHeroImageURL sets the "hero_image_url" field.
func (m *ProgramMutation) SetHeroImageURL(s string) {
	m.hero_image_url = &s
}

// HeroImageURL returns the value of the "hero_image_url" field in the mutation.
func (m *ProgramMutation) HeroImageURL() (r string, exists bool) {
	v := m.hero_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHeroImageURL returns the old "hero_image_url" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldHeroImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeroImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeroImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeroImageURL: %w", err)
	}
	return oldValue.HeroImageURL, nil
}

// ClearHeroImageURL clears the value of the "hero_image_url" field.
func (m *ProgramMutation) ClearHeroImageURL() {
	m.hero_image_url = nil
	m.clearedFields[program.FieldHeroImageURL] = struct{}{}
}

// HeroImageURLCleared returns if the "hero_image_url" field was cleared in this mutation.
func (m *ProgramMutation) HeroImageURLCleared() bool {
	_, ok := m.clearedFields[program.FieldHeroImageURL]
	return ok
}

// ResetHeroImageURL resets all changes to the "hero_image_url" field.
func (m *ProgramMutation) ResetHeroImageURL() {
	m.hero_image_url = nil
	delete(m.clearedFields, program.FieldHeroImageURL)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *ProgramMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *ProgramMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *ProgramMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[program.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *ProgramMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[program.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *ProgramMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, program.FieldThumbnailURL)
}

// SetVideoThumbnailURL sets the "video_thumbnail_url" field.
func (m *ProgramMutation) SetVideoThumbnailURL(s string) {
	m.video_thumbnail_url = &s
}

// VideoThumbnailURL returns the value of the "video_thumbnail_url" field in the mutation.
func (m *ProgramMutation) VideoThumbnailURL() (r string, exists bool) {
	v := m.video_thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoThumbnailURL returns the old "video_thumbnail_url" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldVideoThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoThumbnailURL: %w", err)
	}
	return oldValue.VideoThumbnailURL, nil
}

// ClearVideoThumbnailURL clears the value of the "video_thumbnail_url" field.
func (m *ProgramMutation) ClearVideoThumbnailURL() {
	m.video_thumbnail_url = nil
	m.clearedFields[program.FieldVideoThumbnailURL] = struct{}{}
}

// VideoThumbnailURLCleared returns if the "video_thumbnail_url" field was cleared in this mutation.
func (m *ProgramMutation) VideoThumbnailURLCleared() bool {
	_, ok := m.clearedFields[program.FieldVideoThumbnailURL]
	return ok
}

// ResetVideoThumbnailURL resets all changes to the "video_thumbnail_url" field.
func (m *ProgramMutation) ResetVideoThumbnailURL() {
	m.video_thumbnail_url = nil
	delete(m.clearedFields, program.FieldVideoThumbnailURL)
}

// SetMediaGallery sets the "media_gallery" field.
func (m *ProgramMutation) SetMediaGallery(s []string) {
	m.media_gallery = &s
	m.appendmedia_gallery = nil
}

// MediaGallery returns the value of the "media_gallery" field in the mutation.
func (m *ProgramMutation) MediaGallery() (r []string, exists bool) {
	v := m.media_gallery
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaGallery returns the old "media_gallery" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldMediaGallery(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaGallery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaGallery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaGallery: %w", err)
	}
	return oldValue.MediaGallery, nil
}

// AppendMediaGallery adds s to the "media_gallery" field.
func (m *ProgramMutation) AppendMediaGallery(s []string) {
	m.appendmedia_gallery = append(m.appendmedia_gallery, s...)
}

// AppendedMediaGallery returns the list of values that were appended to the "media_gallery" field in this mutation.
func (m *ProgramMutation) AppendedMediaGallery() ([]string, bool) {
	if len(m.appendmedia_gallery) == 0 {
		return nil, false
	}
	return m.appendmedia_gallery, true
}

// ResetMediaGallery resets all changes to the "media_gallery" field.
func (m *ProgramMutation) ResetMediaGallery() {
	m.media_gallery = nil
	m.appendmedia_gallery = nil
}

// SetTags sets the "tags" field.
func (m *ProgramMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ProgramMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ProgramMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ProgramMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *ProgramMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetMetrics sets the "metrics" field.
func (m *ProgramMutation) SetMetrics(value []map[string]interface{}) {
	m.metrics = &value
	m.appendmetrics = nil
}

// Metrics returns the value of the "metrics" field in the mutation.
func (m *ProgramMutation) Metrics() (r []map[string]interface{}, exists bool) {
	v := m.metrics
	if v == nil {
		return
	}
	return *v, true
}

// OldMetrics returns the old "metrics" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldMetrics(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetrics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetrics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetrics: %w", err)
	}
	return oldValue.Metrics, nil
}

// AppendMetrics adds value to the "metrics" field.
func (m *ProgramMutation) AppendMetrics(value []map[string]interface{}) {
	m.appendmetrics = append(m.appendmetrics, value...)
}

// AppendedMetrics returns the list of values that were appended to the "metrics" field in this mutation.
func (m *ProgramMutation) AppendedMetrics() ([]map[string]interface{}, bool) {
	if len(m.appendmetrics) == 0 {
		return nil, false
	}
	return m.appendmetrics, true
}

// ResetMetrics resets all changes to the "metrics" field.
func (m *ProgramMutation) ResetMetrics() {
	m.metrics = nil
	m.appendmetrics = nil
}

// SetCurriculum sets the "curriculum" field.
func (m *ProgramMutation) SetCurriculum(value []map[string]interface{}) {
	m.curriculum = &value
	m.appendcurriculum = nil
}

// Curriculum returns the value of the "curriculum" field in the mutation.
func (m *ProgramMutation) Curriculum() (r []map[string]interface{}, exists bool) {
	v := m.curriculum
	if v == nil {
		return
	}
	return *v, true
}

// OldCurriculum returns the old "curriculum" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldCurriculum(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurriculum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurriculum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurriculum: %w", err)
	}
	return oldValue.Curriculum, nil
}

// AppendCurriculum adds value to the "curriculum" field.
func (m *ProgramMutation) AppendCurriculum(value []map[string]interface{}) {
	m.appendcurriculum = append(m.appendcurriculum, value...)
}

// AppendedCurriculum returns the list of values that were appended to the "curriculum" field in this mutation.
func (m *ProgramMutation) AppendedCurriculum() ([]map[string]interface{}, bool) {
	if len(m.appendcurriculum) == 0 {
		return nil, false
	}
	return m.appendcurriculum, true
}

// ResetCurriculum resets all changes to the "curriculum" field.
func (m *ProgramMutation) ResetCurriculum() {
	m.curriculum = nil
	m.appendcurriculum = nil
}

// SetEligibilityCriteria sets the "eligibility_criteria" field.
func (m *ProgramMutation) SetEligibilityCriteria(value []map[string]interface{}) {
	m.eligibility_criteria = &value
	m.appendeligibility_criteria = nil
}

// EligibilityCriteria returns the value of the "eligibility_criteria" field in the mutation.
func (m *ProgramMutation) EligibilityCriteria() (r []map[string]interface{}, exists bool) {
	v := m.eligibility_criteria
	if v == nil {
		return
	}
	return *v, true
}

// OldEligibilityCriteria returns the old "eligibility_criteria" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldEligibilityCriteria(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligibilityCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligibilityCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligibilityCriteria: %w", err)
	}
	return oldValue.EligibilityCriteria, nil
}

// AppendEligibilityCriteria adds value to the "eligibility_criteria" field.
func (m *ProgramMutation) AppendEligibilityCriteria(value []map[string]interface{}) {
	m.appendeligibility_criteria = append(m.appendeligibility_criteria, value...)
}

// AppendedEligibilityCriteria returns the list of values that were appended to the "eligibility_criteria" field in this mutation.
func (m *ProgramMutation) AppendedEligibilityCriteria() ([]map[string]interface{}, bool) {
	if len(m.appendeligibility_criteria) == 0 {
		return nil, false
	}
	return m.appendeligibility_criteria, true
}

// ResetEligibilityCriteria resets all changes to the "eligibility_criteria" field.
func (m *ProgramMutation) ResetEligibilityCriteria() {
	m.eligibility_criteria = nil
	m.appendeligibility_criteria = nil
}

// SetApplicationSteps sets the "application_steps" field.
func (m *ProgramMutation) SetApplicationSteps(value []map[string]interface{}) {
	m.application_steps = &value
	m.appendapplication_steps = nil
}

// ApplicationSteps returns the value of the "application_steps" field in the mutation.
func (m *ProgramMutation) ApplicationSteps() (r []map[string]interface{}, exists bool) {
	v := m.application_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationSteps returns the old "application_steps" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldApplicationSteps(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationSteps: %w", err)
	}
	return oldValue.ApplicationSteps, nil
}

// AppendApplicationSteps adds value to the "application_steps" field.
func (m *ProgramMutation) AppendApplicationSteps(value []map[string]interface{}) {
	m.appendapplication_steps = append(m.appendapplication_steps, value...)
}

// AppendedApplicationSteps returns the list of values that were appended to the "application_steps" field in this mutation.
func (m *ProgramMutation) AppendedApplicationSteps() ([]map[string]interface{}, bool) {
	if len(m.appendapplication_steps) == 0 {
		return nil, false
	}
	return m.appendapplication_steps, true
}

// ResetApplicationSteps resets all changes to the "application_steps" field.
func (m *ProgramMutation) ResetApplicationSteps() {
	m.application_steps = nil
	m.appendapplication_steps = nil
}

// SetDuration sets the "duration" field.
func (m *ProgramMutation) SetDuration(s string) {
	m.duration = &s
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ProgramMutation) Duration() (r string, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ClearDuration clears the value of the "duration" field.
func (m *ProgramMutation) ClearDuration() {
	m.duration = nil
	m.clearedFields[program.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *ProgramMutation) DurationCleared() bool {
	_, ok := m.clearedFields[program.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *ProgramMutation) ResetDuration() {
	m.duration = nil
	delete(m.clearedFields, program.FieldDuration)
}

// SetCapacity sets the "capacity" field.
func (m *ProgramMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *ProgramMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *ProgramMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *ProgramMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCapacity clears the value of the "capacity" field.
func (m *ProgramMutation) ClearCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	m.clearedFields[program.FieldCapacity] = struct{}{}
}

// CapacityCleared returns if the "capacity" field was cleared in this mutation.
func (m *ProgramMutation) CapacityCleared() bool {
	_, ok := m.clearedFields[program.FieldCapacity]
	return ok
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *ProgramMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	delete(m.clearedFields, program.FieldCapacity)
}

// SetApplicationDeadline sets the "application_deadline" field.
func (m *ProgramMutation) SetApplicationDeadline(t time.Time) {
	m.application_deadline = &t
}

// ApplicationDeadline returns the value of the "application_deadline" field in the mutation.
func (m *ProgramMutation) ApplicationDeadline() (r time.Time, exists bool) {
	v := m.application_deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationDeadline returns the old "application_deadline" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldApplicationDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationDeadline: %w", err)
	}
	return oldValue.ApplicationDeadline, nil
}

// ClearApplicationDeadline clears the value of the "application_deadline" field.
func (m *ProgramMutation) ClearApplicationDeadline() {
	m.application_deadline = nil
	m.clearedFields[program.FieldApplicationDeadline] = struct{}{}
}

// ApplicationDeadlineCleared returns if the "application_deadline" field was cleared in this mutation.
func (m *ProgramMutation) ApplicationDeadlineCleared() bool {
	_, ok := m.clearedFields[program.FieldApplicationDeadline]
	return ok
}

// ResetApplicationDeadline resets all changes to the "application_deadline" field.
func (m *ProgramMutation) ResetApplicationDeadline() {
	m.application_deadline = nil
	delete(m.clearedFields, program.FieldApplicationDeadline)
}

// SetRequirements sets the "requirements" field.
func (m *ProgramMutation) SetRequirements(s []string) {
	m.requirements = &s
	m.appendrequirements = nil
}

// Requirements returns the value of the "requirements" field in the mutation.
func (m *ProgramMutation) Requirements() (r []string, exists bool) {
	v := m.requirements
	if v == nil {
		return
	}
	return *v, true
}

// OldRequirements returns the old "requirements" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldRequirements(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequirements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequirements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequirements: %w", err)
	}
	return oldValue.Requirements, nil
}

// AppendRequirements adds s to the "requirements" field.
func (m *ProgramMutation) AppendRequirements(s []string) {
	m.appendrequirements = append(m.appendrequirements, s...)
}

// AppendedRequirements returns the list of values that were appended to the "requirements" field in this mutation.
func (m *ProgramMutation) AppendedRequirements() ([]string, bool) {
	if len(m.appendrequirements) == 0 {
		return nil, false
	}
	return m.appendrequirements, true
}

// ResetRequirements resets all changes to the "requirements" field.
func (m *ProgramMutation) ResetRequirements() {
	m.requirements = nil
	m.appendrequirements = nil
}

// SetMinAge sets the "min_age" field.
func (m *ProgramMutation) SetMinAge(i int) {
	m.min_age = &i
	m.addmin_age = nil
}

// MinAge returns the value of the "min_age" field in the mutation.
func (m *ProgramMutation) MinAge() (r int, exists bool) {
	v := m.min_age
	if v == nil {
		return
	}
	return *v, true
}

// OldMinAge returns the old "min_age" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldMinAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinAge: %w", err)
	}
	return oldValue.MinAge, nil
}

// AddMinAge adds i to the "min_age" field.
func (m *ProgramMutation) AddMinAge(i int) {
	if m.addmin_age != nil {
		*m.addmin_age += i
	} else {
		m.addmin_age = &i
	}
}

// AddedMinAge returns the value that was added to the "min_age" field in this mutation.
func (m *ProgramMutation) AddedMinAge() (r int, exists bool) {
	v := m.addmin_age
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinAge clears the value of the "min_age" field.
func (m *ProgramMutation) ClearMinAge() {
	m.min_age = nil
	m.addmin_age = nil
	m.clearedFields[program.FieldMinAge] = struct{}{}
}

// MinAgeCleared returns if the "min_age" field was cleared in this mutation.
func (m *ProgramMutation) MinAgeCleared() bool {
	_, ok := m.clearedFields[program.FieldMinAge]
	return ok
}

// ResetMinAge resets all changes to the "min_age" field.
func (m *ProgramMutation) ResetMinAge() {
	m.min_age = nil
	m.addmin_age = nil
	delete(m.clearedFields, program.FieldMinAge)
}

// SetMaxAge sets the "max_age" field.
func (m *ProgramMutation) SetMaxAge(i int) {
	m.max_age = &i
	m.addmax_age = nil
}

// MaxAge returns the value of the "max_age" field in the mutation.
func (m *ProgramMutation) MaxAge() (r int, exists bool) {
	v := m.max_age
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAge returns the old "max_age" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldMaxAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAge: %w", err)
	}
	return oldValue.MaxAge, nil
}

// AddMaxAge adds i to the "max_age" field.
func (m *ProgramMutation) AddMaxAge(i int) {
	if m.addmax_age != nil {
		*m.addmax_age += i
	} else {
		m.addmax_age = &i
	}
}

// AddedMaxAge returns the value that was added to the "max_age" field in this mutation.
func (m *ProgramMutation) AddedMaxAge() (r int, exists bool) {
	v := m.addmax_age
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxAge clears the value of the "max_age" field.
func (m *ProgramMutation) ClearMaxAge() {
	m.max_age = nil
	m.addmax_age = nil
	m.clearedFields[program.FieldMaxAge] = struct{}{}
}

// MaxAgeCleared returns if the "max_age" field was cleared in this mutation.
func (m *ProgramMutation) MaxAgeCleared() bool {
	_, ok := m.clearedFields[program.FieldMaxAge]
	return ok
}

// ResetMaxAge resets all changes to the "max_age" field.
func (m *ProgramMutation) ResetMaxAge() {
	m.max_age = nil
	m.addmax_age = nil
	delete(m.clearedFields, program.FieldMaxAge)
}

// SetRequiredDocs sets the "required_docs" field.
func (m *ProgramMutation) SetRequiredDocs(s []string) {
	m.required_docs = &s
	m.appendrequired_docs = nil
}

// RequiredDocs returns the value of the "required_docs" field in the mutation.
func (m *ProgramMutation) RequiredDocs() (r []string, exists bool) {
	v := m.required_docs
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredDocs returns the old "required_docs" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldRequiredDocs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredDocs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredDocs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredDocs: %w", err)
	}
	return oldValue.RequiredDocs, nil
}

// AppendRequiredDocs adds s to the "required_docs" field.
func (m *ProgramMutation) AppendRequiredDocs(s []string) {
	m.appendrequired_docs = append(m.appendrequired_docs, s...)
}

// AppendedRequiredDocs returns the list of values that were appended to the "required_docs" field in this mutation.
func (m *ProgramMutation) AppendedRequiredDocs() ([]string, bool) {
	if len(m.appendrequired_docs) == 0 {
		return nil, false
	}
	return m.appendrequired_docs, true
}

// ResetRequiredDocs resets all changes to the "required_docs" field.
func (m *ProgramMutation) ResetRequiredDocs() {
	m.required_docs = nil
	m.appendrequired_docs = nil
}

// SetCost sets the "cost" field.
func (m *ProgramMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *ProgramMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *ProgramMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *ProgramMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ClearCost clears the value of the "cost" field.
func (m *ProgramMutation) ClearCost() {
	m.cost = nil
	m.addcost = nil
	m.clearedFields[program.FieldCost] = struct{}{}
}

// CostCleared returns if the "cost" field was cleared in this mutation.
func (m *ProgramMutation) CostCleared() bool {
	_, ok := m.clearedFields[program.FieldCost]
	return ok
}

// ResetCost resets all changes to the "cost" field.
func (m *ProgramMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
	delete(m.clearedFields, program.FieldCost)
}

// SetCurrency sets the "currency" field.
func (m *ProgramMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *ProgramMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *ProgramMutation) ResetCurrency() {
	m.currency = nil
}

// SetRules sets the "rules" field.
func (m *ProgramMutation) SetRules(s []string) {
	m.rules = &s
	m.appendrules = nil
}

// Rules returns the value of the "rules" field in the mutation.
func (m *ProgramMutation) Rules() (r []string, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRules returns the old "rules" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldRules(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRules: %w", err)
	}
	return oldValue.Rules, nil
}

// AppendRules adds s to the "rules" field.
func (m *ProgramMutation) AppendRules(s []string) {
	m.appendrules = append(m.appendrules, s...)
}

// AppendedRules returns the list of values that were appended to the "rules" field in this mutation.
func (m *ProgramMutation) AppendedRules() ([]string, bool) {
	if len(m.appendrules) == 0 {
		return nil, false
	}
	return m.appendrules, true
}

// ResetRules resets all changes to the "rules" field.
func (m *ProgramMutation) ResetRules() {
	m.rules = nil
	m.appendrules = nil
}

// SetSteps sets the "steps" field.
func (m *ProgramMutation) SetSteps(value []map[string]interface{}) {
	m.steps = &value
	m.appendsteps = nil
}

// Steps returns the value of the "steps" field in the mutation.
func (m *ProgramMutation) Steps() (r []map[string]interface{}, exists bool) {
	v := m.steps
	if v == nil {
		return
	}
	return *v, true
}

// OldSteps returns the old "steps" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldSteps(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSteps: %w", err)
	}
	return oldValue.Steps, nil
}

// AppendSteps adds value to the "steps" field.
func (m *ProgramMutation) AppendSteps(value []map[string]interface{}) {
	m.appendsteps = append(m.appendsteps, value...)
}

// AppendedSteps returns the list of values that were appended to the "steps" field in this mutation.
func (m *ProgramMutation) AppendedSteps() ([]map[string]interface{}, bool) {
	if len(m.appendsteps) == 0 {
		return nil, false
	}
	return m.appendsteps, true
}

// ResetSteps resets all changes to the "steps" field.
func (m *ProgramMutation) ResetSteps() {
	m.steps = nil
	m.appendsteps = nil
}

// SetRequiredSkills sets the "required_skills" field.
func (m *ProgramMutation) SetRequiredSkills(s []string) {
	m.required_skills = &s
	m.appendrequired_skills = nil
}

// RequiredSkills returns the value of the "required_skills" field in the mutation.
func (m *ProgramMutation) RequiredSkills() (r []string, exists bool) {
	v := m.required_skills
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredSkills returns the old "required_skills" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldRequiredSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredSkills: %w", err)
	}
	return oldValue.RequiredSkills, nil
}

// AppendRequiredSkills adds s to the "required_skills" field.
func (m *ProgramMutation) AppendRequiredSkills(s []string) {
	m.appendrequired_skills = append(m.appendrequired_skills, s...)
}

// AppendedRequiredSkills returns the list of values that were appended to the "required_skills" field in this mutation.
func (m *ProgramMutation) AppendedRequiredSkills() ([]string, bool) {
	if len(m.appendrequired_skills) == 0 {
		return nil, false
	}
	return m.appendrequired_skills, true
}

// ResetRequiredSkills resets all changes to the "required_skills" field.
func (m *ProgramMutation) ResetRequiredSkills() {
	m.required_skills = nil
	m.appendrequired_skills = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProgramMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProgramMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProgramMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProgramMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProgramMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Program entity.
// If the Program object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProgramMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCategoryID sets the "category" edge to the ProgramCategory entity by id.
func (m *ProgramMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the ProgramCategory entity.
func (m *ProgramMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the ProgramCategory entity was cleared.
func (m *ProgramMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *ProgramMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *ProgramMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *ProgramMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddEnrolmentIDs adds the "enrolments" edge to the ProgramEnrolment entity by ids.
func (m *ProgramMutation) AddEnrolmentIDs(ids ...int) {
	if m.enrolments == nil {
		m.enrolments = make(map[int]struct{})
	}
	for i := range ids {
		m.enrolments[ids[i]] = struct{}{}
	}
}

// ClearEnrolments clears the "enrolments" edge to the ProgramEnrolment entity.
func (m *ProgramMutation) ClearEnrolments() {
	m.clearedenrolments = true
}

// EnrolmentsCleared reports if the "enrolments" edge to the ProgramEnrolment entity was cleared.
func (m *ProgramMutation) EnrolmentsCleared() bool {
	return m.clearedenrolments
}

// RemoveEnrolmentIDs removes the "enrolments" edge to the ProgramEnrolment entity by IDs.
func (m *ProgramMutation) RemoveEnrolmentIDs(ids ...int) {
	if m.removedenrolments == nil {
		m.removedenrolments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.enrolments, ids[i])
		m.removedenrolments[ids[i]] = struct{}{}
	}
}

// RemovedEnrolments returns the removed IDs of the "enrolments" edge to the ProgramEnrolment entity.
func (m *ProgramMutation) RemovedEnrolmentsIDs() (ids []int) {
	for id := range m.removedenrolments {
		ids = append(ids, id)
	}
	return
}

// EnrolmentsIDs returns the "enrolments" edge IDs in the mutation.
func (m *ProgramMutation) EnrolmentsIDs() (ids []int) {
	for id := range m.enrolments {
		ids = append(ids, id)
	}
	return
}

// ResetEnrolments resets all changes to the "enrolments" edge.
func (m *ProgramMutation) ResetEnrolments() {
	m.enrolments = nil
	m.clearedenrolments = false
	m.removedenrolments = nil
}

// AddParticipantIDs adds the "participants" edge to the ProgramParticipant entity by ids.
func (m *ProgramMutation) AddParticipantIDs(ids ...int) {
	if m.participants == nil {
		m.participants = make(map[int]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the ProgramParticipant entity.
func (m *ProgramMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the ProgramParticipant entity was cleared.
func (m *ProgramMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the ProgramParticipant entity by IDs.
func (m *ProgramMutation) RemoveParticipantIDs(ids ...int) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the ProgramParticipant entity.
func (m *ProgramMutation) RemovedParticipantsIDs() (ids []int) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *ProgramMutation) ParticipantsIDs() (ids []int) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *ProgramMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *ProgramMutation) SetCreatedByID(id int) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *ProgramMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *ProgramMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *ProgramMutation) CreatedByID() (id int, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *ProgramMutation) CreatedByIDs() (ids []int) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *ProgramMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetUpdatedByID sets the "updated_by" edge to the User entity by id.
func (m *ProgramMutation) SetUpdatedByID(id int) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *ProgramMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *ProgramMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *ProgramMutation) UpdatedByID() (id int, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *ProgramMutation) UpdatedByIDs() (ids []int) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *ProgramMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// AddProgramCardItemIDs adds the "program_card_items" edge to the ProgramCardItem entity by ids.
func (m *ProgramMutation) AddProgramCardItemIDs(ids ...int) {
	if m.program_card_items == nil {
		m.program_card_items = make(map[int]struct{})
	}
	for i := range ids {
		m.program_card_items[ids[i]] = struct{}{}
	}
}

// ClearProgramCardItems clears the "program_card_items" edge to the ProgramCardItem entity.
func (m *ProgramMutation) ClearProgramCardItems() {
	m.clearedprogram_card_items = true
}

// ProgramCardItemsCleared reports if the "program_card_items" edge to the ProgramCardItem entity was cleared.
func (m *ProgramMutation) ProgramCardItemsCleared() bool {
	return m.clearedprogram_card_items
}

// RemoveProgramCardItemIDs removes the "program_card_items" edge to the ProgramCardItem entity by IDs.
func (m *ProgramMutation) RemoveProgramCardItemIDs(ids ...int) {
	if m.removedprogram_card_items == nil {
		m.removedprogram_card_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.program_card_items, ids[i])
		m.removedprogram_card_items[ids[i]] = struct{}{}
	}
}

// RemovedProgramCardItems returns the removed IDs of the "program_card_items" edge to the ProgramCardItem entity.
func (m *ProgramMutation) RemovedProgramCardItemsIDs() (ids []int) {
	for id := range m.removedprogram_card_items {
		ids = append(ids, id)
	}
	return
}

// ProgramCardItemsIDs returns the "program_card_items" edge IDs in the mutation.
func (m *ProgramMutation) ProgramCardItemsIDs() (ids []int) {
	for id := range m.program_card_items {
		ids = append(ids, id)
	}
	return
}

// ResetProgramCardItems resets all changes to the "program_card_items" edge.
func (m *ProgramMutation) ResetProgramCardItems() {
	m.program_card_items = nil
	m.clearedprogram_card_items = false
	m.removedprogram_card_items = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *ProgramMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *ProgramMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *ProgramMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *ProgramMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *ProgramMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *ProgramMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *ProgramMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// AddSuccessStoryIDs adds the "success_stories" edge to the SuccessStory entity by ids.
func (m *ProgramMutation) AddSuccessStoryIDs(ids ...int) {
	if m.success_stories == nil {
		m.success_stories = make(map[int]struct{})
	}
	for i := range ids {
		m.success_stories[ids[i]] = struct{}{}
	}
}

// ClearSuccessStories clears the "success_stories" edge to the SuccessStory entity.
func (m *ProgramMutation) ClearSuccessStories() {
	m.clearedsuccess_stories = true
}

// SuccessStoriesCleared reports if the "success_stories" edge to the SuccessStory entity was cleared.
func (m *ProgramMutation) SuccessStoriesCleared() bool {
	return m.clearedsuccess_stories
}

// RemoveSuccessStoryIDs removes the "success_stories" edge to the SuccessStory entity by IDs.
func (m *ProgramMutation) RemoveSuccessStoryIDs(ids ...int) {
	if m.removedsuccess_stories == nil {
		m.removedsuccess_stories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.success_stories, ids[i])
		m.removedsuccess_stories[ids[i]] = struct{}{}
	}
}

// RemovedSuccessStories returns the removed IDs of the "success_stories" edge to the SuccessStory entity.
func (m *ProgramMutation) RemovedSuccessStoriesIDs() (ids []int) {
	for id := range m.removedsuccess_stories {
		ids = append(ids, id)
	}
	return
}

// SuccessStoriesIDs returns the "success_stories" edge IDs in the mutation.
func (m *ProgramMutation) SuccessStoriesIDs() (ids []int) {
	for id := range m.success_stories {
		ids = append(ids, id)
	}
	return
}

// ResetSuccessStories resets all changes to the "success_stories" edge.
func (m *ProgramMutation) ResetSuccessStories() {
	m.success_stories = nil
	m.clearedsuccess_stories = false
	m.removedsuccess_stories = nil
}

// AddVolunteerOpportunityIDs adds the "volunteer_opportunities" edge to the VolunteerOpportunity entity by ids.
func (m *ProgramMutation) AddVolunteerOpportunityIDs(ids ...int) {
	if m.volunteer_opportunities == nil {
		m.volunteer_opportunities = make(map[int]struct{})
	}
	for i := range ids {
		m.volunteer_opportunities[ids[i]] = struct{}{}
	}
}

// ClearVolunteerOpportunities clears the "volunteer_opportunities" edge to the VolunteerOpportunity entity.
func (m *ProgramMutation) ClearVolunteerOpportunities() {
	m.clearedvolunteer_opportunities = true
}

// VolunteerOpportunitiesCleared reports if the "volunteer_opportunities" edge to the VolunteerOpportunity entity was cleared.
func (m *ProgramMutation) VolunteerOpportunitiesCleared() bool {
	return m.clearedvolunteer_opportunities
}

// RemoveVolunteerOpportunityIDs removes the "volunteer_opportunities" edge to the VolunteerOpportunity entity by IDs.
func (m *ProgramMutation) RemoveVolunteerOpportunityIDs(ids ...int) {
	if m.removedvolunteer_opportunities == nil {
		m.removedvolunteer_opportunities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.volunteer_opportunities, ids[i])
		m.removedvolunteer_opportunities[ids[i]] = struct{}{}
	}
}

// RemovedVolunteerOpportunities returns the removed IDs of the "volunteer_opportunities" edge to the VolunteerOpportunity entity.
func (m *ProgramMutation) RemovedVolunteerOpportunitiesIDs() (ids []int) {
	for id := range m.removedvolunteer_opportunities {
		ids = append(ids, id)
	}
	return
}

// VolunteerOpportunitiesIDs returns the "volunteer_opportunities" edge IDs in the mutation.
func (m *ProgramMutation) VolunteerOpportunitiesIDs() (ids []int) {
	for id := range m.volunteer_opportunities {
		ids = append(ids, id)
	}
	return
}

// ResetVolunteerOpportunities resets all changes to the "volunteer_opportunities" edge.
func (m *ProgramMutation) ResetVolunteerOpportunities() {
	m.volunteer_opportunities = nil
	m.clearedvolunteer_opportunities = false
	m.removedvolunteer_opportunities = nil
}

// AddFundraisingCampaignIDs adds the "fundraising_campaigns" edge to the FundraisingCampaign entity by ids.
func (m *ProgramMutation) AddFundraisingCampaignIDs(ids ...int) {
	if m.fundraising_campaigns == nil {
		m.fundraising_campaigns = make(map[int]struct{})
	}
	for i := range ids {
		m.fundraising_campaigns[ids[i]] = struct{}{}
	}
}

// ClearFundraisingCampaigns clears the "fundraising_campaigns" edge to the FundraisingCampaign entity.
func (m *ProgramMutation) ClearFundraisingCampaigns() {
	m.clearedfundraising_campaigns = true
}

// FundraisingCampaignsCleared reports if the "fundraising_campaigns" edge to the FundraisingCampaign entity was cleared.
func (m *ProgramMutation) FundraisingCampaignsCleared() bool {
	return m.clearedfundraising_campaigns
}

// RemoveFundraisingCampaignIDs removes the "fundraising_campaigns" edge to the FundraisingCampaign entity by IDs.
func (m *ProgramMutation) RemoveFundraisingCampaignIDs(ids ...int) {
	if m.removedfundraising_campaigns == nil {
		m.removedfundraising_campaigns = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fundraising_campaigns, ids[i])
		m.removedfundraising_campaigns[ids[i]] = struct{}{}
	}
}

// RemovedFundraisingCampaigns returns the removed IDs of the "fundraising_campaigns" edge to the FundraisingCampaign entity.
func (m *ProgramMutation) RemovedFundraisingCampaignsIDs() (ids []int) {
	for id := range m.removedfundraising_campaigns {
		ids = append(ids, id)
	}
	return
}

// FundraisingCampaignsIDs returns the "fundraising_campaigns" edge IDs in the mutation.
func (m *ProgramMutation) FundraisingCampaignsIDs() (ids []int) {
	for id := range m.fundraising_campaigns {
		ids = append(ids, id)
	}
	return
}

// ResetFundraisingCampaigns resets all changes to the "fundraising_campaigns" edge.
func (m *ProgramMutation) ResetFundraisingCampaigns() {
	m.fundraising_campaigns = nil
	m.clearedfundraising_campaigns = false
	m.removedfundraising_campaigns = nil
}

// AddDonationIDs adds the "donations" edge to the Donation entity by ids.
func (m *ProgramMutation) AddDonationIDs(ids ...int) {
	if m.donations == nil {
		m.donations = make(map[int]struct{})
	}
	for i := range ids {
		m.donations[ids[i]] = struct{}{}
	}
}

// ClearDonations clears the "donations" edge to the Donation entity.
func (m *ProgramMutation) ClearDonations() {
	m.cleareddonations = true
}

// DonationsCleared reports if the "donations" edge to the Donation entity was cleared.
func (m *ProgramMutation) DonationsCleared() bool {
	return m.cleareddonations
}

// RemoveDonationIDs removes the "donations" edge to the Donation entity by IDs.
func (m *ProgramMutation) RemoveDonationIDs(ids ...int) {
	if m.removeddonations == nil {
		m.removeddonations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.donations, ids[i])
		m.removeddonations[ids[i]] = struct{}{}
	}
}

// RemovedDonations returns the removed IDs of the "donations" edge to the Donation entity.
func (m *ProgramMutation) RemovedDonationsIDs() (ids []int) {
	for id := range m.removeddonations {
		ids = append(ids, id)
	}
	return
}

// DonationsIDs returns the "donations" edge IDs in the mutation.
func (m *ProgramMutation) DonationsIDs() (ids []int) {
	for id := range m.donations {
		ids = append(ids, id)
	}
	return
}

// ResetDonations resets all changes to the "donations" edge.
func (m *ProgramMutation) ResetDonations() {
	m.donations = nil
	m.cleareddonations = false
	m.removeddonations = nil
}

// AddGrantIDs adds the "grants" edge to the Grant entity by ids.
func (m *ProgramMutation) AddGrantIDs(ids ...int) {
	if m.grants == nil {
		m.grants = make(map[int]struct{})
	}
	for i := range ids {
		m.grants[ids[i]] = struct{}{}
	}
}

// ClearGrants clears the "grants" edge to the Grant entity.
func (m *ProgramMutation) ClearGrants() {
	m.clearedgrants = true
}

// GrantsCleared reports if the "grants" edge to the Grant entity was cleared.
func (m *ProgramMutation) GrantsCleared() bool {
	return m.clearedgrants
}

// RemoveGrantIDs removes the "grants" edge to the Grant entity by IDs.
func (m *ProgramMutation) RemoveGrantIDs(ids ...int) {
	if m.removedgrants == nil {
		m.removedgrants = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.grants, ids[i])
		m.removedgrants[ids[i]] = struct{}{}
	}
}

// RemovedGrants returns the removed IDs of the "grants" edge to the Grant entity.
func (m *ProgramMutation) RemovedGrantsIDs() (ids []int) {
	for id := range m.removedgrants {
		ids = append(ids, id)
	}
	return
}

// GrantsIDs returns the "grants" edge IDs in the mutation.
func (m *ProgramMutation) GrantsIDs() (ids []int) {
	for id := range m.grants {
		ids = append(ids, id)
	}
	return
}

// ResetGrants resets all changes to the "grants" edge.
func (m *ProgramMutation) ResetGrants() {
	m.grants = nil
	m.clearedgrants = false
	m.removedgrants = nil
}

// AddSiteVisitIDs adds the "site_visits" edge to the SiteVisit entity by ids.
func (m *ProgramMutation) AddSiteVisitIDs(ids ...int) {
	if m.site_visits == nil {
		m.site_visits = make(map[int]struct{})
	}
	for i := range ids {
		m.site_visits[ids[i]] = struct{}{}
	}
}

// ClearSiteVisits clears the "site_visits" edge to the SiteVisit entity.
func (m *ProgramMutation) ClearSiteVisits() {
	m.clearedsite_visits = true
}

// SiteVisitsCleared reports if the "site_visits" edge to the SiteVisit entity was cleared.
func (m *ProgramMutation) SiteVisitsCleared() bool {
	return m.clearedsite_visits
}

// RemoveSiteVisitIDs removes the "site_visits" edge to the SiteVisit entity by IDs.
func (m *ProgramMutation) RemoveSiteVisitIDs(ids ...int) {
	if m.removedsite_visits == nil {
		m.removedsite_visits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.site_visits, ids[i])
		m.removedsite_visits[ids[i]] = struct{}{}
	}
}

// RemovedSiteVisits returns the removed IDs of the "site_visits" edge to the SiteVisit entity.
func (m *ProgramMutation) RemovedSiteVisitsIDs() (ids []int) {
	for id := range m.removedsite_visits {
		ids = append(ids, id)
	}
	return
}

// SiteVisitsIDs returns the "site_visits" edge IDs in the mutation.
func (m *ProgramMutation) SiteVisitsIDs() (ids []int) {
	for id := range m.site_visits {
		ids = append(ids, id)
	}
	return
}

// ResetSiteVisits resets all changes to the "site_visits" edge.
func (m *ProgramMutation) ResetSiteVisits() {
	m.site_visits = nil
	m.clearedsite_visits = false
	m.removedsite_visits = nil
}

// AddImpactMetricIDs adds the "impact_metrics" edge to the ImpactMetric entity by ids.
func (m *ProgramMutation) AddImpactMetricIDs(ids ...int) {
	if m.impact_metrics == nil {
		m.impact_metrics = make(map[int]struct{})
	}
	for i := range ids {
		m.impact_metrics[ids[i]] = struct{}{}
	}
}

// ClearImpactMetrics clears the "impact_metrics" edge to the ImpactMetric entity.
func (m *ProgramMutation) ClearImpactMetrics() {
	m.clearedimpact_metrics = true
}

// ImpactMetricsCleared reports if the "impact_metrics" edge to the ImpactMetric entity was cleared.
func (m *ProgramMutation) ImpactMetricsCleared() bool {
	return m.clearedimpact_metrics
}

// RemoveImpactMetricIDs removes the "impact_metrics" edge to the ImpactMetric entity by IDs.
func (m *ProgramMutation) RemoveImpactMetricIDs(ids ...int) {
	if m.removedimpact_metrics == nil {
		m.removedimpact_metrics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.impact_metrics, ids[i])
		m.removedimpact_metrics[ids[i]] = struct{}{}
	}
}

// RemovedImpactMetrics returns the removed IDs of the "impact_metrics" edge to the ImpactMetric entity.
func (m *ProgramMutation) RemovedImpactMetricsIDs() (ids []int) {
	for id := range m.removedimpact_metrics {
		ids = append(ids, id)
	}
	return
}

// ImpactMetricsIDs returns the "impact_metrics" edge IDs in the mutation.
func (m *ProgramMutation) ImpactMetricsIDs() (ids []int) {
	for id := range m.impact_metrics {
		ids = append(ids, id)
	}
	return
}

// ResetImpactMetrics resets all changes to the "impact_metrics" edge.
func (m *ProgramMutation) ResetImpactMetrics() {
	m.impact_metrics = nil
	m.clearedimpact_metrics = false
	m.removedimpact_metrics = nil
}

// Where appends a list predicates to the ProgramMutation builder.
func (m *ProgramMutation) Where(ps ...predicate.Program) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProgramMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProgramMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Program, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProgramMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProgramMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Program).
func (m *ProgramMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProgramMutation) Fields() []string {
	fields := make([]string, 0, 30)
	if m.slug != nil {
		fields = append(fields, program.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, program.FieldName)
	}
	if m.description != nil {
		fields = append(fields, program.FieldDescription)
	}
	if m.tagline != nil {
		fields = append(fields, program.FieldTagline)
	}
	if m.status != nil {
		fields = append(fields, program.FieldStatus)
	}
	if m.start_date != nil {
		fields = append(fields, program.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, program.FieldEndDate)
	}
	if m.hero_image_url != nil {
		fields = append(fields, program.FieldHeroImageURL)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, program.FieldThumbnailURL)
	}
	if m.video_thumbnail_url != nil {
		fields = append(fields, program.FieldVideoThumbnailURL)
	}
	if m.media_gallery != nil {
		fields = append(fields, program.FieldMediaGallery)
	}
	if m.tags != nil {
		fields = append(fields, program.FieldTags)
	}
	if m.metrics != nil {
		fields = append(fields, program.FieldMetrics)
	}
	if m.curriculum != nil {
		fields = append(fields, program.FieldCurriculum)
	}
	if m.eligibility_criteria != nil {
		fields = append(fields, program.FieldEligibilityCriteria)
	}
	if m.application_steps != nil {
		fields = append(fields, program.FieldApplicationSteps)
	}
	if m.duration != nil {
		fields = append(fields, program.FieldDuration)
	}
	if m.capacity != nil {
		fields = append(fields, program.FieldCapacity)
	}
	if m.application_deadline != nil {
		fields = append(fields, program.FieldApplicationDeadline)
	}
	if m.requirements != nil {
		fields = append(fields, program.FieldRequirements)
	}
	if m.min_age != nil {
		fields = append(fields, program.FieldMinAge)
	}
	if m.max_age != nil {
		fields = append(fields, program.FieldMaxAge)
	}
	if m.required_docs != nil {
		fields = append(fields, program.FieldRequiredDocs)
	}
	if m.cost != nil {
		fields = append(fields, program.FieldCost)
	}
	if m.currency != nil {
		fields = append(fields, program.FieldCurrency)
	}
	if m.rules != nil {
		fields = append(fields, program.FieldRules)
	}
	if m.steps != nil {
		fields = append(fields, program.FieldSteps)
	}
	if m.required_skills != nil {
		fields = append(fields, program.FieldRequiredSkills)
	}
	if m.created_at != nil {
		fields = append(fields, program.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, program.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProgramMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case program.FieldSlug:
		return m.Slug()
	case program.FieldName:
		return m.Name()
	case program.FieldDescription:
		return m.Description()
	case program.FieldTagline:
		return m.Tagline()
	case program.FieldStatus:
		return m.Status()
	case program.FieldStartDate:
		return m.StartDate()
	case program.FieldEndDate:
		return m.EndDate()
	case program.FieldHeroImageURL:
		return m.HeroImageURL()
	case program.FieldThumbnailURL:
		return m.ThumbnailURL()
	case program.FieldVideoThumbnailURL:
		return m.VideoThumbnailURL()
	case program.FieldMediaGallery:
		return m.MediaGallery()
	case program.FieldTags:
		return m.Tags()
	case program.FieldMetrics:
		return m.Metrics()
	case program.FieldCurriculum:
		return m.Curriculum()
	case program.FieldEligibilityCriteria:
		return m.EligibilityCriteria()
	case program.FieldApplicationSteps:
		return m.ApplicationSteps()
	case program.FieldDuration:
		return m.Duration()
	case program.FieldCapacity:
		return m.Capacity()
	case program.FieldApplicationDeadline:
		return m.ApplicationDeadline()
	case program.FieldRequirements:
		return m.Requirements()
	case program.FieldMinAge:
		return m.MinAge()
	case program.FieldMaxAge:
		return m.MaxAge()
	case program.FieldRequiredDocs:
		return m.RequiredDocs()
	case program.FieldCost:
		return m.Cost()
	case program.FieldCurrency:
		return m.Currency()
	case program.FieldRules:
		return m.Rules()
	case program.FieldSteps:
		return m.Steps()
	case program.FieldRequiredSkills:
		return m.RequiredSkills()
	case program.FieldCreatedAt:
		return m.CreatedAt()
	case program.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProgramMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case program.FieldSlug:
		return m.OldSlug(ctx)
	case program.FieldName:
		return m.OldName(ctx)
	case program.FieldDescription:
		return m.OldDescription(ctx)
	case program.FieldTagline:
		return m.OldTagline(ctx)
	case program.FieldStatus:
		return m.OldStatus(ctx)
	case program.FieldStartDate:
		return m.OldStartDate(ctx)
	case program.FieldEndDate:
		return m.OldEndDate(ctx)
	case program.FieldHeroImageURL:
		return m.OldHeroImageURL(ctx)
	case program.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case program.FieldVideoThumbnailURL:
		return m.OldVideoThumbnailURL(ctx)
	case program.FieldMediaGallery:
		return m.OldMediaGallery(ctx)
	case program.FieldTags:
		return m.OldTags(ctx)
	case program.FieldMetrics:
		return m.OldMetrics(ctx)
	case program.FieldCurriculum:
		return m.OldCurriculum(ctx)
	case program.FieldEligibilityCriteria:
		return m.OldEligibilityCriteria(ctx)
	case program.FieldApplicationSteps:
		return m.OldApplicationSteps(ctx)
	case program.FieldDuration:
		return m.OldDuration(ctx)
	case program.FieldCapacity:
		return m.OldCapacity(ctx)
	case program.FieldApplicationDeadline:
		return m.OldApplicationDeadline(ctx)
	case program.FieldRequirements:
		return m.OldRequirements(ctx)
	case program.FieldMinAge:
		return m.OldMinAge(ctx)
	case program.FieldMaxAge:
		return m.OldMaxAge(ctx)
	case program.FieldRequiredDocs:
		return m.OldRequiredDocs(ctx)
	case program.FieldCost:
		return m.OldCost(ctx)
	case program.FieldCurrency:
		return m.OldCurrency(ctx)
	case program.FieldRules:
		return m.OldRules(ctx)
	case program.FieldSteps:
		return m.OldSteps(ctx)
	case program.FieldRequiredSkills:
		return m.OldRequiredSkills(ctx)
	case program.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case program.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Program field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramMutation) SetField(name string, value ent.Value) error {
	switch name {
	case program.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case program.FieldName:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case program.FieldDescription:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case program.FieldTagline:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagline(v)
		return nil
	case program.FieldStatus:
		v, ok := value.(program.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case program.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case program.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case program.FieldHeroImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeroImageURL(v)
		return nil
	case program.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case program.FieldVideoThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoThumbnailURL(v)
		return nil
	case program.FieldMediaGallery:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaGallery(v)
		return nil
	case program.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case program.FieldMetrics:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetrics(v)
		return nil
	case program.FieldCurriculum:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurriculum(v)
		return nil
	case program.FieldEligibilityCriteria:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligibilityCriteria(v)
		return nil
	case program.FieldApplicationSteps:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationSteps(v)
		return nil
	case program.FieldDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case program.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case program.FieldApplicationDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationDeadline(v)
		return nil
	case program.FieldRequirements:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequirements(v)
		return nil
	case program.FieldMinAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinAge(v)
		return nil
	case program.FieldMaxAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAge(v)
		return nil
	case program.FieldRequiredDocs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredDocs(v)
		return nil
	case program.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case program.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case program.FieldRules:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRules(v)
		return nil
	case program.FieldSteps:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSteps(v)
		return nil
	case program.FieldRequiredSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredSkills(v)
		return nil
	case program.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case program.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Program field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProgramMutation) AddedFields() []string {
	var fields []string
	if m.addcapacity != nil {
		fields = append(fields, program.FieldCapacity)
	}
	if m.addmin_age != nil {
		fields = append(fields, program.FieldMinAge)
	}
	if m.addmax_age != nil {
		fields = append(fields, program.FieldMaxAge)
	}
	if m.addcost != nil {
		fields = append(fields, program.FieldCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProgramMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case program.FieldCapacity:
		return m.AddedCapacity()
	case program.FieldMinAge:
		return m.AddedMinAge()
	case program.FieldMaxAge:
		return m.AddedMaxAge()
	case program.FieldCost:
		return m.AddedCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramMutation) AddField(name string, value ent.Value) error {
	switch name {
	case program.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	case program.FieldMinAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinAge(v)
		return nil
	case program.FieldMaxAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxAge(v)
		return nil
	case program.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	}
	return fmt.Errorf("unknown Program numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProgramMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(program.FieldStartDate) {
		fields = append(fields, program.FieldStartDate)
	}
	if m.FieldCleared(program.FieldEndDate) {
		fields = append(fields, program.FieldEndDate)
	}
	if m.FieldCleared(program.FieldHeroImageURL) {
		fields = append(fields, program.FieldHeroImageURL)
	}
	if m.FieldCleared(program.FieldThumbnailURL) {
		fields = append(fields, program.FieldThumbnailURL)
	}
	if m.FieldCleared(program.FieldVideoThumbnailURL) {
		fields = append(fields, program.FieldVideoThumbnailURL)
	}
	if m.FieldCleared(program.FieldDuration) {
		fields = append(fields, program.FieldDuration)
	}
	if m.FieldCleared(program.FieldCapacity) {
		fields = append(fields, program.FieldCapacity)
	}
	if m.FieldCleared(program.FieldApplicationDeadline) {
		fields = append(fields, program.FieldApplicationDeadline)
	}
	if m.FieldCleared(program.FieldMinAge) {
		fields = append(fields, program.FieldMinAge)
	}
	if m.FieldCleared(program.FieldMaxAge) {
		fields = append(fields, program.FieldMaxAge)
	}
	if m.FieldCleared(program.FieldCost) {
		fields = append(fields, program.FieldCost)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProgramMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProgramMutation) ClearField(name string) error {
	switch name {
	case program.FieldStartDate:
		m.ClearStartDate()
		return nil
	case program.FieldEndDate:
		m.ClearEndDate()
		return nil
	case program.FieldHeroImageURL:
		m.ClearHeroImageURL()
		return nil
	case program.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case program.FieldVideoThumbnailURL:
		m.ClearVideoThumbnailURL()
		return nil
	case program.FieldDuration:
		m.ClearDuration()
		return nil
	case program.FieldCapacity:
		m.ClearCapacity()
		return nil
	case program.FieldApplicationDeadline:
		m.ClearApplicationDeadline()
		return nil
	case program.FieldMinAge:
		m.ClearMinAge()
		return nil
	case program.FieldMaxAge:
		m.ClearMaxAge()
		return nil
	case program.FieldCost:
		m.ClearCost()
		return nil
	}
	return fmt.Errorf("unknown Program nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProgramMutation) ResetField(name string) error {
	switch name {
	case program.FieldSlug:
		m.ResetSlug()
		return nil
	case program.FieldName:
		m.ResetName()
		return nil
	case program.FieldDescription:
		m.ResetDescription()
		return nil
	case program.FieldTagline:
		m.ResetTagline()
		return nil
	case program.FieldStatus:
		m.ResetStatus()
		return nil
	case program.FieldStartDate:
		m.ResetStartDate()
		return nil
	case program.FieldEndDate:
		m.ResetEndDate()
		return nil
	case program.FieldHeroImageURL:
		m.ResetHeroImageURL()
		return nil
	case program.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case program.FieldVideoThumbnailURL:
		m.ResetVideoThumbnailURL()
		return nil
	case program.FieldMediaGallery:
		m.ResetMediaGallery()
		return nil
	case program.FieldTags:
		m.ResetTags()
		return nil
	case program.FieldMetrics:
		m.ResetMetrics()
		return nil
	case program.FieldCurriculum:
		m.ResetCurriculum()
		return nil
	case program.FieldEligibilityCriteria:
		m.ResetEligibilityCriteria()
		return nil
	case program.FieldApplicationSteps:
		m.ResetApplicationSteps()
		return nil
	case program.FieldDuration:
		m.ResetDuration()
		return nil
	case program.FieldCapacity:
		m.ResetCapacity()
		return nil
	case program.FieldApplicationDeadline:
		m.ResetApplicationDeadline()
		return nil
	case program.FieldRequirements:
		m.ResetRequirements()
		return nil
	case program.FieldMinAge:
		m.ResetMinAge()
		return nil
	case program.FieldMaxAge:
		m.ResetMaxAge()
		return nil
	case program.FieldRequiredDocs:
		m.ResetRequiredDocs()
		return nil
	case program.FieldCost:
		m.ResetCost()
		return nil
	case program.FieldCurrency:
		m.ResetCurrency()
		return nil
	case program.FieldRules:
		m.ResetRules()
		return nil
	case program.FieldSteps:
		m.ResetSteps()
		return nil
	case program.FieldRequiredSkills:
		m.ResetRequiredSkills()
		return nil
	case program.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case program.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Program field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProgramMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.category != nil {
		edges = append(edges, program.EdgeCategory)
	}
	if m.enrolments != nil {
		edges = append(edges, program.EdgeEnrolments)
	}
	if m.participants != nil {
		edges = append(edges, program.EdgeParticipants)
	}
	if m.created_by != nil {
		edges = append(edges, program.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, program.EdgeUpdatedBy)
	}
	if m.program_card_items != nil {
		edges = append(edges, program.EdgeProgramCardItems)
	}
	if m.events != nil {
		edges = append(edges, program.EdgeEvents)
	}
	if m.success_stories != nil {
		edges = append(edges, program.EdgeSuccessStories)
	}
	if m.volunteer_opportunities != nil {
		edges = append(edges, program.EdgeVolunteerOpportunities)
	}
	if m.fundraising_campaigns != nil {
		edges = append(edges, program.EdgeFundraisingCampaigns)
	}
	if m.donations != nil {
		edges = append(edges, program.EdgeDonations)
	}
	if m.grants != nil {
		edges = append(edges, program.EdgeGrants)
	}
	if m.site_visits != nil {
		edges = append(edges, program.EdgeSiteVisits)
	}
	if m.impact_metrics != nil {
		edges = append(edges, program.EdgeImpactMetrics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProgramMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case program.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case program.EdgeEnrolments:
		ids := make([]ent.Value, 0, len(m.enrolments))
		for id := range m.enrolments {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case program.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	case program.EdgeProgramCardItems:
		ids := make([]ent.Value, 0, len(m.program_card_items))
		for id := range m.program_card_items {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeSuccessStories:
		ids := make([]ent.Value, 0, len(m.success_stories))
		for id := range m.success_stories {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeVolunteerOpportunities:
		ids := make([]ent.Value, 0, len(m.volunteer_opportunities))
		for id := range m.volunteer_opportunities {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeFundraisingCampaigns:
		ids := make([]ent.Value, 0, len(m.fundraising_campaigns))
		for id := range m.fundraising_campaigns {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeDonations:
		ids := make([]ent.Value, 0, len(m.donations))
		for id := range m.donations {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeGrants:
		ids := make([]ent.Value, 0, len(m.grants))
		for id := range m.grants {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeSiteVisits:
		ids := make([]ent.Value, 0, len(m.site_visits))
		for id := range m.site_visits {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeImpactMetrics:
		ids := make([]ent.Value, 0, len(m.impact_metrics))
		for id := range m.impact_metrics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProgramMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removedenrolments != nil {
		edges = append(edges, program.EdgeEnrolments)
	}
	if m.removedparticipants != nil {
		edges = append(edges, program.EdgeParticipants)
	}
	if m.removedprogram_card_items != nil {
		edges = append(edges, program.EdgeProgramCardItems)
	}
	if m.removedevents != nil {
		edges = append(edges, program.EdgeEvents)
	}
	if m.removedsuccess_stories != nil {
		edges = append(edges, program.EdgeSuccessStories)
	}
	if m.removedvolunteer_opportunities != nil {
		edges = append(edges, program.EdgeVolunteerOpportunities)
	}
	if m.removedfundraising_campaigns != nil {
		edges = append(edges, program.EdgeFundraisingCampaigns)
	}
	if m.removeddonations != nil {
		edges = append(edges, program.EdgeDonations)
	}
	if m.removedgrants != nil {
		edges = append(edges, program.EdgeGrants)
	}
	if m.removedsite_visits != nil {
		edges = append(edges, program.EdgeSiteVisits)
	}
	if m.removedimpact_metrics != nil {
		edges = append(edges, program.EdgeImpactMetrics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProgramMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case program.EdgeEnrolments:
		ids := make([]ent.Value, 0, len(m.removedenrolments))
		for id := range m.removedenrolments {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeProgramCardItems:
		ids := make([]ent.Value, 0, len(m.removedprogram_card_items))
		for id := range m.removedprogram_card_items {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeSuccessStories:
		ids := make([]ent.Value, 0, len(m.removedsuccess_stories))
		for id := range m.removedsuccess_stories {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeVolunteerOpportunities:
		ids := make([]ent.Value, 0, len(m.removedvolunteer_opportunities))
		for id := range m.removedvolunteer_opportunities {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeFundraisingCampaigns:
		ids := make([]ent.Value, 0, len(m.removedfundraising_campaigns))
		for id := range m.removedfundraising_campaigns {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeDonations:
		ids := make([]ent.Value, 0, len(m.removeddonations))
		for id := range m.removeddonations {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeGrants:
		ids := make([]ent.Value, 0, len(m.removedgrants))
		for id := range m.removedgrants {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeSiteVisits:
		ids := make([]ent.Value, 0, len(m.removedsite_visits))
		for id := range m.removedsite_visits {
			ids = append(ids, id)
		}
		return ids
	case program.EdgeImpactMetrics:
		ids := make([]ent.Value, 0, len(m.removedimpact_metrics))
		for id := range m.removedimpact_metrics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProgramMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedcategory {
		edges = append(edges, program.EdgeCategory)
	}
	if m.clearedenrolments {
		edges = append(edges, program.EdgeEnrolments)
	}
	if m.clearedparticipants {
		edges = append(edges, program.EdgeParticipants)
	}
	if m.clearedcreated_by {
		edges = append(edges, program.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, program.EdgeUpdatedBy)
	}
	if m.clearedprogram_card_items {
		edges = append(edges, program.EdgeProgramCardItems)
	}
	if m.clearedevents {
		edges = append(edges, program.EdgeEvents)
	}
	if m.clearedsuccess_stories {
		edges = append(edges, program.EdgeSuccessStories)
	}
	if m.clearedvolunteer_opportunities {
		edges = append(edges, program.EdgeVolunteerOpportunities)
	}
	if m.clearedfundraising_campaigns {
		edges = append(edges, program.EdgeFundraisingCampaigns)
	}
	if m.cleareddonations {
		edges = append(edges, program.EdgeDonations)
	}
	if m.clearedgrants {
		edges = append(edges, program.EdgeGrants)
	}
	if m.clearedsite_visits {
		edges = append(edges, program.EdgeSiteVisits)
	}
	if m.clearedimpact_metrics {
		edges = append(edges, program.EdgeImpactMetrics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProgramMutation) EdgeCleared(name string) bool {
	switch name {
	case program.EdgeCategory:
		return m.clearedcategory
	case program.EdgeEnrolments:
		return m.clearedenrolments
	case program.EdgeParticipants:
		return m.clearedparticipants
	case program.EdgeCreatedBy:
		return m.clearedcreated_by
	case program.EdgeUpdatedBy:
		return m.clearedupdated_by
	case program.EdgeProgramCardItems:
		return m.clearedprogram_card_items
	case program.EdgeEvents:
		return m.clearedevents
	case program.EdgeSuccessStories:
		return m.clearedsuccess_stories
	case program.EdgeVolunteerOpportunities:
		return m.clearedvolunteer_opportunities
	case program.EdgeFundraisingCampaigns:
		return m.clearedfundraising_campaigns
	case program.EdgeDonations:
		return m.cleareddonations
	case program.EdgeGrants:
		return m.clearedgrants
	case program.EdgeSiteVisits:
		return m.clearedsite_visits
	case program.EdgeImpactMetrics:
		return m.clearedimpact_metrics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProgramMutation) ClearEdge(name string) error {
	switch name {
	case program.EdgeCategory:
		m.ClearCategory()
		return nil
	case program.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case program.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Program unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProgramMutation) ResetEdge(name string) error {
	switch name {
	case program.EdgeCategory:
		m.ResetCategory()
		return nil
	case program.EdgeEnrolments:
		m.ResetEnrolments()
		return nil
	case program.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case program.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case program.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case program.EdgeProgramCardItems:
		m.ResetProgramCardItems()
		return nil
	case program.EdgeEvents:
		m.ResetEvents()
		return nil
	case program.EdgeSuccessStories:
		m.ResetSuccessStories()
		return nil
	case program.EdgeVolunteerOpportunities:
		m.ResetVolunteerOpportunities()
		return nil
	case program.EdgeFundraisingCampaigns:
		m.ResetFundraisingCampaigns()
		return nil
	case program.EdgeDonations:
		m.ResetDonations()
		return nil
	case program.EdgeGrants:
		m.ResetGrants()
		return nil
	case program.EdgeSiteVisits:
		m.ResetSiteVisits()
		return nil
	case program.EdgeImpactMetrics:
		m.ResetImpactMetrics()
		return nil
	}
	return fmt.Errorf("unknown Program edge %s", name)
}

// ProgramCardItemMutation represents an operation that mutates the ProgramCardItem nodes in the graph.
type ProgramCardItemMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_order         *int
	add_order      *int
	clearedFields  map[string]struct{}
	block          *int
	clearedblock   bool
	program        *int
	clearedprogram bool
	done           bool
	oldValue       func(context.Context) (*ProgramCardItem, error)
	predicates     []predicate.ProgramCardItem
}

var _ ent.Mutation = (*ProgramCardItemMutation)(nil)

// programcarditemOption allows management of the mutation configuration using functional options.
type programcarditemOption func(*ProgramCardItemMutation)

// newProgramCardItemMutation creates new mutation for the ProgramCardItem entity.
func newProgramCardItemMutation(c config, op Op, opts ...programcarditemOption) *ProgramCardItemMutation {
	m := &ProgramCardItemMutation{
		config:        c,
		op:            op,
		typ:           TypeProgramCardItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProgramCardItemID sets the ID field of the mutation.
func withProgramCardItemID(id int) programcarditemOption {
	return func(m *ProgramCardItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ProgramCardItem
		)
		m.oldValue = func(ctx context.Context) (*ProgramCardItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProgramCardItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProgramCardItem sets the old ProgramCardItem of the mutation.
func withProgramCardItem(node *ProgramCardItem) programcarditemOption {
	return func(m *ProgramCardItemMutation) {
		m.oldValue = func(context.Context) (*ProgramCardItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProgramCardItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProgramCardItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProgramCardItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProgramCardItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProgramCardItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *ProgramCardItemMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *ProgramCardItemMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the ProgramCardItem entity.
// If the ProgramCardItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramCardItemMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *ProgramCardItemMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *ProgramCardItemMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *ProgramCardItemMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetBlockID sets the "block" edge to the BlockProgramCards entity by id.
func (m *ProgramCardItemMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the BlockProgramCards entity.
func (m *ProgramCardItemMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the BlockProgramCards entity was cleared.
func (m *ProgramCardItemMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *ProgramCardItemMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *ProgramCardItemMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *ProgramCardItemMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// SetProgramID sets the "program" edge to the Program entity by id.
func (m *ProgramCardItemMutation) SetProgramID(id int) {
	m.program = &id
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *ProgramCardItemMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *ProgramCardItemMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// ProgramID returns the "program" edge ID in the mutation.
func (m *ProgramCardItemMutation) ProgramID() (id int, exists bool) {
	if m.program != nil {
		return *m.program, true
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgramID instead. It exists only for internal usage by the builders.
func (m *ProgramCardItemMutation) ProgramIDs() (ids []int) {
	if id := m.program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *ProgramCardItemMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
}

// Where appends a list predicates to the ProgramCardItemMutation builder.
func (m *ProgramCardItemMutation) Where(ps ...predicate.ProgramCardItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProgramCardItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProgramCardItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProgramCardItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProgramCardItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProgramCardItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProgramCardItem).
func (m *ProgramCardItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProgramCardItemMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._order != nil {
		fields = append(fields, programcarditem.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProgramCardItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case programcarditem.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProgramCardItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case programcarditem.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown ProgramCardItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramCardItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case programcarditem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ProgramCardItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProgramCardItemMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, programcarditem.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProgramCardItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case programcarditem.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramCardItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case programcarditem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ProgramCardItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProgramCardItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProgramCardItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProgramCardItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProgramCardItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProgramCardItemMutation) ResetField(name string) error {
	switch name {
	case programcarditem.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown ProgramCardItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProgramCardItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.block != nil {
		edges = append(edges, programcarditem.EdgeBlock)
	}
	if m.program != nil {
		edges = append(edges, programcarditem.EdgeProgram)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProgramCardItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case programcarditem.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	case programcarditem.EdgeProgram:
		if id := m.program; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProgramCardItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProgramCardItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProgramCardItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblock {
		edges = append(edges, programcarditem.EdgeBlock)
	}
	if m.clearedprogram {
		edges = append(edges, programcarditem.EdgeProgram)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProgramCardItemMutation) EdgeCleared(name string) bool {
	switch name {
	case programcarditem.EdgeBlock:
		return m.clearedblock
	case programcarditem.EdgeProgram:
		return m.clearedprogram
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProgramCardItemMutation) ClearEdge(name string) error {
	switch name {
	case programcarditem.EdgeBlock:
		m.ClearBlock()
		return nil
	case programcarditem.EdgeProgram:
		m.ClearProgram()
		return nil
	}
	return fmt.Errorf("unknown ProgramCardItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProgramCardItemMutation) ResetEdge(name string) error {
	switch name {
	case programcarditem.EdgeBlock:
		m.ResetBlock()
		return nil
	case programcarditem.EdgeProgram:
		m.ResetProgram()
		return nil
	}
	return fmt.Errorf("unknown ProgramCardItem edge %s", name)
}

// ProgramCategoryMutation represents an operation that mutates the ProgramCategory nodes in the graph.
type ProgramCategoryMutation struct {
	config
	op               Op
	typ              string
	id               *int
	slug             *string
	name             *map[string]string
	description      *map[string]string
	icon_name        *string
	display_order    *int
	adddisplay_order *int
	color            *string
	hero_image_url   *string
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	programs         map[int]struct{}
	removedprograms  map[int]struct{}
	clearedprograms  bool
	done             bool
	oldValue         func(context.Context) (*ProgramCategory, error)
	predicates       []predicate.ProgramCategory
}

var _ ent.Mutation = (*ProgramCategoryMutation)(nil)

// programcategoryOption allows management of the mutation configuration using functional options.
type programcategoryOption func(*ProgramCategoryMutation)

// newProgramCategoryMutation creates new mutation for the ProgramCategory entity.
func newProgramCategoryMutation(c config, op Op, opts ...programcategoryOption) *ProgramCategoryMutation {
	m := &ProgramCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProgramCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProgramCategoryID sets the ID field of the mutation.
func withProgramCategoryID(id int) programcategoryOption {
	return func(m *ProgramCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProgramCategory
		)
		m.oldValue = func(ctx context.Context) (*ProgramCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProgramCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProgramCategory sets the old ProgramCategory of the mutation.
func withProgramCategory(node *ProgramCategory) programcategoryOption {
	return func(m *ProgramCategoryMutation) {
		m.oldValue = func(context.Context) (*ProgramCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProgramCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProgramCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProgramCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProgramCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProgramCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *ProgramCategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ProgramCategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the ProgramCategory entity.
// If the ProgramCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramCategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ProgramCategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *ProgramCategoryMutation) SetName(value map[string]string) {
	m.name = &value
}

// Name returns the value of the "name" field in the mutation.
func (m *ProgramCategoryMutation) Name() (r map[string]string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProgramCategory entity.
// If the ProgramCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramCategoryMutation) OldName(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProgramCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProgramCategoryMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *ProgramCategoryMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProgramCategory entity.
// If the ProgramCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramCategoryMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProgramCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[programcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProgramCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[programcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProgramCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, programcategory.FieldDescription)
}

// SetIconName sets the "icon_name" field.
func (m *ProgramCategoryMutation) SetIconName(s string) {
	m.icon_name = &s
}

// IconName returns the value of the "icon_name" field in the mutation.
func (m *ProgramCategoryMutation) IconName() (r string, exists bool) {
	v := m.icon_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIconName returns the old "icon_name" field's value of the ProgramCategory entity.
// If the ProgramCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramCategoryMutation) OldIconName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconName: %w", err)
	}
	return oldValue.IconName, nil
}

// ClearIconName clears the value of the "icon_name" field.
func (m *ProgramCategoryMutation) ClearIconName() {
	m.icon_name = nil
	m.clearedFields[programcategory.FieldIconName] = struct{}{}
}

// IconNameCleared returns if the "icon_name" field was cleared in this mutation.
func (m *ProgramCategoryMutation) IconNameCleared() bool {
	_, ok := m.clearedFields[programcategory.FieldIconName]
	return ok
}

// ResetIconName resets all changes to the "icon_name" field.
func (m *ProgramCategoryMutation) ResetIconName() {
	m.icon_name = nil
	delete(m.clearedFields, programcategory.FieldIconName)
}

// SetDisplayOrder sets the "display_order" field.
func (m *ProgramCategoryMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *ProgramCategoryMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the ProgramCategory entity.
// If the ProgramCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramCategoryMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *ProgramCategoryMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *ProgramCategoryMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *ProgramCategoryMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetColor sets the "color" field.
func (m *ProgramCategoryMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *ProgramCategoryMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the ProgramCategory entity.
// If the ProgramCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramCategoryMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *ProgramCategoryMutation) ResetColor() {
	m.color = nil
}

// SetHeroImageURL sets the "hero_image_url" field.
func (m *ProgramCategoryMutation) SetHeroImageURL(s string) {
	m.hero_image_url = &s
}

// HeroImageURL returns the value of the "hero_image_url" field in the mutation.
func (m *ProgramCategoryMutation) HeroImageURL() (r string, exists bool) {
	v := m.hero_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHeroImageURL returns the old "hero_image_url" field's value of the ProgramCategory entity.
// If the ProgramCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramCategoryMutation) OldHeroImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeroImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeroImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeroImageURL: %w", err)
	}
	return oldValue.HeroImageURL, nil
}

// ClearHeroImageURL clears the value of the "hero_image_url" field.
func (m *ProgramCategoryMutation) ClearHeroImageURL() {
	m.hero_image_url = nil
	m.clearedFields[programcategory.FieldHeroImageURL] = struct{}{}
}

// HeroImageURLCleared returns if the "hero_image_url" field was cleared in this mutation.
func (m *ProgramCategoryMutation) HeroImageURLCleared() bool {
	_, ok := m.clearedFields[programcategory.FieldHeroImageURL]
	return ok
}

// ResetHeroImageURL resets all changes to the "hero_image_url" field.
func (m *ProgramCategoryMutation) ResetHeroImageURL() {
	m.hero_image_url = nil
	delete(m.clearedFields, programcategory.FieldHeroImageURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProgramCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProgramCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProgramCategory entity.
// If the ProgramCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProgramCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProgramCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProgramCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProgramCategory entity.
// If the ProgramCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProgramCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProgramIDs adds the "programs" edge to the Program entity by ids.
func (m *ProgramCategoryMutation) AddProgramIDs(ids ...int) {
	if m.programs == nil {
		m.programs = make(map[int]struct{})
	}
	for i := range ids {
		m.programs[ids[i]] = struct{}{}
	}
}

// ClearPrograms clears the "programs" edge to the Program entity.
func (m *ProgramCategoryMutation) ClearPrograms() {
	m.clearedprograms = true
}

// ProgramsCleared reports if the "programs" edge to the Program entity was cleared.
func (m *ProgramCategoryMutation) ProgramsCleared() bool {
	return m.clearedprograms
}

// RemoveProgramIDs removes the "programs" edge to the Program entity by IDs.
func (m *ProgramCategoryMutation) RemoveProgramIDs(ids ...int) {
	if m.removedprograms == nil {
		m.removedprograms = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.programs, ids[i])
		m.removedprograms[ids[i]] = struct{}{}
	}
}

// RemovedPrograms returns the removed IDs of the "programs" edge to the Program entity.
func (m *ProgramCategoryMutation) RemovedProgramsIDs() (ids []int) {
	for id := range m.removedprograms {
		ids = append(ids, id)
	}
	return
}

// ProgramsIDs returns the "programs" edge IDs in the mutation.
func (m *ProgramCategoryMutation) ProgramsIDs() (ids []int) {
	for id := range m.programs {
		ids = append(ids, id)
	}
	return
}

// ResetPrograms resets all changes to the "programs" edge.
func (m *ProgramCategoryMutation) ResetPrograms() {
	m.programs = nil
	m.clearedprograms = false
	m.removedprograms = nil
}

// Where appends a list predicates to the ProgramCategoryMutation builder.
func (m *ProgramCategoryMutation) Where(ps ...predicate.ProgramCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProgramCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProgramCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProgramCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProgramCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProgramCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProgramCategory).
func (m *ProgramCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProgramCategoryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.slug != nil {
		fields = append(fields, programcategory.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, programcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, programcategory.FieldDescription)
	}
	if m.icon_name != nil {
		fields = append(fields, programcategory.FieldIconName)
	}
	if m.display_order != nil {
		fields = append(fields, programcategory.FieldDisplayOrder)
	}
	if m.color != nil {
		fields = append(fields, programcategory.FieldColor)
	}
	if m.hero_image_url != nil {
		fields = append(fields, programcategory.FieldHeroImageURL)
	}
	if m.created_at != nil {
		fields = append(fields, programcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, programcategory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProgramCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case programcategory.FieldSlug:
		return m.Slug()
	case programcategory.FieldName:
		return m.Name()
	case programcategory.FieldDescription:
		return m.Description()
	case programcategory.FieldIconName:
		return m.IconName()
	case programcategory.FieldDisplayOrder:
		return m.DisplayOrder()
	case programcategory.FieldColor:
		return m.Color()
	case programcategory.FieldHeroImageURL:
		return m.HeroImageURL()
	case programcategory.FieldCreatedAt:
		return m.CreatedAt()
	case programcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProgramCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case programcategory.FieldSlug:
		return m.OldSlug(ctx)
	case programcategory.FieldName:
		return m.OldName(ctx)
	case programcategory.FieldDescription:
		return m.OldDescription(ctx)
	case programcategory.FieldIconName:
		return m.OldIconName(ctx)
	case programcategory.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case programcategory.FieldColor:
		return m.OldColor(ctx)
	case programcategory.FieldHeroImageURL:
		return m.OldHeroImageURL(ctx)
	case programcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case programcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProgramCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case programcategory.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case programcategory.FieldName:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case programcategory.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case programcategory.FieldIconName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconName(v)
		return nil
	case programcategory.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case programcategory.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case programcategory.FieldHeroImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeroImageURL(v)
		return nil
	case programcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case programcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProgramCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProgramCategoryMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, programcategory.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProgramCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case programcategory.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case programcategory.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ProgramCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProgramCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(programcategory.FieldDescription) {
		fields = append(fields, programcategory.FieldDescription)
	}
	if m.FieldCleared(programcategory.FieldIconName) {
		fields = append(fields, programcategory.FieldIconName)
	}
	if m.FieldCleared(programcategory.FieldHeroImageURL) {
		fields = append(fields, programcategory.FieldHeroImageURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProgramCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProgramCategoryMutation) ClearField(name string) error {
	switch name {
	case programcategory.FieldDescription:
		m.ClearDescription()
		return nil
	case programcategory.FieldIconName:
		m.ClearIconName()
		return nil
	case programcategory.FieldHeroImageURL:
		m.ClearHeroImageURL()
		return nil
	}
	return fmt.Errorf("unknown ProgramCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProgramCategoryMutation) ResetField(name string) error {
	switch name {
	case programcategory.FieldSlug:
		m.ResetSlug()
		return nil
	case programcategory.FieldName:
		m.ResetName()
		return nil
	case programcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case programcategory.FieldIconName:
		m.ResetIconName()
		return nil
	case programcategory.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case programcategory.FieldColor:
		m.ResetColor()
		return nil
	case programcategory.FieldHeroImageURL:
		m.ResetHeroImageURL()
		return nil
	case programcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case programcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProgramCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProgramCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.programs != nil {
		edges = append(edges, programcategory.EdgePrograms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProgramCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case programcategory.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.programs))
		for id := range m.programs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProgramCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprograms != nil {
		edges = append(edges, programcategory.EdgePrograms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProgramCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case programcategory.EdgePrograms:
		ids := make([]ent.Value, 0, len(m.removedprograms))
		for id := range m.removedprograms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProgramCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprograms {
		edges = append(edges, programcategory.EdgePrograms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProgramCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case programcategory.EdgePrograms:
		return m.clearedprograms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProgramCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProgramCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProgramCategoryMutation) ResetEdge(name string) error {
	switch name {
	case programcategory.EdgePrograms:
		m.ResetPrograms()
		return nil
	}
	return fmt.Errorf("unknown ProgramCategory edge %s", name)
}

// ProgramEnrolmentMutation represents an operation that mutates the ProgramEnrolment nodes in the graph.
type ProgramEnrolmentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	status         *programenrolment.Status
	answers        *map[string]interface{}
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	program        *int
	clearedprogram bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*ProgramEnrolment, error)
	predicates     []predicate.ProgramEnrolment
}

var _ ent.Mutation = (*ProgramEnrolmentMutation)(nil)

// programenrolmentOption allows management of the mutation configuration using functional options.
type programenrolmentOption func(*ProgramEnrolmentMutation)

// newProgramEnrolmentMutation creates new mutation for the ProgramEnrolment entity.
func newProgramEnrolmentMutation(c config, op Op, opts ...programenrolmentOption) *ProgramEnrolmentMutation {
	m := &ProgramEnrolmentMutation{
		config:        c,
		op:            op,
		typ:           TypeProgramEnrolment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProgramEnrolmentID sets the ID field of the mutation.
func withProgramEnrolmentID(id int) programenrolmentOption {
	return func(m *ProgramEnrolmentMutation) {
		var (
			err   error
			once  sync.Once
			value *ProgramEnrolment
		)
		m.oldValue = func(ctx context.Context) (*ProgramEnrolment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProgramEnrolment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProgramEnrolment sets the old ProgramEnrolment of the mutation.
func withProgramEnrolment(node *ProgramEnrolment) programenrolmentOption {
	return func(m *ProgramEnrolmentMutation) {
		m.oldValue = func(context.Context) (*ProgramEnrolment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProgramEnrolmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProgramEnrolmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProgramEnrolmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProgramEnrolmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProgramEnrolment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *ProgramEnrolmentMutation) SetStatus(pr programenrolment.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProgramEnrolmentMutation) Status() (r programenrolment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProgramEnrolment entity.
// If the ProgramEnrolment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramEnrolmentMutation) OldStatus(ctx context.Context) (v programenrolment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProgramEnrolmentMutation) ResetStatus() {
	m.status = nil
}

// SetAnswers sets the "answers" field.
func (m *ProgramEnrolmentMutation) SetAnswers(value map[string]interface{}) {
	m.answers = &value
}

// Answers returns the value of the "answers" field in the mutation.
func (m *ProgramEnrolmentMutation) Answers() (r map[string]interface{}, exists bool) {
	v := m.answers
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswers returns the old "answers" field's value of the ProgramEnrolment entity.
// If the ProgramEnrolment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramEnrolmentMutation) OldAnswers(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnswers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnswers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswers: %w", err)
	}
	return oldValue.Answers, nil
}

// ClearAnswers clears the value of the "answers" field.
func (m *ProgramEnrolmentMutation) ClearAnswers() {
	m.answers = nil
	m.clearedFields[programenrolment.FieldAnswers] = struct{}{}
}

// AnswersCleared returns if the "answers" field was cleared in this mutation.
func (m *ProgramEnrolmentMutation) AnswersCleared() bool {
	_, ok := m.clearedFields[programenrolment.FieldAnswers]
	return ok
}

// ResetAnswers resets all changes to the "answers" field.
func (m *ProgramEnrolmentMutation) ResetAnswers() {
	m.answers = nil
	delete(m.clearedFields, programenrolment.FieldAnswers)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProgramEnrolmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProgramEnrolmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProgramEnrolment entity.
// If the ProgramEnrolment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramEnrolmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProgramEnrolmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProgramEnrolmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProgramEnrolmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProgramEnrolment entity.
// If the ProgramEnrolment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramEnrolmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProgramEnrolmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProgramID sets the "program" edge to the Program entity by id.
func (m *ProgramEnrolmentMutation) SetProgramID(id int) {
	m.program = &id
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *ProgramEnrolmentMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *ProgramEnrolmentMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// ProgramID returns the "program" edge ID in the mutation.
func (m *ProgramEnrolmentMutation) ProgramID() (id int, exists bool) {
	if m.program != nil {
		return *m.program, true
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgramID instead. It exists only for internal usage by the builders.
func (m *ProgramEnrolmentMutation) ProgramIDs() (ids []int) {
	if id := m.program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *ProgramEnrolmentMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProgramEnrolmentMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProgramEnrolmentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProgramEnrolmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProgramEnrolmentMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProgramEnrolmentMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProgramEnrolmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ProgramEnrolmentMutation builder.
func (m *ProgramEnrolmentMutation) Where(ps ...predicate.ProgramEnrolment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProgramEnrolmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProgramEnrolmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProgramEnrolment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProgramEnrolmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProgramEnrolmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProgramEnrolment).
func (m *ProgramEnrolmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProgramEnrolmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.status != nil {
		fields = append(fields, programenrolment.FieldStatus)
	}
	if m.answers != nil {
		fields = append(fields, programenrolment.FieldAnswers)
	}
	if m.created_at != nil {
		fields = append(fields, programenrolment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, programenrolment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProgramEnrolmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case programenrolment.FieldStatus:
		return m.Status()
	case programenrolment.FieldAnswers:
		return m.Answers()
	case programenrolment.FieldCreatedAt:
		return m.CreatedAt()
	case programenrolment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProgramEnrolmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case programenrolment.FieldStatus:
		return m.OldStatus(ctx)
	case programenrolment.FieldAnswers:
		return m.OldAnswers(ctx)
	case programenrolment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case programenrolment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProgramEnrolment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramEnrolmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case programenrolment.FieldStatus:
		v, ok := value.(programenrolment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case programenrolment.FieldAnswers:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswers(v)
		return nil
	case programenrolment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case programenrolment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProgramEnrolment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProgramEnrolmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProgramEnrolmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramEnrolmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProgramEnrolment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProgramEnrolmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(programenrolment.FieldAnswers) {
		fields = append(fields, programenrolment.FieldAnswers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProgramEnrolmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProgramEnrolmentMutation) ClearField(name string) error {
	switch name {
	case programenrolment.FieldAnswers:
		m.ClearAnswers()
		return nil
	}
	return fmt.Errorf("unknown ProgramEnrolment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProgramEnrolmentMutation) ResetField(name string) error {
	switch name {
	case programenrolment.FieldStatus:
		m.ResetStatus()
		return nil
	case programenrolment.FieldAnswers:
		m.ResetAnswers()
		return nil
	case programenrolment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case programenrolment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProgramEnrolment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProgramEnrolmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.program != nil {
		edges = append(edges, programenrolment.EdgeProgram)
	}
	if m.user != nil {
		edges = append(edges, programenrolment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProgramEnrolmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case programenrolment.EdgeProgram:
		if id := m.program; id != nil {
			return []ent.Value{*id}
		}
	case programenrolment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProgramEnrolmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProgramEnrolmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProgramEnrolmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprogram {
		edges = append(edges, programenrolment.EdgeProgram)
	}
	if m.cleareduser {
		edges = append(edges, programenrolment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProgramEnrolmentMutation) EdgeCleared(name string) bool {
	switch name {
	case programenrolment.EdgeProgram:
		return m.clearedprogram
	case programenrolment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProgramEnrolmentMutation) ClearEdge(name string) error {
	switch name {
	case programenrolment.EdgeProgram:
		m.ClearProgram()
		return nil
	case programenrolment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ProgramEnrolment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProgramEnrolmentMutation) ResetEdge(name string) error {
	switch name {
	case programenrolment.EdgeProgram:
		m.ResetProgram()
		return nil
	case programenrolment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ProgramEnrolment edge %s", name)
}

// ProgramParticipantMutation represents an operation that mutates the ProgramParticipant nodes in the graph.
type ProgramParticipantMutation struct {
	config
	op              Op
	typ             string
	id              *int
	status          *string
	enrollment_date *time.Time
	completion_date *time.Time
	outcomes        *map[string]interface{}
	notes           *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	program         *int
	clearedprogram  bool
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*ProgramParticipant, error)
	predicates      []predicate.ProgramParticipant
}

var _ ent.Mutation = (*ProgramParticipantMutation)(nil)

// programparticipantOption allows management of the mutation configuration using functional options.
type programparticipantOption func(*ProgramParticipantMutation)

// newProgramParticipantMutation creates new mutation for the ProgramParticipant entity.
func newProgramParticipantMutation(c config, op Op, opts ...programparticipantOption) *ProgramParticipantMutation {
	m := &ProgramParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeProgramParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProgramParticipantID sets the ID field of the mutation.
func withProgramParticipantID(id int) programparticipantOption {
	return func(m *ProgramParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *ProgramParticipant
		)
		m.oldValue = func(ctx context.Context) (*ProgramParticipant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProgramParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProgramParticipant sets the old ProgramParticipant of the mutation.
func withProgramParticipant(node *ProgramParticipant) programparticipantOption {
	return func(m *ProgramParticipantMutation) {
		m.oldValue = func(context.Context) (*ProgramParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProgramParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProgramParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProgramParticipantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProgramParticipantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProgramParticipant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *ProgramParticipantMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProgramParticipantMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProgramParticipant entity.
// If the ProgramParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramParticipantMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProgramParticipantMutation) ResetStatus() {
	m.status = nil
}

// SetEnrollmentDate sets the "enrollment_date" field.
func (m *ProgramParticipantMutation) SetEnrollmentDate(t time.Time) {
	m.enrollment_date = &t
}

// EnrollmentDate returns the value of the "enrollment_date" field in the mutation.
func (m *ProgramParticipantMutation) EnrollmentDate() (r time.Time, exists bool) {
	v := m.enrollment_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEnrollmentDate returns the old "enrollment_date" field's value of the ProgramParticipant entity.
// If the ProgramParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramParticipantMutation) OldEnrollmentDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnrollmentDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnrollmentDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnrollmentDate: %w", err)
	}
	return oldValue.EnrollmentDate, nil
}

// ResetEnrollmentDate resets all changes to the "enrollment_date" field.
func (m *ProgramParticipantMutation) ResetEnrollmentDate() {
	m.enrollment_date = nil
}

// SetCompletionDate sets the "completion_date" field.
func (m *ProgramParticipantMutation) SetCompletionDate(t time.Time) {
	m.completion_date = &t
}

// CompletionDate returns the value of the "completion_date" field in the mutation.
func (m *ProgramParticipantMutation) CompletionDate() (r time.Time, exists bool) {
	v := m.completion_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionDate returns the old "completion_date" field's value of the ProgramParticipant entity.
// If the ProgramParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramParticipantMutation) OldCompletionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionDate: %w", err)
	}
	return oldValue.CompletionDate, nil
}

// ClearCompletionDate clears the value of the "completion_date" field.
func (m *ProgramParticipantMutation) ClearCompletionDate() {
	m.completion_date = nil
	m.clearedFields[programparticipant.FieldCompletionDate] = struct{}{}
}

// CompletionDateCleared returns if the "completion_date" field was cleared in this mutation.
func (m *ProgramParticipantMutation) CompletionDateCleared() bool {
	_, ok := m.clearedFields[programparticipant.FieldCompletionDate]
	return ok
}

// ResetCompletionDate resets all changes to the "completion_date" field.
func (m *ProgramParticipantMutation) ResetCompletionDate() {
	m.completion_date = nil
	delete(m.clearedFields, programparticipant.FieldCompletionDate)
}

// SetOutcomes sets the "outcomes" field.
func (m *ProgramParticipantMutation) SetOutcomes(value map[string]interface{}) {
	m.outcomes = &value
}

// Outcomes returns the value of the "outcomes" field in the mutation.
func (m *ProgramParticipantMutation) Outcomes() (r map[string]interface{}, exists bool) {
	v := m.outcomes
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomes returns the old "outcomes" field's value of the ProgramParticipant entity.
// If the ProgramParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramParticipantMutation) OldOutcomes(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomes: %w", err)
	}
	return oldValue.Outcomes, nil
}

// ClearOutcomes clears the value of the "outcomes" field.
func (m *ProgramParticipantMutation) ClearOutcomes() {
	m.outcomes = nil
	m.clearedFields[programparticipant.FieldOutcomes] = struct{}{}
}

// OutcomesCleared returns if the "outcomes" field was cleared in this mutation.
func (m *ProgramParticipantMutation) OutcomesCleared() bool {
	_, ok := m.clearedFields[programparticipant.FieldOutcomes]
	return ok
}

// ResetOutcomes resets all changes to the "outcomes" field.
func (m *ProgramParticipantMutation) ResetOutcomes() {
	m.outcomes = nil
	delete(m.clearedFields, programparticipant.FieldOutcomes)
}

// SetNotes sets the "notes" field.
func (m *ProgramParticipantMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ProgramParticipantMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ProgramParticipant entity.
// If the ProgramParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramParticipantMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ProgramParticipantMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[programparticipant.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ProgramParticipantMutation) NotesCleared() bool {
	_, ok := m.clearedFields[programparticipant.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ProgramParticipantMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, programparticipant.FieldNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProgramParticipantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProgramParticipantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProgramParticipant entity.
// If the ProgramParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramParticipantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProgramParticipantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProgramParticipantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProgramParticipantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProgramParticipant entity.
// If the ProgramParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProgramParticipantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProgramParticipantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProgramID sets the "program" edge to the Program entity by id.
func (m *ProgramParticipantMutation) SetProgramID(id int) {
	m.program = &id
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *ProgramParticipantMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *ProgramParticipantMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// ProgramID returns the "program" edge ID in the mutation.
func (m *ProgramParticipantMutation) ProgramID() (id int, exists bool) {
	if m.program != nil {
		return *m.program, true
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgramID instead. It exists only for internal usage by the builders.
func (m *ProgramParticipantMutation) ProgramIDs() (ids []int) {
	if id := m.program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *ProgramParticipantMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProgramParticipantMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProgramParticipantMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProgramParticipantMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProgramParticipantMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProgramParticipantMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProgramParticipantMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ProgramParticipantMutation builder.
func (m *ProgramParticipantMutation) Where(ps ...predicate.ProgramParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProgramParticipantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProgramParticipantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProgramParticipant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProgramParticipantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProgramParticipantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProgramParticipant).
func (m *ProgramParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProgramParticipantMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.status != nil {
		fields = append(fields, programparticipant.FieldStatus)
	}
	if m.enrollment_date != nil {
		fields = append(fields, programparticipant.FieldEnrollmentDate)
	}
	if m.completion_date != nil {
		fields = append(fields, programparticipant.FieldCompletionDate)
	}
	if m.outcomes != nil {
		fields = append(fields, programparticipant.FieldOutcomes)
	}
	if m.notes != nil {
		fields = append(fields, programparticipant.FieldNotes)
	}
	if m.created_at != nil {
		fields = append(fields, programparticipant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, programparticipant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProgramParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case programparticipant.FieldStatus:
		return m.Status()
	case programparticipant.FieldEnrollmentDate:
		return m.EnrollmentDate()
	case programparticipant.FieldCompletionDate:
		return m.CompletionDate()
	case programparticipant.FieldOutcomes:
		return m.Outcomes()
	case programparticipant.FieldNotes:
		return m.Notes()
	case programparticipant.FieldCreatedAt:
		return m.CreatedAt()
	case programparticipant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProgramParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case programparticipant.FieldStatus:
		return m.OldStatus(ctx)
	case programparticipant.FieldEnrollmentDate:
		return m.OldEnrollmentDate(ctx)
	case programparticipant.FieldCompletionDate:
		return m.OldCompletionDate(ctx)
	case programparticipant.FieldOutcomes:
		return m.OldOutcomes(ctx)
	case programparticipant.FieldNotes:
		return m.OldNotes(ctx)
	case programparticipant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case programparticipant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProgramParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case programparticipant.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case programparticipant.FieldEnrollmentDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnrollmentDate(v)
		return nil
	case programparticipant.FieldCompletionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionDate(v)
		return nil
	case programparticipant.FieldOutcomes:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomes(v)
		return nil
	case programparticipant.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case programparticipant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case programparticipant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProgramParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProgramParticipantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProgramParticipantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProgramParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProgramParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProgramParticipantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(programparticipant.FieldCompletionDate) {
		fields = append(fields, programparticipant.FieldCompletionDate)
	}
	if m.FieldCleared(programparticipant.FieldOutcomes) {
		fields = append(fields, programparticipant.FieldOutcomes)
	}
	if m.FieldCleared(programparticipant.FieldNotes) {
		fields = append(fields, programparticipant.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProgramParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProgramParticipantMutation) ClearField(name string) error {
	switch name {
	case programparticipant.FieldCompletionDate:
		m.ClearCompletionDate()
		return nil
	case programparticipant.FieldOutcomes:
		m.ClearOutcomes()
		return nil
	case programparticipant.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown ProgramParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProgramParticipantMutation) ResetField(name string) error {
	switch name {
	case programparticipant.FieldStatus:
		m.ResetStatus()
		return nil
	case programparticipant.FieldEnrollmentDate:
		m.ResetEnrollmentDate()
		return nil
	case programparticipant.FieldCompletionDate:
		m.ResetCompletionDate()
		return nil
	case programparticipant.FieldOutcomes:
		m.ResetOutcomes()
		return nil
	case programparticipant.FieldNotes:
		m.ResetNotes()
		return nil
	case programparticipant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case programparticipant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProgramParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProgramParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.program != nil {
		edges = append(edges, programparticipant.EdgeProgram)
	}
	if m.user != nil {
		edges = append(edges, programparticipant.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProgramParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case programparticipant.EdgeProgram:
		if id := m.program; id != nil {
			return []ent.Value{*id}
		}
	case programparticipant.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProgramParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProgramParticipantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProgramParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprogram {
		edges = append(edges, programparticipant.EdgeProgram)
	}
	if m.cleareduser {
		edges = append(edges, programparticipant.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProgramParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case programparticipant.EdgeProgram:
		return m.clearedprogram
	case programparticipant.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProgramParticipantMutation) ClearEdge(name string) error {
	switch name {
	case programparticipant.EdgeProgram:
		m.ClearProgram()
		return nil
	case programparticipant.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ProgramParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProgramParticipantMutation) ResetEdge(name string) error {
	switch name {
	case programparticipant.EdgeProgram:
		m.ResetProgram()
		return nil
	case programparticipant.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ProgramParticipant edge %s", name)
}

// ReportDefinitionMutation represents an operation that mutates the ReportDefinition nodes in the graph.
type ReportDefinitionMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	slug                     *string
	_type                    *reportdefinition.Type
	description              *string
	query                    *map[string]interface{}
	parameters               *[]map[string]interface{}
	appendparameters         []map[string]interface{}
	is_public                *bool
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	creator                  *int
	clearedcreator           bool
	permissions              map[int]struct{}
	removedpermissions       map[int]struct{}
	clearedpermissions       bool
	generated_reports        map[int]struct{}
	removedgenerated_reports map[int]struct{}
	clearedgenerated_reports bool
	schedules                map[int]struct{}
	removedschedules         map[int]struct{}
	clearedschedules         bool
	done                     bool
	oldValue                 func(context.Context) (*ReportDefinition, error)
	predicates               []predicate.ReportDefinition
}

var _ ent.Mutation = (*ReportDefinitionMutation)(nil)

// reportdefinitionOption allows management of the mutation configuration using functional options.
type reportdefinitionOption func(*ReportDefinitionMutation)

// newReportDefinitionMutation creates new mutation for the ReportDefinition entity.
func newReportDefinitionMutation(c config, op Op, opts ...reportdefinitionOption) *ReportDefinitionMutation {
	m := &ReportDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeReportDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportDefinitionID sets the ID field of the mutation.
func withReportDefinitionID(id int) reportdefinitionOption {
	return func(m *ReportDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *ReportDefinition
		)
		m.oldValue = func(ctx context.Context) (*ReportDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReportDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReportDefinition sets the old ReportDefinition of the mutation.
func withReportDefinition(node *ReportDefinition) reportdefinitionOption {
	return func(m *ReportDefinitionMutation) {
		m.oldValue = func(context.Context) (*ReportDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportDefinitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReportDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ReportDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReportDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ReportDefinition entity.
// If the ReportDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReportDefinitionMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *ReportDefinitionMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ReportDefinitionMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the ReportDefinition entity.
// If the ReportDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportDefinitionMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ReportDefinitionMutation) ResetSlug() {
	m.slug = nil
}

// SetType sets the "type" field.
func (m *ReportDefinitionMutation) SetType(r reportdefinition.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *ReportDefinitionMutation) GetType() (r reportdefinition.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ReportDefinition entity.
// If the ReportDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportDefinitionMutation) OldType(ctx context.Context) (v reportdefinition.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ReportDefinitionMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *ReportDefinitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ReportDefinitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ReportDefinition entity.
// If the ReportDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportDefinitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ReportDefinitionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[reportdefinition.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ReportDefinitionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[reportdefinition.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ReportDefinitionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, reportdefinition.FieldDescription)
}

// SetQuery sets the "query" field.
func (m *ReportDefinitionMutation) SetQuery(value map[string]interface{}) {
	m.query = &value
}

// Query returns the value of the "query" field in the mutation.
func (m *ReportDefinitionMutation) Query() (r map[string]interface{}, exists bool) {
	v := m.query
	if v == nil {
		return
	}
	return *v, true
}

// OldQuery returns the old "query" field's value of the ReportDefinition entity.
// If the ReportDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportDefinitionMutation) OldQuery(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuery: %w", err)
	}
	return oldValue.Query, nil
}

// ClearQuery clears the value of the "query" field.
func (m *ReportDefinitionMutation) ClearQuery() {
	m.query = nil
	m.clearedFields[reportdefinition.FieldQuery] = struct{}{}
}

// QueryCleared returns if the "query" field was cleared in this mutation.
func (m *ReportDefinitionMutation) QueryCleared() bool {
	_, ok := m.clearedFields[reportdefinition.FieldQuery]
	return ok
}

// ResetQuery resets all changes to the "query" field.
func (m *ReportDefinitionMutation) ResetQuery() {
	m.query = nil
	delete(m.clearedFields, reportdefinition.FieldQuery)
}

// SetParameters sets the "parameters" field.
func (m *ReportDefinitionMutation) SetParameters(value []map[string]interface{}) {
	m.parameters = &value
	m.appendparameters = nil
}

// Parameters returns the value of the "parameters" field in the mutation.
func (m *ReportDefinitionMutation) Parameters() (r []map[string]interface{}, exists bool) {
	v := m.parameters
	if v == nil {
		return
	}
	return *v, true
}

// OldParameters returns the old "parameters" field's value of the ReportDefinition entity.
// If the ReportDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportDefinitionMutation) OldParameters(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParameters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParameters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParameters: %w", err)
	}
	return oldValue.Parameters, nil
}

// AppendParameters adds value to the "parameters" field.
func (m *ReportDefinitionMutation) AppendParameters(value []map[string]interface{}) {
	m.appendparameters = append(m.appendparameters, value...)
}

// AppendedParameters returns the list of values that were appended to the "parameters" field in this mutation.
func (m *ReportDefinitionMutation) AppendedParameters() ([]map[string]interface{}, bool) {
	if len(m.appendparameters) == 0 {
		return nil, false
	}
	return m.appendparameters, true
}

// ClearParameters clears the value of the "parameters" field.
func (m *ReportDefinitionMutation) ClearParameters() {
	m.parameters = nil
	m.appendparameters = nil
	m.clearedFields[reportdefinition.FieldParameters] = struct{}{}
}

// ParametersCleared returns if the "parameters" field was cleared in this mutation.
func (m *ReportDefinitionMutation) ParametersCleared() bool {
	_, ok := m.clearedFields[reportdefinition.FieldParameters]
	return ok
}

// ResetParameters resets all changes to the "parameters" field.
func (m *ReportDefinitionMutation) ResetParameters() {
	m.parameters = nil
	m.appendparameters = nil
	delete(m.clearedFields, reportdefinition.FieldParameters)
}

// SetIsPublic sets the "is_public" field.
func (m *ReportDefinitionMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *ReportDefinitionMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the ReportDefinition entity.
// If the ReportDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportDefinitionMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *ReportDefinitionMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReportDefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReportDefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReportDefinition entity.
// If the ReportDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportDefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReportDefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReportDefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReportDefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ReportDefinition entity.
// If the ReportDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportDefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReportDefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *ReportDefinitionMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *ReportDefinitionMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *ReportDefinitionMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *ReportDefinitionMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *ReportDefinitionMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *ReportDefinitionMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddPermissionIDs adds the "permissions" edge to the ReportPermission entity by ids.
func (m *ReportDefinitionMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the ReportPermission entity.
func (m *ReportDefinitionMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the ReportPermission entity was cleared.
func (m *ReportDefinitionMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the ReportPermission entity by IDs.
func (m *ReportDefinitionMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the ReportPermission entity.
func (m *ReportDefinitionMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *ReportDefinitionMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *ReportDefinitionMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddGeneratedReportIDs adds the "generated_reports" edge to the GeneratedReport entity by ids.
func (m *ReportDefinitionMutation) AddGeneratedReportIDs(ids ...int) {
	if m.generated_reports == nil {
		m.generated_reports = make(map[int]struct{})
	}
	for i := range ids {
		m.generated_reports[ids[i]] = struct{}{}
	}
}

// ClearGeneratedReports clears the "generated_reports" edge to the GeneratedReport entity.
func (m *ReportDefinitionMutation) ClearGeneratedReports() {
	m.clearedgenerated_reports = true
}

// GeneratedReportsCleared reports if the "generated_reports" edge to the GeneratedReport entity was cleared.
func (m *ReportDefinitionMutation) GeneratedReportsCleared() bool {
	return m.clearedgenerated_reports
}

// RemoveGeneratedReportIDs removes the "generated_reports" edge to the GeneratedReport entity by IDs.
func (m *ReportDefinitionMutation) RemoveGeneratedReportIDs(ids ...int) {
	if m.removedgenerated_reports == nil {
		m.removedgenerated_reports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.generated_reports, ids[i])
		m.removedgenerated_reports[ids[i]] = struct{}{}
	}
}

// RemovedGeneratedReports returns the removed IDs of the "generated_reports" edge to the GeneratedReport entity.
func (m *ReportDefinitionMutation) RemovedGeneratedReportsIDs() (ids []int) {
	for id := range m.removedgenerated_reports {
		ids = append(ids, id)
	}
	return
}

// GeneratedReportsIDs returns the "generated_reports" edge IDs in the mutation.
func (m *ReportDefinitionMutation) GeneratedReportsIDs() (ids []int) {
	for id := range m.generated_reports {
		ids = append(ids, id)
	}
	return
}

// ResetGeneratedReports resets all changes to the "generated_reports" edge.
func (m *ReportDefinitionMutation) ResetGeneratedReports() {
	m.generated_reports = nil
	m.clearedgenerated_reports = false
	m.removedgenerated_reports = nil
}

// AddScheduleIDs adds the "schedules" edge to the ScheduledReport entity by ids.
func (m *ReportDefinitionMutation) AddScheduleIDs(ids ...int) {
	if m.schedules == nil {
		m.schedules = make(map[int]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// ClearSchedules clears the "schedules" edge to the ScheduledReport entity.
func (m *ReportDefinitionMutation) ClearSchedules() {
	m.clearedschedules = true
}

// SchedulesCleared reports if the "schedules" edge to the ScheduledReport entity was cleared.
func (m *ReportDefinitionMutation) SchedulesCleared() bool {
	return m.clearedschedules
}

// RemoveScheduleIDs removes the "schedules" edge to the ScheduledReport entity by IDs.
func (m *ReportDefinitionMutation) RemoveScheduleIDs(ids ...int) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.schedules, ids[i])
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed IDs of the "schedules" edge to the ScheduledReport entity.
func (m *ReportDefinitionMutation) RemovedSchedulesIDs() (ids []int) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the "schedules" edge IDs in the mutation.
func (m *ReportDefinitionMutation) SchedulesIDs() (ids []int) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules resets all changes to the "schedules" edge.
func (m *ReportDefinitionMutation) ResetSchedules() {
	m.schedules = nil
	m.clearedschedules = false
	m.removedschedules = nil
}

// Where appends a list predicates to the ReportDefinitionMutation builder.
func (m *ReportDefinitionMutation) Where(ps ...predicate.ReportDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReportDefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReportDefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReportDefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReportDefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReportDefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReportDefinition).
func (m *ReportDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, reportdefinition.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, reportdefinition.FieldSlug)
	}
	if m._type != nil {
		fields = append(fields, reportdefinition.FieldType)
	}
	if m.description != nil {
		fields = append(fields, reportdefinition.FieldDescription)
	}
	if m.query != nil {
		fields = append(fields, reportdefinition.FieldQuery)
	}
	if m.parameters != nil {
		fields = append(fields, reportdefinition.FieldParameters)
	}
	if m.is_public != nil {
		fields = append(fields, reportdefinition.FieldIsPublic)
	}
	if m.created_at != nil {
		fields = append(fields, reportdefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, reportdefinition.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reportdefinition.FieldName:
		return m.Name()
	case reportdefinition.FieldSlug:
		return m.Slug()
	case reportdefinition.FieldType:
		return m.GetType()
	case reportdefinition.FieldDescription:
		return m.Description()
	case reportdefinition.FieldQuery:
		return m.Query()
	case reportdefinition.FieldParameters:
		return m.Parameters()
	case reportdefinition.FieldIsPublic:
		return m.IsPublic()
	case reportdefinition.FieldCreatedAt:
		return m.CreatedAt()
	case reportdefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reportdefinition.FieldName:
		return m.OldName(ctx)
	case reportdefinition.FieldSlug:
		return m.OldSlug(ctx)
	case reportdefinition.FieldType:
		return m.OldType(ctx)
	case reportdefinition.FieldDescription:
		return m.OldDescription(ctx)
	case reportdefinition.FieldQuery:
		return m.OldQuery(ctx)
	case reportdefinition.FieldParameters:
		return m.OldParameters(ctx)
	case reportdefinition.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case reportdefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reportdefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ReportDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reportdefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case reportdefinition.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case reportdefinition.FieldType:
		v, ok := value.(reportdefinition.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case reportdefinition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case reportdefinition.FieldQuery:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuery(v)
		return nil
	case reportdefinition.FieldParameters:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParameters(v)
		return nil
	case reportdefinition.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case reportdefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reportdefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ReportDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportDefinitionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReportDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reportdefinition.FieldDescription) {
		fields = append(fields, reportdefinition.FieldDescription)
	}
	if m.FieldCleared(reportdefinition.FieldQuery) {
		fields = append(fields, reportdefinition.FieldQuery)
	}
	if m.FieldCleared(reportdefinition.FieldParameters) {
		fields = append(fields, reportdefinition.FieldParameters)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportDefinitionMutation) ClearField(name string) error {
	switch name {
	case reportdefinition.FieldDescription:
		m.ClearDescription()
		return nil
	case reportdefinition.FieldQuery:
		m.ClearQuery()
		return nil
	case reportdefinition.FieldParameters:
		m.ClearParameters()
		return nil
	}
	return fmt.Errorf("unknown ReportDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportDefinitionMutation) ResetField(name string) error {
	switch name {
	case reportdefinition.FieldName:
		m.ResetName()
		return nil
	case reportdefinition.FieldSlug:
		m.ResetSlug()
		return nil
	case reportdefinition.FieldType:
		m.ResetType()
		return nil
	case reportdefinition.FieldDescription:
		m.ResetDescription()
		return nil
	case reportdefinition.FieldQuery:
		m.ResetQuery()
		return nil
	case reportdefinition.FieldParameters:
		m.ResetParameters()
		return nil
	case reportdefinition.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case reportdefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reportdefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ReportDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.creator != nil {
		edges = append(edges, reportdefinition.EdgeCreator)
	}
	if m.permissions != nil {
		edges = append(edges, reportdefinition.EdgePermissions)
	}
	if m.generated_reports != nil {
		edges = append(edges, reportdefinition.EdgeGeneratedReports)
	}
	if m.schedules != nil {
		edges = append(edges, reportdefinition.EdgeSchedules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reportdefinition.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case reportdefinition.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case reportdefinition.EdgeGeneratedReports:
		ids := make([]ent.Value, 0, len(m.generated_reports))
		for id := range m.generated_reports {
			ids = append(ids, id)
		}
		return ids
	case reportdefinition.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpermissions != nil {
		edges = append(edges, reportdefinition.EdgePermissions)
	}
	if m.removedgenerated_reports != nil {
		edges = append(edges, reportdefinition.EdgeGeneratedReports)
	}
	if m.removedschedules != nil {
		edges = append(edges, reportdefinition.EdgeSchedules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case reportdefinition.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case reportdefinition.EdgeGeneratedReports:
		ids := make([]ent.Value, 0, len(m.removedgenerated_reports))
		for id := range m.removedgenerated_reports {
			ids = append(ids, id)
		}
		return ids
	case reportdefinition.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreator {
		edges = append(edges, reportdefinition.EdgeCreator)
	}
	if m.clearedpermissions {
		edges = append(edges, reportdefinition.EdgePermissions)
	}
	if m.clearedgenerated_reports {
		edges = append(edges, reportdefinition.EdgeGeneratedReports)
	}
	if m.clearedschedules {
		edges = append(edges, reportdefinition.EdgeSchedules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case reportdefinition.EdgeCreator:
		return m.clearedcreator
	case reportdefinition.EdgePermissions:
		return m.clearedpermissions
	case reportdefinition.EdgeGeneratedReports:
		return m.clearedgenerated_reports
	case reportdefinition.EdgeSchedules:
		return m.clearedschedules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportDefinitionMutation) ClearEdge(name string) error {
	switch name {
	case reportdefinition.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown ReportDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case reportdefinition.EdgeCreator:
		m.ResetCreator()
		return nil
	case reportdefinition.EdgePermissions:
		m.ResetPermissions()
		return nil
	case reportdefinition.EdgeGeneratedReports:
		m.ResetGeneratedReports()
		return nil
	case reportdefinition.EdgeSchedules:
		m.ResetSchedules()
		return nil
	}
	return fmt.Errorf("unknown ReportDefinition edge %s", name)
}

// ReportPermissionMutation represents an operation that mutates the ReportPermission nodes in the graph.
type ReportPermissionMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	role_id                  *string
	can_view                 *bool
	can_edit                 *bool
	can_delete               *bool
	can_schedule             *bool
	created_at               *time.Time
	clearedFields            map[string]struct{}
	report_definition        *int
	clearedreport_definition bool
	user                     *int
	cleareduser              bool
	done                     bool
	oldValue                 func(context.Context) (*ReportPermission, error)
	predicates               []predicate.ReportPermission
}

var _ ent.Mutation = (*ReportPermissionMutation)(nil)

// reportpermissionOption allows management of the mutation configuration using functional options.
type reportpermissionOption func(*ReportPermissionMutation)

// newReportPermissionMutation creates new mutation for the ReportPermission entity.
func newReportPermissionMutation(c config, op Op, opts ...reportpermissionOption) *ReportPermissionMutation {
	m := &ReportPermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeReportPermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportPermissionID sets the ID field of the mutation.
func withReportPermissionID(id int) reportpermissionOption {
	return func(m *ReportPermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *ReportPermission
		)
		m.oldValue = func(ctx context.Context) (*ReportPermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReportPermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReportPermission sets the old ReportPermission of the mutation.
func withReportPermission(node *ReportPermission) reportpermissionOption {
	return func(m *ReportPermissionMutation) {
		m.oldValue = func(context.Context) (*ReportPermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportPermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportPermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportPermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportPermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReportPermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleID sets the "role_id" field.
func (m *ReportPermissionMutation) SetRoleID(s string) {
	m.role_id = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *ReportPermissionMutation) RoleID() (r string, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the ReportPermission entity.
// If the ReportPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportPermissionMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *ReportPermissionMutation) ClearRoleID() {
	m.role_id = nil
	m.clearedFields[reportpermission.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *ReportPermissionMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[reportpermission.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *ReportPermissionMutation) ResetRoleID() {
	m.role_id = nil
	delete(m.clearedFields, reportpermission.FieldRoleID)
}

// SetCanView sets the "can_view" field.
func (m *ReportPermissionMutation) SetCanView(b bool) {
	m.can_view = &b
}

// CanView returns the value of the "can_view" field in the mutation.
func (m *ReportPermissionMutation) CanView() (r bool, exists bool) {
	v := m.can_view
	if v == nil {
		return
	}
	return *v, true
}

// OldCanView returns the old "can_view" field's value of the ReportPermission entity.
// If the ReportPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportPermissionMutation) OldCanView(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanView is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanView requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanView: %w", err)
	}
	return oldValue.CanView, nil
}

// ResetCanView resets all changes to the "can_view" field.
func (m *ReportPermissionMutation) ResetCanView() {
	m.can_view = nil
}

// SetCanEdit sets the "can_edit" field.
func (m *ReportPermissionMutation) SetCanEdit(b bool) {
	m.can_edit = &b
}

// CanEdit returns the value of the "can_edit" field in the mutation.
func (m *ReportPermissionMutation) CanEdit() (r bool, exists bool) {
	v := m.can_edit
	if v == nil {
		return
	}
	return *v, true
}

// OldCanEdit returns the old "can_edit" field's value of the ReportPermission entity.
// If the ReportPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportPermissionMutation) OldCanEdit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanEdit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanEdit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanEdit: %w", err)
	}
	return oldValue.CanEdit, nil
}

// ResetCanEdit resets all changes to the "can_edit" field.
func (m *ReportPermissionMutation) ResetCanEdit() {
	m.can_edit = nil
}

// SetCanDelete sets the "can_delete" field.
func (m *ReportPermissionMutation) SetCanDelete(b bool) {
	m.can_delete = &b
}

// CanDelete returns the value of the "can_delete" field in the mutation.
func (m *ReportPermissionMutation) CanDelete() (r bool, exists bool) {
	v := m.can_delete
	if v == nil {
		return
	}
	return *v, true
}

// OldCanDelete returns the old "can_delete" field's value of the ReportPermission entity.
// If the ReportPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportPermissionMutation) OldCanDelete(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanDelete: %w", err)
	}
	return oldValue.CanDelete, nil
}

// ResetCanDelete resets all changes to the "can_delete" field.
func (m *ReportPermissionMutation) ResetCanDelete() {
	m.can_delete = nil
}

// SetCanSchedule sets the "can_schedule" field.
func (m *ReportPermissionMutation) SetCanSchedule(b bool) {
	m.can_schedule = &b
}

// CanSchedule returns the value of the "can_schedule" field in the mutation.
func (m *ReportPermissionMutation) CanSchedule() (r bool, exists bool) {
	v := m.can_schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldCanSchedule returns the old "can_schedule" field's value of the ReportPermission entity.
// If the ReportPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportPermissionMutation) OldCanSchedule(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanSchedule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanSchedule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanSchedule: %w", err)
	}
	return oldValue.CanSchedule, nil
}

// ResetCanSchedule resets all changes to the "can_schedule" field.
func (m *ReportPermissionMutation) ResetCanSchedule() {
	m.can_schedule = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReportPermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReportPermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReportPermission entity.
// If the ReportPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportPermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReportPermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetReportDefinitionID sets the "report_definition" edge to the ReportDefinition entity by id.
func (m *ReportPermissionMutation) SetReportDefinitionID(id int) {
	m.report_definition = &id
}

// ClearReportDefinition clears the "report_definition" edge to the ReportDefinition entity.
func (m *ReportPermissionMutation) ClearReportDefinition() {
	m.clearedreport_definition = true
}

// ReportDefinitionCleared reports if the "report_definition" edge to the ReportDefinition entity was cleared.
func (m *ReportPermissionMutation) ReportDefinitionCleared() bool {
	return m.clearedreport_definition
}

// ReportDefinitionID returns the "report_definition" edge ID in the mutation.
func (m *ReportPermissionMutation) ReportDefinitionID() (id int, exists bool) {
	if m.report_definition != nil {
		return *m.report_definition, true
	}
	return
}

// ReportDefinitionIDs returns the "report_definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReportDefinitionID instead. It exists only for internal usage by the builders.
func (m *ReportPermissionMutation) ReportDefinitionIDs() (ids []int) {
	if id := m.report_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReportDefinition resets all changes to the "report_definition" edge.
func (m *ReportPermissionMutation) ResetReportDefinition() {
	m.report_definition = nil
	m.clearedreport_definition = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ReportPermissionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ReportPermissionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ReportPermissionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ReportPermissionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ReportPermissionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ReportPermissionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ReportPermissionMutation builder.
func (m *ReportPermissionMutation) Where(ps ...predicate.ReportPermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReportPermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReportPermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReportPermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReportPermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReportPermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReportPermission).
func (m *ReportPermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportPermissionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.role_id != nil {
		fields = append(fields, reportpermission.FieldRoleID)
	}
	if m.can_view != nil {
		fields = append(fields, reportpermission.FieldCanView)
	}
	if m.can_edit != nil {
		fields = append(fields, reportpermission.FieldCanEdit)
	}
	if m.can_delete != nil {
		fields = append(fields, reportpermission.FieldCanDelete)
	}
	if m.can_schedule != nil {
		fields = append(fields, reportpermission.FieldCanSchedule)
	}
	if m.created_at != nil {
		fields = append(fields, reportpermission.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportPermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reportpermission.FieldRoleID:
		return m.RoleID()
	case reportpermission.FieldCanView:
		return m.CanView()
	case reportpermission.FieldCanEdit:
		return m.CanEdit()
	case reportpermission.FieldCanDelete:
		return m.CanDelete()
	case reportpermission.FieldCanSchedule:
		return m.CanSchedule()
	case reportpermission.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportPermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reportpermission.FieldRoleID:
		return m.OldRoleID(ctx)
	case reportpermission.FieldCanView:
		return m.OldCanView(ctx)
	case reportpermission.FieldCanEdit:
		return m.OldCanEdit(ctx)
	case reportpermission.FieldCanDelete:
		return m.OldCanDelete(ctx)
	case reportpermission.FieldCanSchedule:
		return m.OldCanSchedule(ctx)
	case reportpermission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ReportPermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportPermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reportpermission.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case reportpermission.FieldCanView:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanView(v)
		return nil
	case reportpermission.FieldCanEdit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanEdit(v)
		return nil
	case reportpermission.FieldCanDelete:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanDelete(v)
		return nil
	case reportpermission.FieldCanSchedule:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanSchedule(v)
		return nil
	case reportpermission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ReportPermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportPermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportPermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportPermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReportPermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportPermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reportpermission.FieldRoleID) {
		fields = append(fields, reportpermission.FieldRoleID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportPermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportPermissionMutation) ClearField(name string) error {
	switch name {
	case reportpermission.FieldRoleID:
		m.ClearRoleID()
		return nil
	}
	return fmt.Errorf("unknown ReportPermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportPermissionMutation) ResetField(name string) error {
	switch name {
	case reportpermission.FieldRoleID:
		m.ResetRoleID()
		return nil
	case reportpermission.FieldCanView:
		m.ResetCanView()
		return nil
	case reportpermission.FieldCanEdit:
		m.ResetCanEdit()
		return nil
	case reportpermission.FieldCanDelete:
		m.ResetCanDelete()
		return nil
	case reportpermission.FieldCanSchedule:
		m.ResetCanSchedule()
		return nil
	case reportpermission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ReportPermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportPermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.report_definition != nil {
		edges = append(edges, reportpermission.EdgeReportDefinition)
	}
	if m.user != nil {
		edges = append(edges, reportpermission.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportPermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reportpermission.EdgeReportDefinition:
		if id := m.report_definition; id != nil {
			return []ent.Value{*id}
		}
	case reportpermission.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportPermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportPermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportPermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedreport_definition {
		edges = append(edges, reportpermission.EdgeReportDefinition)
	}
	if m.cleareduser {
		edges = append(edges, reportpermission.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportPermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case reportpermission.EdgeReportDefinition:
		return m.clearedreport_definition
	case reportpermission.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportPermissionMutation) ClearEdge(name string) error {
	switch name {
	case reportpermission.EdgeReportDefinition:
		m.ClearReportDefinition()
		return nil
	case reportpermission.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ReportPermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportPermissionMutation) ResetEdge(name string) error {
	switch name {
	case reportpermission.EdgeReportDefinition:
		m.ResetReportDefinition()
		return nil
	case reportpermission.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ReportPermission edge %s", name)
}

// RolePermissionMutation represents an operation that mutates the RolePermission nodes in the graph.
type RolePermissionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	role              *rolepermission.Role
	clearedFields     map[string]struct{}
	permission        *int
	clearedpermission bool
	done              bool
	oldValue          func(context.Context) (*RolePermission, error)
	predicates        []predicate.RolePermission
}

var _ ent.Mutation = (*RolePermissionMutation)(nil)

// rolepermissionOption allows management of the mutation configuration using functional options.
type rolepermissionOption func(*RolePermissionMutation)

// newRolePermissionMutation creates new mutation for the RolePermission entity.
func newRolePermissionMutation(c config, op Op, opts ...rolepermissionOption) *RolePermissionMutation {
	m := &RolePermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeRolePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRolePermissionID sets the ID field of the mutation.
func withRolePermissionID(id int) rolepermissionOption {
	return func(m *RolePermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *RolePermission
		)
		m.oldValue = func(ctx context.Context) (*RolePermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RolePermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRolePermission sets the old RolePermission of the mutation.
func withRolePermission(node *RolePermission) rolepermissionOption {
	return func(m *RolePermissionMutation) {
		m.oldValue = func(context.Context) (*RolePermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RolePermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RolePermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RolePermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RolePermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RolePermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *RolePermissionMutation) SetRole(r rolepermission.Role) {
	m.role = &r
}

// Role returns the value of the "role" field in the mutation.
func (m *RolePermissionMutation) Role() (r rolepermission.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the RolePermission entity.
// If the RolePermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RolePermissionMutation) OldRole(ctx context.Context) (v rolepermission.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *RolePermissionMutation) ResetRole() {
	m.role = nil
}

// SetPermissionID sets the "permission" edge to the Permission entity by id.
func (m *RolePermissionMutation) SetPermissionID(id int) {
	m.permission = &id
}

// ClearPermission clears the "permission" edge to the Permission entity.
func (m *RolePermissionMutation) ClearPermission() {
	m.clearedpermission = true
}

// PermissionCleared reports if the "permission" edge to the Permission entity was cleared.
func (m *RolePermissionMutation) PermissionCleared() bool {
	return m.clearedpermission
}

// PermissionID returns the "permission" edge ID in the mutation.
func (m *RolePermissionMutation) PermissionID() (id int, exists bool) {
	if m.permission != nil {
		return *m.permission, true
	}
	return
}

// PermissionIDs returns the "permission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PermissionID instead. It exists only for internal usage by the builders.
func (m *RolePermissionMutation) PermissionIDs() (ids []int) {
	if id := m.permission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPermission resets all changes to the "permission" edge.
func (m *RolePermissionMutation) ResetPermission() {
	m.permission = nil
	m.clearedpermission = false
}

// Where appends a list predicates to the RolePermissionMutation builder.
func (m *RolePermissionMutation) Where(ps ...predicate.RolePermission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RolePermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RolePermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RolePermission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RolePermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RolePermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RolePermission).
func (m *RolePermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RolePermissionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.role != nil {
		fields = append(fields, rolepermission.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RolePermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rolepermission.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RolePermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rolepermission.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown RolePermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rolepermission.FieldRole:
		v, ok := value.(rolepermission.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RolePermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RolePermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RolePermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RolePermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RolePermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RolePermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RolePermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RolePermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RolePermissionMutation) ResetField(name string) error {
	switch name {
	case rolepermission.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown RolePermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RolePermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.permission != nil {
		edges = append(edges, rolepermission.EdgePermission)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RolePermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rolepermission.EdgePermission:
		if id := m.permission; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RolePermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RolePermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RolePermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpermission {
		edges = append(edges, rolepermission.EdgePermission)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RolePermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case rolepermission.EdgePermission:
		return m.clearedpermission
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RolePermissionMutation) ClearEdge(name string) error {
	switch name {
	case rolepermission.EdgePermission:
		m.ClearPermission()
		return nil
	}
	return fmt.Errorf("unknown RolePermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RolePermissionMutation) ResetEdge(name string) error {
	switch name {
	case rolepermission.EdgePermission:
		m.ResetPermission()
		return nil
	}
	return fmt.Errorf("unknown RolePermission edge %s", name)
}

// ScheduledReportMutation represents an operation that mutates the ScheduledReport nodes in the graph.
type ScheduledReportMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	frequency                *string
	day_of_week              *int
	addday_of_week           *int
	day_of_month             *int
	addday_of_month          *int
	time                     *string
	timezone                 *string
	recipients               *[]map[string]interface{}
	appendrecipients         []map[string]interface{}
	format                   *scheduledreport.Format
	parameters               *map[string]interface{}
	is_active                *bool
	last_run_at              *time.Time
	next_run_at              *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	report_definition        *int
	clearedreport_definition bool
	creator                  *int
	clearedcreator           bool
	done                     bool
	oldValue                 func(context.Context) (*ScheduledReport, error)
	predicates               []predicate.ScheduledReport
}

var _ ent.Mutation = (*ScheduledReportMutation)(nil)

// scheduledreportOption allows management of the mutation configuration using functional options.
type scheduledreportOption func(*ScheduledReportMutation)

// newScheduledReportMutation creates new mutation for the ScheduledReport entity.
func newScheduledReportMutation(c config, op Op, opts ...scheduledreportOption) *ScheduledReportMutation {
	m := &ScheduledReportMutation{
		config:        c,
		op:            op,
		typ:           TypeScheduledReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduledReportID sets the ID field of the mutation.
func withScheduledReportID(id int) scheduledreportOption {
	return func(m *ScheduledReportMutation) {
		var (
			err   error
			once  sync.Once
			value *ScheduledReport
		)
		m.oldValue = func(ctx context.Context) (*ScheduledReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScheduledReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheduledReport sets the old ScheduledReport of the mutation.
func withScheduledReport(node *ScheduledReport) scheduledreportOption {
	return func(m *ScheduledReportMutation) {
		m.oldValue = func(context.Context) (*ScheduledReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduledReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduledReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduledReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduledReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScheduledReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFrequency sets the "frequency" field.
func (m *ScheduledReportMutation) SetFrequency(s string) {
	m.frequency = &s
}

// Frequency returns the value of the "frequency" field in the mutation.
func (m *ScheduledReportMutation) Frequency() (r string, exists bool) {
	v := m.frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequency returns the old "frequency" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldFrequency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequency: %w", err)
	}
	return oldValue.Frequency, nil
}

// ResetFrequency resets all changes to the "frequency" field.
func (m *ScheduledReportMutation) ResetFrequency() {
	m.frequency = nil
}

// SetDayOfWeek sets the "day_of_week" field.
func (m *ScheduledReportMutation) SetDayOfWeek(i int) {
	m.day_of_week = &i
	m.addday_of_week = nil
}

// DayOfWeek returns the value of the "day_of_week" field in the mutation.
func (m *ScheduledReportMutation) DayOfWeek() (r int, exists bool) {
	v := m.day_of_week
	if v == nil {
		return
	}
	return *v, true
}

// OldDayOfWeek returns the old "day_of_week" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldDayOfWeek(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayOfWeek is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayOfWeek requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayOfWeek: %w", err)
	}
	return oldValue.DayOfWeek, nil
}

// AddDayOfWeek adds i to the "day_of_week" field.
func (m *ScheduledReportMutation) AddDayOfWeek(i int) {
	if m.addday_of_week != nil {
		*m.addday_of_week += i
	} else {
		m.addday_of_week = &i
	}
}

// AddedDayOfWeek returns the value that was added to the "day_of_week" field in this mutation.
func (m *ScheduledReportMutation) AddedDayOfWeek() (r int, exists bool) {
	v := m.addday_of_week
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayOfWeek clears the value of the "day_of_week" field.
func (m *ScheduledReportMutation) ClearDayOfWeek() {
	m.day_of_week = nil
	m.addday_of_week = nil
	m.clearedFields[scheduledreport.FieldDayOfWeek] = struct{}{}
}

// DayOfWeekCleared returns if the "day_of_week" field was cleared in this mutation.
func (m *ScheduledReportMutation) DayOfWeekCleared() bool {
	_, ok := m.clearedFields[scheduledreport.FieldDayOfWeek]
	return ok
}

// ResetDayOfWeek resets all changes to the "day_of_week" field.
func (m *ScheduledReportMutation) ResetDayOfWeek() {
	m.day_of_week = nil
	m.addday_of_week = nil
	delete(m.clearedFields, scheduledreport.FieldDayOfWeek)
}

// SetDayOfMonth sets the "day_of_month" field.
func (m *ScheduledReportMutation) SetDayOfMonth(i int) {
	m.day_of_month = &i
	m.addday_of_month = nil
}

// DayOfMonth returns the value of the "day_of_month" field in the mutation.
func (m *ScheduledReportMutation) DayOfMonth() (r int, exists bool) {
	v := m.day_of_month
	if v == nil {
		return
	}
	return *v, true
}

// OldDayOfMonth returns the old "day_of_month" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldDayOfMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayOfMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayOfMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayOfMonth: %w", err)
	}
	return oldValue.DayOfMonth, nil
}

// AddDayOfMonth adds i to the "day_of_month" field.
func (m *ScheduledReportMutation) AddDayOfMonth(i int) {
	if m.addday_of_month != nil {
		*m.addday_of_month += i
	} else {
		m.addday_of_month = &i
	}
}

// AddedDayOfMonth returns the value that was added to the "day_of_month" field in this mutation.
func (m *ScheduledReportMutation) AddedDayOfMonth() (r int, exists bool) {
	v := m.addday_of_month
	if v == nil {
		return
	}
	return *v, true
}

// ClearDayOfMonth clears the value of the "day_of_month" field.
func (m *ScheduledReportMutation) ClearDayOfMonth() {
	m.day_of_month = nil
	m.addday_of_month = nil
	m.clearedFields[scheduledreport.FieldDayOfMonth] = struct{}{}
}

// DayOfMonthCleared returns if the "day_of_month" field was cleared in this mutation.
func (m *ScheduledReportMutation) DayOfMonthCleared() bool {
	_, ok := m.clearedFields[scheduledreport.FieldDayOfMonth]
	return ok
}

// ResetDayOfMonth resets all changes to the "day_of_month" field.
func (m *ScheduledReportMutation) ResetDayOfMonth() {
	m.day_of_month = nil
	m.addday_of_month = nil
	delete(m.clearedFields, scheduledreport.FieldDayOfMonth)
}

// SetTime sets the "time" field.
func (m *ScheduledReportMutation) SetTime(s string) {
	m.time = &s
}

// Time returns the value of the "time" field in the mutation.
func (m *ScheduledReportMutation) Time() (r string, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ClearTime clears the value of the "time" field.
func (m *ScheduledReportMutation) ClearTime() {
	m.time = nil
	m.clearedFields[scheduledreport.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *ScheduledReportMutation) TimeCleared() bool {
	_, ok := m.clearedFields[scheduledreport.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *ScheduledReportMutation) ResetTime() {
	m.time = nil
	delete(m.clearedFields, scheduledreport.FieldTime)
}

// SetTimezone sets the "timezone" field.
func (m *ScheduledReportMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *ScheduledReportMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *ScheduledReportMutation) ResetTimezone() {
	m.timezone = nil
}

// SetRecipients sets the "recipients" field.
func (m *ScheduledReportMutation) SetRecipients(value []map[string]interface{}) {
	m.recipients = &value
	m.appendrecipients = nil
}

// Recipients returns the value of the "recipients" field in the mutation.
func (m *ScheduledReportMutation) Recipients() (r []map[string]interface{}, exists bool) {
	v := m.recipients
	if v == nil {
		return
	}
	return *v, true
}

// OldRecipients returns the old "recipients" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldRecipients(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecipients is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecipients requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecipients: %w", err)
	}
	return oldValue.Recipients, nil
}

// AppendRecipients adds value to the "recipients" field.
func (m *ScheduledReportMutation) AppendRecipients(value []map[string]interface{}) {
	m.appendrecipients = append(m.appendrecipients, value...)
}

// AppendedRecipients returns the list of values that were appended to the "recipients" field in this mutation.
func (m *ScheduledReportMutation) AppendedRecipients() ([]map[string]interface{}, bool) {
	if len(m.appendrecipients) == 0 {
		return nil, false
	}
	return m.appendrecipients, true
}

// ResetRecipients resets all changes to the "recipients" field.
func (m *ScheduledReportMutation) ResetRecipients() {
	m.recipients = nil
	m.appendrecipients = nil
}

// SetFormat sets the "format" field.
func (m *ScheduledReportMutation) SetFormat(s scheduledreport.Format) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *ScheduledReportMutation) Format() (r scheduledreport.Format, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldFormat(ctx context.Context) (v scheduledreport.Format, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *ScheduledReportMutation) ResetFormat() {
	m.format = nil
}

// SetParameters sets the "parameters" field.
func (m *ScheduledReportMutation) SetParameters(value map[string]interface{}) {
	m.parameters = &value
}

// Parameters returns the value of the "parameters" field in the mutation.
func (m *ScheduledReportMutation) Parameters() (r map[string]interface{}, exists bool) {
	v := m.parameters
	if v == nil {
		return
	}
	return *v, true
}

// OldParameters returns the old "parameters" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldParameters(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParameters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParameters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParameters: %w", err)
	}
	return oldValue.Parameters, nil
}

// ClearParameters clears the value of the "parameters" field.
func (m *ScheduledReportMutation) ClearParameters() {
	m.parameters = nil
	m.clearedFields[scheduledreport.FieldParameters] = struct{}{}
}

// ParametersCleared returns if the "parameters" field was cleared in this mutation.
func (m *ScheduledReportMutation) ParametersCleared() bool {
	_, ok := m.clearedFields[scheduledreport.FieldParameters]
	return ok
}

// ResetParameters resets all changes to the "parameters" field.
func (m *ScheduledReportMutation) ResetParameters() {
	m.parameters = nil
	delete(m.clearedFields, scheduledreport.FieldParameters)
}

// SetIsActive sets the "is_active" field.
func (m *ScheduledReportMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ScheduledReportMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ScheduledReportMutation) ResetIsActive() {
	m.is_active = nil
}

// SetLastRunAt sets the "last_run_at" field.
func (m *ScheduledReportMutation) SetLastRunAt(t time.Time) {
	m.last_run_at = &t
}

// LastRunAt returns the value of the "last_run_at" field in the mutation.
func (m *ScheduledReportMutation) LastRunAt() (r time.Time, exists bool) {
	v := m.last_run_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRunAt returns the old "last_run_at" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldLastRunAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRunAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRunAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRunAt: %w", err)
	}
	return oldValue.LastRunAt, nil
}

// ClearLastRunAt clears the value of the "last_run_at" field.
func (m *ScheduledReportMutation) ClearLastRunAt() {
	m.last_run_at = nil
	m.clearedFields[scheduledreport.FieldLastRunAt] = struct{}{}
}

// LastRunAtCleared returns if the "last_run_at" field was cleared in this mutation.
func (m *ScheduledReportMutation) LastRunAtCleared() bool {
	_, ok := m.clearedFields[scheduledreport.FieldLastRunAt]
	return ok
}

// ResetLastRunAt resets all changes to the "last_run_at" field.
func (m *ScheduledReportMutation) ResetLastRunAt() {
	m.last_run_at = nil
	delete(m.clearedFields, scheduledreport.FieldLastRunAt)
}

// SetNextRunAt sets the "next_run_at" field.
func (m *ScheduledReportMutation) SetNextRunAt(t time.Time) {
	m.next_run_at = &t
}

// NextRunAt returns the value of the "next_run_at" field in the mutation.
func (m *ScheduledReportMutation) NextRunAt() (r time.Time, exists bool) {
	v := m.next_run_at
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRunAt returns the old "next_run_at" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldNextRunAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRunAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRunAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRunAt: %w", err)
	}
	return oldValue.NextRunAt, nil
}

// ClearNextRunAt clears the value of the "next_run_at" field.
func (m *ScheduledReportMutation) ClearNextRunAt() {
	m.next_run_at = nil
	m.clearedFields[scheduledreport.FieldNextRunAt] = struct{}{}
}

// NextRunAtCleared returns if the "next_run_at" field was cleared in this mutation.
func (m *ScheduledReportMutation) NextRunAtCleared() bool {
	_, ok := m.clearedFields[scheduledreport.FieldNextRunAt]
	return ok
}

// ResetNextRunAt resets all changes to the "next_run_at" field.
func (m *ScheduledReportMutation) ResetNextRunAt() {
	m.next_run_at = nil
	delete(m.clearedFields, scheduledreport.FieldNextRunAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ScheduledReportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScheduledReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScheduledReportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScheduledReportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScheduledReportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScheduledReport entity.
// If the ScheduledReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledReportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScheduledReportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetReportDefinitionID sets the "report_definition" edge to the ReportDefinition entity by id.
func (m *ScheduledReportMutation) SetReportDefinitionID(id int) {
	m.report_definition = &id
}

// ClearReportDefinition clears the "report_definition" edge to the ReportDefinition entity.
func (m *ScheduledReportMutation) ClearReportDefinition() {
	m.clearedreport_definition = true
}

// ReportDefinitionCleared reports if the "report_definition" edge to the ReportDefinition entity was cleared.
func (m *ScheduledReportMutation) ReportDefinitionCleared() bool {
	return m.clearedreport_definition
}

// ReportDefinitionID returns the "report_definition" edge ID in the mutation.
func (m *ScheduledReportMutation) ReportDefinitionID() (id int, exists bool) {
	if m.report_definition != nil {
		return *m.report_definition, true
	}
	return
}

// ReportDefinitionIDs returns the "report_definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReportDefinitionID instead. It exists only for internal usage by the builders.
func (m *ScheduledReportMutation) ReportDefinitionIDs() (ids []int) {
	if id := m.report_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReportDefinition resets all changes to the "report_definition" edge.
func (m *ScheduledReportMutation) ResetReportDefinition() {
	m.report_definition = nil
	m.clearedreport_definition = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *ScheduledReportMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *ScheduledReportMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *ScheduledReportMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *ScheduledReportMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *ScheduledReportMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *ScheduledReportMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the ScheduledReportMutation builder.
func (m *ScheduledReportMutation) Where(ps ...predicate.ScheduledReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduledReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduledReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScheduledReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduledReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduledReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScheduledReport).
func (m *ScheduledReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduledReportMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.frequency != nil {
		fields = append(fields, scheduledreport.FieldFrequency)
	}
	if m.day_of_week != nil {
		fields = append(fields, scheduledreport.FieldDayOfWeek)
	}
	if m.day_of_month != nil {
		fields = append(fields, scheduledreport.FieldDayOfMonth)
	}
	if m.time != nil {
		fields = append(fields, scheduledreport.FieldTime)
	}
	if m.timezone != nil {
		fields = append(fields, scheduledreport.FieldTimezone)
	}
	if m.recipients != nil {
		fields = append(fields, scheduledreport.FieldRecipients)
	}
	if m.format != nil {
		fields = append(fields, scheduledreport.FieldFormat)
	}
	if m.parameters != nil {
		fields = append(fields, scheduledreport.FieldParameters)
	}
	if m.is_active != nil {
		fields = append(fields, scheduledreport.FieldIsActive)
	}
	if m.last_run_at != nil {
		fields = append(fields, scheduledreport.FieldLastRunAt)
	}
	if m.next_run_at != nil {
		fields = append(fields, scheduledreport.FieldNextRunAt)
	}
	if m.created_at != nil {
		fields = append(fields, scheduledreport.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, scheduledreport.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduledReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scheduledreport.FieldFrequency:
		return m.Frequency()
	case scheduledreport.FieldDayOfWeek:
		return m.DayOfWeek()
	case scheduledreport.FieldDayOfMonth:
		return m.DayOfMonth()
	case scheduledreport.FieldTime:
		return m.Time()
	case scheduledreport.FieldTimezone:
		return m.Timezone()
	case scheduledreport.FieldRecipients:
		return m.Recipients()
	case scheduledreport.FieldFormat:
		return m.Format()
	case scheduledreport.FieldParameters:
		return m.Parameters()
	case scheduledreport.FieldIsActive:
		return m.IsActive()
	case scheduledreport.FieldLastRunAt:
		return m.LastRunAt()
	case scheduledreport.FieldNextRunAt:
		return m.NextRunAt()
	case scheduledreport.FieldCreatedAt:
		return m.CreatedAt()
	case scheduledreport.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduledReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scheduledreport.FieldFrequency:
		return m.OldFrequency(ctx)
	case scheduledreport.FieldDayOfWeek:
		return m.OldDayOfWeek(ctx)
	case scheduledreport.FieldDayOfMonth:
		return m.OldDayOfMonth(ctx)
	case scheduledreport.FieldTime:
		return m.OldTime(ctx)
	case scheduledreport.FieldTimezone:
		return m.OldTimezone(ctx)
	case scheduledreport.FieldRecipients:
		return m.OldRecipients(ctx)
	case scheduledreport.FieldFormat:
		return m.OldFormat(ctx)
	case scheduledreport.FieldParameters:
		return m.OldParameters(ctx)
	case scheduledreport.FieldIsActive:
		return m.OldIsActive(ctx)
	case scheduledreport.FieldLastRunAt:
		return m.OldLastRunAt(ctx)
	case scheduledreport.FieldNextRunAt:
		return m.OldNextRunAt(ctx)
	case scheduledreport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case scheduledreport.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ScheduledReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduledReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scheduledreport.FieldFrequency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequency(v)
		return nil
	case scheduledreport.FieldDayOfWeek:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayOfWeek(v)
		return nil
	case scheduledreport.FieldDayOfMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayOfMonth(v)
		return nil
	case scheduledreport.FieldTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case scheduledreport.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case scheduledreport.FieldRecipients:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecipients(v)
		return nil
	case scheduledreport.FieldFormat:
		v, ok := value.(scheduledreport.Format)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case scheduledreport.FieldParameters:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParameters(v)
		return nil
	case scheduledreport.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case scheduledreport.FieldLastRunAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRunAt(v)
		return nil
	case scheduledreport.FieldNextRunAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRunAt(v)
		return nil
	case scheduledreport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case scheduledreport.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduledReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduledReportMutation) AddedFields() []string {
	var fields []string
	if m.addday_of_week != nil {
		fields = append(fields, scheduledreport.FieldDayOfWeek)
	}
	if m.addday_of_month != nil {
		fields = append(fields, scheduledreport.FieldDayOfMonth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduledReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scheduledreport.FieldDayOfWeek:
		return m.AddedDayOfWeek()
	case scheduledreport.FieldDayOfMonth:
		return m.AddedDayOfMonth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduledReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scheduledreport.FieldDayOfWeek:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayOfWeek(v)
		return nil
	case scheduledreport.FieldDayOfMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayOfMonth(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduledReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduledReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scheduledreport.FieldDayOfWeek) {
		fields = append(fields, scheduledreport.FieldDayOfWeek)
	}
	if m.FieldCleared(scheduledreport.FieldDayOfMonth) {
		fields = append(fields, scheduledreport.FieldDayOfMonth)
	}
	if m.FieldCleared(scheduledreport.FieldTime) {
		fields = append(fields, scheduledreport.FieldTime)
	}
	if m.FieldCleared(scheduledreport.FieldParameters) {
		fields = append(fields, scheduledreport.FieldParameters)
	}
	if m.FieldCleared(scheduledreport.FieldLastRunAt) {
		fields = append(fields, scheduledreport.FieldLastRunAt)
	}
	if m.FieldCleared(scheduledreport.FieldNextRunAt) {
		fields = append(fields, scheduledreport.FieldNextRunAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduledReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduledReportMutation) ClearField(name string) error {
	switch name {
	case scheduledreport.FieldDayOfWeek:
		m.ClearDayOfWeek()
		return nil
	case scheduledreport.FieldDayOfMonth:
		m.ClearDayOfMonth()
		return nil
	case scheduledreport.FieldTime:
		m.ClearTime()
		return nil
	case scheduledreport.FieldParameters:
		m.ClearParameters()
		return nil
	case scheduledreport.FieldLastRunAt:
		m.ClearLastRunAt()
		return nil
	case scheduledreport.FieldNextRunAt:
		m.ClearNextRunAt()
		return nil
	}
	return fmt.Errorf("unknown ScheduledReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduledReportMutation) ResetField(name string) error {
	switch name {
	case scheduledreport.FieldFrequency:
		m.ResetFrequency()
		return nil
	case scheduledreport.FieldDayOfWeek:
		m.ResetDayOfWeek()
		return nil
	case scheduledreport.FieldDayOfMonth:
		m.ResetDayOfMonth()
		return nil
	case scheduledreport.FieldTime:
		m.ResetTime()
		return nil
	case scheduledreport.FieldTimezone:
		m.ResetTimezone()
		return nil
	case scheduledreport.FieldRecipients:
		m.ResetRecipients()
		return nil
	case scheduledreport.FieldFormat:
		m.ResetFormat()
		return nil
	case scheduledreport.FieldParameters:
		m.ResetParameters()
		return nil
	case scheduledreport.FieldIsActive:
		m.ResetIsActive()
		return nil
	case scheduledreport.FieldLastRunAt:
		m.ResetLastRunAt()
		return nil
	case scheduledreport.FieldNextRunAt:
		m.ResetNextRunAt()
		return nil
	case scheduledreport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case scheduledreport.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ScheduledReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduledReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.report_definition != nil {
		edges = append(edges, scheduledreport.EdgeReportDefinition)
	}
	if m.creator != nil {
		edges = append(edges, scheduledreport.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduledReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scheduledreport.EdgeReportDefinition:
		if id := m.report_definition; id != nil {
			return []ent.Value{*id}
		}
	case scheduledreport.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduledReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduledReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduledReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedreport_definition {
		edges = append(edges, scheduledreport.EdgeReportDefinition)
	}
	if m.clearedcreator {
		edges = append(edges, scheduledreport.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduledReportMutation) EdgeCleared(name string) bool {
	switch name {
	case scheduledreport.EdgeReportDefinition:
		return m.clearedreport_definition
	case scheduledreport.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduledReportMutation) ClearEdge(name string) error {
	switch name {
	case scheduledreport.EdgeReportDefinition:
		m.ClearReportDefinition()
		return nil
	case scheduledreport.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown ScheduledReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduledReportMutation) ResetEdge(name string) error {
	switch name {
	case scheduledreport.EdgeReportDefinition:
		m.ResetReportDefinition()
		return nil
	case scheduledreport.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown ScheduledReport edge %s", name)
}

// SeoConfigMutation represents an operation that mutates the SeoConfig nodes in the graph.
type SeoConfigMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	meta_title          *map[string]string
	meta_description    *map[string]string
	keywords            *map[string][]string
	og_title            *map[string]string
	og_description      *map[string]string
	og_image_url        *string
	og_type             *string
	twitter_card        *string
	twitter_title       *map[string]string
	twitter_description *map[string]string
	twitter_image_url   *string
	canonical_url       *string
	noindex             *bool
	nofollow            *bool
	structured_data     *map[string]interface{}
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	page                *int
	clearedpage         bool
	done                bool
	oldValue            func(context.Context) (*SeoConfig, error)
	predicates          []predicate.SeoConfig
}

var _ ent.Mutation = (*SeoConfigMutation)(nil)

// seoconfigOption allows management of the mutation configuration using functional options.
type seoconfigOption func(*SeoConfigMutation)

// newSeoConfigMutation creates new mutation for the SeoConfig entity.
func newSeoConfigMutation(c config, op Op, opts ...seoconfigOption) *SeoConfigMutation {
	m := &SeoConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeSeoConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeoConfigID sets the ID field of the mutation.
func withSeoConfigID(id int) seoconfigOption {
	return func(m *SeoConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *SeoConfig
		)
		m.oldValue = func(ctx context.Context) (*SeoConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SeoConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeoConfig sets the old SeoConfig of the mutation.
func withSeoConfig(node *SeoConfig) seoconfigOption {
	return func(m *SeoConfigMutation) {
		m.oldValue = func(context.Context) (*SeoConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeoConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeoConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeoConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeoConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SeoConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMetaTitle sets the "meta_title" field.
func (m *SeoConfigMutation) SetMetaTitle(value map[string]string) {
	m.meta_title = &value
}

// MetaTitle returns the value of the "meta_title" field in the mutation.
func (m *SeoConfigMutation) MetaTitle() (r map[string]string, exists bool) {
	v := m.meta_title
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaTitle returns the old "meta_title" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldMetaTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaTitle: %w", err)
	}
	return oldValue.MetaTitle, nil
}

// ResetMetaTitle resets all changes to the "meta_title" field.
func (m *SeoConfigMutation) ResetMetaTitle() {
	m.meta_title = nil
}

// SetMetaDescription sets the "meta_description" field.
func (m *SeoConfigMutation) SetMetaDescription(value map[string]string) {
	m.meta_description = &value
}

// MetaDescription returns the value of the "meta_description" field in the mutation.
func (m *SeoConfigMutation) MetaDescription() (r map[string]string, exists bool) {
	v := m.meta_description
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaDescription returns the old "meta_description" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldMetaDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaDescription: %w", err)
	}
	return oldValue.MetaDescription, nil
}

// ClearMetaDescription clears the value of the "meta_description" field.
func (m *SeoConfigMutation) ClearMetaDescription() {
	m.meta_description = nil
	m.clearedFields[seoconfig.FieldMetaDescription] = struct{}{}
}

// MetaDescriptionCleared returns if the "meta_description" field was cleared in this mutation.
func (m *SeoConfigMutation) MetaDescriptionCleared() bool {
	_, ok := m.clearedFields[seoconfig.FieldMetaDescription]
	return ok
}

// ResetMetaDescription resets all changes to the "meta_description" field.
func (m *SeoConfigMutation) ResetMetaDescription() {
	m.meta_description = nil
	delete(m.clearedFields, seoconfig.FieldMetaDescription)
}

// SetKeywords sets the "keywords" field.
func (m *SeoConfigMutation) SetKeywords(value map[string][]string) {
	m.keywords = &value
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *SeoConfigMutation) Keywords() (r map[string][]string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldKeywords(ctx context.Context) (v map[string][]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// ClearKeywords clears the value of the "keywords" field.
func (m *SeoConfigMutation) ClearKeywords() {
	m.keywords = nil
	m.clearedFields[seoconfig.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *SeoConfigMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[seoconfig.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *SeoConfigMutation) ResetKeywords() {
	m.keywords = nil
	delete(m.clearedFields, seoconfig.FieldKeywords)
}

// SetOgTitle sets the "og_title" field.
func (m *SeoConfigMutation) SetOgTitle(value map[string]string) {
	m.og_title = &value
}

// OgTitle returns the value of the "og_title" field in the mutation.
func (m *SeoConfigMutation) OgTitle() (r map[string]string, exists bool) {
	v := m.og_title
	if v == nil {
		return
	}
	return *v, true
}

// OldOgTitle returns the old "og_title" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldOgTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOgTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOgTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOgTitle: %w", err)
	}
	return oldValue.OgTitle, nil
}

// ClearOgTitle clears the value of the "og_title" field.
func (m *SeoConfigMutation) ClearOgTitle() {
	m.og_title = nil
	m.clearedFields[seoconfig.FieldOgTitle] = struct{}{}
}

// OgTitleCleared returns if the "og_title" field was cleared in this mutation.
func (m *SeoConfigMutation) OgTitleCleared() bool {
	_, ok := m.clearedFields[seoconfig.FieldOgTitle]
	return ok
}

// ResetOgTitle resets all changes to the "og_title" field.
func (m *SeoConfigMutation) ResetOgTitle() {
	m.og_title = nil
	delete(m.clearedFields, seoconfig.FieldOgTitle)
}

// SetOgDescription sets the "og_description" field.
func (m *SeoConfigMutation) SetOgDescription(value map[string]string) {
	m.og_description = &value
}

// OgDescription returns the value of the "og_description" field in the mutation.
func (m *SeoConfigMutation) OgDescription() (r map[string]string, exists bool) {
	v := m.og_description
	if v == nil {
		return
	}
	return *v, true
}

// OldOgDescription returns the old "og_description" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldOgDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOgDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOgDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOgDescription: %w", err)
	}
	return oldValue.OgDescription, nil
}

// ClearOgDescription clears the value of the "og_description" field.
func (m *SeoConfigMutation) ClearOgDescription() {
	m.og_description = nil
	m.clearedFields[seoconfig.FieldOgDescription] = struct{}{}
}

// OgDescriptionCleared returns if the "og_description" field was cleared in this mutation.
func (m *SeoConfigMutation) OgDescriptionCleared() bool {
	_, ok := m.clearedFields[seoconfig.FieldOgDescription]
	return ok
}

// ResetOgDescription resets all changes to the "og_description" field.
func (m *SeoConfigMutation) ResetOgDescription() {
	m.og_description = nil
	delete(m.clearedFields, seoconfig.FieldOgDescription)
}

// SetOgImageURL sets the "og_image_url" field.
func (m *SeoConfigMutation) SetOgImageURL(s string) {
	m.og_image_url = &s
}

// OgImageURL returns the value of the "og_image_url" field in the mutation.
func (m *SeoConfigMutation) OgImageURL() (r string, exists bool) {
	v := m.og_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOgImageURL returns the old "og_image_url" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldOgImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOgImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOgImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOgImageURL: %w", err)
	}
	return oldValue.OgImageURL, nil
}

// ClearOgImageURL clears the value of the "og_image_url" field.
func (m *SeoConfigMutation) ClearOgImageURL() {
	m.og_image_url = nil
	m.clearedFields[seoconfig.FieldOgImageURL] = struct{}{}
}

// OgImageURLCleared returns if the "og_image_url" field was cleared in this mutation.
func (m *SeoConfigMutation) OgImageURLCleared() bool {
	_, ok := m.clearedFields[seoconfig.FieldOgImageURL]
	return ok
}

// ResetOgImageURL resets all changes to the "og_image_url" field.
func (m *SeoConfigMutation) ResetOgImageURL() {
	m.og_image_url = nil
	delete(m.clearedFields, seoconfig.FieldOgImageURL)
}

// SetOgType sets the "og_type" field.
func (m *SeoConfigMutation) SetOgType(s string) {
	m.og_type = &s
}

// OgType returns the value of the "og_type" field in the mutation.
func (m *SeoConfigMutation) OgType() (r string, exists bool) {
	v := m.og_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOgType returns the old "og_type" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldOgType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOgType: %w", err)
	}
	return oldValue.OgType, nil
}

// ResetOgType resets all changes to the "og_type" field.
func (m *SeoConfigMutation) ResetOgType() {
	m.og_type = nil
}

// SetTwitterCard sets the "twitter_card" field.
func (m *SeoConfigMutation) SetTwitterCard(s string) {
	m.twitter_card = &s
}

// TwitterCard returns the value of the "twitter_card" field in the mutation.
func (m *SeoConfigMutation) TwitterCard() (r string, exists bool) {
	v := m.twitter_card
	if v == nil {
		return
	}
	return *v, true
}

// OldTwitterCard returns the old "twitter_card" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldTwitterCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwitterCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwitterCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwitterCard: %w", err)
	}
	return oldValue.TwitterCard, nil
}

// ResetTwitterCard resets all changes to the "twitter_card" field.
func (m *SeoConfigMutation) ResetTwitterCard() {
	m.twitter_card = nil
}

// SetTwitterTitle sets the "twitter_title" field.
func (m *SeoConfigMutation) SetTwitterTitle(value map[string]string) {
	m.twitter_title = &value
}

// TwitterTitle returns the value of the "twitter_title" field in the mutation.
func (m *SeoConfigMutation) TwitterTitle() (r map[string]string, exists bool) {
	v := m.twitter_title
	if v == nil {
		return
	}
	return *v, true
}

// OldTwitterTitle returns the old "twitter_title" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldTwitterTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwitterTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwitterTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwitterTitle: %w", err)
	}
	return oldValue.TwitterTitle, nil
}

// ClearTwitterTitle clears the value of the "twitter_title" field.
func (m *SeoConfigMutation) ClearTwitterTitle() {
	m.twitter_title = nil
	m.clearedFields[seoconfig.FieldTwitterTitle] = struct{}{}
}

// TwitterTitleCleared returns if the "twitter_title" field was cleared in this mutation.
func (m *SeoConfigMutation) TwitterTitleCleared() bool {
	_, ok := m.clearedFields[seoconfig.FieldTwitterTitle]
	return ok
}

// ResetTwitterTitle resets all changes to the "twitter_title" field.
func (m *SeoConfigMutation) ResetTwitterTitle() {
	m.twitter_title = nil
	delete(m.clearedFields, seoconfig.FieldTwitterTitle)
}

// SetTwitterDescription sets the "twitter_description" field.
func (m *SeoConfigMutation) SetTwitterDescription(value map[string]string) {
	m.twitter_description = &value
}

// TwitterDescription returns the value of the "twitter_description" field in the mutation.
func (m *SeoConfigMutation) TwitterDescription() (r map[string]string, exists bool) {
	v := m.twitter_description
	if v == nil {
		return
	}
	return *v, true
}

// OldTwitterDescription returns the old "twitter_description" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldTwitterDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwitterDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwitterDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwitterDescription: %w", err)
	}
	return oldValue.TwitterDescription, nil
}

// ClearTwitterDescription clears the value of the "twitter_description" field.
func (m *SeoConfigMutation) ClearTwitterDescription() {
	m.twitter_description = nil
	m.clearedFields[seoconfig.FieldTwitterDescription] = struct{}{}
}

// TwitterDescriptionCleared returns if the "twitter_description" field was cleared in this mutation.
func (m *SeoConfigMutation) TwitterDescriptionCleared() bool {
	_, ok := m.clearedFields[seoconfig.FieldTwitterDescription]
	return ok
}

// ResetTwitterDescription resets all changes to the "twitter_description" field.
func (m *SeoConfigMutation) ResetTwitterDescription() {
	m.twitter_description = nil
	delete(m.clearedFields, seoconfig.FieldTwitterDescription)
}

// SetTwitterImageURL sets the "twitter_image_url" field.
func (m *SeoConfigMutation) SetTwitterImageURL(s string) {
	m.twitter_image_url = &s
}

// TwitterImageURL returns the value of the "twitter_image_url" field in the mutation.
func (m *SeoConfigMutation) TwitterImageURL() (r string, exists bool) {
	v := m.twitter_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTwitterImageURL returns the old "twitter_image_url" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldTwitterImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwitterImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwitterImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwitterImageURL: %w", err)
	}
	return oldValue.TwitterImageURL, nil
}

// ClearTwitterImageURL clears the value of the "twitter_image_url" field.
func (m *SeoConfigMutation) ClearTwitterImageURL() {
	m.twitter_image_url = nil
	m.clearedFields[seoconfig.FieldTwitterImageURL] = struct{}{}
}

// TwitterImageURLCleared returns if the "twitter_image_url" field was cleared in this mutation.
func (m *SeoConfigMutation) TwitterImageURLCleared() bool {
	_, ok := m.clearedFields[seoconfig.FieldTwitterImageURL]
	return ok
}

// ResetTwitterImageURL resets all changes to the "twitter_image_url" field.
func (m *SeoConfigMutation) ResetTwitterImageURL() {
	m.twitter_image_url = nil
	delete(m.clearedFields, seoconfig.FieldTwitterImageURL)
}

// SetCanonicalURL sets the "canonical_url" field.
func (m *SeoConfigMutation) SetCanonicalURL(s string) {
	m.canonical_url = &s
}

// CanonicalURL returns the value of the "canonical_url" field in the mutation.
func (m *SeoConfigMutation) CanonicalURL() (r string, exists bool) {
	v := m.canonical_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCanonicalURL returns the old "canonical_url" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldCanonicalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanonicalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanonicalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanonicalURL: %w", err)
	}
	return oldValue.CanonicalURL, nil
}

// ClearCanonicalURL clears the value of the "canonical_url" field.
func (m *SeoConfigMutation) ClearCanonicalURL() {
	m.canonical_url = nil
	m.clearedFields[seoconfig.FieldCanonicalURL] = struct{}{}
}

// CanonicalURLCleared returns if the "canonical_url" field was cleared in this mutation.
func (m *SeoConfigMutation) CanonicalURLCleared() bool {
	_, ok := m.clearedFields[seoconfig.FieldCanonicalURL]
	return ok
}

// ResetCanonicalURL resets all changes to the "canonical_url" field.
func (m *SeoConfigMutation) ResetCanonicalURL() {
	m.canonical_url = nil
	delete(m.clearedFields, seoconfig.FieldCanonicalURL)
}

// SetNoindex sets the "noindex" field.
func (m *SeoConfigMutation) SetNoindex(b bool) {
	m.noindex = &b
}

// Noindex returns the value of the "noindex" field in the mutation.
func (m *SeoConfigMutation) Noindex() (r bool, exists bool) {
	v := m.noindex
	if v == nil {
		return
	}
	return *v, true
}

// OldNoindex returns the old "noindex" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldNoindex(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoindex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoindex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoindex: %w", err)
	}
	return oldValue.Noindex, nil
}

// ResetNoindex resets all changes to the "noindex" field.
func (m *SeoConfigMutation) ResetNoindex() {
	m.noindex = nil
}

// SetNofollow sets the "nofollow" field.
func (m *SeoConfigMutation) SetNofollow(b bool) {
	m.nofollow = &b
}

// Nofollow returns the value of the "nofollow" field in the mutation.
func (m *SeoConfigMutation) Nofollow() (r bool, exists bool) {
	v := m.nofollow
	if v == nil {
		return
	}
	return *v, true
}

// OldNofollow returns the old "nofollow" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldNofollow(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNofollow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNofollow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNofollow: %w", err)
	}
	return oldValue.Nofollow, nil
}

// ResetNofollow resets all changes to the "nofollow" field.
func (m *SeoConfigMutation) ResetNofollow() {
	m.nofollow = nil
}

// SetStructuredData sets the "structured_data" field.
func (m *SeoConfigMutation) SetStructuredData(value map[string]interface{}) {
	m.structured_data = &value
}

// StructuredData returns the value of the "structured_data" field in the mutation.
func (m *SeoConfigMutation) StructuredData() (r map[string]interface{}, exists bool) {
	v := m.structured_data
	if v == nil {
		return
	}
	return *v, true
}

// OldStructuredData returns the old "structured_data" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldStructuredData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStructuredData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStructuredData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStructuredData: %w", err)
	}
	return oldValue.StructuredData, nil
}

// ClearStructuredData clears the value of the "structured_data" field.
func (m *SeoConfigMutation) ClearStructuredData() {
	m.structured_data = nil
	m.clearedFields[seoconfig.FieldStructuredData] = struct{}{}
}

// StructuredDataCleared returns if the "structured_data" field was cleared in this mutation.
func (m *SeoConfigMutation) StructuredDataCleared() bool {
	_, ok := m.clearedFields[seoconfig.FieldStructuredData]
	return ok
}

// ResetStructuredData resets all changes to the "structured_data" field.
func (m *SeoConfigMutation) ResetStructuredData() {
	m.structured_data = nil
	delete(m.clearedFields, seoconfig.FieldStructuredData)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SeoConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SeoConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SeoConfig entity.
// If the SeoConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeoConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SeoConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPageID sets the "page" edge to the Page entity by id.
func (m *SeoConfigMutation) SetPageID(id int) {
	m.page = &id
}

// ClearPage clears the "page" edge to the Page entity.
func (m *SeoConfigMutation) ClearPage() {
	m.clearedpage = true
}

// PageCleared reports if the "page" edge to the Page entity was cleared.
func (m *SeoConfigMutation) PageCleared() bool {
	return m.clearedpage
}

// PageID returns the "page" edge ID in the mutation.
func (m *SeoConfigMutation) PageID() (id int, exists bool) {
	if m.page != nil {
		return *m.page, true
	}
	return
}

// PageIDs returns the "page" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PageID instead. It exists only for internal usage by the builders.
func (m *SeoConfigMutation) PageIDs() (ids []int) {
	if id := m.page; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPage resets all changes to the "page" edge.
func (m *SeoConfigMutation) ResetPage() {
	m.page = nil
	m.clearedpage = false
}

// Where appends a list predicates to the SeoConfigMutation builder.
func (m *SeoConfigMutation) Where(ps ...predicate.SeoConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeoConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeoConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SeoConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeoConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeoConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SeoConfig).
func (m *SeoConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeoConfigMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.meta_title != nil {
		fields = append(fields, seoconfig.FieldMetaTitle)
	}
	if m.meta_description != nil {
		fields = append(fields, seoconfig.FieldMetaDescription)
	}
	if m.keywords != nil {
		fields = append(fields, seoconfig.FieldKeywords)
	}
	if m.og_title != nil {
		fields = append(fields, seoconfig.FieldOgTitle)
	}
	if m.og_description != nil {
		fields = append(fields, seoconfig.FieldOgDescription)
	}
	if m.og_image_url != nil {
		fields = append(fields, seoconfig.FieldOgImageURL)
	}
	if m.og_type != nil {
		fields = append(fields, seoconfig.FieldOgType)
	}
	if m.twitter_card != nil {
		fields = append(fields, seoconfig.FieldTwitterCard)
	}
	if m.twitter_title != nil {
		fields = append(fields, seoconfig.FieldTwitterTitle)
	}
	if m.twitter_description != nil {
		fields = append(fields, seoconfig.FieldTwitterDescription)
	}
	if m.twitter_image_url != nil {
		fields = append(fields, seoconfig.FieldTwitterImageURL)
	}
	if m.canonical_url != nil {
		fields = append(fields, seoconfig.FieldCanonicalURL)
	}
	if m.noindex != nil {
		fields = append(fields, seoconfig.FieldNoindex)
	}
	if m.nofollow != nil {
		fields = append(fields, seoconfig.FieldNofollow)
	}
	if m.structured_data != nil {
		fields = append(fields, seoconfig.FieldStructuredData)
	}
	if m.updated_at != nil {
		fields = append(fields, seoconfig.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeoConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case seoconfig.FieldMetaTitle:
		return m.MetaTitle()
	case seoconfig.FieldMetaDescription:
		return m.MetaDescription()
	case seoconfig.FieldKeywords:
		return m.Keywords()
	case seoconfig.FieldOgTitle:
		return m.OgTitle()
	case seoconfig.FieldOgDescription:
		return m.OgDescription()
	case seoconfig.FieldOgImageURL:
		return m.OgImageURL()
	case seoconfig.FieldOgType:
		return m.OgType()
	case seoconfig.FieldTwitterCard:
		return m.TwitterCard()
	case seoconfig.FieldTwitterTitle:
		return m.TwitterTitle()
	case seoconfig.FieldTwitterDescription:
		return m.TwitterDescription()
	case seoconfig.FieldTwitterImageURL:
		return m.TwitterImageURL()
	case seoconfig.FieldCanonicalURL:
		return m.CanonicalURL()
	case seoconfig.FieldNoindex:
		return m.Noindex()
	case seoconfig.FieldNofollow:
		return m.Nofollow()
	case seoconfig.FieldStructuredData:
		return m.StructuredData()
	case seoconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeoConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case seoconfig.FieldMetaTitle:
		return m.OldMetaTitle(ctx)
	case seoconfig.FieldMetaDescription:
		return m.OldMetaDescription(ctx)
	case seoconfig.FieldKeywords:
		return m.OldKeywords(ctx)
	case seoconfig.FieldOgTitle:
		return m.OldOgTitle(ctx)
	case seoconfig.FieldOgDescription:
		return m.OldOgDescription(ctx)
	case seoconfig.FieldOgImageURL:
		return m.OldOgImageURL(ctx)
	case seoconfig.FieldOgType:
		return m.OldOgType(ctx)
	case seoconfig.FieldTwitterCard:
		return m.OldTwitterCard(ctx)
	case seoconfig.FieldTwitterTitle:
		return m.OldTwitterTitle(ctx)
	case seoconfig.FieldTwitterDescription:
		return m.OldTwitterDescription(ctx)
	case seoconfig.FieldTwitterImageURL:
		return m.OldTwitterImageURL(ctx)
	case seoconfig.FieldCanonicalURL:
		return m.OldCanonicalURL(ctx)
	case seoconfig.FieldNoindex:
		return m.OldNoindex(ctx)
	case seoconfig.FieldNofollow:
		return m.OldNofollow(ctx)
	case seoconfig.FieldStructuredData:
		return m.OldStructuredData(ctx)
	case seoconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SeoConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeoConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case seoconfig.FieldMetaTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaTitle(v)
		return nil
	case seoconfig.FieldMetaDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaDescription(v)
		return nil
	case seoconfig.FieldKeywords:
		v, ok := value.(map[string][]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case seoconfig.FieldOgTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOgTitle(v)
		return nil
	case seoconfig.FieldOgDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOgDescription(v)
		return nil
	case seoconfig.FieldOgImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOgImageURL(v)
		return nil
	case seoconfig.FieldOgType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOgType(v)
		return nil
	case seoconfig.FieldTwitterCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwitterCard(v)
		return nil
	case seoconfig.FieldTwitterTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwitterTitle(v)
		return nil
	case seoconfig.FieldTwitterDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwitterDescription(v)
		return nil
	case seoconfig.FieldTwitterImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwitterImageURL(v)
		return nil
	case seoconfig.FieldCanonicalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanonicalURL(v)
		return nil
	case seoconfig.FieldNoindex:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoindex(v)
		return nil
	case seoconfig.FieldNofollow:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNofollow(v)
		return nil
	case seoconfig.FieldStructuredData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStructuredData(v)
		return nil
	case seoconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SeoConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeoConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeoConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeoConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SeoConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeoConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(seoconfig.FieldMetaDescription) {
		fields = append(fields, seoconfig.FieldMetaDescription)
	}
	if m.FieldCleared(seoconfig.FieldKeywords) {
		fields = append(fields, seoconfig.FieldKeywords)
	}
	if m.FieldCleared(seoconfig.FieldOgTitle) {
		fields = append(fields, seoconfig.FieldOgTitle)
	}
	if m.FieldCleared(seoconfig.FieldOgDescription) {
		fields = append(fields, seoconfig.FieldOgDescription)
	}
	if m.FieldCleared(seoconfig.FieldOgImageURL) {
		fields = append(fields, seoconfig.FieldOgImageURL)
	}
	if m.FieldCleared(seoconfig.FieldTwitterTitle) {
		fields = append(fields, seoconfig.FieldTwitterTitle)
	}
	if m.FieldCleared(seoconfig.FieldTwitterDescription) {
		fields = append(fields, seoconfig.FieldTwitterDescription)
	}
	if m.FieldCleared(seoconfig.FieldTwitterImageURL) {
		fields = append(fields, seoconfig.FieldTwitterImageURL)
	}
	if m.FieldCleared(seoconfig.FieldCanonicalURL) {
		fields = append(fields, seoconfig.FieldCanonicalURL)
	}
	if m.FieldCleared(seoconfig.FieldStructuredData) {
		fields = append(fields, seoconfig.FieldStructuredData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeoConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeoConfigMutation) ClearField(name string) error {
	switch name {
	case seoconfig.FieldMetaDescription:
		m.ClearMetaDescription()
		return nil
	case seoconfig.FieldKeywords:
		m.ClearKeywords()
		return nil
	case seoconfig.FieldOgTitle:
		m.ClearOgTitle()
		return nil
	case seoconfig.FieldOgDescription:
		m.ClearOgDescription()
		return nil
	case seoconfig.FieldOgImageURL:
		m.ClearOgImageURL()
		return nil
	case seoconfig.FieldTwitterTitle:
		m.ClearTwitterTitle()
		return nil
	case seoconfig.FieldTwitterDescription:
		m.ClearTwitterDescription()
		return nil
	case seoconfig.FieldTwitterImageURL:
		m.ClearTwitterImageURL()
		return nil
	case seoconfig.FieldCanonicalURL:
		m.ClearCanonicalURL()
		return nil
	case seoconfig.FieldStructuredData:
		m.ClearStructuredData()
		return nil
	}
	return fmt.Errorf("unknown SeoConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeoConfigMutation) ResetField(name string) error {
	switch name {
	case seoconfig.FieldMetaTitle:
		m.ResetMetaTitle()
		return nil
	case seoconfig.FieldMetaDescription:
		m.ResetMetaDescription()
		return nil
	case seoconfig.FieldKeywords:
		m.ResetKeywords()
		return nil
	case seoconfig.FieldOgTitle:
		m.ResetOgTitle()
		return nil
	case seoconfig.FieldOgDescription:
		m.ResetOgDescription()
		return nil
	case seoconfig.FieldOgImageURL:
		m.ResetOgImageURL()
		return nil
	case seoconfig.FieldOgType:
		m.ResetOgType()
		return nil
	case seoconfig.FieldTwitterCard:
		m.ResetTwitterCard()
		return nil
	case seoconfig.FieldTwitterTitle:
		m.ResetTwitterTitle()
		return nil
	case seoconfig.FieldTwitterDescription:
		m.ResetTwitterDescription()
		return nil
	case seoconfig.FieldTwitterImageURL:
		m.ResetTwitterImageURL()
		return nil
	case seoconfig.FieldCanonicalURL:
		m.ResetCanonicalURL()
		return nil
	case seoconfig.FieldNoindex:
		m.ResetNoindex()
		return nil
	case seoconfig.FieldNofollow:
		m.ResetNofollow()
		return nil
	case seoconfig.FieldStructuredData:
		m.ResetStructuredData()
		return nil
	case seoconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SeoConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeoConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.page != nil {
		edges = append(edges, seoconfig.EdgePage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeoConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case seoconfig.EdgePage:
		if id := m.page; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeoConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeoConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeoConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpage {
		edges = append(edges, seoconfig.EdgePage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeoConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case seoconfig.EdgePage:
		return m.clearedpage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeoConfigMutation) ClearEdge(name string) error {
	switch name {
	case seoconfig.EdgePage:
		m.ClearPage()
		return nil
	}
	return fmt.Errorf("unknown SeoConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeoConfigMutation) ResetEdge(name string) error {
	switch name {
	case seoconfig.EdgePage:
		m.ResetPage()
		return nil
	}
	return fmt.Errorf("unknown SeoConfig edge %s", name)
}

// SiteVisitMutation represents an operation that mutates the SiteVisit nodes in the graph.
type SiteVisitMutation struct {
	config
	op             Op
	typ            string
	id             *int
	requested_date *time.Time
	scheduled_date *time.Time
	status         *string
	notes          *string
	clearedFields  map[string]struct{}
	donor          *int
	cleareddonor   bool
	program        *int
	clearedprogram bool
	done           bool
	oldValue       func(context.Context) (*SiteVisit, error)
	predicates     []predicate.SiteVisit
}

var _ ent.Mutation = (*SiteVisitMutation)(nil)

// sitevisitOption allows management of the mutation configuration using functional options.
type sitevisitOption func(*SiteVisitMutation)

// newSiteVisitMutation creates new mutation for the SiteVisit entity.
func newSiteVisitMutation(c config, op Op, opts ...sitevisitOption) *SiteVisitMutation {
	m := &SiteVisitMutation{
		config:        c,
		op:            op,
		typ:           TypeSiteVisit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSiteVisitID sets the ID field of the mutation.
func withSiteVisitID(id int) sitevisitOption {
	return func(m *SiteVisitMutation) {
		var (
			err   error
			once  sync.Once
			value *SiteVisit
		)
		m.oldValue = func(ctx context.Context) (*SiteVisit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SiteVisit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSiteVisit sets the old SiteVisit of the mutation.
func withSiteVisit(node *SiteVisit) sitevisitOption {
	return func(m *SiteVisitMutation) {
		m.oldValue = func(context.Context) (*SiteVisit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SiteVisitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SiteVisitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SiteVisitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SiteVisitMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SiteVisit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestedDate sets the "requested_date" field.
func (m *SiteVisitMutation) SetRequestedDate(t time.Time) {
	m.requested_date = &t
}

// RequestedDate returns the value of the "requested_date" field in the mutation.
func (m *SiteVisitMutation) RequestedDate() (r time.Time, exists bool) {
	v := m.requested_date
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedDate returns the old "requested_date" field's value of the SiteVisit entity.
// If the SiteVisit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteVisitMutation) OldRequestedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedDate: %w", err)
	}
	return oldValue.RequestedDate, nil
}

// ResetRequestedDate resets all changes to the "requested_date" field.
func (m *SiteVisitMutation) ResetRequestedDate() {
	m.requested_date = nil
}

// SetScheduledDate sets the "scheduled_date" field.
func (m *SiteVisitMutation) SetScheduledDate(t time.Time) {
	m.scheduled_date = &t
}

// ScheduledDate returns the value of the "scheduled_date" field in the mutation.
func (m *SiteVisitMutation) ScheduledDate() (r time.Time, exists bool) {
	v := m.scheduled_date
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledDate returns the old "scheduled_date" field's value of the SiteVisit entity.
// If the SiteVisit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteVisitMutation) OldScheduledDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledDate: %w", err)
	}
	return oldValue.ScheduledDate, nil
}

// ClearScheduledDate clears the value of the "scheduled_date" field.
func (m *SiteVisitMutation) ClearScheduledDate() {
	m.scheduled_date = nil
	m.clearedFields[sitevisit.FieldScheduledDate] = struct{}{}
}

// ScheduledDateCleared returns if the "scheduled_date" field was cleared in this mutation.
func (m *SiteVisitMutation) ScheduledDateCleared() bool {
	_, ok := m.clearedFields[sitevisit.FieldScheduledDate]
	return ok
}

// ResetScheduledDate resets all changes to the "scheduled_date" field.
func (m *SiteVisitMutation) ResetScheduledDate() {
	m.scheduled_date = nil
	delete(m.clearedFields, sitevisit.FieldScheduledDate)
}

// SetStatus sets the "status" field.
func (m *SiteVisitMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SiteVisitMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SiteVisit entity.
// If the SiteVisit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteVisitMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SiteVisitMutation) ResetStatus() {
	m.status = nil
}

// SetNotes sets the "notes" field.
func (m *SiteVisitMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *SiteVisitMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the SiteVisit entity.
// If the SiteVisit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiteVisitMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *SiteVisitMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[sitevisit.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *SiteVisitMutation) NotesCleared() bool {
	_, ok := m.clearedFields[sitevisit.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *SiteVisitMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, sitevisit.FieldNotes)
}

// SetDonorID sets the "donor" edge to the User entity by id.
func (m *SiteVisitMutation) SetDonorID(id int) {
	m.donor = &id
}

// ClearDonor clears the "donor" edge to the User entity.
func (m *SiteVisitMutation) ClearDonor() {
	m.cleareddonor = true
}

// DonorCleared reports if the "donor" edge to the User entity was cleared.
func (m *SiteVisitMutation) DonorCleared() bool {
	return m.cleareddonor
}

// DonorID returns the "donor" edge ID in the mutation.
func (m *SiteVisitMutation) DonorID() (id int, exists bool) {
	if m.donor != nil {
		return *m.donor, true
	}
	return
}

// DonorIDs returns the "donor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DonorID instead. It exists only for internal usage by the builders.
func (m *SiteVisitMutation) DonorIDs() (ids []int) {
	if id := m.donor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDonor resets all changes to the "donor" edge.
func (m *SiteVisitMutation) ResetDonor() {
	m.donor = nil
	m.cleareddonor = false
}

// SetProgramID sets the "program" edge to the Program entity by id.
func (m *SiteVisitMutation) SetProgramID(id int) {
	m.program = &id
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *SiteVisitMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *SiteVisitMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// ProgramID returns the "program" edge ID in the mutation.
func (m *SiteVisitMutation) ProgramID() (id int, exists bool) {
	if m.program != nil {
		return *m.program, true
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgramID instead. It exists only for internal usage by the builders.
func (m *SiteVisitMutation) ProgramIDs() (ids []int) {
	if id := m.program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *SiteVisitMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
}

// Where appends a list predicates to the SiteVisitMutation builder.
func (m *SiteVisitMutation) Where(ps ...predicate.SiteVisit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SiteVisitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SiteVisitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SiteVisit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SiteVisitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SiteVisitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SiteVisit).
func (m *SiteVisitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SiteVisitMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.requested_date != nil {
		fields = append(fields, sitevisit.FieldRequestedDate)
	}
	if m.scheduled_date != nil {
		fields = append(fields, sitevisit.FieldScheduledDate)
	}
	if m.status != nil {
		fields = append(fields, sitevisit.FieldStatus)
	}
	if m.notes != nil {
		fields = append(fields, sitevisit.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SiteVisitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sitevisit.FieldRequestedDate:
		return m.RequestedDate()
	case sitevisit.FieldScheduledDate:
		return m.ScheduledDate()
	case sitevisit.FieldStatus:
		return m.Status()
	case sitevisit.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SiteVisitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sitevisit.FieldRequestedDate:
		return m.OldRequestedDate(ctx)
	case sitevisit.FieldScheduledDate:
		return m.OldScheduledDate(ctx)
	case sitevisit.FieldStatus:
		return m.OldStatus(ctx)
	case sitevisit.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown SiteVisit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiteVisitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sitevisit.FieldRequestedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedDate(v)
		return nil
	case sitevisit.FieldScheduledDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledDate(v)
		return nil
	case sitevisit.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sitevisit.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown SiteVisit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SiteVisitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SiteVisitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiteVisitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SiteVisit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SiteVisitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sitevisit.FieldScheduledDate) {
		fields = append(fields, sitevisit.FieldScheduledDate)
	}
	if m.FieldCleared(sitevisit.FieldNotes) {
		fields = append(fields, sitevisit.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SiteVisitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SiteVisitMutation) ClearField(name string) error {
	switch name {
	case sitevisit.FieldScheduledDate:
		m.ClearScheduledDate()
		return nil
	case sitevisit.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown SiteVisit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SiteVisitMutation) ResetField(name string) error {
	switch name {
	case sitevisit.FieldRequestedDate:
		m.ResetRequestedDate()
		return nil
	case sitevisit.FieldScheduledDate:
		m.ResetScheduledDate()
		return nil
	case sitevisit.FieldStatus:
		m.ResetStatus()
		return nil
	case sitevisit.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown SiteVisit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SiteVisitMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.donor != nil {
		edges = append(edges, sitevisit.EdgeDonor)
	}
	if m.program != nil {
		edges = append(edges, sitevisit.EdgeProgram)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SiteVisitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sitevisit.EdgeDonor:
		if id := m.donor; id != nil {
			return []ent.Value{*id}
		}
	case sitevisit.EdgeProgram:
		if id := m.program; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SiteVisitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SiteVisitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SiteVisitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddonor {
		edges = append(edges, sitevisit.EdgeDonor)
	}
	if m.clearedprogram {
		edges = append(edges, sitevisit.EdgeProgram)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SiteVisitMutation) EdgeCleared(name string) bool {
	switch name {
	case sitevisit.EdgeDonor:
		return m.cleareddonor
	case sitevisit.EdgeProgram:
		return m.clearedprogram
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SiteVisitMutation) ClearEdge(name string) error {
	switch name {
	case sitevisit.EdgeDonor:
		m.ClearDonor()
		return nil
	case sitevisit.EdgeProgram:
		m.ClearProgram()
		return nil
	}
	return fmt.Errorf("unknown SiteVisit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SiteVisitMutation) ResetEdge(name string) error {
	switch name {
	case sitevisit.EdgeDonor:
		m.ResetDonor()
		return nil
	case sitevisit.EdgeProgram:
		m.ResetProgram()
		return nil
	}
	return fmt.Errorf("unknown SiteVisit edge %s", name)
}

// SkillMutation represents an operation that mutates the Skill nodes in the graph.
type SkillMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	name          *map[string]string
	category      *skill.Category
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Skill, error)
	predicates    []predicate.Skill
}

var _ ent.Mutation = (*SkillMutation)(nil)

// skillOption allows management of the mutation configuration using functional options.
type skillOption func(*SkillMutation)

// newSkillMutation creates new mutation for the Skill entity.
func newSkillMutation(c config, op Op, opts ...skillOption) *SkillMutation {
	m := &SkillMutation{
		config:        c,
		op:            op,
		typ:           TypeSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillID sets the ID field of the mutation.
func withSkillID(id int) skillOption {
	return func(m *SkillMutation) {
		var (
			err   error
			once  sync.Once
			value *Skill
		)
		m.oldValue = func(ctx context.Context) (*Skill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Skill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkill sets the old Skill of the mutation.
func withSkill(node *Skill) skillOption {
	return func(m *SkillMutation) {
		m.oldValue = func(context.Context) (*Skill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkillMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Skill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *SkillMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SkillMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SkillMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *SkillMutation) SetName(value map[string]string) {
	m.name = &value
}

// Name returns the value of the "name" field in the mutation.
func (m *SkillMutation) Name() (r map[string]string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldName(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SkillMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *SkillMutation) SetCategory(s skill.Category) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *SkillMutation) Category() (r skill.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldCategory(ctx context.Context) (v skill.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *SkillMutation) ResetCategory() {
	m.category = nil
}

// AddUserIDs adds the "users" edge to the UserSkill entity by ids.
func (m *SkillMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the UserSkill entity.
func (m *SkillMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the UserSkill entity was cleared.
func (m *SkillMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the UserSkill entity by IDs.
func (m *SkillMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the UserSkill entity.
func (m *SkillMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *SkillMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *SkillMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the SkillMutation builder.
func (m *SkillMutation) Where(ps ...predicate.Skill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Skill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Skill).
func (m *SkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, skill.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, skill.FieldName)
	}
	if m.category != nil {
		fields = append(fields, skill.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skill.FieldKey:
		return m.Key()
	case skill.FieldName:
		return m.Name()
	case skill.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skill.FieldKey:
		return m.OldKey(ctx)
	case skill.FieldName:
		return m.OldName(ctx)
	case skill.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Skill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skill.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case skill.FieldName:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case skill.FieldCategory:
		v, ok := value.(skill.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Skill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Skill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillMutation) ResetField(name string) error {
	switch name {
	case skill.FieldKey:
		m.ResetKey()
		return nil
	case skill.FieldName:
		m.ResetName()
		return nil
	case skill.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, skill.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, skill.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, skill.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillMutation) EdgeCleared(name string) bool {
	switch name {
	case skill.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Skill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillMutation) ResetEdge(name string) error {
	switch name {
	case skill.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Skill edge %s", name)
}

// StatItemMutation represents an operation that mutates the StatItem nodes in the graph.
type StatItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_order        *int
	add_order     *int
	value         *string
	label         *map[string]string
	description   *map[string]string
	icon_name     *string
	color         *string
	clearedFields map[string]struct{}
	block         *int
	clearedblock  bool
	done          bool
	oldValue      func(context.Context) (*StatItem, error)
	predicates    []predicate.StatItem
}

var _ ent.Mutation = (*StatItemMutation)(nil)

// statitemOption allows management of the mutation configuration using functional options.
type statitemOption func(*StatItemMutation)

// newStatItemMutation creates new mutation for the StatItem entity.
func newStatItemMutation(c config, op Op, opts ...statitemOption) *StatItemMutation {
	m := &StatItemMutation{
		config:        c,
		op:            op,
		typ:           TypeStatItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatItemID sets the ID field of the mutation.
func withStatItemID(id int) statitemOption {
	return func(m *StatItemMutation) {
		var (
			err   error
			once  sync.Once
			value *StatItem
		)
		m.oldValue = func(ctx context.Context) (*StatItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatItem sets the old StatItem of the mutation.
func withStatItem(node *StatItem) statitemOption {
	return func(m *StatItemMutation) {
		m.oldValue = func(context.Context) (*StatItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StatItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *StatItemMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *StatItemMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the StatItem entity.
// If the StatItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatItemMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *StatItemMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *StatItemMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *StatItemMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetValue sets the "value" field.
func (m *StatItemMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *StatItemMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the StatItem entity.
// If the StatItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatItemMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *StatItemMutation) ResetValue() {
	m.value = nil
}

// SetLabel sets the "label" field.
func (m *StatItemMutation) SetLabel(value map[string]string) {
	m.label = &value
}

// Label returns the value of the "label" field in the mutation.
func (m *StatItemMutation) Label() (r map[string]string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the StatItem entity.
// If the StatItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatItemMutation) OldLabel(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *StatItemMutation) ResetLabel() {
	m.label = nil
}

// SetDescription sets the "description" field.
func (m *StatItemMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *StatItemMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the StatItem entity.
// If the StatItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatItemMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StatItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[statitem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StatItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[statitem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StatItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, statitem.FieldDescription)
}

// SetIconName sets the "icon_name" field.
func (m *StatItemMutation) SetIconName(s string) {
	m.icon_name = &s
}

// IconName returns the value of the "icon_name" field in the mutation.
func (m *StatItemMutation) IconName() (r string, exists bool) {
	v := m.icon_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIconName returns the old "icon_name" field's value of the StatItem entity.
// If the StatItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatItemMutation) OldIconName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconName: %w", err)
	}
	return oldValue.IconName, nil
}

// ClearIconName clears the value of the "icon_name" field.
func (m *StatItemMutation) ClearIconName() {
	m.icon_name = nil
	m.clearedFields[statitem.FieldIconName] = struct{}{}
}

// IconNameCleared returns if the "icon_name" field was cleared in this mutation.
func (m *StatItemMutation) IconNameCleared() bool {
	_, ok := m.clearedFields[statitem.FieldIconName]
	return ok
}

// ResetIconName resets all changes to the "icon_name" field.
func (m *StatItemMutation) ResetIconName() {
	m.icon_name = nil
	delete(m.clearedFields, statitem.FieldIconName)
}

// SetColor sets the "color" field.
func (m *StatItemMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *StatItemMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the StatItem entity.
// If the StatItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatItemMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *StatItemMutation) ClearColor() {
	m.color = nil
	m.clearedFields[statitem.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *StatItemMutation) ColorCleared() bool {
	_, ok := m.clearedFields[statitem.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *StatItemMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, statitem.FieldColor)
}

// SetBlockID sets the "block" edge to the BlockStats entity by id.
func (m *StatItemMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the BlockStats entity.
func (m *StatItemMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the BlockStats entity was cleared.
func (m *StatItemMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *StatItemMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *StatItemMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *StatItemMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// Where appends a list predicates to the StatItemMutation builder.
func (m *StatItemMutation) Where(ps ...predicate.StatItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StatItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StatItem).
func (m *StatItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatItemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._order != nil {
		fields = append(fields, statitem.FieldOrder)
	}
	if m.value != nil {
		fields = append(fields, statitem.FieldValue)
	}
	if m.label != nil {
		fields = append(fields, statitem.FieldLabel)
	}
	if m.description != nil {
		fields = append(fields, statitem.FieldDescription)
	}
	if m.icon_name != nil {
		fields = append(fields, statitem.FieldIconName)
	}
	if m.color != nil {
		fields = append(fields, statitem.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statitem.FieldOrder:
		return m.Order()
	case statitem.FieldValue:
		return m.Value()
	case statitem.FieldLabel:
		return m.Label()
	case statitem.FieldDescription:
		return m.Description()
	case statitem.FieldIconName:
		return m.IconName()
	case statitem.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statitem.FieldOrder:
		return m.OldOrder(ctx)
	case statitem.FieldValue:
		return m.OldValue(ctx)
	case statitem.FieldLabel:
		return m.OldLabel(ctx)
	case statitem.FieldDescription:
		return m.OldDescription(ctx)
	case statitem.FieldIconName:
		return m.OldIconName(ctx)
	case statitem.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown StatItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case statitem.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case statitem.FieldLabel:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case statitem.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case statitem.FieldIconName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconName(v)
		return nil
	case statitem.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown StatItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatItemMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, statitem.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statitem.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown StatItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(statitem.FieldDescription) {
		fields = append(fields, statitem.FieldDescription)
	}
	if m.FieldCleared(statitem.FieldIconName) {
		fields = append(fields, statitem.FieldIconName)
	}
	if m.FieldCleared(statitem.FieldColor) {
		fields = append(fields, statitem.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatItemMutation) ClearField(name string) error {
	switch name {
	case statitem.FieldDescription:
		m.ClearDescription()
		return nil
	case statitem.FieldIconName:
		m.ClearIconName()
		return nil
	case statitem.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown StatItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatItemMutation) ResetField(name string) error {
	switch name {
	case statitem.FieldOrder:
		m.ResetOrder()
		return nil
	case statitem.FieldValue:
		m.ResetValue()
		return nil
	case statitem.FieldLabel:
		m.ResetLabel()
		return nil
	case statitem.FieldDescription:
		m.ResetDescription()
		return nil
	case statitem.FieldIconName:
		m.ResetIconName()
		return nil
	case statitem.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown StatItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.block != nil {
		edges = append(edges, statitem.EdgeBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statitem.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblock {
		edges = append(edges, statitem.EdgeBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatItemMutation) EdgeCleared(name string) bool {
	switch name {
	case statitem.EdgeBlock:
		return m.clearedblock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatItemMutation) ClearEdge(name string) error {
	switch name {
	case statitem.EdgeBlock:
		m.ClearBlock()
		return nil
	}
	return fmt.Errorf("unknown StatItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatItemMutation) ResetEdge(name string) error {
	switch name {
	case statitem.EdgeBlock:
		m.ResetBlock()
		return nil
	}
	return fmt.Errorf("unknown StatItem edge %s", name)
}

// SuccessStoryMutation represents an operation that mutates the SuccessStory nodes in the graph.
type SuccessStoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	slug                *string
	title               *map[string]string
	excerpt             *map[string]string
	content             *map[string]interface{}
	quote               *string
	status              *successstory.Status
	published_at        *time.Time
	image_url           *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	author              *int
	clearedauthor       bool
	program             *int
	clearedprogram      bool
	testimonials        map[int]struct{}
	removedtestimonials map[int]struct{}
	clearedtestimonials bool
	done                bool
	oldValue            func(context.Context) (*SuccessStory, error)
	predicates          []predicate.SuccessStory
}

var _ ent.Mutation = (*SuccessStoryMutation)(nil)

// successstoryOption allows management of the mutation configuration using functional options.
type successstoryOption func(*SuccessStoryMutation)

// newSuccessStoryMutation creates new mutation for the SuccessStory entity.
func newSuccessStoryMutation(c config, op Op, opts ...successstoryOption) *SuccessStoryMutation {
	m := &SuccessStoryMutation{
		config:        c,
		op:            op,
		typ:           TypeSuccessStory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSuccessStoryID sets the ID field of the mutation.
func withSuccessStoryID(id int) successstoryOption {
	return func(m *SuccessStoryMutation) {
		var (
			err   error
			once  sync.Once
			value *SuccessStory
		)
		m.oldValue = func(ctx context.Context) (*SuccessStory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SuccessStory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSuccessStory sets the old SuccessStory of the mutation.
func withSuccessStory(node *SuccessStory) successstoryOption {
	return func(m *SuccessStoryMutation) {
		m.oldValue = func(context.Context) (*SuccessStory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SuccessStoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SuccessStoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SuccessStoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SuccessStoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SuccessStory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *SuccessStoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *SuccessStoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the SuccessStory entity.
// If the SuccessStory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessStoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *SuccessStoryMutation) ResetSlug() {
	m.slug = nil
}

// SetTitle sets the "title" field.
func (m *SuccessStoryMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *SuccessStoryMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the SuccessStory entity.
// If the SuccessStory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessStoryMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SuccessStoryMutation) ResetTitle() {
	m.title = nil
}

// SetExcerpt sets the "excerpt" field.
func (m *SuccessStoryMutation) SetExcerpt(value map[string]string) {
	m.excerpt = &value
}

// Excerpt returns the value of the "excerpt" field in the mutation.
func (m *SuccessStoryMutation) Excerpt() (r map[string]string, exists bool) {
	v := m.excerpt
	if v == nil {
		return
	}
	return *v, true
}

// OldExcerpt returns the old "excerpt" field's value of the SuccessStory entity.
// If the SuccessStory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessStoryMutation) OldExcerpt(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcerpt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcerpt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcerpt: %w", err)
	}
	return oldValue.Excerpt, nil
}

// ResetExcerpt resets all changes to the "excerpt" field.
func (m *SuccessStoryMutation) ResetExcerpt() {
	m.excerpt = nil
}

// SetContent sets the "content" field.
func (m *SuccessStoryMutation) SetContent(value map[string]interface{}) {
	m.content = &value
}

// Content returns the value of the "content" field in the mutation.
func (m *SuccessStoryMutation) Content() (r map[string]interface{}, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SuccessStory entity.
// If the SuccessStory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessStoryMutation) OldContent(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *SuccessStoryMutation) ResetContent() {
	m.content = nil
}

// SetQuote sets the "quote" field.
func (m *SuccessStoryMutation) SetQuote(s string) {
	m.quote = &s
}

// Quote returns the value of the "quote" field in the mutation.
func (m *SuccessStoryMutation) Quote() (r string, exists bool) {
	v := m.quote
	if v == nil {
		return
	}
	return *v, true
}

// OldQuote returns the old "quote" field's value of the SuccessStory entity.
// If the SuccessStory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessStoryMutation) OldQuote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuote: %w", err)
	}
	return oldValue.Quote, nil
}

// ResetQuote resets all changes to the "quote" field.
func (m *SuccessStoryMutation) ResetQuote() {
	m.quote = nil
}

// SetStatus sets the "status" field.
func (m *SuccessStoryMutation) SetStatus(s successstory.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SuccessStoryMutation) Status() (r successstory.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SuccessStory entity.
// If the SuccessStory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessStoryMutation) OldStatus(ctx context.Context) (v successstory.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SuccessStoryMutation) ResetStatus() {
	m.status = nil
}

// SetPublishedAt sets the "published_at" field.
func (m *SuccessStoryMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *SuccessStoryMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the SuccessStory entity.
// If the SuccessStory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessStoryMutation) OldPublishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *SuccessStoryMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[successstory.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *SuccessStoryMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[successstory.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *SuccessStoryMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, successstory.FieldPublishedAt)
}

// SetImageURL sets the "image_url" field.
func (m *SuccessStoryMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *SuccessStoryMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the SuccessStory entity.
// If the SuccessStory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessStoryMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *SuccessStoryMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[successstory.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *SuccessStoryMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[successstory.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *SuccessStoryMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, successstory.FieldImageURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *SuccessStoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SuccessStoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SuccessStory entity.
// If the SuccessStory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessStoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SuccessStoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SuccessStoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SuccessStoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SuccessStory entity.
// If the SuccessStory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SuccessStoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SuccessStoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *SuccessStoryMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *SuccessStoryMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *SuccessStoryMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *SuccessStoryMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *SuccessStoryMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *SuccessStoryMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetProgramID sets the "program" edge to the Program entity by id.
func (m *SuccessStoryMutation) SetProgramID(id int) {
	m.program = &id
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *SuccessStoryMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *SuccessStoryMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// ProgramID returns the "program" edge ID in the mutation.
func (m *SuccessStoryMutation) ProgramID() (id int, exists bool) {
	if m.program != nil {
		return *m.program, true
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgramID instead. It exists only for internal usage by the builders.
func (m *SuccessStoryMutation) ProgramIDs() (ids []int) {
	if id := m.program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *SuccessStoryMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
}

// AddTestimonialIDs adds the "testimonials" edge to the TestimonialItem entity by ids.
func (m *SuccessStoryMutation) AddTestimonialIDs(ids ...int) {
	if m.testimonials == nil {
		m.testimonials = make(map[int]struct{})
	}
	for i := range ids {
		m.testimonials[ids[i]] = struct{}{}
	}
}

// ClearTestimonials clears the "testimonials" edge to the TestimonialItem entity.
func (m *SuccessStoryMutation) ClearTestimonials() {
	m.clearedtestimonials = true
}

// TestimonialsCleared reports if the "testimonials" edge to the TestimonialItem entity was cleared.
func (m *SuccessStoryMutation) TestimonialsCleared() bool {
	return m.clearedtestimonials
}

// RemoveTestimonialIDs removes the "testimonials" edge to the TestimonialItem entity by IDs.
func (m *SuccessStoryMutation) RemoveTestimonialIDs(ids ...int) {
	if m.removedtestimonials == nil {
		m.removedtestimonials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.testimonials, ids[i])
		m.removedtestimonials[ids[i]] = struct{}{}
	}
}

// RemovedTestimonials returns the removed IDs of the "testimonials" edge to the TestimonialItem entity.
func (m *SuccessStoryMutation) RemovedTestimonialsIDs() (ids []int) {
	for id := range m.removedtestimonials {
		ids = append(ids, id)
	}
	return
}

// TestimonialsIDs returns the "testimonials" edge IDs in the mutation.
func (m *SuccessStoryMutation) TestimonialsIDs() (ids []int) {
	for id := range m.testimonials {
		ids = append(ids, id)
	}
	return
}

// ResetTestimonials resets all changes to the "testimonials" edge.
func (m *SuccessStoryMutation) ResetTestimonials() {
	m.testimonials = nil
	m.clearedtestimonials = false
	m.removedtestimonials = nil
}

// Where appends a list predicates to the SuccessStoryMutation builder.
func (m *SuccessStoryMutation) Where(ps ...predicate.SuccessStory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SuccessStoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SuccessStoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SuccessStory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SuccessStoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SuccessStoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SuccessStory).
func (m *SuccessStoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SuccessStoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.slug != nil {
		fields = append(fields, successstory.FieldSlug)
	}
	if m.title != nil {
		fields = append(fields, successstory.FieldTitle)
	}
	if m.excerpt != nil {
		fields = append(fields, successstory.FieldExcerpt)
	}
	if m.content != nil {
		fields = append(fields, successstory.FieldContent)
	}
	if m.quote != nil {
		fields = append(fields, successstory.FieldQuote)
	}
	if m.status != nil {
		fields = append(fields, successstory.FieldStatus)
	}
	if m.published_at != nil {
		fields = append(fields, successstory.FieldPublishedAt)
	}
	if m.image_url != nil {
		fields = append(fields, successstory.FieldImageURL)
	}
	if m.created_at != nil {
		fields = append(fields, successstory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, successstory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SuccessStoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case successstory.FieldSlug:
		return m.Slug()
	case successstory.FieldTitle:
		return m.Title()
	case successstory.FieldExcerpt:
		return m.Excerpt()
	case successstory.FieldContent:
		return m.Content()
	case successstory.FieldQuote:
		return m.Quote()
	case successstory.FieldStatus:
		return m.Status()
	case successstory.FieldPublishedAt:
		return m.PublishedAt()
	case successstory.FieldImageURL:
		return m.ImageURL()
	case successstory.FieldCreatedAt:
		return m.CreatedAt()
	case successstory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SuccessStoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case successstory.FieldSlug:
		return m.OldSlug(ctx)
	case successstory.FieldTitle:
		return m.OldTitle(ctx)
	case successstory.FieldExcerpt:
		return m.OldExcerpt(ctx)
	case successstory.FieldContent:
		return m.OldContent(ctx)
	case successstory.FieldQuote:
		return m.OldQuote(ctx)
	case successstory.FieldStatus:
		return m.OldStatus(ctx)
	case successstory.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case successstory.FieldImageURL:
		return m.OldImageURL(ctx)
	case successstory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case successstory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SuccessStory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SuccessStoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case successstory.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case successstory.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case successstory.FieldExcerpt:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcerpt(v)
		return nil
	case successstory.FieldContent:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case successstory.FieldQuote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuote(v)
		return nil
	case successstory.FieldStatus:
		v, ok := value.(successstory.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case successstory.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case successstory.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case successstory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case successstory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SuccessStory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SuccessStoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SuccessStoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SuccessStoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SuccessStory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SuccessStoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(successstory.FieldPublishedAt) {
		fields = append(fields, successstory.FieldPublishedAt)
	}
	if m.FieldCleared(successstory.FieldImageURL) {
		fields = append(fields, successstory.FieldImageURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SuccessStoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SuccessStoryMutation) ClearField(name string) error {
	switch name {
	case successstory.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	case successstory.FieldImageURL:
		m.ClearImageURL()
		return nil
	}
	return fmt.Errorf("unknown SuccessStory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SuccessStoryMutation) ResetField(name string) error {
	switch name {
	case successstory.FieldSlug:
		m.ResetSlug()
		return nil
	case successstory.FieldTitle:
		m.ResetTitle()
		return nil
	case successstory.FieldExcerpt:
		m.ResetExcerpt()
		return nil
	case successstory.FieldContent:
		m.ResetContent()
		return nil
	case successstory.FieldQuote:
		m.ResetQuote()
		return nil
	case successstory.FieldStatus:
		m.ResetStatus()
		return nil
	case successstory.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case successstory.FieldImageURL:
		m.ResetImageURL()
		return nil
	case successstory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case successstory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SuccessStory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SuccessStoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.author != nil {
		edges = append(edges, successstory.EdgeAuthor)
	}
	if m.program != nil {
		edges = append(edges, successstory.EdgeProgram)
	}
	if m.testimonials != nil {
		edges = append(edges, successstory.EdgeTestimonials)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SuccessStoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case successstory.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case successstory.EdgeProgram:
		if id := m.program; id != nil {
			return []ent.Value{*id}
		}
	case successstory.EdgeTestimonials:
		ids := make([]ent.Value, 0, len(m.testimonials))
		for id := range m.testimonials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SuccessStoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtestimonials != nil {
		edges = append(edges, successstory.EdgeTestimonials)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SuccessStoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case successstory.EdgeTestimonials:
		ids := make([]ent.Value, 0, len(m.removedtestimonials))
		for id := range m.removedtestimonials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SuccessStoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedauthor {
		edges = append(edges, successstory.EdgeAuthor)
	}
	if m.clearedprogram {
		edges = append(edges, successstory.EdgeProgram)
	}
	if m.clearedtestimonials {
		edges = append(edges, successstory.EdgeTestimonials)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SuccessStoryMutation) EdgeCleared(name string) bool {
	switch name {
	case successstory.EdgeAuthor:
		return m.clearedauthor
	case successstory.EdgeProgram:
		return m.clearedprogram
	case successstory.EdgeTestimonials:
		return m.clearedtestimonials
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SuccessStoryMutation) ClearEdge(name string) error {
	switch name {
	case successstory.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case successstory.EdgeProgram:
		m.ClearProgram()
		return nil
	}
	return fmt.Errorf("unknown SuccessStory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SuccessStoryMutation) ResetEdge(name string) error {
	switch name {
	case successstory.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case successstory.EdgeProgram:
		m.ResetProgram()
		return nil
	case successstory.EdgeTestimonials:
		m.ResetTestimonials()
		return nil
	}
	return fmt.Errorf("unknown SuccessStory edge %s", name)
}

// SystemErrorMutation represents an operation that mutates the SystemError nodes in the graph.
type SystemErrorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	timestamp     *time.Time
	message       *string
	name          *string
	stack         *string
	metadata      *map[string]interface{}
	user_id       *string
	context       *string
	is_resolved   *bool
	resolved_at   *time.Time
	resolved_by   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SystemError, error)
	predicates    []predicate.SystemError
}

var _ ent.Mutation = (*SystemErrorMutation)(nil)

// systemerrorOption allows management of the mutation configuration using functional options.
type systemerrorOption func(*SystemErrorMutation)

// newSystemErrorMutation creates new mutation for the SystemError entity.
func newSystemErrorMutation(c config, op Op, opts ...systemerrorOption) *SystemErrorMutation {
	m := &SystemErrorMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemError,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemErrorID sets the ID field of the mutation.
func withSystemErrorID(id int) systemerrorOption {
	return func(m *SystemErrorMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemError
		)
		m.oldValue = func(ctx context.Context) (*SystemError, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemError.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemError sets the old SystemError of the mutation.
func withSystemError(node *SystemError) systemerrorOption {
	return func(m *SystemErrorMutation) {
		m.oldValue = func(context.Context) (*SystemError, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemErrorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemErrorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemErrorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemErrorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemError.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *SystemErrorMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *SystemErrorMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the SystemError entity.
// If the SystemError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemErrorMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *SystemErrorMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetMessage sets the "message" field.
func (m *SystemErrorMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *SystemErrorMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the SystemError entity.
// If the SystemError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemErrorMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *SystemErrorMutation) ResetMessage() {
	m.message = nil
}

// SetName sets the "name" field.
func (m *SystemErrorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SystemErrorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SystemError entity.
// If the SystemError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemErrorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SystemErrorMutation) ResetName() {
	m.name = nil
}

// SetStack sets the "stack" field.
func (m *SystemErrorMutation) SetStack(s string) {
	m.stack = &s
}

// Stack returns the value of the "stack" field in the mutation.
func (m *SystemErrorMutation) Stack() (r string, exists bool) {
	v := m.stack
	if v == nil {
		return
	}
	return *v, true
}

// OldStack returns the old "stack" field's value of the SystemError entity.
// If the SystemError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemErrorMutation) OldStack(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStack is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStack requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStack: %w", err)
	}
	return oldValue.Stack, nil
}

// ResetStack resets all changes to the "stack" field.
func (m *SystemErrorMutation) ResetStack() {
	m.stack = nil
}

// SetMetadata sets the "metadata" field.
func (m *SystemErrorMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SystemErrorMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SystemError entity.
// If the SystemError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemErrorMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SystemErrorMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[systemerror.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SystemErrorMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[systemerror.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SystemErrorMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, systemerror.FieldMetadata)
}

// SetUserID sets the "user_id" field.
func (m *SystemErrorMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SystemErrorMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SystemError entity.
// If the SystemError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemErrorMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *SystemErrorMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[systemerror.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SystemErrorMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[systemerror.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SystemErrorMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, systemerror.FieldUserID)
}

// SetContext sets the "context" field.
func (m *SystemErrorMutation) SetContext(s string) {
	m.context = &s
}

// Context returns the value of the "context" field in the mutation.
func (m *SystemErrorMutation) Context() (r string, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the SystemError entity.
// If the SystemError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemErrorMutation) OldContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// ClearContext clears the value of the "context" field.
func (m *SystemErrorMutation) ClearContext() {
	m.context = nil
	m.clearedFields[systemerror.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *SystemErrorMutation) ContextCleared() bool {
	_, ok := m.clearedFields[systemerror.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *SystemErrorMutation) ResetContext() {
	m.context = nil
	delete(m.clearedFields, systemerror.FieldContext)
}

// SetIsResolved sets the "is_resolved" field.
func (m *SystemErrorMutation) SetIsResolved(b bool) {
	m.is_resolved = &b
}

// IsResolved returns the value of the "is_resolved" field in the mutation.
func (m *SystemErrorMutation) IsResolved() (r bool, exists bool) {
	v := m.is_resolved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsResolved returns the old "is_resolved" field's value of the SystemError entity.
// If the SystemError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemErrorMutation) OldIsResolved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsResolved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsResolved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsResolved: %w", err)
	}
	return oldValue.IsResolved, nil
}

// ResetIsResolved resets all changes to the "is_resolved" field.
func (m *SystemErrorMutation) ResetIsResolved() {
	m.is_resolved = nil
}

// SetResolvedAt sets the "resolved_at" field.
func (m *SystemErrorMutation) SetResolvedAt(t time.Time) {
	m.resolved_at = &t
}

// ResolvedAt returns the value of the "resolved_at" field in the mutation.
func (m *SystemErrorMutation) ResolvedAt() (r time.Time, exists bool) {
	v := m.resolved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedAt returns the old "resolved_at" field's value of the SystemError entity.
// If the SystemError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemErrorMutation) OldResolvedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedAt: %w", err)
	}
	return oldValue.ResolvedAt, nil
}

// ClearResolvedAt clears the value of the "resolved_at" field.
func (m *SystemErrorMutation) ClearResolvedAt() {
	m.resolved_at = nil
	m.clearedFields[systemerror.FieldResolvedAt] = struct{}{}
}

// ResolvedAtCleared returns if the "resolved_at" field was cleared in this mutation.
func (m *SystemErrorMutation) ResolvedAtCleared() bool {
	_, ok := m.clearedFields[systemerror.FieldResolvedAt]
	return ok
}

// ResetResolvedAt resets all changes to the "resolved_at" field.
func (m *SystemErrorMutation) ResetResolvedAt() {
	m.resolved_at = nil
	delete(m.clearedFields, systemerror.FieldResolvedAt)
}

// SetResolvedBy sets the "resolved_by" field.
func (m *SystemErrorMutation) SetResolvedBy(s string) {
	m.resolved_by = &s
}

// ResolvedBy returns the value of the "resolved_by" field in the mutation.
func (m *SystemErrorMutation) ResolvedBy() (r string, exists bool) {
	v := m.resolved_by
	if v == nil {
		return
	}
	return *v, true
}

// OldResolvedBy returns the old "resolved_by" field's value of the SystemError entity.
// If the SystemError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemErrorMutation) OldResolvedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolvedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolvedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolvedBy: %w", err)
	}
	return oldValue.ResolvedBy, nil
}

// ClearResolvedBy clears the value of the "resolved_by" field.
func (m *SystemErrorMutation) ClearResolvedBy() {
	m.resolved_by = nil
	m.clearedFields[systemerror.FieldResolvedBy] = struct{}{}
}

// ResolvedByCleared returns if the "resolved_by" field was cleared in this mutation.
func (m *SystemErrorMutation) ResolvedByCleared() bool {
	_, ok := m.clearedFields[systemerror.FieldResolvedBy]
	return ok
}

// ResetResolvedBy resets all changes to the "resolved_by" field.
func (m *SystemErrorMutation) ResetResolvedBy() {
	m.resolved_by = nil
	delete(m.clearedFields, systemerror.FieldResolvedBy)
}

// Where appends a list predicates to the SystemErrorMutation builder.
func (m *SystemErrorMutation) Where(ps ...predicate.SystemError) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemErrorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemErrorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemError, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemErrorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemErrorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemError).
func (m *SystemErrorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemErrorMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.timestamp != nil {
		fields = append(fields, systemerror.FieldTimestamp)
	}
	if m.message != nil {
		fields = append(fields, systemerror.FieldMessage)
	}
	if m.name != nil {
		fields = append(fields, systemerror.FieldName)
	}
	if m.stack != nil {
		fields = append(fields, systemerror.FieldStack)
	}
	if m.metadata != nil {
		fields = append(fields, systemerror.FieldMetadata)
	}
	if m.user_id != nil {
		fields = append(fields, systemerror.FieldUserID)
	}
	if m.context != nil {
		fields = append(fields, systemerror.FieldContext)
	}
	if m.is_resolved != nil {
		fields = append(fields, systemerror.FieldIsResolved)
	}
	if m.resolved_at != nil {
		fields = append(fields, systemerror.FieldResolvedAt)
	}
	if m.resolved_by != nil {
		fields = append(fields, systemerror.FieldResolvedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemErrorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemerror.FieldTimestamp:
		return m.Timestamp()
	case systemerror.FieldMessage:
		return m.Message()
	case systemerror.FieldName:
		return m.Name()
	case systemerror.FieldStack:
		return m.Stack()
	case systemerror.FieldMetadata:
		return m.Metadata()
	case systemerror.FieldUserID:
		return m.UserID()
	case systemerror.FieldContext:
		return m.Context()
	case systemerror.FieldIsResolved:
		return m.IsResolved()
	case systemerror.FieldResolvedAt:
		return m.ResolvedAt()
	case systemerror.FieldResolvedBy:
		return m.ResolvedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemErrorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemerror.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case systemerror.FieldMessage:
		return m.OldMessage(ctx)
	case systemerror.FieldName:
		return m.OldName(ctx)
	case systemerror.FieldStack:
		return m.OldStack(ctx)
	case systemerror.FieldMetadata:
		return m.OldMetadata(ctx)
	case systemerror.FieldUserID:
		return m.OldUserID(ctx)
	case systemerror.FieldContext:
		return m.OldContext(ctx)
	case systemerror.FieldIsResolved:
		return m.OldIsResolved(ctx)
	case systemerror.FieldResolvedAt:
		return m.OldResolvedAt(ctx)
	case systemerror.FieldResolvedBy:
		return m.OldResolvedBy(ctx)
	}
	return nil, fmt.Errorf("unknown SystemError field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemErrorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemerror.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case systemerror.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case systemerror.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case systemerror.FieldStack:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStack(v)
		return nil
	case systemerror.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case systemerror.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case systemerror.FieldContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	case systemerror.FieldIsResolved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsResolved(v)
		return nil
	case systemerror.FieldResolvedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedAt(v)
		return nil
	case systemerror.FieldResolvedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolvedBy(v)
		return nil
	}
	return fmt.Errorf("unknown SystemError field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemErrorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemErrorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemErrorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemError numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemErrorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemerror.FieldMetadata) {
		fields = append(fields, systemerror.FieldMetadata)
	}
	if m.FieldCleared(systemerror.FieldUserID) {
		fields = append(fields, systemerror.FieldUserID)
	}
	if m.FieldCleared(systemerror.FieldContext) {
		fields = append(fields, systemerror.FieldContext)
	}
	if m.FieldCleared(systemerror.FieldResolvedAt) {
		fields = append(fields, systemerror.FieldResolvedAt)
	}
	if m.FieldCleared(systemerror.FieldResolvedBy) {
		fields = append(fields, systemerror.FieldResolvedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemErrorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemErrorMutation) ClearField(name string) error {
	switch name {
	case systemerror.FieldMetadata:
		m.ClearMetadata()
		return nil
	case systemerror.FieldUserID:
		m.ClearUserID()
		return nil
	case systemerror.FieldContext:
		m.ClearContext()
		return nil
	case systemerror.FieldResolvedAt:
		m.ClearResolvedAt()
		return nil
	case systemerror.FieldResolvedBy:
		m.ClearResolvedBy()
		return nil
	}
	return fmt.Errorf("unknown SystemError nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemErrorMutation) ResetField(name string) error {
	switch name {
	case systemerror.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case systemerror.FieldMessage:
		m.ResetMessage()
		return nil
	case systemerror.FieldName:
		m.ResetName()
		return nil
	case systemerror.FieldStack:
		m.ResetStack()
		return nil
	case systemerror.FieldMetadata:
		m.ResetMetadata()
		return nil
	case systemerror.FieldUserID:
		m.ResetUserID()
		return nil
	case systemerror.FieldContext:
		m.ResetContext()
		return nil
	case systemerror.FieldIsResolved:
		m.ResetIsResolved()
		return nil
	case systemerror.FieldResolvedAt:
		m.ResetResolvedAt()
		return nil
	case systemerror.FieldResolvedBy:
		m.ResetResolvedBy()
		return nil
	}
	return fmt.Errorf("unknown SystemError field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemErrorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemErrorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemErrorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemErrorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemErrorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemErrorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemErrorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SystemError unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemErrorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SystemError edge %s", name)
}

// SystemLogMutation represents an operation that mutates the SystemLog nodes in the graph.
type SystemLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	timestamp     *time.Time
	level         *systemlog.Level
	message       *string
	metadata      *map[string]interface{}
	user_id       *string
	context       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SystemLog, error)
	predicates    []predicate.SystemLog
}

var _ ent.Mutation = (*SystemLogMutation)(nil)

// systemlogOption allows management of the mutation configuration using functional options.
type systemlogOption func(*SystemLogMutation)

// newSystemLogMutation creates new mutation for the SystemLog entity.
func newSystemLogMutation(c config, op Op, opts ...systemlogOption) *SystemLogMutation {
	m := &SystemLogMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemLogID sets the ID field of the mutation.
func withSystemLogID(id int) systemlogOption {
	return func(m *SystemLogMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemLog
		)
		m.oldValue = func(ctx context.Context) (*SystemLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemLog sets the old SystemLog of the mutation.
func withSystemLog(node *SystemLog) systemlogOption {
	return func(m *SystemLogMutation) {
		m.oldValue = func(context.Context) (*SystemLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *SystemLogMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *SystemLogMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *SystemLogMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetLevel sets the "level" field.
func (m *SystemLogMutation) SetLevel(s systemlog.Level) {
	m.level = &s
}

// Level returns the value of the "level" field in the mutation.
func (m *SystemLogMutation) Level() (r systemlog.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldLevel(ctx context.Context) (v systemlog.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *SystemLogMutation) ResetLevel() {
	m.level = nil
}

// SetMessage sets the "message" field.
func (m *SystemLogMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *SystemLogMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *SystemLogMutation) ResetMessage() {
	m.message = nil
}

// SetMetadata sets the "metadata" field.
func (m *SystemLogMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SystemLogMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SystemLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[systemlog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SystemLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[systemlog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SystemLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, systemlog.FieldMetadata)
}

// SetUserID sets the "user_id" field.
func (m *SystemLogMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SystemLogMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *SystemLogMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[systemlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SystemLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[systemlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SystemLogMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, systemlog.FieldUserID)
}

// SetContext sets the "context" field.
func (m *SystemLogMutation) SetContext(s string) {
	m.context = &s
}

// Context returns the value of the "context" field in the mutation.
func (m *SystemLogMutation) Context() (r string, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the SystemLog entity.
// If the SystemLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemLogMutation) OldContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// ClearContext clears the value of the "context" field.
func (m *SystemLogMutation) ClearContext() {
	m.context = nil
	m.clearedFields[systemlog.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *SystemLogMutation) ContextCleared() bool {
	_, ok := m.clearedFields[systemlog.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *SystemLogMutation) ResetContext() {
	m.context = nil
	delete(m.clearedFields, systemlog.FieldContext)
}

// Where appends a list predicates to the SystemLogMutation builder.
func (m *SystemLogMutation) Where(ps ...predicate.SystemLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemLog).
func (m *SystemLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemLogMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.timestamp != nil {
		fields = append(fields, systemlog.FieldTimestamp)
	}
	if m.level != nil {
		fields = append(fields, systemlog.FieldLevel)
	}
	if m.message != nil {
		fields = append(fields, systemlog.FieldMessage)
	}
	if m.metadata != nil {
		fields = append(fields, systemlog.FieldMetadata)
	}
	if m.user_id != nil {
		fields = append(fields, systemlog.FieldUserID)
	}
	if m.context != nil {
		fields = append(fields, systemlog.FieldContext)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemlog.FieldTimestamp:
		return m.Timestamp()
	case systemlog.FieldLevel:
		return m.Level()
	case systemlog.FieldMessage:
		return m.Message()
	case systemlog.FieldMetadata:
		return m.Metadata()
	case systemlog.FieldUserID:
		return m.UserID()
	case systemlog.FieldContext:
		return m.Context()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemlog.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case systemlog.FieldLevel:
		return m.OldLevel(ctx)
	case systemlog.FieldMessage:
		return m.OldMessage(ctx)
	case systemlog.FieldMetadata:
		return m.OldMetadata(ctx)
	case systemlog.FieldUserID:
		return m.OldUserID(ctx)
	case systemlog.FieldContext:
		return m.OldContext(ctx)
	}
	return nil, fmt.Errorf("unknown SystemLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemlog.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case systemlog.FieldLevel:
		v, ok := value.(systemlog.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case systemlog.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case systemlog.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case systemlog.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case systemlog.FieldContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	}
	return fmt.Errorf("unknown SystemLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemlog.FieldMetadata) {
		fields = append(fields, systemlog.FieldMetadata)
	}
	if m.FieldCleared(systemlog.FieldUserID) {
		fields = append(fields, systemlog.FieldUserID)
	}
	if m.FieldCleared(systemlog.FieldContext) {
		fields = append(fields, systemlog.FieldContext)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemLogMutation) ClearField(name string) error {
	switch name {
	case systemlog.FieldMetadata:
		m.ClearMetadata()
		return nil
	case systemlog.FieldUserID:
		m.ClearUserID()
		return nil
	case systemlog.FieldContext:
		m.ClearContext()
		return nil
	}
	return fmt.Errorf("unknown SystemLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemLogMutation) ResetField(name string) error {
	switch name {
	case systemlog.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case systemlog.FieldLevel:
		m.ResetLevel()
		return nil
	case systemlog.FieldMessage:
		m.ResetMessage()
		return nil
	case systemlog.FieldMetadata:
		m.ResetMetadata()
		return nil
	case systemlog.FieldUserID:
		m.ResetUserID()
		return nil
	case systemlog.FieldContext:
		m.ResetContext()
		return nil
	}
	return fmt.Errorf("unknown SystemLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SystemLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SystemLog edge %s", name)
}

// TabItemMutation represents an operation that mutates the TabItem nodes in the graph.
type TabItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_order        *int
	add_order     *int
	title         *map[string]string
	content       *map[string]string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	block         *int
	clearedblock  bool
	done          bool
	oldValue      func(context.Context) (*TabItem, error)
	predicates    []predicate.TabItem
}

var _ ent.Mutation = (*TabItemMutation)(nil)

// tabitemOption allows management of the mutation configuration using functional options.
type tabitemOption func(*TabItemMutation)

// newTabItemMutation creates new mutation for the TabItem entity.
func newTabItemMutation(c config, op Op, opts ...tabitemOption) *TabItemMutation {
	m := &TabItemMutation{
		config:        c,
		op:            op,
		typ:           TypeTabItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTabItemID sets the ID field of the mutation.
func withTabItemID(id int) tabitemOption {
	return func(m *TabItemMutation) {
		var (
			err   error
			once  sync.Once
			value *TabItem
		)
		m.oldValue = func(ctx context.Context) (*TabItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TabItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTabItem sets the old TabItem of the mutation.
func withTabItem(node *TabItem) tabitemOption {
	return func(m *TabItemMutation) {
		m.oldValue = func(context.Context) (*TabItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TabItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TabItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TabItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TabItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TabItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *TabItemMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *TabItemMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the TabItem entity.
// If the TabItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TabItemMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *TabItemMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *TabItemMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *TabItemMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetTitle sets the "title" field.
func (m *TabItemMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *TabItemMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the TabItem entity.
// If the TabItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TabItemMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TabItemMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *TabItemMutation) SetContent(value map[string]string) {
	m.content = &value
}

// Content returns the value of the "content" field in the mutation.
func (m *TabItemMutation) Content() (r map[string]string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the TabItem entity.
// If the TabItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TabItemMutation) OldContent(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *TabItemMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TabItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TabItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TabItem entity.
// If the TabItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TabItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TabItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TabItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TabItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TabItem entity.
// If the TabItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TabItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TabItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBlockID sets the "block" edge to the BlockTabs entity by id.
func (m *TabItemMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the BlockTabs entity.
func (m *TabItemMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the BlockTabs entity was cleared.
func (m *TabItemMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *TabItemMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *TabItemMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *TabItemMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// Where appends a list predicates to the TabItemMutation builder.
func (m *TabItemMutation) Where(ps ...predicate.TabItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TabItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TabItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TabItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TabItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TabItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TabItem).
func (m *TabItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TabItemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._order != nil {
		fields = append(fields, tabitem.FieldOrder)
	}
	if m.title != nil {
		fields = append(fields, tabitem.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, tabitem.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, tabitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tabitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TabItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tabitem.FieldOrder:
		return m.Order()
	case tabitem.FieldTitle:
		return m.Title()
	case tabitem.FieldContent:
		return m.Content()
	case tabitem.FieldCreatedAt:
		return m.CreatedAt()
	case tabitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TabItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tabitem.FieldOrder:
		return m.OldOrder(ctx)
	case tabitem.FieldTitle:
		return m.OldTitle(ctx)
	case tabitem.FieldContent:
		return m.OldContent(ctx)
	case tabitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tabitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TabItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TabItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tabitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case tabitem.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case tabitem.FieldContent:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case tabitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tabitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TabItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TabItemMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, tabitem.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TabItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tabitem.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TabItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tabitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown TabItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TabItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TabItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TabItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TabItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TabItemMutation) ResetField(name string) error {
	switch name {
	case tabitem.FieldOrder:
		m.ResetOrder()
		return nil
	case tabitem.FieldTitle:
		m.ResetTitle()
		return nil
	case tabitem.FieldContent:
		m.ResetContent()
		return nil
	case tabitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tabitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TabItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TabItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.block != nil {
		edges = append(edges, tabitem.EdgeBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TabItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tabitem.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TabItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TabItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TabItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblock {
		edges = append(edges, tabitem.EdgeBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TabItemMutation) EdgeCleared(name string) bool {
	switch name {
	case tabitem.EdgeBlock:
		return m.clearedblock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TabItemMutation) ClearEdge(name string) error {
	switch name {
	case tabitem.EdgeBlock:
		m.ClearBlock()
		return nil
	}
	return fmt.Errorf("unknown TabItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TabItemMutation) ResetEdge(name string) error {
	switch name {
	case tabitem.EdgeBlock:
		m.ResetBlock()
		return nil
	}
	return fmt.Errorf("unknown TabItem edge %s", name)
}

// TeamMemberMutation represents an operation that mutates the TeamMember nodes in the graph.
type TeamMemberMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	title            *map[string]string
	bio              *map[string]string
	image_url        *string
	linkedin_url     *string
	twitter_url      *string
	email            *string
	_type            *teammember.Type
	display_order    *int
	adddisplay_order *int
	is_active        *bool
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*TeamMember, error)
	predicates       []predicate.TeamMember
}

var _ ent.Mutation = (*TeamMemberMutation)(nil)

// teammemberOption allows management of the mutation configuration using functional options.
type teammemberOption func(*TeamMemberMutation)

// newTeamMemberMutation creates new mutation for the TeamMember entity.
func newTeamMemberMutation(c config, op Op, opts ...teammemberOption) *TeamMemberMutation {
	m := &TeamMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamMemberID sets the ID field of the mutation.
func withTeamMemberID(id int) teammemberOption {
	return func(m *TeamMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamMember
		)
		m.oldValue = func(ctx context.Context) (*TeamMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamMember sets the old TeamMember of the mutation.
func withTeamMember(node *TeamMember) teammemberOption {
	return func(m *TeamMemberMutation) {
		m.oldValue = func(context.Context) (*TeamMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeamMemberMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMemberMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMemberMutation) ResetName() {
	m.name = nil
}

// SetTitle sets the "title" field.
func (m *TeamMemberMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *TeamMemberMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TeamMemberMutation) ResetTitle() {
	m.title = nil
}

// SetBio sets the "bio" field.
func (m *TeamMemberMutation) SetBio(value map[string]string) {
	m.bio = &value
}

// Bio returns the value of the "bio" field in the mutation.
func (m *TeamMemberMutation) Bio() (r map[string]string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldBio(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *TeamMemberMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[teammember.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *TeamMemberMutation) BioCleared() bool {
	_, ok := m.clearedFields[teammember.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *TeamMemberMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, teammember.FieldBio)
}

// SetImageURL sets the "image_url" field.
func (m *TeamMemberMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *TeamMemberMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *TeamMemberMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[teammember.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *TeamMemberMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[teammember.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *TeamMemberMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, teammember.FieldImageURL)
}

// SetLinkedinURL sets the "linkedin_url" field.
func (m *TeamMemberMutation) SetLinkedinURL(s string) {
	m.linkedin_url = &s
}

// LinkedinURL returns the value of the "linkedin_url" field in the mutation.
func (m *TeamMemberMutation) LinkedinURL() (r string, exists bool) {
	v := m.linkedin_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedinURL returns the old "linkedin_url" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldLinkedinURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedinURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedinURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedinURL: %w", err)
	}
	return oldValue.LinkedinURL, nil
}

// ClearLinkedinURL clears the value of the "linkedin_url" field.
func (m *TeamMemberMutation) ClearLinkedinURL() {
	m.linkedin_url = nil
	m.clearedFields[teammember.FieldLinkedinURL] = struct{}{}
}

// LinkedinURLCleared returns if the "linkedin_url" field was cleared in this mutation.
func (m *TeamMemberMutation) LinkedinURLCleared() bool {
	_, ok := m.clearedFields[teammember.FieldLinkedinURL]
	return ok
}

// ResetLinkedinURL resets all changes to the "linkedin_url" field.
func (m *TeamMemberMutation) ResetLinkedinURL() {
	m.linkedin_url = nil
	delete(m.clearedFields, teammember.FieldLinkedinURL)
}

// SetTwitterURL sets the "twitter_url" field.
func (m *TeamMemberMutation) SetTwitterURL(s string) {
	m.twitter_url = &s
}

// TwitterURL returns the value of the "twitter_url" field in the mutation.
func (m *TeamMemberMutation) TwitterURL() (r string, exists bool) {
	v := m.twitter_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTwitterURL returns the old "twitter_url" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldTwitterURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwitterURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwitterURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwitterURL: %w", err)
	}
	return oldValue.TwitterURL, nil
}

// ClearTwitterURL clears the value of the "twitter_url" field.
func (m *TeamMemberMutation) ClearTwitterURL() {
	m.twitter_url = nil
	m.clearedFields[teammember.FieldTwitterURL] = struct{}{}
}

// TwitterURLCleared returns if the "twitter_url" field was cleared in this mutation.
func (m *TeamMemberMutation) TwitterURLCleared() bool {
	_, ok := m.clearedFields[teammember.FieldTwitterURL]
	return ok
}

// ResetTwitterURL resets all changes to the "twitter_url" field.
func (m *TeamMemberMutation) ResetTwitterURL() {
	m.twitter_url = nil
	delete(m.clearedFields, teammember.FieldTwitterURL)
}

// SetEmail sets the "email" field.
func (m *TeamMemberMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TeamMemberMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *TeamMemberMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[teammember.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *TeamMemberMutation) EmailCleared() bool {
	_, ok := m.clearedFields[teammember.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *TeamMemberMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, teammember.FieldEmail)
}

// SetType sets the "type" field.
func (m *TeamMemberMutation) SetType(t teammember.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TeamMemberMutation) GetType() (r teammember.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldType(ctx context.Context) (v teammember.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TeamMemberMutation) ResetType() {
	m._type = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *TeamMemberMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *TeamMemberMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *TeamMemberMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *TeamMemberMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *TeamMemberMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetIsActive sets the "is_active" field.
func (m *TeamMemberMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TeamMemberMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TeamMemberMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamMemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamMemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamMemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamMemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamMemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamMemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TeamMemberMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TeamMemberMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TeamMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TeamMemberMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TeamMemberMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TeamMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TeamMemberMutation builder.
func (m *TeamMemberMutation) Where(ps ...predicate.TeamMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TeamMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TeamMember).
func (m *TeamMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMemberMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, teammember.FieldName)
	}
	if m.title != nil {
		fields = append(fields, teammember.FieldTitle)
	}
	if m.bio != nil {
		fields = append(fields, teammember.FieldBio)
	}
	if m.image_url != nil {
		fields = append(fields, teammember.FieldImageURL)
	}
	if m.linkedin_url != nil {
		fields = append(fields, teammember.FieldLinkedinURL)
	}
	if m.twitter_url != nil {
		fields = append(fields, teammember.FieldTwitterURL)
	}
	if m.email != nil {
		fields = append(fields, teammember.FieldEmail)
	}
	if m._type != nil {
		fields = append(fields, teammember.FieldType)
	}
	if m.display_order != nil {
		fields = append(fields, teammember.FieldDisplayOrder)
	}
	if m.is_active != nil {
		fields = append(fields, teammember.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, teammember.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teammember.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammember.FieldName:
		return m.Name()
	case teammember.FieldTitle:
		return m.Title()
	case teammember.FieldBio:
		return m.Bio()
	case teammember.FieldImageURL:
		return m.ImageURL()
	case teammember.FieldLinkedinURL:
		return m.LinkedinURL()
	case teammember.FieldTwitterURL:
		return m.TwitterURL()
	case teammember.FieldEmail:
		return m.Email()
	case teammember.FieldType:
		return m.GetType()
	case teammember.FieldDisplayOrder:
		return m.DisplayOrder()
	case teammember.FieldIsActive:
		return m.IsActive()
	case teammember.FieldCreatedAt:
		return m.CreatedAt()
	case teammember.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammember.FieldName:
		return m.OldName(ctx)
	case teammember.FieldTitle:
		return m.OldTitle(ctx)
	case teammember.FieldBio:
		return m.OldBio(ctx)
	case teammember.FieldImageURL:
		return m.OldImageURL(ctx)
	case teammember.FieldLinkedinURL:
		return m.OldLinkedinURL(ctx)
	case teammember.FieldTwitterURL:
		return m.OldTwitterURL(ctx)
	case teammember.FieldEmail:
		return m.OldEmail(ctx)
	case teammember.FieldType:
		return m.OldType(ctx)
	case teammember.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case teammember.FieldIsActive:
		return m.OldIsActive(ctx)
	case teammember.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teammember.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TeamMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammember.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teammember.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case teammember.FieldBio:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case teammember.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case teammember.FieldLinkedinURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedinURL(v)
		return nil
	case teammember.FieldTwitterURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwitterURL(v)
		return nil
	case teammember.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case teammember.FieldType:
		v, ok := value.(teammember.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case teammember.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case teammember.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case teammember.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teammember.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TeamMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMemberMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, teammember.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case teammember.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case teammember.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown TeamMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teammember.FieldBio) {
		fields = append(fields, teammember.FieldBio)
	}
	if m.FieldCleared(teammember.FieldImageURL) {
		fields = append(fields, teammember.FieldImageURL)
	}
	if m.FieldCleared(teammember.FieldLinkedinURL) {
		fields = append(fields, teammember.FieldLinkedinURL)
	}
	if m.FieldCleared(teammember.FieldTwitterURL) {
		fields = append(fields, teammember.FieldTwitterURL)
	}
	if m.FieldCleared(teammember.FieldEmail) {
		fields = append(fields, teammember.FieldEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMemberMutation) ClearField(name string) error {
	switch name {
	case teammember.FieldBio:
		m.ClearBio()
		return nil
	case teammember.FieldImageURL:
		m.ClearImageURL()
		return nil
	case teammember.FieldLinkedinURL:
		m.ClearLinkedinURL()
		return nil
	case teammember.FieldTwitterURL:
		m.ClearTwitterURL()
		return nil
	case teammember.FieldEmail:
		m.ClearEmail()
		return nil
	}
	return fmt.Errorf("unknown TeamMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMemberMutation) ResetField(name string) error {
	switch name {
	case teammember.FieldName:
		m.ResetName()
		return nil
	case teammember.FieldTitle:
		m.ResetTitle()
		return nil
	case teammember.FieldBio:
		m.ResetBio()
		return nil
	case teammember.FieldImageURL:
		m.ResetImageURL()
		return nil
	case teammember.FieldLinkedinURL:
		m.ResetLinkedinURL()
		return nil
	case teammember.FieldTwitterURL:
		m.ResetTwitterURL()
		return nil
	case teammember.FieldEmail:
		m.ResetEmail()
		return nil
	case teammember.FieldType:
		m.ResetType()
		return nil
	case teammember.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case teammember.FieldIsActive:
		m.ResetIsActive()
		return nil
	case teammember.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teammember.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TeamMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, teammember.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, teammember.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case teammember.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMemberMutation) ClearEdge(name string) error {
	switch name {
	case teammember.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TeamMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMemberMutation) ResetEdge(name string) error {
	switch name {
	case teammember.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TeamMember edge %s", name)
}

// TeamMemberItemMutation represents an operation that mutates the TeamMemberItem nodes in the graph.
type TeamMemberItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_order        *int
	add_order     *int
	name          *string
	role          *map[string]string
	bio           *map[string]string
	image_url     *string
	linkedin_url  *string
	twitter_url   *string
	email_url     *string
	clearedFields map[string]struct{}
	block         *int
	clearedblock  bool
	done          bool
	oldValue      func(context.Context) (*TeamMemberItem, error)
	predicates    []predicate.TeamMemberItem
}

var _ ent.Mutation = (*TeamMemberItemMutation)(nil)

// teammemberitemOption allows management of the mutation configuration using functional options.
type teammemberitemOption func(*TeamMemberItemMutation)

// newTeamMemberItemMutation creates new mutation for the TeamMemberItem entity.
func newTeamMemberItemMutation(c config, op Op, opts ...teammemberitemOption) *TeamMemberItemMutation {
	m := &TeamMemberItemMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamMemberItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamMemberItemID sets the ID field of the mutation.
func withTeamMemberItemID(id int) teammemberitemOption {
	return func(m *TeamMemberItemMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamMemberItem
		)
		m.oldValue = func(ctx context.Context) (*TeamMemberItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamMemberItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamMemberItem sets the old TeamMemberItem of the mutation.
func withTeamMemberItem(node *TeamMemberItem) teammemberitemOption {
	return func(m *TeamMemberItemMutation) {
		m.oldValue = func(context.Context) (*TeamMemberItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMemberItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMemberItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMemberItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMemberItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamMemberItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *TeamMemberItemMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *TeamMemberItemMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the TeamMemberItem entity.
// If the TeamMemberItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberItemMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *TeamMemberItemMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *TeamMemberItemMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *TeamMemberItemMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetName sets the "name" field.
func (m *TeamMemberItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMemberItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TeamMemberItem entity.
// If the TeamMemberItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMemberItemMutation) ResetName() {
	m.name = nil
}

// SetRole sets the "role" field.
func (m *TeamMemberItemMutation) SetRole(value map[string]string) {
	m.role = &value
}

// Role returns the value of the "role" field in the mutation.
func (m *TeamMemberItemMutation) Role() (r map[string]string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the TeamMemberItem entity.
// If the TeamMemberItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberItemMutation) OldRole(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *TeamMemberItemMutation) ResetRole() {
	m.role = nil
}

// SetBio sets the "bio" field.
func (m *TeamMemberItemMutation) SetBio(value map[string]string) {
	m.bio = &value
}

// Bio returns the value of the "bio" field in the mutation.
func (m *TeamMemberItemMutation) Bio() (r map[string]string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the TeamMemberItem entity.
// If the TeamMemberItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberItemMutation) OldBio(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *TeamMemberItemMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[teammemberitem.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *TeamMemberItemMutation) BioCleared() bool {
	_, ok := m.clearedFields[teammemberitem.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *TeamMemberItemMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, teammemberitem.FieldBio)
}

// SetImageURL sets the "image_url" field.
func (m *TeamMemberItemMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *TeamMemberItemMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the TeamMemberItem entity.
// If the TeamMemberItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberItemMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *TeamMemberItemMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[teammemberitem.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *TeamMemberItemMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[teammemberitem.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *TeamMemberItemMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, teammemberitem.FieldImageURL)
}

// SetLinkedinURL sets the "linkedin_url" field.
func (m *TeamMemberItemMutation) SetLinkedinURL(s string) {
	m.linkedin_url = &s
}

// LinkedinURL returns the value of the "linkedin_url" field in the mutation.
func (m *TeamMemberItemMutation) LinkedinURL() (r string, exists bool) {
	v := m.linkedin_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedinURL returns the old "linkedin_url" field's value of the TeamMemberItem entity.
// If the TeamMemberItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberItemMutation) OldLinkedinURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedinURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedinURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedinURL: %w", err)
	}
	return oldValue.LinkedinURL, nil
}

// ClearLinkedinURL clears the value of the "linkedin_url" field.
func (m *TeamMemberItemMutation) ClearLinkedinURL() {
	m.linkedin_url = nil
	m.clearedFields[teammemberitem.FieldLinkedinURL] = struct{}{}
}

// LinkedinURLCleared returns if the "linkedin_url" field was cleared in this mutation.
func (m *TeamMemberItemMutation) LinkedinURLCleared() bool {
	_, ok := m.clearedFields[teammemberitem.FieldLinkedinURL]
	return ok
}

// ResetLinkedinURL resets all changes to the "linkedin_url" field.
func (m *TeamMemberItemMutation) ResetLinkedinURL() {
	m.linkedin_url = nil
	delete(m.clearedFields, teammemberitem.FieldLinkedinURL)
}

// SetTwitterURL sets the "twitter_url" field.
func (m *TeamMemberItemMutation) SetTwitterURL(s string) {
	m.twitter_url = &s
}

// TwitterURL returns the value of the "twitter_url" field in the mutation.
func (m *TeamMemberItemMutation) TwitterURL() (r string, exists bool) {
	v := m.twitter_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTwitterURL returns the old "twitter_url" field's value of the TeamMemberItem entity.
// If the TeamMemberItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberItemMutation) OldTwitterURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwitterURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwitterURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwitterURL: %w", err)
	}
	return oldValue.TwitterURL, nil
}

// ClearTwitterURL clears the value of the "twitter_url" field.
func (m *TeamMemberItemMutation) ClearTwitterURL() {
	m.twitter_url = nil
	m.clearedFields[teammemberitem.FieldTwitterURL] = struct{}{}
}

// TwitterURLCleared returns if the "twitter_url" field was cleared in this mutation.
func (m *TeamMemberItemMutation) TwitterURLCleared() bool {
	_, ok := m.clearedFields[teammemberitem.FieldTwitterURL]
	return ok
}

// ResetTwitterURL resets all changes to the "twitter_url" field.
func (m *TeamMemberItemMutation) ResetTwitterURL() {
	m.twitter_url = nil
	delete(m.clearedFields, teammemberitem.FieldTwitterURL)
}

// SetEmailURL sets the "email_url" field.
func (m *TeamMemberItemMutation) SetEmailURL(s string) {
	m.email_url = &s
}

// EmailURL returns the value of the "email_url" field in the mutation.
func (m *TeamMemberItemMutation) EmailURL() (r string, exists bool) {
	v := m.email_url
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailURL returns the old "email_url" field's value of the TeamMemberItem entity.
// If the TeamMemberItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberItemMutation) OldEmailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailURL: %w", err)
	}
	return oldValue.EmailURL, nil
}

// ClearEmailURL clears the value of the "email_url" field.
func (m *TeamMemberItemMutation) ClearEmailURL() {
	m.email_url = nil
	m.clearedFields[teammemberitem.FieldEmailURL] = struct{}{}
}

// EmailURLCleared returns if the "email_url" field was cleared in this mutation.
func (m *TeamMemberItemMutation) EmailURLCleared() bool {
	_, ok := m.clearedFields[teammemberitem.FieldEmailURL]
	return ok
}

// ResetEmailURL resets all changes to the "email_url" field.
func (m *TeamMemberItemMutation) ResetEmailURL() {
	m.email_url = nil
	delete(m.clearedFields, teammemberitem.FieldEmailURL)
}

// SetBlockID sets the "block" edge to the BlockTeamGrid entity by id.
func (m *TeamMemberItemMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the BlockTeamGrid entity.
func (m *TeamMemberItemMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the BlockTeamGrid entity was cleared.
func (m *TeamMemberItemMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *TeamMemberItemMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *TeamMemberItemMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *TeamMemberItemMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// Where appends a list predicates to the TeamMemberItemMutation builder.
func (m *TeamMemberItemMutation) Where(ps ...predicate.TeamMemberItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMemberItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMemberItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TeamMemberItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMemberItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMemberItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TeamMemberItem).
func (m *TeamMemberItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMemberItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._order != nil {
		fields = append(fields, teammemberitem.FieldOrder)
	}
	if m.name != nil {
		fields = append(fields, teammemberitem.FieldName)
	}
	if m.role != nil {
		fields = append(fields, teammemberitem.FieldRole)
	}
	if m.bio != nil {
		fields = append(fields, teammemberitem.FieldBio)
	}
	if m.image_url != nil {
		fields = append(fields, teammemberitem.FieldImageURL)
	}
	if m.linkedin_url != nil {
		fields = append(fields, teammemberitem.FieldLinkedinURL)
	}
	if m.twitter_url != nil {
		fields = append(fields, teammemberitem.FieldTwitterURL)
	}
	if m.email_url != nil {
		fields = append(fields, teammemberitem.FieldEmailURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMemberItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammemberitem.FieldOrder:
		return m.Order()
	case teammemberitem.FieldName:
		return m.Name()
	case teammemberitem.FieldRole:
		return m.Role()
	case teammemberitem.FieldBio:
		return m.Bio()
	case teammemberitem.FieldImageURL:
		return m.ImageURL()
	case teammemberitem.FieldLinkedinURL:
		return m.LinkedinURL()
	case teammemberitem.FieldTwitterURL:
		return m.TwitterURL()
	case teammemberitem.FieldEmailURL:
		return m.EmailURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMemberItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammemberitem.FieldOrder:
		return m.OldOrder(ctx)
	case teammemberitem.FieldName:
		return m.OldName(ctx)
	case teammemberitem.FieldRole:
		return m.OldRole(ctx)
	case teammemberitem.FieldBio:
		return m.OldBio(ctx)
	case teammemberitem.FieldImageURL:
		return m.OldImageURL(ctx)
	case teammemberitem.FieldLinkedinURL:
		return m.OldLinkedinURL(ctx)
	case teammemberitem.FieldTwitterURL:
		return m.OldTwitterURL(ctx)
	case teammemberitem.FieldEmailURL:
		return m.OldEmailURL(ctx)
	}
	return nil, fmt.Errorf("unknown TeamMemberItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMemberItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammemberitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case teammemberitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teammemberitem.FieldRole:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case teammemberitem.FieldBio:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case teammemberitem.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case teammemberitem.FieldLinkedinURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedinURL(v)
		return nil
	case teammemberitem.FieldTwitterURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwitterURL(v)
		return nil
	case teammemberitem.FieldEmailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailURL(v)
		return nil
	}
	return fmt.Errorf("unknown TeamMemberItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMemberItemMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, teammemberitem.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMemberItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case teammemberitem.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMemberItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case teammemberitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown TeamMemberItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMemberItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teammemberitem.FieldBio) {
		fields = append(fields, teammemberitem.FieldBio)
	}
	if m.FieldCleared(teammemberitem.FieldImageURL) {
		fields = append(fields, teammemberitem.FieldImageURL)
	}
	if m.FieldCleared(teammemberitem.FieldLinkedinURL) {
		fields = append(fields, teammemberitem.FieldLinkedinURL)
	}
	if m.FieldCleared(teammemberitem.FieldTwitterURL) {
		fields = append(fields, teammemberitem.FieldTwitterURL)
	}
	if m.FieldCleared(teammemberitem.FieldEmailURL) {
		fields = append(fields, teammemberitem.FieldEmailURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMemberItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMemberItemMutation) ClearField(name string) error {
	switch name {
	case teammemberitem.FieldBio:
		m.ClearBio()
		return nil
	case teammemberitem.FieldImageURL:
		m.ClearImageURL()
		return nil
	case teammemberitem.FieldLinkedinURL:
		m.ClearLinkedinURL()
		return nil
	case teammemberitem.FieldTwitterURL:
		m.ClearTwitterURL()
		return nil
	case teammemberitem.FieldEmailURL:
		m.ClearEmailURL()
		return nil
	}
	return fmt.Errorf("unknown TeamMemberItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMemberItemMutation) ResetField(name string) error {
	switch name {
	case teammemberitem.FieldOrder:
		m.ResetOrder()
		return nil
	case teammemberitem.FieldName:
		m.ResetName()
		return nil
	case teammemberitem.FieldRole:
		m.ResetRole()
		return nil
	case teammemberitem.FieldBio:
		m.ResetBio()
		return nil
	case teammemberitem.FieldImageURL:
		m.ResetImageURL()
		return nil
	case teammemberitem.FieldLinkedinURL:
		m.ResetLinkedinURL()
		return nil
	case teammemberitem.FieldTwitterURL:
		m.ResetTwitterURL()
		return nil
	case teammemberitem.FieldEmailURL:
		m.ResetEmailURL()
		return nil
	}
	return fmt.Errorf("unknown TeamMemberItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMemberItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.block != nil {
		edges = append(edges, teammemberitem.EdgeBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMemberItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammemberitem.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMemberItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMemberItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMemberItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblock {
		edges = append(edges, teammemberitem.EdgeBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMemberItemMutation) EdgeCleared(name string) bool {
	switch name {
	case teammemberitem.EdgeBlock:
		return m.clearedblock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMemberItemMutation) ClearEdge(name string) error {
	switch name {
	case teammemberitem.EdgeBlock:
		m.ClearBlock()
		return nil
	}
	return fmt.Errorf("unknown TeamMemberItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMemberItemMutation) ResetEdge(name string) error {
	switch name {
	case teammemberitem.EdgeBlock:
		m.ResetBlock()
		return nil
	}
	return fmt.Errorf("unknown TeamMemberItem edge %s", name)
}

// TestimonialItemMutation represents an operation that mutates the TestimonialItem nodes in the graph.
type TestimonialItemMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_order               *int
	add_order            *int
	quote                *map[string]string
	author_name          *string
	author_role          *map[string]string
	author_image_url     *string
	clearedFields        map[string]struct{}
	block                *int
	clearedblock         bool
	success_story        *int
	clearedsuccess_story bool
	done                 bool
	oldValue             func(context.Context) (*TestimonialItem, error)
	predicates           []predicate.TestimonialItem
}

var _ ent.Mutation = (*TestimonialItemMutation)(nil)

// testimonialitemOption allows management of the mutation configuration using functional options.
type testimonialitemOption func(*TestimonialItemMutation)

// newTestimonialItemMutation creates new mutation for the TestimonialItem entity.
func newTestimonialItemMutation(c config, op Op, opts ...testimonialitemOption) *TestimonialItemMutation {
	m := &TestimonialItemMutation{
		config:        c,
		op:            op,
		typ:           TypeTestimonialItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestimonialItemID sets the ID field of the mutation.
func withTestimonialItemID(id int) testimonialitemOption {
	return func(m *TestimonialItemMutation) {
		var (
			err   error
			once  sync.Once
			value *TestimonialItem
		)
		m.oldValue = func(ctx context.Context) (*TestimonialItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestimonialItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestimonialItem sets the old TestimonialItem of the mutation.
func withTestimonialItem(node *TestimonialItem) testimonialitemOption {
	return func(m *TestimonialItemMutation) {
		m.oldValue = func(context.Context) (*TestimonialItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestimonialItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestimonialItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestimonialItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestimonialItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestimonialItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *TestimonialItemMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *TestimonialItemMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the TestimonialItem entity.
// If the TestimonialItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestimonialItemMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *TestimonialItemMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *TestimonialItemMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *TestimonialItemMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetQuote sets the "quote" field.
func (m *TestimonialItemMutation) SetQuote(value map[string]string) {
	m.quote = &value
}

// Quote returns the value of the "quote" field in the mutation.
func (m *TestimonialItemMutation) Quote() (r map[string]string, exists bool) {
	v := m.quote
	if v == nil {
		return
	}
	return *v, true
}

// OldQuote returns the old "quote" field's value of the TestimonialItem entity.
// If the TestimonialItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestimonialItemMutation) OldQuote(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuote: %w", err)
	}
	return oldValue.Quote, nil
}

// ResetQuote resets all changes to the "quote" field.
func (m *TestimonialItemMutation) ResetQuote() {
	m.quote = nil
}

// SetAuthorName sets the "author_name" field.
func (m *TestimonialItemMutation) SetAuthorName(s string) {
	m.author_name = &s
}

// AuthorName returns the value of the "author_name" field in the mutation.
func (m *TestimonialItemMutation) AuthorName() (r string, exists bool) {
	v := m.author_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorName returns the old "author_name" field's value of the TestimonialItem entity.
// If the TestimonialItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestimonialItemMutation) OldAuthorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorName: %w", err)
	}
	return oldValue.AuthorName, nil
}

// ResetAuthorName resets all changes to the "author_name" field.
func (m *TestimonialItemMutation) ResetAuthorName() {
	m.author_name = nil
}

// SetAuthorRole sets the "author_role" field.
func (m *TestimonialItemMutation) SetAuthorRole(value map[string]string) {
	m.author_role = &value
}

// AuthorRole returns the value of the "author_role" field in the mutation.
func (m *TestimonialItemMutation) AuthorRole() (r map[string]string, exists bool) {
	v := m.author_role
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorRole returns the old "author_role" field's value of the TestimonialItem entity.
// If the TestimonialItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestimonialItemMutation) OldAuthorRole(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorRole: %w", err)
	}
	return oldValue.AuthorRole, nil
}

// ResetAuthorRole resets all changes to the "author_role" field.
func (m *TestimonialItemMutation) ResetAuthorRole() {
	m.author_role = nil
}

// SetAuthorImageURL sets the "author_image_url" field.
func (m *TestimonialItemMutation) SetAuthorImageURL(s string) {
	m.author_image_url = &s
}

// AuthorImageURL returns the value of the "author_image_url" field in the mutation.
func (m *TestimonialItemMutation) AuthorImageURL() (r string, exists bool) {
	v := m.author_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorImageURL returns the old "author_image_url" field's value of the TestimonialItem entity.
// If the TestimonialItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestimonialItemMutation) OldAuthorImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorImageURL: %w", err)
	}
	return oldValue.AuthorImageURL, nil
}

// ClearAuthorImageURL clears the value of the "author_image_url" field.
func (m *TestimonialItemMutation) ClearAuthorImageURL() {
	m.author_image_url = nil
	m.clearedFields[testimonialitem.FieldAuthorImageURL] = struct{}{}
}

// AuthorImageURLCleared returns if the "author_image_url" field was cleared in this mutation.
func (m *TestimonialItemMutation) AuthorImageURLCleared() bool {
	_, ok := m.clearedFields[testimonialitem.FieldAuthorImageURL]
	return ok
}

// ResetAuthorImageURL resets all changes to the "author_image_url" field.
func (m *TestimonialItemMutation) ResetAuthorImageURL() {
	m.author_image_url = nil
	delete(m.clearedFields, testimonialitem.FieldAuthorImageURL)
}

// SetBlockID sets the "block" edge to the BlockTestimonials entity by id.
func (m *TestimonialItemMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the BlockTestimonials entity.
func (m *TestimonialItemMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the BlockTestimonials entity was cleared.
func (m *TestimonialItemMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *TestimonialItemMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *TestimonialItemMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *TestimonialItemMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// SetSuccessStoryID sets the "success_story" edge to the SuccessStory entity by id.
func (m *TestimonialItemMutation) SetSuccessStoryID(id int) {
	m.success_story = &id
}

// ClearSuccessStory clears the "success_story" edge to the SuccessStory entity.
func (m *TestimonialItemMutation) ClearSuccessStory() {
	m.clearedsuccess_story = true
}

// SuccessStoryCleared reports if the "success_story" edge to the SuccessStory entity was cleared.
func (m *TestimonialItemMutation) SuccessStoryCleared() bool {
	return m.clearedsuccess_story
}

// SuccessStoryID returns the "success_story" edge ID in the mutation.
func (m *TestimonialItemMutation) SuccessStoryID() (id int, exists bool) {
	if m.success_story != nil {
		return *m.success_story, true
	}
	return
}

// SuccessStoryIDs returns the "success_story" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SuccessStoryID instead. It exists only for internal usage by the builders.
func (m *TestimonialItemMutation) SuccessStoryIDs() (ids []int) {
	if id := m.success_story; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSuccessStory resets all changes to the "success_story" edge.
func (m *TestimonialItemMutation) ResetSuccessStory() {
	m.success_story = nil
	m.clearedsuccess_story = false
}

// Where appends a list predicates to the TestimonialItemMutation builder.
func (m *TestimonialItemMutation) Where(ps ...predicate.TestimonialItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestimonialItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestimonialItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestimonialItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestimonialItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestimonialItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestimonialItem).
func (m *TestimonialItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestimonialItemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._order != nil {
		fields = append(fields, testimonialitem.FieldOrder)
	}
	if m.quote != nil {
		fields = append(fields, testimonialitem.FieldQuote)
	}
	if m.author_name != nil {
		fields = append(fields, testimonialitem.FieldAuthorName)
	}
	if m.author_role != nil {
		fields = append(fields, testimonialitem.FieldAuthorRole)
	}
	if m.author_image_url != nil {
		fields = append(fields, testimonialitem.FieldAuthorImageURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestimonialItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testimonialitem.FieldOrder:
		return m.Order()
	case testimonialitem.FieldQuote:
		return m.Quote()
	case testimonialitem.FieldAuthorName:
		return m.AuthorName()
	case testimonialitem.FieldAuthorRole:
		return m.AuthorRole()
	case testimonialitem.FieldAuthorImageURL:
		return m.AuthorImageURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestimonialItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testimonialitem.FieldOrder:
		return m.OldOrder(ctx)
	case testimonialitem.FieldQuote:
		return m.OldQuote(ctx)
	case testimonialitem.FieldAuthorName:
		return m.OldAuthorName(ctx)
	case testimonialitem.FieldAuthorRole:
		return m.OldAuthorRole(ctx)
	case testimonialitem.FieldAuthorImageURL:
		return m.OldAuthorImageURL(ctx)
	}
	return nil, fmt.Errorf("unknown TestimonialItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestimonialItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testimonialitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case testimonialitem.FieldQuote:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuote(v)
		return nil
	case testimonialitem.FieldAuthorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorName(v)
		return nil
	case testimonialitem.FieldAuthorRole:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorRole(v)
		return nil
	case testimonialitem.FieldAuthorImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorImageURL(v)
		return nil
	}
	return fmt.Errorf("unknown TestimonialItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestimonialItemMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, testimonialitem.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestimonialItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testimonialitem.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestimonialItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testimonialitem.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown TestimonialItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestimonialItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testimonialitem.FieldAuthorImageURL) {
		fields = append(fields, testimonialitem.FieldAuthorImageURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestimonialItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestimonialItemMutation) ClearField(name string) error {
	switch name {
	case testimonialitem.FieldAuthorImageURL:
		m.ClearAuthorImageURL()
		return nil
	}
	return fmt.Errorf("unknown TestimonialItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestimonialItemMutation) ResetField(name string) error {
	switch name {
	case testimonialitem.FieldOrder:
		m.ResetOrder()
		return nil
	case testimonialitem.FieldQuote:
		m.ResetQuote()
		return nil
	case testimonialitem.FieldAuthorName:
		m.ResetAuthorName()
		return nil
	case testimonialitem.FieldAuthorRole:
		m.ResetAuthorRole()
		return nil
	case testimonialitem.FieldAuthorImageURL:
		m.ResetAuthorImageURL()
		return nil
	}
	return fmt.Errorf("unknown TestimonialItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestimonialItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.block != nil {
		edges = append(edges, testimonialitem.EdgeBlock)
	}
	if m.success_story != nil {
		edges = append(edges, testimonialitem.EdgeSuccessStory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestimonialItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case testimonialitem.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	case testimonialitem.EdgeSuccessStory:
		if id := m.success_story; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestimonialItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestimonialItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestimonialItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblock {
		edges = append(edges, testimonialitem.EdgeBlock)
	}
	if m.clearedsuccess_story {
		edges = append(edges, testimonialitem.EdgeSuccessStory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestimonialItemMutation) EdgeCleared(name string) bool {
	switch name {
	case testimonialitem.EdgeBlock:
		return m.clearedblock
	case testimonialitem.EdgeSuccessStory:
		return m.clearedsuccess_story
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestimonialItemMutation) ClearEdge(name string) error {
	switch name {
	case testimonialitem.EdgeBlock:
		m.ClearBlock()
		return nil
	case testimonialitem.EdgeSuccessStory:
		m.ClearSuccessStory()
		return nil
	}
	return fmt.Errorf("unknown TestimonialItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestimonialItemMutation) ResetEdge(name string) error {
	switch name {
	case testimonialitem.EdgeBlock:
		m.ResetBlock()
		return nil
	case testimonialitem.EdgeSuccessStory:
		m.ResetSuccessStory()
		return nil
	}
	return fmt.Errorf("unknown TestimonialItem edge %s", name)
}

// TimelineEventMutation represents an operation that mutates the TimelineEvent nodes in the graph.
type TimelineEventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_order        *int
	add_order     *int
	date          *string
	title         *map[string]string
	description   *map[string]string
	image_url     *string
	clearedFields map[string]struct{}
	block         *int
	clearedblock  bool
	done          bool
	oldValue      func(context.Context) (*TimelineEvent, error)
	predicates    []predicate.TimelineEvent
}

var _ ent.Mutation = (*TimelineEventMutation)(nil)

// timelineeventOption allows management of the mutation configuration using functional options.
type timelineeventOption func(*TimelineEventMutation)

// newTimelineEventMutation creates new mutation for the TimelineEvent entity.
func newTimelineEventMutation(c config, op Op, opts ...timelineeventOption) *TimelineEventMutation {
	m := &TimelineEventMutation{
		config:        c,
		op:            op,
		typ:           TypeTimelineEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimelineEventID sets the ID field of the mutation.
func withTimelineEventID(id int) timelineeventOption {
	return func(m *TimelineEventMutation) {
		var (
			err   error
			once  sync.Once
			value *TimelineEvent
		)
		m.oldValue = func(ctx context.Context) (*TimelineEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimelineEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimelineEvent sets the old TimelineEvent of the mutation.
func withTimelineEvent(node *TimelineEvent) timelineeventOption {
	return func(m *TimelineEventMutation) {
		m.oldValue = func(context.Context) (*TimelineEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimelineEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimelineEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimelineEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimelineEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimelineEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrder sets the "order" field.
func (m *TimelineEventMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *TimelineEventMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *TimelineEventMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *TimelineEventMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *TimelineEventMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetDate sets the "date" field.
func (m *TimelineEventMutation) SetDate(s string) {
	m.date = &s
}

// Date returns the value of the "date" field in the mutation.
func (m *TimelineEventMutation) Date() (r string, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *TimelineEventMutation) ResetDate() {
	m.date = nil
}

// SetTitle sets the "title" field.
func (m *TimelineEventMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *TimelineEventMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TimelineEventMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TimelineEventMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *TimelineEventMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TimelineEventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[timelineevent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TimelineEventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[timelineevent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TimelineEventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, timelineevent.FieldDescription)
}

// SetImageURL sets the "image_url" field.
func (m *TimelineEventMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *TimelineEventMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *TimelineEventMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[timelineevent.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *TimelineEventMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[timelineevent.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *TimelineEventMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, timelineevent.FieldImageURL)
}

// SetBlockID sets the "block" edge to the BlockTimeline entity by id.
func (m *TimelineEventMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the BlockTimeline entity.
func (m *TimelineEventMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the BlockTimeline entity was cleared.
func (m *TimelineEventMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *TimelineEventMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *TimelineEventMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *TimelineEventMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// Where appends a list predicates to the TimelineEventMutation builder.
func (m *TimelineEventMutation) Where(ps ...predicate.TimelineEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimelineEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimelineEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TimelineEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimelineEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimelineEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TimelineEvent).
func (m *TimelineEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimelineEventMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._order != nil {
		fields = append(fields, timelineevent.FieldOrder)
	}
	if m.date != nil {
		fields = append(fields, timelineevent.FieldDate)
	}
	if m.title != nil {
		fields = append(fields, timelineevent.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, timelineevent.FieldDescription)
	}
	if m.image_url != nil {
		fields = append(fields, timelineevent.FieldImageURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimelineEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timelineevent.FieldOrder:
		return m.Order()
	case timelineevent.FieldDate:
		return m.Date()
	case timelineevent.FieldTitle:
		return m.Title()
	case timelineevent.FieldDescription:
		return m.Description()
	case timelineevent.FieldImageURL:
		return m.ImageURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimelineEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timelineevent.FieldOrder:
		return m.OldOrder(ctx)
	case timelineevent.FieldDate:
		return m.OldDate(ctx)
	case timelineevent.FieldTitle:
		return m.OldTitle(ctx)
	case timelineevent.FieldDescription:
		return m.OldDescription(ctx)
	case timelineevent.FieldImageURL:
		return m.OldImageURL(ctx)
	}
	return nil, fmt.Errorf("unknown TimelineEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimelineEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timelineevent.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case timelineevent.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case timelineevent.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case timelineevent.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case timelineevent.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimelineEventMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, timelineevent.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimelineEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timelineevent.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimelineEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timelineevent.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimelineEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(timelineevent.FieldDescription) {
		fields = append(fields, timelineevent.FieldDescription)
	}
	if m.FieldCleared(timelineevent.FieldImageURL) {
		fields = append(fields, timelineevent.FieldImageURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimelineEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimelineEventMutation) ClearField(name string) error {
	switch name {
	case timelineevent.FieldDescription:
		m.ClearDescription()
		return nil
	case timelineevent.FieldImageURL:
		m.ClearImageURL()
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimelineEventMutation) ResetField(name string) error {
	switch name {
	case timelineevent.FieldOrder:
		m.ResetOrder()
		return nil
	case timelineevent.FieldDate:
		m.ResetDate()
		return nil
	case timelineevent.FieldTitle:
		m.ResetTitle()
		return nil
	case timelineevent.FieldDescription:
		m.ResetDescription()
		return nil
	case timelineevent.FieldImageURL:
		m.ResetImageURL()
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimelineEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.block != nil {
		edges = append(edges, timelineevent.EdgeBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimelineEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timelineevent.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimelineEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimelineEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimelineEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblock {
		edges = append(edges, timelineevent.EdgeBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimelineEventMutation) EdgeCleared(name string) bool {
	switch name {
	case timelineevent.EdgeBlock:
		return m.clearedblock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimelineEventMutation) ClearEdge(name string) error {
	switch name {
	case timelineevent.EdgeBlock:
		m.ClearBlock()
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimelineEventMutation) ResetEdge(name string) error {
	switch name {
	case timelineevent.EdgeBlock:
		m.ResetBlock()
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_type         *token.Type
	token_hash    *string
	jti           *string
	expires_at    *time.Time
	used          *bool
	mfa_verified  *bool
	mfa_method    *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *TokenMutation) SetType(t token.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TokenMutation) GetType() (r token.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldType(ctx context.Context) (v token.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TokenMutation) ResetType() {
	m._type = nil
}

// SetTokenHash sets the "token_hash" field.
func (m *TokenMutation) SetTokenHash(s string) {
	m.token_hash = &s
}

// TokenHash returns the value of the "token_hash" field in the mutation.
func (m *TokenMutation) TokenHash() (r string, exists bool) {
	v := m.token_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenHash returns the old "token_hash" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldTokenHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenHash: %w", err)
	}
	return oldValue.TokenHash, nil
}

// ResetTokenHash resets all changes to the "token_hash" field.
func (m *TokenMutation) ResetTokenHash() {
	m.token_hash = nil
}

// SetJti sets the "jti" field.
func (m *TokenMutation) SetJti(s string) {
	m.jti = &s
}

// Jti returns the value of the "jti" field in the mutation.
func (m *TokenMutation) Jti() (r string, exists bool) {
	v := m.jti
	if v == nil {
		return
	}
	return *v, true
}

// OldJti returns the old "jti" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldJti(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJti is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJti requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJti: %w", err)
	}
	return oldValue.Jti, nil
}

// ClearJti clears the value of the "jti" field.
func (m *TokenMutation) ClearJti() {
	m.jti = nil
	m.clearedFields[token.FieldJti] = struct{}{}
}

// JtiCleared returns if the "jti" field was cleared in this mutation.
func (m *TokenMutation) JtiCleared() bool {
	_, ok := m.clearedFields[token.FieldJti]
	return ok
}

// ResetJti resets all changes to the "jti" field.
func (m *TokenMutation) ResetJti() {
	m.jti = nil
	delete(m.clearedFields, token.FieldJti)
}

// SetExpiresAt sets the "expires_at" field.
func (m *TokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsed sets the "used" field.
func (m *TokenMutation) SetUsed(b bool) {
	m.used = &b
}

// Used returns the value of the "used" field in the mutation.
func (m *TokenMutation) Used() (r bool, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// ResetUsed resets all changes to the "used" field.
func (m *TokenMutation) ResetUsed() {
	m.used = nil
}

// SetMfaVerified sets the "mfa_verified" field.
func (m *TokenMutation) SetMfaVerified(b bool) {
	m.mfa_verified = &b
}

// MfaVerified returns the value of the "mfa_verified" field in the mutation.
func (m *TokenMutation) MfaVerified() (r bool, exists bool) {
	v := m.mfa_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaVerified returns the old "mfa_verified" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldMfaVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaVerified: %w", err)
	}
	return oldValue.MfaVerified, nil
}

// ResetMfaVerified resets all changes to the "mfa_verified" field.
func (m *TokenMutation) ResetMfaVerified() {
	m.mfa_verified = nil
}

// SetMfaMethod sets the "mfa_method" field.
func (m *TokenMutation) SetMfaMethod(s string) {
	m.mfa_method = &s
}

// MfaMethod returns the value of the "mfa_method" field in the mutation.
func (m *TokenMutation) MfaMethod() (r string, exists bool) {
	v := m.mfa_method
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaMethod returns the old "mfa_method" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldMfaMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaMethod: %w", err)
	}
	return oldValue.MfaMethod, nil
}

// ClearMfaMethod clears the value of the "mfa_method" field.
func (m *TokenMutation) ClearMfaMethod() {
	m.mfa_method = nil
	m.clearedFields[token.FieldMfaMethod] = struct{}{}
}

// MfaMethodCleared returns if the "mfa_method" field was cleared in this mutation.
func (m *TokenMutation) MfaMethodCleared() bool {
	_, ok := m.clearedFields[token.FieldMfaMethod]
	return ok
}

// ResetMfaMethod resets all changes to the "mfa_method" field.
func (m *TokenMutation) ResetMfaMethod() {
	m.mfa_method = nil
	delete(m.clearedFields, token.FieldMfaMethod)
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TokenMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TokenMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._type != nil {
		fields = append(fields, token.FieldType)
	}
	if m.token_hash != nil {
		fields = append(fields, token.FieldTokenHash)
	}
	if m.jti != nil {
		fields = append(fields, token.FieldJti)
	}
	if m.expires_at != nil {
		fields = append(fields, token.FieldExpiresAt)
	}
	if m.used != nil {
		fields = append(fields, token.FieldUsed)
	}
	if m.mfa_verified != nil {
		fields = append(fields, token.FieldMfaVerified)
	}
	if m.mfa_method != nil {
		fields = append(fields, token.FieldMfaMethod)
	}
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldType:
		return m.GetType()
	case token.FieldTokenHash:
		return m.TokenHash()
	case token.FieldJti:
		return m.Jti()
	case token.FieldExpiresAt:
		return m.ExpiresAt()
	case token.FieldUsed:
		return m.Used()
	case token.FieldMfaVerified:
		return m.MfaVerified()
	case token.FieldMfaMethod:
		return m.MfaMethod()
	case token.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldType:
		return m.OldType(ctx)
	case token.FieldTokenHash:
		return m.OldTokenHash(ctx)
	case token.FieldJti:
		return m.OldJti(ctx)
	case token.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case token.FieldUsed:
		return m.OldUsed(ctx)
	case token.FieldMfaVerified:
		return m.OldMfaVerified(ctx)
	case token.FieldMfaMethod:
		return m.OldMfaMethod(ctx)
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldType:
		v, ok := value.(token.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case token.FieldTokenHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenHash(v)
		return nil
	case token.FieldJti:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJti(v)
		return nil
	case token.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case token.FieldUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case token.FieldMfaVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaVerified(v)
		return nil
	case token.FieldMfaMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaMethod(v)
		return nil
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldJti) {
		fields = append(fields, token.FieldJti)
	}
	if m.FieldCleared(token.FieldMfaMethod) {
		fields = append(fields, token.FieldMfaMethod)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldJti:
		m.ClearJti()
		return nil
	case token.FieldMfaMethod:
		m.ClearMfaMethod()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldType:
		m.ResetType()
		return nil
	case token.FieldTokenHash:
		m.ResetTokenHash()
		return nil
	case token.FieldJti:
		m.ResetJti()
		return nil
	case token.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case token.FieldUsed:
		m.ResetUsed()
		return nil
	case token.FieldMfaVerified:
		m.ResetMfaVerified()
		return nil
	case token.FieldMfaMethod:
		m.ResetMfaMethod()
		return nil
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// TrustedDeviceMutation represents an operation that mutates the TrustedDevice nodes in the graph.
type TrustedDeviceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	fingerprint   *string
	user_agent    *string
	last_ip       *string
	last_used_at  *time.Time
	created_at    *time.Time
	verified_at   *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*TrustedDevice, error)
	predicates    []predicate.TrustedDevice
}

var _ ent.Mutation = (*TrustedDeviceMutation)(nil)

// trusteddeviceOption allows management of the mutation configuration using functional options.
type trusteddeviceOption func(*TrustedDeviceMutation)

// newTrustedDeviceMutation creates new mutation for the TrustedDevice entity.
func newTrustedDeviceMutation(c config, op Op, opts ...trusteddeviceOption) *TrustedDeviceMutation {
	m := &TrustedDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeTrustedDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrustedDeviceID sets the ID field of the mutation.
func withTrustedDeviceID(id int) trusteddeviceOption {
	return func(m *TrustedDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *TrustedDevice
		)
		m.oldValue = func(ctx context.Context) (*TrustedDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrustedDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrustedDevice sets the old TrustedDevice of the mutation.
func withTrustedDevice(node *TrustedDevice) trusteddeviceOption {
	return func(m *TrustedDeviceMutation) {
		m.oldValue = func(context.Context) (*TrustedDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrustedDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrustedDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrustedDeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrustedDeviceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrustedDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFingerprint sets the "fingerprint" field.
func (m *TrustedDeviceMutation) SetFingerprint(s string) {
	m.fingerprint = &s
}

// Fingerprint returns the value of the "fingerprint" field in the mutation.
func (m *TrustedDeviceMutation) Fingerprint() (r string, exists bool) {
	v := m.fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldFingerprint returns the old "fingerprint" field's value of the TrustedDevice entity.
// If the TrustedDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustedDeviceMutation) OldFingerprint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFingerprint: %w", err)
	}
	return oldValue.Fingerprint, nil
}

// ResetFingerprint resets all changes to the "fingerprint" field.
func (m *TrustedDeviceMutation) ResetFingerprint() {
	m.fingerprint = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *TrustedDeviceMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *TrustedDeviceMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the TrustedDevice entity.
// If the TrustedDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustedDeviceMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *TrustedDeviceMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[trusteddevice.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *TrustedDeviceMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[trusteddevice.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *TrustedDeviceMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, trusteddevice.FieldUserAgent)
}

// SetLastIP sets the "last_ip" field.
func (m *TrustedDeviceMutation) SetLastIP(s string) {
	m.last_ip = &s
}

// LastIP returns the value of the "last_ip" field in the mutation.
func (m *TrustedDeviceMutation) LastIP() (r string, exists bool) {
	v := m.last_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastIP returns the old "last_ip" field's value of the TrustedDevice entity.
// If the TrustedDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustedDeviceMutation) OldLastIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastIP: %w", err)
	}
	return oldValue.LastIP, nil
}

// ClearLastIP clears the value of the "last_ip" field.
func (m *TrustedDeviceMutation) ClearLastIP() {
	m.last_ip = nil
	m.clearedFields[trusteddevice.FieldLastIP] = struct{}{}
}

// LastIPCleared returns if the "last_ip" field was cleared in this mutation.
func (m *TrustedDeviceMutation) LastIPCleared() bool {
	_, ok := m.clearedFields[trusteddevice.FieldLastIP]
	return ok
}

// ResetLastIP resets all changes to the "last_ip" field.
func (m *TrustedDeviceMutation) ResetLastIP() {
	m.last_ip = nil
	delete(m.clearedFields, trusteddevice.FieldLastIP)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *TrustedDeviceMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *TrustedDeviceMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the TrustedDevice entity.
// If the TrustedDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustedDeviceMutation) OldLastUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *TrustedDeviceMutation) ResetLastUsedAt() {
	m.last_used_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TrustedDeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrustedDeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrustedDevice entity.
// If the TrustedDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustedDeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrustedDeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetVerifiedAt sets the "verified_at" field.
func (m *TrustedDeviceMutation) SetVerifiedAt(t time.Time) {
	m.verified_at = &t
}

// VerifiedAt returns the value of the "verified_at" field in the mutation.
func (m *TrustedDeviceMutation) VerifiedAt() (r time.Time, exists bool) {
	v := m.verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedAt returns the old "verified_at" field's value of the TrustedDevice entity.
// If the TrustedDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrustedDeviceMutation) OldVerifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedAt: %w", err)
	}
	return oldValue.VerifiedAt, nil
}

// ClearVerifiedAt clears the value of the "verified_at" field.
func (m *TrustedDeviceMutation) ClearVerifiedAt() {
	m.verified_at = nil
	m.clearedFields[trusteddevice.FieldVerifiedAt] = struct{}{}
}

// VerifiedAtCleared returns if the "verified_at" field was cleared in this mutation.
func (m *TrustedDeviceMutation) VerifiedAtCleared() bool {
	_, ok := m.clearedFields[trusteddevice.FieldVerifiedAt]
	return ok
}

// ResetVerifiedAt resets all changes to the "verified_at" field.
func (m *TrustedDeviceMutation) ResetVerifiedAt() {
	m.verified_at = nil
	delete(m.clearedFields, trusteddevice.FieldVerifiedAt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TrustedDeviceMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TrustedDeviceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TrustedDeviceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TrustedDeviceMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TrustedDeviceMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TrustedDeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TrustedDeviceMutation builder.
func (m *TrustedDeviceMutation) Where(ps ...predicate.TrustedDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrustedDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrustedDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TrustedDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrustedDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrustedDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TrustedDevice).
func (m *TrustedDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrustedDeviceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.fingerprint != nil {
		fields = append(fields, trusteddevice.FieldFingerprint)
	}
	if m.user_agent != nil {
		fields = append(fields, trusteddevice.FieldUserAgent)
	}
	if m.last_ip != nil {
		fields = append(fields, trusteddevice.FieldLastIP)
	}
	if m.last_used_at != nil {
		fields = append(fields, trusteddevice.FieldLastUsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, trusteddevice.FieldCreatedAt)
	}
	if m.verified_at != nil {
		fields = append(fields, trusteddevice.FieldVerifiedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrustedDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trusteddevice.FieldFingerprint:
		return m.Fingerprint()
	case trusteddevice.FieldUserAgent:
		return m.UserAgent()
	case trusteddevice.FieldLastIP:
		return m.LastIP()
	case trusteddevice.FieldLastUsedAt:
		return m.LastUsedAt()
	case trusteddevice.FieldCreatedAt:
		return m.CreatedAt()
	case trusteddevice.FieldVerifiedAt:
		return m.VerifiedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrustedDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trusteddevice.FieldFingerprint:
		return m.OldFingerprint(ctx)
	case trusteddevice.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case trusteddevice.FieldLastIP:
		return m.OldLastIP(ctx)
	case trusteddevice.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case trusteddevice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trusteddevice.FieldVerifiedAt:
		return m.OldVerifiedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TrustedDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustedDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trusteddevice.FieldFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFingerprint(v)
		return nil
	case trusteddevice.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case trusteddevice.FieldLastIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastIP(v)
		return nil
	case trusteddevice.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case trusteddevice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trusteddevice.FieldVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TrustedDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrustedDeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrustedDeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrustedDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TrustedDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrustedDeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trusteddevice.FieldUserAgent) {
		fields = append(fields, trusteddevice.FieldUserAgent)
	}
	if m.FieldCleared(trusteddevice.FieldLastIP) {
		fields = append(fields, trusteddevice.FieldLastIP)
	}
	if m.FieldCleared(trusteddevice.FieldVerifiedAt) {
		fields = append(fields, trusteddevice.FieldVerifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrustedDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrustedDeviceMutation) ClearField(name string) error {
	switch name {
	case trusteddevice.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case trusteddevice.FieldLastIP:
		m.ClearLastIP()
		return nil
	case trusteddevice.FieldVerifiedAt:
		m.ClearVerifiedAt()
		return nil
	}
	return fmt.Errorf("unknown TrustedDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrustedDeviceMutation) ResetField(name string) error {
	switch name {
	case trusteddevice.FieldFingerprint:
		m.ResetFingerprint()
		return nil
	case trusteddevice.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case trusteddevice.FieldLastIP:
		m.ResetLastIP()
		return nil
	case trusteddevice.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case trusteddevice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trusteddevice.FieldVerifiedAt:
		m.ResetVerifiedAt()
		return nil
	}
	return fmt.Errorf("unknown TrustedDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrustedDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, trusteddevice.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrustedDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trusteddevice.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrustedDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrustedDeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrustedDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, trusteddevice.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrustedDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case trusteddevice.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrustedDeviceMutation) ClearEdge(name string) error {
	switch name {
	case trusteddevice.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TrustedDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrustedDeviceMutation) ResetEdge(name string) error {
	switch name {
	case trusteddevice.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TrustedDevice edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	email                         *string
	username                      *string
	hashed_password               *string
	is_verified                   *bool
	email_verified                *time.Time
	last_login_at                 *time.Time
	is_active                     *bool
	deactivated_at                *time.Time
	locked_until                  *time.Time
	created_at                    *time.Time
	updated_at                    *time.Time
	impersonating_user_id         *string
	security_timestamp            *time.Time
	password_reset_required       *bool
	roles                         *[]string
	appendroles                   []string
	mfa_secret                    *string
	mfa_enabled                   *bool
	onboarding_started_at         *time.Time
	onboarding_completed_at       *time.Time
	onboarding_skipped            *bool
	onboarding_version            *string
	onboarding_completed          *bool
	position                      *string
	analytics_properties          *map[string]interface{}
	clearedFields                 map[string]struct{}
	profile                       *int
	clearedprofile                bool
	sessions                      map[int]struct{}
	removedsessions               map[int]struct{}
	clearedsessions               bool
	tokens                        map[int]struct{}
	removedtokens                 map[int]struct{}
	clearedtokens                 bool
	trusted_devices               map[int]struct{}
	removedtrusted_devices        map[int]struct{}
	clearedtrusted_devices        bool
	password_history              map[int]struct{}
	removedpassword_history       map[int]struct{}
	clearedpassword_history       bool
	team_member                   *int
	clearedteam_member            bool
	audit_logs                    map[int]struct{}
	removedaudit_logs             map[int]struct{}
	clearedaudit_logs             bool
	jobs                          map[int]struct{}
	removedjobs                   map[int]struct{}
	clearedjobs                   bool
	dashboards                    map[int]struct{}
	removeddashboards             map[int]struct{}
	cleareddashboards             bool
	analytics_events              map[int]struct{}
	removedanalytics_events       map[int]struct{}
	clearedanalytics_events       bool
	created_reports               map[int]struct{}
	removedcreated_reports        map[int]struct{}
	clearedcreated_reports        bool
	generated_reports             map[int]struct{}
	removedgenerated_reports      map[int]struct{}
	clearedgenerated_reports      bool
	report_permissions            map[int]struct{}
	removedreport_permissions     map[int]struct{}
	clearedreport_permissions     bool
	scheduled_reports             map[int]struct{}
	removedscheduled_reports      map[int]struct{}
	clearedscheduled_reports      bool
	created_programs              map[int]struct{}
	removedcreated_programs       map[int]struct{}
	clearedcreated_programs       bool
	updated_programs              map[int]struct{}
	removedupdated_programs       map[int]struct{}
	clearedupdated_programs       bool
	program_enrolments            map[int]struct{}
	removedprogram_enrolments     map[int]struct{}
	clearedprogram_enrolments     bool
	participant_in                map[int]struct{}
	removedparticipant_in         map[int]struct{}
	clearedparticipant_in         bool
	success_stories               map[int]struct{}
	removedsuccess_stories        map[int]struct{}
	clearedsuccess_stories        bool
	news_articles                 map[int]struct{}
	removednews_articles          map[int]struct{}
	clearednews_articles          bool
	created_events                map[int]struct{}
	removedcreated_events         map[int]struct{}
	clearedcreated_events         bool
	event_registrations           map[int]struct{}
	removedevent_registrations    map[int]struct{}
	clearedevent_registrations    bool
	messages_sent                 map[int]struct{}
	removedmessages_sent          map[int]struct{}
	clearedmessages_sent          bool
	conversation_links            map[int]struct{}
	removedconversation_links     map[int]struct{}
	clearedconversation_links     bool
	volunteer_applications        map[int]struct{}
	removedvolunteer_applications map[int]struct{}
	clearedvolunteer_applications bool
	mentorship_requests           map[int]struct{}
	removedmentorship_requests    map[int]struct{}
	clearedmentorship_requests    bool
	mentorships_mentoring         map[int]struct{}
	removedmentorships_mentoring  map[int]struct{}
	clearedmentorships_mentoring  bool
	achievements                  map[int]struct{}
	removedachievements           map[int]struct{}
	clearedachievements           bool
	donations                     map[int]struct{}
	removeddonations              map[int]struct{}
	cleareddonations              bool
	organization                  map[int]struct{}
	removedorganization           map[int]struct{}
	clearedorganization           bool
	managed_partnerships          map[int]struct{}
	removedmanaged_partnerships   map[int]struct{}
	clearedmanaged_partnerships   bool
	partnership_contacts          map[int]struct{}
	removedpartnership_contacts   map[int]struct{}
	clearedpartnership_contacts   bool
	site_visits                   map[int]struct{}
	removedsite_visits            map[int]struct{}
	clearedsite_visits            bool
	document_uploads              map[int]struct{}
	removeddocument_uploads       map[int]struct{}
	cleareddocument_uploads       bool
	activity_logs                 map[int]struct{}
	removedactivity_logs          map[int]struct{}
	clearedactivity_logs          bool
	consents                      *int
	clearedconsents               bool
	onboarding                    *int
	clearedonboarding             bool
	done                          bool
	oldValue                      func(context.Context) (*User, error)
	predicates                    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetHashedPassword sets the "hashed_password" field.
func (m *UserMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *UserMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ClearHashedPassword clears the value of the "hashed_password" field.
func (m *UserMutation) ClearHashedPassword() {
	m.hashed_password = nil
	m.clearedFields[user.FieldHashedPassword] = struct{}{}
}

// HashedPasswordCleared returns if the "hashed_password" field was cleared in this mutation.
func (m *UserMutation) HashedPasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldHashedPassword]
	return ok
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *UserMutation) ResetHashedPassword() {
	m.hashed_password = nil
	delete(m.clearedFields, user.FieldHashedPassword)
}

// SetIsVerified sets the "is_verified" field.
func (m *UserMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *UserMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *UserMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(t time.Time) {
	m.email_verified = &t
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r time.Time, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ClearEmailVerified clears the value of the "email_verified" field.
func (m *UserMutation) ClearEmailVerified() {
	m.email_verified = nil
	m.clearedFields[user.FieldEmailVerified] = struct{}{}
}

// EmailVerifiedCleared returns if the "email_verified" field was cleared in this mutation.
func (m *UserMutation) EmailVerifiedCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailVerified]
	return ok
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
	delete(m.clearedFields, user.FieldEmailVerified)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetDeactivatedAt sets the "deactivated_at" field.
func (m *UserMutation) SetDeactivatedAt(t time.Time) {
	m.deactivated_at = &t
}

// DeactivatedAt returns the value of the "deactivated_at" field in the mutation.
func (m *UserMutation) DeactivatedAt() (r time.Time, exists bool) {
	v := m.deactivated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeactivatedAt returns the old "deactivated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeactivatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeactivatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeactivatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeactivatedAt: %w", err)
	}
	return oldValue.DeactivatedAt, nil
}

// ClearDeactivatedAt clears the value of the "deactivated_at" field.
func (m *UserMutation) ClearDeactivatedAt() {
	m.deactivated_at = nil
	m.clearedFields[user.FieldDeactivatedAt] = struct{}{}
}

// DeactivatedAtCleared returns if the "deactivated_at" field was cleared in this mutation.
func (m *UserMutation) DeactivatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeactivatedAt]
	return ok
}

// ResetDeactivatedAt resets all changes to the "deactivated_at" field.
func (m *UserMutation) ResetDeactivatedAt() {
	m.deactivated_at = nil
	delete(m.clearedFields, user.FieldDeactivatedAt)
}

// SetLockedUntil sets the "locked_until" field.
func (m *UserMutation) SetLockedUntil(t time.Time) {
	m.locked_until = &t
}

// LockedUntil returns the value of the "locked_until" field in the mutation.
func (m *UserMutation) LockedUntil() (r time.Time, exists bool) {
	v := m.locked_until
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedUntil returns the old "locked_until" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLockedUntil(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedUntil: %w", err)
	}
	return oldValue.LockedUntil, nil
}

// ClearLockedUntil clears the value of the "locked_until" field.
func (m *UserMutation) ClearLockedUntil() {
	m.locked_until = nil
	m.clearedFields[user.FieldLockedUntil] = struct{}{}
}

// LockedUntilCleared returns if the "locked_until" field was cleared in this mutation.
func (m *UserMutation) LockedUntilCleared() bool {
	_, ok := m.clearedFields[user.FieldLockedUntil]
	return ok
}

// ResetLockedUntil resets all changes to the "locked_until" field.
func (m *UserMutation) ResetLockedUntil() {
	m.locked_until = nil
	delete(m.clearedFields, user.FieldLockedUntil)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetImpersonatingUserID sets the "impersonating_user_id" field.
func (m *UserMutation) SetImpersonatingUserID(s string) {
	m.impersonating_user_id = &s
}

// ImpersonatingUserID returns the value of the "impersonating_user_id" field in the mutation.
func (m *UserMutation) ImpersonatingUserID() (r string, exists bool) {
	v := m.impersonating_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImpersonatingUserID returns the old "impersonating_user_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldImpersonatingUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpersonatingUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpersonatingUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpersonatingUserID: %w", err)
	}
	return oldValue.ImpersonatingUserID, nil
}

// ClearImpersonatingUserID clears the value of the "impersonating_user_id" field.
func (m *UserMutation) ClearImpersonatingUserID() {
	m.impersonating_user_id = nil
	m.clearedFields[user.FieldImpersonatingUserID] = struct{}{}
}

// ImpersonatingUserIDCleared returns if the "impersonating_user_id" field was cleared in this mutation.
func (m *UserMutation) ImpersonatingUserIDCleared() bool {
	_, ok := m.clearedFields[user.FieldImpersonatingUserID]
	return ok
}

// ResetImpersonatingUserID resets all changes to the "impersonating_user_id" field.
func (m *UserMutation) ResetImpersonatingUserID() {
	m.impersonating_user_id = nil
	delete(m.clearedFields, user.FieldImpersonatingUserID)
}

// SetSecurityTimestamp sets the "security_timestamp" field.
func (m *UserMutation) SetSecurityTimestamp(t time.Time) {
	m.security_timestamp = &t
}

// SecurityTimestamp returns the value of the "security_timestamp" field in the mutation.
func (m *UserMutation) SecurityTimestamp() (r time.Time, exists bool) {
	v := m.security_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityTimestamp returns the old "security_timestamp" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSecurityTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecurityTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecurityTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityTimestamp: %w", err)
	}
	return oldValue.SecurityTimestamp, nil
}

// ResetSecurityTimestamp resets all changes to the "security_timestamp" field.
func (m *UserMutation) ResetSecurityTimestamp() {
	m.security_timestamp = nil
}

// SetPasswordResetRequired sets the "password_reset_required" field.
func (m *UserMutation) SetPasswordResetRequired(b bool) {
	m.password_reset_required = &b
}

// PasswordResetRequired returns the value of the "password_reset_required" field in the mutation.
func (m *UserMutation) PasswordResetRequired() (r bool, exists bool) {
	v := m.password_reset_required
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordResetRequired returns the old "password_reset_required" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordResetRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordResetRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordResetRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordResetRequired: %w", err)
	}
	return oldValue.PasswordResetRequired, nil
}

// ResetPasswordResetRequired resets all changes to the "password_reset_required" field.
func (m *UserMutation) ResetPasswordResetRequired() {
	m.password_reset_required = nil
}

// SetRoles sets the "roles" field.
func (m *UserMutation) SetRoles(s []string) {
	m.roles = &s
	m.appendroles = nil
}

// Roles returns the value of the "roles" field in the mutation.
func (m *UserMutation) Roles() (r []string, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoles returns the old "roles" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoles: %w", err)
	}
	return oldValue.Roles, nil
}

// AppendRoles adds s to the "roles" field.
func (m *UserMutation) AppendRoles(s []string) {
	m.appendroles = append(m.appendroles, s...)
}

// AppendedRoles returns the list of values that were appended to the "roles" field in this mutation.
func (m *UserMutation) AppendedRoles() ([]string, bool) {
	if len(m.appendroles) == 0 {
		return nil, false
	}
	return m.appendroles, true
}

// ResetRoles resets all changes to the "roles" field.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.appendroles = nil
}

// SetMfaSecret sets the "mfa_secret" field.
func (m *UserMutation) SetMfaSecret(s string) {
	m.mfa_secret = &s
}

// MfaSecret returns the value of the "mfa_secret" field in the mutation.
func (m *UserMutation) MfaSecret() (r string, exists bool) {
	v := m.mfa_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaSecret returns the old "mfa_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMfaSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaSecret: %w", err)
	}
	return oldValue.MfaSecret, nil
}

// ClearMfaSecret clears the value of the "mfa_secret" field.
func (m *UserMutation) ClearMfaSecret() {
	m.mfa_secret = nil
	m.clearedFields[user.FieldMfaSecret] = struct{}{}
}

// MfaSecretCleared returns if the "mfa_secret" field was cleared in this mutation.
func (m *UserMutation) MfaSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldMfaSecret]
	return ok
}

// ResetMfaSecret resets all changes to the "mfa_secret" field.
func (m *UserMutation) ResetMfaSecret() {
	m.mfa_secret = nil
	delete(m.clearedFields, user.FieldMfaSecret)
}

// SetMfaEnabled sets the "mfa_enabled" field.
func (m *UserMutation) SetMfaEnabled(b bool) {
	m.mfa_enabled = &b
}

// MfaEnabled returns the value of the "mfa_enabled" field in the mutation.
func (m *UserMutation) MfaEnabled() (r bool, exists bool) {
	v := m.mfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaEnabled returns the old "mfa_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaEnabled: %w", err)
	}
	return oldValue.MfaEnabled, nil
}

// ResetMfaEnabled resets all changes to the "mfa_enabled" field.
func (m *UserMutation) ResetMfaEnabled() {
	m.mfa_enabled = nil
}

// SetOnboardingStartedAt sets the "onboarding_started_at" field.
func (m *UserMutation) SetOnboardingStartedAt(t time.Time) {
	m.onboarding_started_at = &t
}

// OnboardingStartedAt returns the value of the "onboarding_started_at" field in the mutation.
func (m *UserMutation) OnboardingStartedAt() (r time.Time, exists bool) {
	v := m.onboarding_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingStartedAt returns the old "onboarding_started_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOnboardingStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingStartedAt: %w", err)
	}
	return oldValue.OnboardingStartedAt, nil
}

// ClearOnboardingStartedAt clears the value of the "onboarding_started_at" field.
func (m *UserMutation) ClearOnboardingStartedAt() {
	m.onboarding_started_at = nil
	m.clearedFields[user.FieldOnboardingStartedAt] = struct{}{}
}

// OnboardingStartedAtCleared returns if the "onboarding_started_at" field was cleared in this mutation.
func (m *UserMutation) OnboardingStartedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldOnboardingStartedAt]
	return ok
}

// ResetOnboardingStartedAt resets all changes to the "onboarding_started_at" field.
func (m *UserMutation) ResetOnboardingStartedAt() {
	m.onboarding_started_at = nil
	delete(m.clearedFields, user.FieldOnboardingStartedAt)
}

// SetOnboardingCompletedAt sets the "onboarding_completed_at" field.
func (m *UserMutation) SetOnboardingCompletedAt(t time.Time) {
	m.onboarding_completed_at = &t
}

// OnboardingCompletedAt returns the value of the "onboarding_completed_at" field in the mutation.
func (m *UserMutation) OnboardingCompletedAt() (r time.Time, exists bool) {
	v := m.onboarding_completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingCompletedAt returns the old "onboarding_completed_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOnboardingCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingCompletedAt: %w", err)
	}
	return oldValue.OnboardingCompletedAt, nil
}

// ClearOnboardingCompletedAt clears the value of the "onboarding_completed_at" field.
func (m *UserMutation) ClearOnboardingCompletedAt() {
	m.onboarding_completed_at = nil
	m.clearedFields[user.FieldOnboardingCompletedAt] = struct{}{}
}

// OnboardingCompletedAtCleared returns if the "onboarding_completed_at" field was cleared in this mutation.
func (m *UserMutation) OnboardingCompletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldOnboardingCompletedAt]
	return ok
}

// ResetOnboardingCompletedAt resets all changes to the "onboarding_completed_at" field.
func (m *UserMutation) ResetOnboardingCompletedAt() {
	m.onboarding_completed_at = nil
	delete(m.clearedFields, user.FieldOnboardingCompletedAt)
}

// SetOnboardingSkipped sets the "onboarding_skipped" field.
func (m *UserMutation) SetOnboardingSkipped(b bool) {
	m.onboarding_skipped = &b
}

// OnboardingSkipped returns the value of the "onboarding_skipped" field in the mutation.
func (m *UserMutation) OnboardingSkipped() (r bool, exists bool) {
	v := m.onboarding_skipped
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingSkipped returns the old "onboarding_skipped" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOnboardingSkipped(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingSkipped is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingSkipped requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingSkipped: %w", err)
	}
	return oldValue.OnboardingSkipped, nil
}

// ResetOnboardingSkipped resets all changes to the "onboarding_skipped" field.
func (m *UserMutation) ResetOnboardingSkipped() {
	m.onboarding_skipped = nil
}

// SetOnboardingVersion sets the "onboarding_version" field.
func (m *UserMutation) SetOnboardingVersion(s string) {
	m.onboarding_version = &s
}

// OnboardingVersion returns the value of the "onboarding_version" field in the mutation.
func (m *UserMutation) OnboardingVersion() (r string, exists bool) {
	v := m.onboarding_version
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingVersion returns the old "onboarding_version" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOnboardingVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingVersion: %w", err)
	}
	return oldValue.OnboardingVersion, nil
}

// ClearOnboardingVersion clears the value of the "onboarding_version" field.
func (m *UserMutation) ClearOnboardingVersion() {
	m.onboarding_version = nil
	m.clearedFields[user.FieldOnboardingVersion] = struct{}{}
}

// OnboardingVersionCleared returns if the "onboarding_version" field was cleared in this mutation.
func (m *UserMutation) OnboardingVersionCleared() bool {
	_, ok := m.clearedFields[user.FieldOnboardingVersion]
	return ok
}

// ResetOnboardingVersion resets all changes to the "onboarding_version" field.
func (m *UserMutation) ResetOnboardingVersion() {
	m.onboarding_version = nil
	delete(m.clearedFields, user.FieldOnboardingVersion)
}

// SetOnboardingCompleted sets the "onboarding_completed" field.
func (m *UserMutation) SetOnboardingCompleted(b bool) {
	m.onboarding_completed = &b
}

// OnboardingCompleted returns the value of the "onboarding_completed" field in the mutation.
func (m *UserMutation) OnboardingCompleted() (r bool, exists bool) {
	v := m.onboarding_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingCompleted returns the old "onboarding_completed" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOnboardingCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingCompleted: %w", err)
	}
	return oldValue.OnboardingCompleted, nil
}

// ResetOnboardingCompleted resets all changes to the "onboarding_completed" field.
func (m *UserMutation) ResetOnboardingCompleted() {
	m.onboarding_completed = nil
}

// SetPosition sets the "position" field.
func (m *UserMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *UserMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "position" field.
func (m *UserMutation) ClearPosition() {
	m.position = nil
	m.clearedFields[user.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "position" field was cleared in this mutation.
func (m *UserMutation) PositionCleared() bool {
	_, ok := m.clearedFields[user.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "position" field.
func (m *UserMutation) ResetPosition() {
	m.position = nil
	delete(m.clearedFields, user.FieldPosition)
}

// SetAnalyticsProperties sets the "analytics_properties" field.
func (m *UserMutation) SetAnalyticsProperties(value map[string]interface{}) {
	m.analytics_properties = &value
}

// AnalyticsProperties returns the value of the "analytics_properties" field in the mutation.
func (m *UserMutation) AnalyticsProperties() (r map[string]interface{}, exists bool) {
	v := m.analytics_properties
	if v == nil {
		return
	}
	return *v, true
}

// OldAnalyticsProperties returns the old "analytics_properties" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAnalyticsProperties(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnalyticsProperties is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnalyticsProperties requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnalyticsProperties: %w", err)
	}
	return oldValue.AnalyticsProperties, nil
}

// ClearAnalyticsProperties clears the value of the "analytics_properties" field.
func (m *UserMutation) ClearAnalyticsProperties() {
	m.analytics_properties = nil
	m.clearedFields[user.FieldAnalyticsProperties] = struct{}{}
}

// AnalyticsPropertiesCleared returns if the "analytics_properties" field was cleared in this mutation.
func (m *UserMutation) AnalyticsPropertiesCleared() bool {
	_, ok := m.clearedFields[user.FieldAnalyticsProperties]
	return ok
}

// ResetAnalyticsProperties resets all changes to the "analytics_properties" field.
func (m *UserMutation) ResetAnalyticsProperties() {
	m.analytics_properties = nil
	delete(m.clearedFields, user.FieldAnalyticsProperties)
}

// SetProfileID sets the "profile" edge to the UserProfile entity by id.
func (m *UserMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the UserProfile entity.
func (m *UserMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the UserProfile entity was cleared.
func (m *UserMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddSessionIDs adds the "sessions" edge to the UserSession entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the UserSession entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the UserSession entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the UserSession entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the UserSession entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *UserMutation) AddTokenIDs(ids ...int) {
	if m.tokens == nil {
		m.tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *UserMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *UserMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *UserMutation) RemoveTokenIDs(ids ...int) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *UserMutation) RemovedTokensIDs() (ids []int) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *UserMutation) TokensIDs() (ids []int) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *UserMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddTrustedDeviceIDs adds the "trusted_devices" edge to the TrustedDevice entity by ids.
func (m *UserMutation) AddTrustedDeviceIDs(ids ...int) {
	if m.trusted_devices == nil {
		m.trusted_devices = make(map[int]struct{})
	}
	for i := range ids {
		m.trusted_devices[ids[i]] = struct{}{}
	}
}

// ClearTrustedDevices clears the "trusted_devices" edge to the TrustedDevice entity.
func (m *UserMutation) ClearTrustedDevices() {
	m.clearedtrusted_devices = true
}

// TrustedDevicesCleared reports if the "trusted_devices" edge to the TrustedDevice entity was cleared.
func (m *UserMutation) TrustedDevicesCleared() bool {
	return m.clearedtrusted_devices
}

// RemoveTrustedDeviceIDs removes the "trusted_devices" edge to the TrustedDevice entity by IDs.
func (m *UserMutation) RemoveTrustedDeviceIDs(ids ...int) {
	if m.removedtrusted_devices == nil {
		m.removedtrusted_devices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.trusted_devices, ids[i])
		m.removedtrusted_devices[ids[i]] = struct{}{}
	}
}

// RemovedTrustedDevices returns the removed IDs of the "trusted_devices" edge to the TrustedDevice entity.
func (m *UserMutation) RemovedTrustedDevicesIDs() (ids []int) {
	for id := range m.removedtrusted_devices {
		ids = append(ids, id)
	}
	return
}

// TrustedDevicesIDs returns the "trusted_devices" edge IDs in the mutation.
func (m *UserMutation) TrustedDevicesIDs() (ids []int) {
	for id := range m.trusted_devices {
		ids = append(ids, id)
	}
	return
}

// ResetTrustedDevices resets all changes to the "trusted_devices" edge.
func (m *UserMutation) ResetTrustedDevices() {
	m.trusted_devices = nil
	m.clearedtrusted_devices = false
	m.removedtrusted_devices = nil
}

// AddPasswordHistoryIDs adds the "password_history" edge to the PasswordHistory entity by ids.
func (m *UserMutation) AddPasswordHistoryIDs(ids ...int) {
	if m.password_history == nil {
		m.password_history = make(map[int]struct{})
	}
	for i := range ids {
		m.password_history[ids[i]] = struct{}{}
	}
}

// ClearPasswordHistory clears the "password_history" edge to the PasswordHistory entity.
func (m *UserMutation) ClearPasswordHistory() {
	m.clearedpassword_history = true
}

// PasswordHistoryCleared reports if the "password_history" edge to the PasswordHistory entity was cleared.
func (m *UserMutation) PasswordHistoryCleared() bool {
	return m.clearedpassword_history
}

// RemovePasswordHistoryIDs removes the "password_history" edge to the PasswordHistory entity by IDs.
func (m *UserMutation) RemovePasswordHistoryIDs(ids ...int) {
	if m.removedpassword_history == nil {
		m.removedpassword_history = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.password_history, ids[i])
		m.removedpassword_history[ids[i]] = struct{}{}
	}
}

// RemovedPasswordHistory returns the removed IDs of the "password_history" edge to the PasswordHistory entity.
func (m *UserMutation) RemovedPasswordHistoryIDs() (ids []int) {
	for id := range m.removedpassword_history {
		ids = append(ids, id)
	}
	return
}

// PasswordHistoryIDs returns the "password_history" edge IDs in the mutation.
func (m *UserMutation) PasswordHistoryIDs() (ids []int) {
	for id := range m.password_history {
		ids = append(ids, id)
	}
	return
}

// ResetPasswordHistory resets all changes to the "password_history" edge.
func (m *UserMutation) ResetPasswordHistory() {
	m.password_history = nil
	m.clearedpassword_history = false
	m.removedpassword_history = nil
}

// SetTeamMemberID sets the "team_member" edge to the TeamMember entity by id.
func (m *UserMutation) SetTeamMemberID(id int) {
	m.team_member = &id
}

// ClearTeamMember clears the "team_member" edge to the TeamMember entity.
func (m *UserMutation) ClearTeamMember() {
	m.clearedteam_member = true
}

// TeamMemberCleared reports if the "team_member" edge to the TeamMember entity was cleared.
func (m *UserMutation) TeamMemberCleared() bool {
	return m.clearedteam_member
}

// TeamMemberID returns the "team_member" edge ID in the mutation.
func (m *UserMutation) TeamMemberID() (id int, exists bool) {
	if m.team_member != nil {
		return *m.team_member, true
	}
	return
}

// TeamMemberIDs returns the "team_member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamMemberID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TeamMemberIDs() (ids []int) {
	if id := m.team_member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamMember resets all changes to the "team_member" edge.
func (m *UserMutation) ResetTeamMember() {
	m.team_member = nil
	m.clearedteam_member = false
}

// AddAuditLogIDs adds the "audit_logs" edge to the AuditLog entity by ids.
func (m *UserMutation) AddAuditLogIDs(ids ...int) {
	if m.audit_logs == nil {
		m.audit_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.audit_logs[ids[i]] = struct{}{}
	}
}

// ClearAuditLogs clears the "audit_logs" edge to the AuditLog entity.
func (m *UserMutation) ClearAuditLogs() {
	m.clearedaudit_logs = true
}

// AuditLogsCleared reports if the "audit_logs" edge to the AuditLog entity was cleared.
func (m *UserMutation) AuditLogsCleared() bool {
	return m.clearedaudit_logs
}

// RemoveAuditLogIDs removes the "audit_logs" edge to the AuditLog entity by IDs.
func (m *UserMutation) RemoveAuditLogIDs(ids ...int) {
	if m.removedaudit_logs == nil {
		m.removedaudit_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.audit_logs, ids[i])
		m.removedaudit_logs[ids[i]] = struct{}{}
	}
}

// RemovedAuditLogs returns the removed IDs of the "audit_logs" edge to the AuditLog entity.
func (m *UserMutation) RemovedAuditLogsIDs() (ids []int) {
	for id := range m.removedaudit_logs {
		ids = append(ids, id)
	}
	return
}

// AuditLogsIDs returns the "audit_logs" edge IDs in the mutation.
func (m *UserMutation) AuditLogsIDs() (ids []int) {
	for id := range m.audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAuditLogs resets all changes to the "audit_logs" edge.
func (m *UserMutation) ResetAuditLogs() {
	m.audit_logs = nil
	m.clearedaudit_logs = false
	m.removedaudit_logs = nil
}

// AddJobIDs adds the "jobs" edge to the Job entity by ids.
func (m *UserMutation) AddJobIDs(ids ...int) {
	if m.jobs == nil {
		m.jobs = make(map[int]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the Job entity.
func (m *UserMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the Job entity was cleared.
func (m *UserMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the Job entity by IDs.
func (m *UserMutation) RemoveJobIDs(ids ...int) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the Job entity.
func (m *UserMutation) RemovedJobsIDs() (ids []int) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *UserMutation) JobsIDs() (ids []int) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *UserMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// AddDashboardIDs adds the "dashboards" edge to the AnalyticsDashboard entity by ids.
func (m *UserMutation) AddDashboardIDs(ids ...int) {
	if m.dashboards == nil {
		m.dashboards = make(map[int]struct{})
	}
	for i := range ids {
		m.dashboards[ids[i]] = struct{}{}
	}
}

// ClearDashboards clears the "dashboards" edge to the AnalyticsDashboard entity.
func (m *UserMutation) ClearDashboards() {
	m.cleareddashboards = true
}

// DashboardsCleared reports if the "dashboards" edge to the AnalyticsDashboard entity was cleared.
func (m *UserMutation) DashboardsCleared() bool {
	return m.cleareddashboards
}

// RemoveDashboardIDs removes the "dashboards" edge to the AnalyticsDashboard entity by IDs.
func (m *UserMutation) RemoveDashboardIDs(ids ...int) {
	if m.removeddashboards == nil {
		m.removeddashboards = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dashboards, ids[i])
		m.removeddashboards[ids[i]] = struct{}{}
	}
}

// RemovedDashboards returns the removed IDs of the "dashboards" edge to the AnalyticsDashboard entity.
func (m *UserMutation) RemovedDashboardsIDs() (ids []int) {
	for id := range m.removeddashboards {
		ids = append(ids, id)
	}
	return
}

// DashboardsIDs returns the "dashboards" edge IDs in the mutation.
func (m *UserMutation) DashboardsIDs() (ids []int) {
	for id := range m.dashboards {
		ids = append(ids, id)
	}
	return
}

// ResetDashboards resets all changes to the "dashboards" edge.
func (m *UserMutation) ResetDashboards() {
	m.dashboards = nil
	m.cleareddashboards = false
	m.removeddashboards = nil
}

// AddAnalyticsEventIDs adds the "analytics_events" edge to the AnalyticsEvent entity by ids.
func (m *UserMutation) AddAnalyticsEventIDs(ids ...int) {
	if m.analytics_events == nil {
		m.analytics_events = make(map[int]struct{})
	}
	for i := range ids {
		m.analytics_events[ids[i]] = struct{}{}
	}
}

// ClearAnalyticsEvents clears the "analytics_events" edge to the AnalyticsEvent entity.
func (m *UserMutation) ClearAnalyticsEvents() {
	m.clearedanalytics_events = true
}

// AnalyticsEventsCleared reports if the "analytics_events" edge to the AnalyticsEvent entity was cleared.
func (m *UserMutation) AnalyticsEventsCleared() bool {
	return m.clearedanalytics_events
}

// RemoveAnalyticsEventIDs removes the "analytics_events" edge to the AnalyticsEvent entity by IDs.
func (m *UserMutation) RemoveAnalyticsEventIDs(ids ...int) {
	if m.removedanalytics_events == nil {
		m.removedanalytics_events = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.analytics_events, ids[i])
		m.removedanalytics_events[ids[i]] = struct{}{}
	}
}

// RemovedAnalyticsEvents returns the removed IDs of the "analytics_events" edge to the AnalyticsEvent entity.
func (m *UserMutation) RemovedAnalyticsEventsIDs() (ids []int) {
	for id := range m.removedanalytics_events {
		ids = append(ids, id)
	}
	return
}

// AnalyticsEventsIDs returns the "analytics_events" edge IDs in the mutation.
func (m *UserMutation) AnalyticsEventsIDs() (ids []int) {
	for id := range m.analytics_events {
		ids = append(ids, id)
	}
	return
}

// ResetAnalyticsEvents resets all changes to the "analytics_events" edge.
func (m *UserMutation) ResetAnalyticsEvents() {
	m.analytics_events = nil
	m.clearedanalytics_events = false
	m.removedanalytics_events = nil
}

// AddCreatedReportIDs adds the "created_reports" edge to the ReportDefinition entity by ids.
func (m *UserMutation) AddCreatedReportIDs(ids ...int) {
	if m.created_reports == nil {
		m.created_reports = make(map[int]struct{})
	}
	for i := range ids {
		m.created_reports[ids[i]] = struct{}{}
	}
}

// ClearCreatedReports clears the "created_reports" edge to the ReportDefinition entity.
func (m *UserMutation) ClearCreatedReports() {
	m.clearedcreated_reports = true
}

// CreatedReportsCleared reports if the "created_reports" edge to the ReportDefinition entity was cleared.
func (m *UserMutation) CreatedReportsCleared() bool {
	return m.clearedcreated_reports
}

// RemoveCreatedReportIDs removes the "created_reports" edge to the ReportDefinition entity by IDs.
func (m *UserMutation) RemoveCreatedReportIDs(ids ...int) {
	if m.removedcreated_reports == nil {
		m.removedcreated_reports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_reports, ids[i])
		m.removedcreated_reports[ids[i]] = struct{}{}
	}
}

// RemovedCreatedReports returns the removed IDs of the "created_reports" edge to the ReportDefinition entity.
func (m *UserMutation) RemovedCreatedReportsIDs() (ids []int) {
	for id := range m.removedcreated_reports {
		ids = append(ids, id)
	}
	return
}

// CreatedReportsIDs returns the "created_reports" edge IDs in the mutation.
func (m *UserMutation) CreatedReportsIDs() (ids []int) {
	for id := range m.created_reports {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedReports resets all changes to the "created_reports" edge.
func (m *UserMutation) ResetCreatedReports() {
	m.created_reports = nil
	m.clearedcreated_reports = false
	m.removedcreated_reports = nil
}

// AddGeneratedReportIDs adds the "generated_reports" edge to the GeneratedReport entity by ids.
func (m *UserMutation) AddGeneratedReportIDs(ids ...int) {
	if m.generated_reports == nil {
		m.generated_reports = make(map[int]struct{})
	}
	for i := range ids {
		m.generated_reports[ids[i]] = struct{}{}
	}
}

// ClearGeneratedReports clears the "generated_reports" edge to the GeneratedReport entity.
func (m *UserMutation) ClearGeneratedReports() {
	m.clearedgenerated_reports = true
}

// GeneratedReportsCleared reports if the "generated_reports" edge to the GeneratedReport entity was cleared.
func (m *UserMutation) GeneratedReportsCleared() bool {
	return m.clearedgenerated_reports
}

// RemoveGeneratedReportIDs removes the "generated_reports" edge to the GeneratedReport entity by IDs.
func (m *UserMutation) RemoveGeneratedReportIDs(ids ...int) {
	if m.removedgenerated_reports == nil {
		m.removedgenerated_reports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.generated_reports, ids[i])
		m.removedgenerated_reports[ids[i]] = struct{}{}
	}
}

// RemovedGeneratedReports returns the removed IDs of the "generated_reports" edge to the GeneratedReport entity.
func (m *UserMutation) RemovedGeneratedReportsIDs() (ids []int) {
	for id := range m.removedgenerated_reports {
		ids = append(ids, id)
	}
	return
}

// GeneratedReportsIDs returns the "generated_reports" edge IDs in the mutation.
func (m *UserMutation) GeneratedReportsIDs() (ids []int) {
	for id := range m.generated_reports {
		ids = append(ids, id)
	}
	return
}

// ResetGeneratedReports resets all changes to the "generated_reports" edge.
func (m *UserMutation) ResetGeneratedReports() {
	m.generated_reports = nil
	m.clearedgenerated_reports = false
	m.removedgenerated_reports = nil
}

// AddReportPermissionIDs adds the "report_permissions" edge to the ReportPermission entity by ids.
func (m *UserMutation) AddReportPermissionIDs(ids ...int) {
	if m.report_permissions == nil {
		m.report_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.report_permissions[ids[i]] = struct{}{}
	}
}

// ClearReportPermissions clears the "report_permissions" edge to the ReportPermission entity.
func (m *UserMutation) ClearReportPermissions() {
	m.clearedreport_permissions = true
}

// ReportPermissionsCleared reports if the "report_permissions" edge to the ReportPermission entity was cleared.
func (m *UserMutation) ReportPermissionsCleared() bool {
	return m.clearedreport_permissions
}

// RemoveReportPermissionIDs removes the "report_permissions" edge to the ReportPermission entity by IDs.
func (m *UserMutation) RemoveReportPermissionIDs(ids ...int) {
	if m.removedreport_permissions == nil {
		m.removedreport_permissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.report_permissions, ids[i])
		m.removedreport_permissions[ids[i]] = struct{}{}
	}
}

// RemovedReportPermissions returns the removed IDs of the "report_permissions" edge to the ReportPermission entity.
func (m *UserMutation) RemovedReportPermissionsIDs() (ids []int) {
	for id := range m.removedreport_permissions {
		ids = append(ids, id)
	}
	return
}

// ReportPermissionsIDs returns the "report_permissions" edge IDs in the mutation.
func (m *UserMutation) ReportPermissionsIDs() (ids []int) {
	for id := range m.report_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetReportPermissions resets all changes to the "report_permissions" edge.
func (m *UserMutation) ResetReportPermissions() {
	m.report_permissions = nil
	m.clearedreport_permissions = false
	m.removedreport_permissions = nil
}

// AddScheduledReportIDs adds the "scheduled_reports" edge to the ScheduledReport entity by ids.
func (m *UserMutation) AddScheduledReportIDs(ids ...int) {
	if m.scheduled_reports == nil {
		m.scheduled_reports = make(map[int]struct{})
	}
	for i := range ids {
		m.scheduled_reports[ids[i]] = struct{}{}
	}
}

// ClearScheduledReports clears the "scheduled_reports" edge to the ScheduledReport entity.
func (m *UserMutation) ClearScheduledReports() {
	m.clearedscheduled_reports = true
}

// ScheduledReportsCleared reports if the "scheduled_reports" edge to the ScheduledReport entity was cleared.
func (m *UserMutation) ScheduledReportsCleared() bool {
	return m.clearedscheduled_reports
}

// RemoveScheduledReportIDs removes the "scheduled_reports" edge to the ScheduledReport entity by IDs.
func (m *UserMutation) RemoveScheduledReportIDs(ids ...int) {
	if m.removedscheduled_reports == nil {
		m.removedscheduled_reports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scheduled_reports, ids[i])
		m.removedscheduled_reports[ids[i]] = struct{}{}
	}
}

// RemovedScheduledReports returns the removed IDs of the "scheduled_reports" edge to the ScheduledReport entity.
func (m *UserMutation) RemovedScheduledReportsIDs() (ids []int) {
	for id := range m.removedscheduled_reports {
		ids = append(ids, id)
	}
	return
}

// ScheduledReportsIDs returns the "scheduled_reports" edge IDs in the mutation.
func (m *UserMutation) ScheduledReportsIDs() (ids []int) {
	for id := range m.scheduled_reports {
		ids = append(ids, id)
	}
	return
}

// ResetScheduledReports resets all changes to the "scheduled_reports" edge.
func (m *UserMutation) ResetScheduledReports() {
	m.scheduled_reports = nil
	m.clearedscheduled_reports = false
	m.removedscheduled_reports = nil
}

// AddCreatedProgramIDs adds the "created_programs" edge to the Program entity by ids.
func (m *UserMutation) AddCreatedProgramIDs(ids ...int) {
	if m.created_programs == nil {
		m.created_programs = make(map[int]struct{})
	}
	for i := range ids {
		m.created_programs[ids[i]] = struct{}{}
	}
}

// ClearCreatedPrograms clears the "created_programs" edge to the Program entity.
func (m *UserMutation) ClearCreatedPrograms() {
	m.clearedcreated_programs = true
}

// CreatedProgramsCleared reports if the "created_programs" edge to the Program entity was cleared.
func (m *UserMutation) CreatedProgramsCleared() bool {
	return m.clearedcreated_programs
}

// RemoveCreatedProgramIDs removes the "created_programs" edge to the Program entity by IDs.
func (m *UserMutation) RemoveCreatedProgramIDs(ids ...int) {
	if m.removedcreated_programs == nil {
		m.removedcreated_programs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_programs, ids[i])
		m.removedcreated_programs[ids[i]] = struct{}{}
	}
}

// RemovedCreatedPrograms returns the removed IDs of the "created_programs" edge to the Program entity.
func (m *UserMutation) RemovedCreatedProgramsIDs() (ids []int) {
	for id := range m.removedcreated_programs {
		ids = append(ids, id)
	}
	return
}

// CreatedProgramsIDs returns the "created_programs" edge IDs in the mutation.
func (m *UserMutation) CreatedProgramsIDs() (ids []int) {
	for id := range m.created_programs {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedPrograms resets all changes to the "created_programs" edge.
func (m *UserMutation) ResetCreatedPrograms() {
	m.created_programs = nil
	m.clearedcreated_programs = false
	m.removedcreated_programs = nil
}

// AddUpdatedProgramIDs adds the "updated_programs" edge to the Program entity by ids.
func (m *UserMutation) AddUpdatedProgramIDs(ids ...int) {
	if m.updated_programs == nil {
		m.updated_programs = make(map[int]struct{})
	}
	for i := range ids {
		m.updated_programs[ids[i]] = struct{}{}
	}
}

// ClearUpdatedPrograms clears the "updated_programs" edge to the Program entity.
func (m *UserMutation) ClearUpdatedPrograms() {
	m.clearedupdated_programs = true
}

// UpdatedProgramsCleared reports if the "updated_programs" edge to the Program entity was cleared.
func (m *UserMutation) UpdatedProgramsCleared() bool {
	return m.clearedupdated_programs
}

// RemoveUpdatedProgramIDs removes the "updated_programs" edge to the Program entity by IDs.
func (m *UserMutation) RemoveUpdatedProgramIDs(ids ...int) {
	if m.removedupdated_programs == nil {
		m.removedupdated_programs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.updated_programs, ids[i])
		m.removedupdated_programs[ids[i]] = struct{}{}
	}
}

// RemovedUpdatedPrograms returns the removed IDs of the "updated_programs" edge to the Program entity.
func (m *UserMutation) RemovedUpdatedProgramsIDs() (ids []int) {
	for id := range m.removedupdated_programs {
		ids = append(ids, id)
	}
	return
}

// UpdatedProgramsIDs returns the "updated_programs" edge IDs in the mutation.
func (m *UserMutation) UpdatedProgramsIDs() (ids []int) {
	for id := range m.updated_programs {
		ids = append(ids, id)
	}
	return
}

// ResetUpdatedPrograms resets all changes to the "updated_programs" edge.
func (m *UserMutation) ResetUpdatedPrograms() {
	m.updated_programs = nil
	m.clearedupdated_programs = false
	m.removedupdated_programs = nil
}

// AddProgramEnrolmentIDs adds the "program_enrolments" edge to the ProgramEnrolment entity by ids.
func (m *UserMutation) AddProgramEnrolmentIDs(ids ...int) {
	if m.program_enrolments == nil {
		m.program_enrolments = make(map[int]struct{})
	}
	for i := range ids {
		m.program_enrolments[ids[i]] = struct{}{}
	}
}

// ClearProgramEnrolments clears the "program_enrolments" edge to the ProgramEnrolment entity.
func (m *UserMutation) ClearProgramEnrolments() {
	m.clearedprogram_enrolments = true
}

// ProgramEnrolmentsCleared reports if the "program_enrolments" edge to the ProgramEnrolment entity was cleared.
func (m *UserMutation) ProgramEnrolmentsCleared() bool {
	return m.clearedprogram_enrolments
}

// RemoveProgramEnrolmentIDs removes the "program_enrolments" edge to the ProgramEnrolment entity by IDs.
func (m *UserMutation) RemoveProgramEnrolmentIDs(ids ...int) {
	if m.removedprogram_enrolments == nil {
		m.removedprogram_enrolments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.program_enrolments, ids[i])
		m.removedprogram_enrolments[ids[i]] = struct{}{}
	}
}

// RemovedProgramEnrolments returns the removed IDs of the "program_enrolments" edge to the ProgramEnrolment entity.
func (m *UserMutation) RemovedProgramEnrolmentsIDs() (ids []int) {
	for id := range m.removedprogram_enrolments {
		ids = append(ids, id)
	}
	return
}

// ProgramEnrolmentsIDs returns the "program_enrolments" edge IDs in the mutation.
func (m *UserMutation) ProgramEnrolmentsIDs() (ids []int) {
	for id := range m.program_enrolments {
		ids = append(ids, id)
	}
	return
}

// ResetProgramEnrolments resets all changes to the "program_enrolments" edge.
func (m *UserMutation) ResetProgramEnrolments() {
	m.program_enrolments = nil
	m.clearedprogram_enrolments = false
	m.removedprogram_enrolments = nil
}

// AddParticipantInIDs adds the "participant_in" edge to the ProgramParticipant entity by ids.
func (m *UserMutation) AddParticipantInIDs(ids ...int) {
	if m.participant_in == nil {
		m.participant_in = make(map[int]struct{})
	}
	for i := range ids {
		m.participant_in[ids[i]] = struct{}{}
	}
}

// ClearParticipantIn clears the "participant_in" edge to the ProgramParticipant entity.
func (m *UserMutation) ClearParticipantIn() {
	m.clearedparticipant_in = true
}

// ParticipantInCleared reports if the "participant_in" edge to the ProgramParticipant entity was cleared.
func (m *UserMutation) ParticipantInCleared() bool {
	return m.clearedparticipant_in
}

// RemoveParticipantInIDs removes the "participant_in" edge to the ProgramParticipant entity by IDs.
func (m *UserMutation) RemoveParticipantInIDs(ids ...int) {
	if m.removedparticipant_in == nil {
		m.removedparticipant_in = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.participant_in, ids[i])
		m.removedparticipant_in[ids[i]] = struct{}{}
	}
}

// RemovedParticipantIn returns the removed IDs of the "participant_in" edge to the ProgramParticipant entity.
func (m *UserMutation) RemovedParticipantInIDs() (ids []int) {
	for id := range m.removedparticipant_in {
		ids = append(ids, id)
	}
	return
}

// ParticipantInIDs returns the "participant_in" edge IDs in the mutation.
func (m *UserMutation) ParticipantInIDs() (ids []int) {
	for id := range m.participant_in {
		ids = append(ids, id)
	}
	return
}

// ResetParticipantIn resets all changes to the "participant_in" edge.
func (m *UserMutation) ResetParticipantIn() {
	m.participant_in = nil
	m.clearedparticipant_in = false
	m.removedparticipant_in = nil
}

// AddSuccessStoryIDs adds the "success_stories" edge to the SuccessStory entity by ids.
func (m *UserMutation) AddSuccessStoryIDs(ids ...int) {
	if m.success_stories == nil {
		m.success_stories = make(map[int]struct{})
	}
	for i := range ids {
		m.success_stories[ids[i]] = struct{}{}
	}
}

// ClearSuccessStories clears the "success_stories" edge to the SuccessStory entity.
func (m *UserMutation) ClearSuccessStories() {
	m.clearedsuccess_stories = true
}

// SuccessStoriesCleared reports if the "success_stories" edge to the SuccessStory entity was cleared.
func (m *UserMutation) SuccessStoriesCleared() bool {
	return m.clearedsuccess_stories
}

// RemoveSuccessStoryIDs removes the "success_stories" edge to the SuccessStory entity by IDs.
func (m *UserMutation) RemoveSuccessStoryIDs(ids ...int) {
	if m.removedsuccess_stories == nil {
		m.removedsuccess_stories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.success_stories, ids[i])
		m.removedsuccess_stories[ids[i]] = struct{}{}
	}
}

// RemovedSuccessStories returns the removed IDs of the "success_stories" edge to the SuccessStory entity.
func (m *UserMutation) RemovedSuccessStoriesIDs() (ids []int) {
	for id := range m.removedsuccess_stories {
		ids = append(ids, id)
	}
	return
}

// SuccessStoriesIDs returns the "success_stories" edge IDs in the mutation.
func (m *UserMutation) SuccessStoriesIDs() (ids []int) {
	for id := range m.success_stories {
		ids = append(ids, id)
	}
	return
}

// ResetSuccessStories resets all changes to the "success_stories" edge.
func (m *UserMutation) ResetSuccessStories() {
	m.success_stories = nil
	m.clearedsuccess_stories = false
	m.removedsuccess_stories = nil
}

// AddNewsArticleIDs adds the "news_articles" edge to the NewsArticle entity by ids.
func (m *UserMutation) AddNewsArticleIDs(ids ...int) {
	if m.news_articles == nil {
		m.news_articles = make(map[int]struct{})
	}
	for i := range ids {
		m.news_articles[ids[i]] = struct{}{}
	}
}

// ClearNewsArticles clears the "news_articles" edge to the NewsArticle entity.
func (m *UserMutation) ClearNewsArticles() {
	m.clearednews_articles = true
}

// NewsArticlesCleared reports if the "news_articles" edge to the NewsArticle entity was cleared.
func (m *UserMutation) NewsArticlesCleared() bool {
	return m.clearednews_articles
}

// RemoveNewsArticleIDs removes the "news_articles" edge to the NewsArticle entity by IDs.
func (m *UserMutation) RemoveNewsArticleIDs(ids ...int) {
	if m.removednews_articles == nil {
		m.removednews_articles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.news_articles, ids[i])
		m.removednews_articles[ids[i]] = struct{}{}
	}
}

// RemovedNewsArticles returns the removed IDs of the "news_articles" edge to the NewsArticle entity.
func (m *UserMutation) RemovedNewsArticlesIDs() (ids []int) {
	for id := range m.removednews_articles {
		ids = append(ids, id)
	}
	return
}

// NewsArticlesIDs returns the "news_articles" edge IDs in the mutation.
func (m *UserMutation) NewsArticlesIDs() (ids []int) {
	for id := range m.news_articles {
		ids = append(ids, id)
	}
	return
}

// ResetNewsArticles resets all changes to the "news_articles" edge.
func (m *UserMutation) ResetNewsArticles() {
	m.news_articles = nil
	m.clearednews_articles = false
	m.removednews_articles = nil
}

// AddCreatedEventIDs adds the "created_events" edge to the Event entity by ids.
func (m *UserMutation) AddCreatedEventIDs(ids ...int) {
	if m.created_events == nil {
		m.created_events = make(map[int]struct{})
	}
	for i := range ids {
		m.created_events[ids[i]] = struct{}{}
	}
}

// ClearCreatedEvents clears the "created_events" edge to the Event entity.
func (m *UserMutation) ClearCreatedEvents() {
	m.clearedcreated_events = true
}

// CreatedEventsCleared reports if the "created_events" edge to the Event entity was cleared.
func (m *UserMutation) CreatedEventsCleared() bool {
	return m.clearedcreated_events
}

// RemoveCreatedEventIDs removes the "created_events" edge to the Event entity by IDs.
func (m *UserMutation) RemoveCreatedEventIDs(ids ...int) {
	if m.removedcreated_events == nil {
		m.removedcreated_events = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_events, ids[i])
		m.removedcreated_events[ids[i]] = struct{}{}
	}
}

// RemovedCreatedEvents returns the removed IDs of the "created_events" edge to the Event entity.
func (m *UserMutation) RemovedCreatedEventsIDs() (ids []int) {
	for id := range m.removedcreated_events {
		ids = append(ids, id)
	}
	return
}

// CreatedEventsIDs returns the "created_events" edge IDs in the mutation.
func (m *UserMutation) CreatedEventsIDs() (ids []int) {
	for id := range m.created_events {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedEvents resets all changes to the "created_events" edge.
func (m *UserMutation) ResetCreatedEvents() {
	m.created_events = nil
	m.clearedcreated_events = false
	m.removedcreated_events = nil
}

// AddEventRegistrationIDs adds the "event_registrations" edge to the EventRegistration entity by ids.
func (m *UserMutation) AddEventRegistrationIDs(ids ...int) {
	if m.event_registrations == nil {
		m.event_registrations = make(map[int]struct{})
	}
	for i := range ids {
		m.event_registrations[ids[i]] = struct{}{}
	}
}

// ClearEventRegistrations clears the "event_registrations" edge to the EventRegistration entity.
func (m *UserMutation) ClearEventRegistrations() {
	m.clearedevent_registrations = true
}

// EventRegistrationsCleared reports if the "event_registrations" edge to the EventRegistration entity was cleared.
func (m *UserMutation) EventRegistrationsCleared() bool {
	return m.clearedevent_registrations
}

// RemoveEventRegistrationIDs removes the "event_registrations" edge to the EventRegistration entity by IDs.
func (m *UserMutation) RemoveEventRegistrationIDs(ids ...int) {
	if m.removedevent_registrations == nil {
		m.removedevent_registrations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_registrations, ids[i])
		m.removedevent_registrations[ids[i]] = struct{}{}
	}
}

// RemovedEventRegistrations returns the removed IDs of the "event_registrations" edge to the EventRegistration entity.
func (m *UserMutation) RemovedEventRegistrationsIDs() (ids []int) {
	for id := range m.removedevent_registrations {
		ids = append(ids, id)
	}
	return
}

// EventRegistrationsIDs returns the "event_registrations" edge IDs in the mutation.
func (m *UserMutation) EventRegistrationsIDs() (ids []int) {
	for id := range m.event_registrations {
		ids = append(ids, id)
	}
	return
}

// ResetEventRegistrations resets all changes to the "event_registrations" edge.
func (m *UserMutation) ResetEventRegistrations() {
	m.event_registrations = nil
	m.clearedevent_registrations = false
	m.removedevent_registrations = nil
}

// AddMessagesSentIDs adds the "messages_sent" edge to the Message entity by ids.
func (m *UserMutation) AddMessagesSentIDs(ids ...int) {
	if m.messages_sent == nil {
		m.messages_sent = make(map[int]struct{})
	}
	for i := range ids {
		m.messages_sent[ids[i]] = struct{}{}
	}
}

// ClearMessagesSent clears the "messages_sent" edge to the Message entity.
func (m *UserMutation) ClearMessagesSent() {
	m.clearedmessages_sent = true
}

// MessagesSentCleared reports if the "messages_sent" edge to the Message entity was cleared.
func (m *UserMutation) MessagesSentCleared() bool {
	return m.clearedmessages_sent
}

// RemoveMessagesSentIDs removes the "messages_sent" edge to the Message entity by IDs.
func (m *UserMutation) RemoveMessagesSentIDs(ids ...int) {
	if m.removedmessages_sent == nil {
		m.removedmessages_sent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.messages_sent, ids[i])
		m.removedmessages_sent[ids[i]] = struct{}{}
	}
}

// RemovedMessagesSent returns the removed IDs of the "messages_sent" edge to the Message entity.
func (m *UserMutation) RemovedMessagesSentIDs() (ids []int) {
	for id := range m.removedmessages_sent {
		ids = append(ids, id)
	}
	return
}

// MessagesSentIDs returns the "messages_sent" edge IDs in the mutation.
func (m *UserMutation) MessagesSentIDs() (ids []int) {
	for id := range m.messages_sent {
		ids = append(ids, id)
	}
	return
}

// ResetMessagesSent resets all changes to the "messages_sent" edge.
func (m *UserMutation) ResetMessagesSent() {
	m.messages_sent = nil
	m.clearedmessages_sent = false
	m.removedmessages_sent = nil
}

// AddConversationLinkIDs adds the "conversation_links" edge to the ConversationParticipant entity by ids.
func (m *UserMutation) AddConversationLinkIDs(ids ...int) {
	if m.conversation_links == nil {
		m.conversation_links = make(map[int]struct{})
	}
	for i := range ids {
		m.conversation_links[ids[i]] = struct{}{}
	}
}

// ClearConversationLinks clears the "conversation_links" edge to the ConversationParticipant entity.
func (m *UserMutation) ClearConversationLinks() {
	m.clearedconversation_links = true
}

// ConversationLinksCleared reports if the "conversation_links" edge to the ConversationParticipant entity was cleared.
func (m *UserMutation) ConversationLinksCleared() bool {
	return m.clearedconversation_links
}

// RemoveConversationLinkIDs removes the "conversation_links" edge to the ConversationParticipant entity by IDs.
func (m *UserMutation) RemoveConversationLinkIDs(ids ...int) {
	if m.removedconversation_links == nil {
		m.removedconversation_links = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.conversation_links, ids[i])
		m.removedconversation_links[ids[i]] = struct{}{}
	}
}

// RemovedConversationLinks returns the removed IDs of the "conversation_links" edge to the ConversationParticipant entity.
func (m *UserMutation) RemovedConversationLinksIDs() (ids []int) {
	for id := range m.removedconversation_links {
		ids = append(ids, id)
	}
	return
}

// ConversationLinksIDs returns the "conversation_links" edge IDs in the mutation.
func (m *UserMutation) ConversationLinksIDs() (ids []int) {
	for id := range m.conversation_links {
		ids = append(ids, id)
	}
	return
}

// ResetConversationLinks resets all changes to the "conversation_links" edge.
func (m *UserMutation) ResetConversationLinks() {
	m.conversation_links = nil
	m.clearedconversation_links = false
	m.removedconversation_links = nil
}

// AddVolunteerApplicationIDs adds the "volunteer_applications" edge to the VolunteerApplication entity by ids.
func (m *UserMutation) AddVolunteerApplicationIDs(ids ...int) {
	if m.volunteer_applications == nil {
		m.volunteer_applications = make(map[int]struct{})
	}
	for i := range ids {
		m.volunteer_applications[ids[i]] = struct{}{}
	}
}

// ClearVolunteerApplications clears the "volunteer_applications" edge to the VolunteerApplication entity.
func (m *UserMutation) ClearVolunteerApplications() {
	m.clearedvolunteer_applications = true
}

// VolunteerApplicationsCleared reports if the "volunteer_applications" edge to the VolunteerApplication entity was cleared.
func (m *UserMutation) VolunteerApplicationsCleared() bool {
	return m.clearedvolunteer_applications
}

// RemoveVolunteerApplicationIDs removes the "volunteer_applications" edge to the VolunteerApplication entity by IDs.
func (m *UserMutation) RemoveVolunteerApplicationIDs(ids ...int) {
	if m.removedvolunteer_applications == nil {
		m.removedvolunteer_applications = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.volunteer_applications, ids[i])
		m.removedvolunteer_applications[ids[i]] = struct{}{}
	}
}

// RemovedVolunteerApplications returns the removed IDs of the "volunteer_applications" edge to the VolunteerApplication entity.
func (m *UserMutation) RemovedVolunteerApplicationsIDs() (ids []int) {
	for id := range m.removedvolunteer_applications {
		ids = append(ids, id)
	}
	return
}

// VolunteerApplicationsIDs returns the "volunteer_applications" edge IDs in the mutation.
func (m *UserMutation) VolunteerApplicationsIDs() (ids []int) {
	for id := range m.volunteer_applications {
		ids = append(ids, id)
	}
	return
}

// ResetVolunteerApplications resets all changes to the "volunteer_applications" edge.
func (m *UserMutation) ResetVolunteerApplications() {
	m.volunteer_applications = nil
	m.clearedvolunteer_applications = false
	m.removedvolunteer_applications = nil
}

// AddMentorshipRequestIDs adds the "mentorship_requests" edge to the MentorshipRequest entity by ids.
func (m *UserMutation) AddMentorshipRequestIDs(ids ...int) {
	if m.mentorship_requests == nil {
		m.mentorship_requests = make(map[int]struct{})
	}
	for i := range ids {
		m.mentorship_requests[ids[i]] = struct{}{}
	}
}

// ClearMentorshipRequests clears the "mentorship_requests" edge to the MentorshipRequest entity.
func (m *UserMutation) ClearMentorshipRequests() {
	m.clearedmentorship_requests = true
}

// MentorshipRequestsCleared reports if the "mentorship_requests" edge to the MentorshipRequest entity was cleared.
func (m *UserMutation) MentorshipRequestsCleared() bool {
	return m.clearedmentorship_requests
}

// RemoveMentorshipRequestIDs removes the "mentorship_requests" edge to the MentorshipRequest entity by IDs.
func (m *UserMutation) RemoveMentorshipRequestIDs(ids ...int) {
	if m.removedmentorship_requests == nil {
		m.removedmentorship_requests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mentorship_requests, ids[i])
		m.removedmentorship_requests[ids[i]] = struct{}{}
	}
}

// RemovedMentorshipRequests returns the removed IDs of the "mentorship_requests" edge to the MentorshipRequest entity.
func (m *UserMutation) RemovedMentorshipRequestsIDs() (ids []int) {
	for id := range m.removedmentorship_requests {
		ids = append(ids, id)
	}
	return
}

// MentorshipRequestsIDs returns the "mentorship_requests" edge IDs in the mutation.
func (m *UserMutation) MentorshipRequestsIDs() (ids []int) {
	for id := range m.mentorship_requests {
		ids = append(ids, id)
	}
	return
}

// ResetMentorshipRequests resets all changes to the "mentorship_requests" edge.
func (m *UserMutation) ResetMentorshipRequests() {
	m.mentorship_requests = nil
	m.clearedmentorship_requests = false
	m.removedmentorship_requests = nil
}

// AddMentorshipsMentoringIDs adds the "mentorships_mentoring" edge to the MentorshipRequest entity by ids.
func (m *UserMutation) AddMentorshipsMentoringIDs(ids ...int) {
	if m.mentorships_mentoring == nil {
		m.mentorships_mentoring = make(map[int]struct{})
	}
	for i := range ids {
		m.mentorships_mentoring[ids[i]] = struct{}{}
	}
}

// ClearMentorshipsMentoring clears the "mentorships_mentoring" edge to the MentorshipRequest entity.
func (m *UserMutation) ClearMentorshipsMentoring() {
	m.clearedmentorships_mentoring = true
}

// MentorshipsMentoringCleared reports if the "mentorships_mentoring" edge to the MentorshipRequest entity was cleared.
func (m *UserMutation) MentorshipsMentoringCleared() bool {
	return m.clearedmentorships_mentoring
}

// RemoveMentorshipsMentoringIDs removes the "mentorships_mentoring" edge to the MentorshipRequest entity by IDs.
func (m *UserMutation) RemoveMentorshipsMentoringIDs(ids ...int) {
	if m.removedmentorships_mentoring == nil {
		m.removedmentorships_mentoring = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mentorships_mentoring, ids[i])
		m.removedmentorships_mentoring[ids[i]] = struct{}{}
	}
}

// RemovedMentorshipsMentoring returns the removed IDs of the "mentorships_mentoring" edge to the MentorshipRequest entity.
func (m *UserMutation) RemovedMentorshipsMentoringIDs() (ids []int) {
	for id := range m.removedmentorships_mentoring {
		ids = append(ids, id)
	}
	return
}

// MentorshipsMentoringIDs returns the "mentorships_mentoring" edge IDs in the mutation.
func (m *UserMutation) MentorshipsMentoringIDs() (ids []int) {
	for id := range m.mentorships_mentoring {
		ids = append(ids, id)
	}
	return
}

// ResetMentorshipsMentoring resets all changes to the "mentorships_mentoring" edge.
func (m *UserMutation) ResetMentorshipsMentoring() {
	m.mentorships_mentoring = nil
	m.clearedmentorships_mentoring = false
	m.removedmentorships_mentoring = nil
}

// AddAchievementIDs adds the "achievements" edge to the UserAchievement entity by ids.
func (m *UserMutation) AddAchievementIDs(ids ...int) {
	if m.achievements == nil {
		m.achievements = make(map[int]struct{})
	}
	for i := range ids {
		m.achievements[ids[i]] = struct{}{}
	}
}

// ClearAchievements clears the "achievements" edge to the UserAchievement entity.
func (m *UserMutation) ClearAchievements() {
	m.clearedachievements = true
}

// AchievementsCleared reports if the "achievements" edge to the UserAchievement entity was cleared.
func (m *UserMutation) AchievementsCleared() bool {
	return m.clearedachievements
}

// RemoveAchievementIDs removes the "achievements" edge to the UserAchievement entity by IDs.
func (m *UserMutation) RemoveAchievementIDs(ids ...int) {
	if m.removedachievements == nil {
		m.removedachievements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.achievements, ids[i])
		m.removedachievements[ids[i]] = struct{}{}
	}
}

// RemovedAchievements returns the removed IDs of the "achievements" edge to the UserAchievement entity.
func (m *UserMutation) RemovedAchievementsIDs() (ids []int) {
	for id := range m.removedachievements {
		ids = append(ids, id)
	}
	return
}

// AchievementsIDs returns the "achievements" edge IDs in the mutation.
func (m *UserMutation) AchievementsIDs() (ids []int) {
	for id := range m.achievements {
		ids = append(ids, id)
	}
	return
}

// ResetAchievements resets all changes to the "achievements" edge.
func (m *UserMutation) ResetAchievements() {
	m.achievements = nil
	m.clearedachievements = false
	m.removedachievements = nil
}

// AddDonationIDs adds the "donations" edge to the Donation entity by ids.
func (m *UserMutation) AddDonationIDs(ids ...int) {
	if m.donations == nil {
		m.donations = make(map[int]struct{})
	}
	for i := range ids {
		m.donations[ids[i]] = struct{}{}
	}
}

// ClearDonations clears the "donations" edge to the Donation entity.
func (m *UserMutation) ClearDonations() {
	m.cleareddonations = true
}

// DonationsCleared reports if the "donations" edge to the Donation entity was cleared.
func (m *UserMutation) DonationsCleared() bool {
	return m.cleareddonations
}

// RemoveDonationIDs removes the "donations" edge to the Donation entity by IDs.
func (m *UserMutation) RemoveDonationIDs(ids ...int) {
	if m.removeddonations == nil {
		m.removeddonations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.donations, ids[i])
		m.removeddonations[ids[i]] = struct{}{}
	}
}

// RemovedDonations returns the removed IDs of the "donations" edge to the Donation entity.
func (m *UserMutation) RemovedDonationsIDs() (ids []int) {
	for id := range m.removeddonations {
		ids = append(ids, id)
	}
	return
}

// DonationsIDs returns the "donations" edge IDs in the mutation.
func (m *UserMutation) DonationsIDs() (ids []int) {
	for id := range m.donations {
		ids = append(ids, id)
	}
	return
}

// ResetDonations resets all changes to the "donations" edge.
func (m *UserMutation) ResetDonations() {
	m.donations = nil
	m.cleareddonations = false
	m.removeddonations = nil
}

// AddOrganizationIDs adds the "organization" edge to the Organization entity by ids.
func (m *UserMutation) AddOrganizationIDs(ids ...int) {
	if m.organization == nil {
		m.organization = make(map[int]struct{})
	}
	for i := range ids {
		m.organization[ids[i]] = struct{}{}
	}
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *UserMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// RemoveOrganizationIDs removes the "organization" edge to the Organization entity by IDs.
func (m *UserMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganization == nil {
		m.removedorganization = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organization, ids[i])
		m.removedorganization[ids[i]] = struct{}{}
	}
}

// RemovedOrganization returns the removed IDs of the "organization" edge to the Organization entity.
func (m *UserMutation) RemovedOrganizationIDs() (ids []int) {
	for id := range m.removedorganization {
		ids = append(ids, id)
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
func (m *UserMutation) OrganizationIDs() (ids []int) {
	for id := range m.organization {
		ids = append(ids, id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *UserMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
	m.removedorganization = nil
}

// AddManagedPartnershipIDs adds the "managed_partnerships" edge to the Partnership entity by ids.
func (m *UserMutation) AddManagedPartnershipIDs(ids ...int) {
	if m.managed_partnerships == nil {
		m.managed_partnerships = make(map[int]struct{})
	}
	for i := range ids {
		m.managed_partnerships[ids[i]] = struct{}{}
	}
}

// ClearManagedPartnerships clears the "managed_partnerships" edge to the Partnership entity.
func (m *UserMutation) ClearManagedPartnerships() {
	m.clearedmanaged_partnerships = true
}

// ManagedPartnershipsCleared reports if the "managed_partnerships" edge to the Partnership entity was cleared.
func (m *UserMutation) ManagedPartnershipsCleared() bool {
	return m.clearedmanaged_partnerships
}

// RemoveManagedPartnershipIDs removes the "managed_partnerships" edge to the Partnership entity by IDs.
func (m *UserMutation) RemoveManagedPartnershipIDs(ids ...int) {
	if m.removedmanaged_partnerships == nil {
		m.removedmanaged_partnerships = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.managed_partnerships, ids[i])
		m.removedmanaged_partnerships[ids[i]] = struct{}{}
	}
}

// RemovedManagedPartnerships returns the removed IDs of the "managed_partnerships" edge to the Partnership entity.
func (m *UserMutation) RemovedManagedPartnershipsIDs() (ids []int) {
	for id := range m.removedmanaged_partnerships {
		ids = append(ids, id)
	}
	return
}

// ManagedPartnershipsIDs returns the "managed_partnerships" edge IDs in the mutation.
func (m *UserMutation) ManagedPartnershipsIDs() (ids []int) {
	for id := range m.managed_partnerships {
		ids = append(ids, id)
	}
	return
}

// ResetManagedPartnerships resets all changes to the "managed_partnerships" edge.
func (m *UserMutation) ResetManagedPartnerships() {
	m.managed_partnerships = nil
	m.clearedmanaged_partnerships = false
	m.removedmanaged_partnerships = nil
}

// AddPartnershipContactIDs adds the "partnership_contacts" edge to the Partnership entity by ids.
func (m *UserMutation) AddPartnershipContactIDs(ids ...int) {
	if m.partnership_contacts == nil {
		m.partnership_contacts = make(map[int]struct{})
	}
	for i := range ids {
		m.partnership_contacts[ids[i]] = struct{}{}
	}
}

// ClearPartnershipContacts clears the "partnership_contacts" edge to the Partnership entity.
func (m *UserMutation) ClearPartnershipContacts() {
	m.clearedpartnership_contacts = true
}

// PartnershipContactsCleared reports if the "partnership_contacts" edge to the Partnership entity was cleared.
func (m *UserMutation) PartnershipContactsCleared() bool {
	return m.clearedpartnership_contacts
}

// RemovePartnershipContactIDs removes the "partnership_contacts" edge to the Partnership entity by IDs.
func (m *UserMutation) RemovePartnershipContactIDs(ids ...int) {
	if m.removedpartnership_contacts == nil {
		m.removedpartnership_contacts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.partnership_contacts, ids[i])
		m.removedpartnership_contacts[ids[i]] = struct{}{}
	}
}

// RemovedPartnershipContacts returns the removed IDs of the "partnership_contacts" edge to the Partnership entity.
func (m *UserMutation) RemovedPartnershipContactsIDs() (ids []int) {
	for id := range m.removedpartnership_contacts {
		ids = append(ids, id)
	}
	return
}

// PartnershipContactsIDs returns the "partnership_contacts" edge IDs in the mutation.
func (m *UserMutation) PartnershipContactsIDs() (ids []int) {
	for id := range m.partnership_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetPartnershipContacts resets all changes to the "partnership_contacts" edge.
func (m *UserMutation) ResetPartnershipContacts() {
	m.partnership_contacts = nil
	m.clearedpartnership_contacts = false
	m.removedpartnership_contacts = nil
}

// AddSiteVisitIDs adds the "site_visits" edge to the SiteVisit entity by ids.
func (m *UserMutation) AddSiteVisitIDs(ids ...int) {
	if m.site_visits == nil {
		m.site_visits = make(map[int]struct{})
	}
	for i := range ids {
		m.site_visits[ids[i]] = struct{}{}
	}
}

// ClearSiteVisits clears the "site_visits" edge to the SiteVisit entity.
func (m *UserMutation) ClearSiteVisits() {
	m.clearedsite_visits = true
}

// SiteVisitsCleared reports if the "site_visits" edge to the SiteVisit entity was cleared.
func (m *UserMutation) SiteVisitsCleared() bool {
	return m.clearedsite_visits
}

// RemoveSiteVisitIDs removes the "site_visits" edge to the SiteVisit entity by IDs.
func (m *UserMutation) RemoveSiteVisitIDs(ids ...int) {
	if m.removedsite_visits == nil {
		m.removedsite_visits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.site_visits, ids[i])
		m.removedsite_visits[ids[i]] = struct{}{}
	}
}

// RemovedSiteVisits returns the removed IDs of the "site_visits" edge to the SiteVisit entity.
func (m *UserMutation) RemovedSiteVisitsIDs() (ids []int) {
	for id := range m.removedsite_visits {
		ids = append(ids, id)
	}
	return
}

// SiteVisitsIDs returns the "site_visits" edge IDs in the mutation.
func (m *UserMutation) SiteVisitsIDs() (ids []int) {
	for id := range m.site_visits {
		ids = append(ids, id)
	}
	return
}

// ResetSiteVisits resets all changes to the "site_visits" edge.
func (m *UserMutation) ResetSiteVisits() {
	m.site_visits = nil
	m.clearedsite_visits = false
	m.removedsite_visits = nil
}

// AddDocumentUploadIDs adds the "document_uploads" edge to the Document entity by ids.
func (m *UserMutation) AddDocumentUploadIDs(ids ...int) {
	if m.document_uploads == nil {
		m.document_uploads = make(map[int]struct{})
	}
	for i := range ids {
		m.document_uploads[ids[i]] = struct{}{}
	}
}

// ClearDocumentUploads clears the "document_uploads" edge to the Document entity.
func (m *UserMutation) ClearDocumentUploads() {
	m.cleareddocument_uploads = true
}

// DocumentUploadsCleared reports if the "document_uploads" edge to the Document entity was cleared.
func (m *UserMutation) DocumentUploadsCleared() bool {
	return m.cleareddocument_uploads
}

// RemoveDocumentUploadIDs removes the "document_uploads" edge to the Document entity by IDs.
func (m *UserMutation) RemoveDocumentUploadIDs(ids ...int) {
	if m.removeddocument_uploads == nil {
		m.removeddocument_uploads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.document_uploads, ids[i])
		m.removeddocument_uploads[ids[i]] = struct{}{}
	}
}

// RemovedDocumentUploads returns the removed IDs of the "document_uploads" edge to the Document entity.
func (m *UserMutation) RemovedDocumentUploadsIDs() (ids []int) {
	for id := range m.removeddocument_uploads {
		ids = append(ids, id)
	}
	return
}

// DocumentUploadsIDs returns the "document_uploads" edge IDs in the mutation.
func (m *UserMutation) DocumentUploadsIDs() (ids []int) {
	for id := range m.document_uploads {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentUploads resets all changes to the "document_uploads" edge.
func (m *UserMutation) ResetDocumentUploads() {
	m.document_uploads = nil
	m.cleareddocument_uploads = false
	m.removeddocument_uploads = nil
}

// AddActivityLogIDs adds the "activity_logs" edge to the ActivityLog entity by ids.
func (m *UserMutation) AddActivityLogIDs(ids ...int) {
	if m.activity_logs == nil {
		m.activity_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.activity_logs[ids[i]] = struct{}{}
	}
}

// ClearActivityLogs clears the "activity_logs" edge to the ActivityLog entity.
func (m *UserMutation) ClearActivityLogs() {
	m.clearedactivity_logs = true
}

// ActivityLogsCleared reports if the "activity_logs" edge to the ActivityLog entity was cleared.
func (m *UserMutation) ActivityLogsCleared() bool {
	return m.clearedactivity_logs
}

// RemoveActivityLogIDs removes the "activity_logs" edge to the ActivityLog entity by IDs.
func (m *UserMutation) RemoveActivityLogIDs(ids ...int) {
	if m.removedactivity_logs == nil {
		m.removedactivity_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.activity_logs, ids[i])
		m.removedactivity_logs[ids[i]] = struct{}{}
	}
}

// RemovedActivityLogs returns the removed IDs of the "activity_logs" edge to the ActivityLog entity.
func (m *UserMutation) RemovedActivityLogsIDs() (ids []int) {
	for id := range m.removedactivity_logs {
		ids = append(ids, id)
	}
	return
}

// ActivityLogsIDs returns the "activity_logs" edge IDs in the mutation.
func (m *UserMutation) ActivityLogsIDs() (ids []int) {
	for id := range m.activity_logs {
		ids = append(ids, id)
	}
	return
}

// ResetActivityLogs resets all changes to the "activity_logs" edge.
func (m *UserMutation) ResetActivityLogs() {
	m.activity_logs = nil
	m.clearedactivity_logs = false
	m.removedactivity_logs = nil
}

// SetConsentsID sets the "consents" edge to the UserConsent entity by id.
func (m *UserMutation) SetConsentsID(id int) {
	m.consents = &id
}

// ClearConsents clears the "consents" edge to the UserConsent entity.
func (m *UserMutation) ClearConsents() {
	m.clearedconsents = true
}

// ConsentsCleared reports if the "consents" edge to the UserConsent entity was cleared.
func (m *UserMutation) ConsentsCleared() bool {
	return m.clearedconsents
}

// ConsentsID returns the "consents" edge ID in the mutation.
func (m *UserMutation) ConsentsID() (id int, exists bool) {
	if m.consents != nil {
		return *m.consents, true
	}
	return
}

// ConsentsIDs returns the "consents" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConsentsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ConsentsIDs() (ids []int) {
	if id := m.consents; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConsents resets all changes to the "consents" edge.
func (m *UserMutation) ResetConsents() {
	m.consents = nil
	m.clearedconsents = false
}

// SetOnboardingID sets the "onboarding" edge to the UserOnboarding entity by id.
func (m *UserMutation) SetOnboardingID(id int) {
	m.onboarding = &id
}

// ClearOnboarding clears the "onboarding" edge to the UserOnboarding entity.
func (m *UserMutation) ClearOnboarding() {
	m.clearedonboarding = true
}

// OnboardingCleared reports if the "onboarding" edge to the UserOnboarding entity was cleared.
func (m *UserMutation) OnboardingCleared() bool {
	return m.clearedonboarding
}

// OnboardingID returns the "onboarding" edge ID in the mutation.
func (m *UserMutation) OnboardingID() (id int, exists bool) {
	if m.onboarding != nil {
		return *m.onboarding, true
	}
	return
}

// OnboardingIDs returns the "onboarding" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OnboardingID instead. It exists only for internal usage by the builders.
func (m *UserMutation) OnboardingIDs() (ids []int) {
	if id := m.onboarding; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOnboarding resets all changes to the "onboarding" edge.
func (m *UserMutation) ResetOnboarding() {
	m.onboarding = nil
	m.clearedonboarding = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.hashed_password != nil {
		fields = append(fields, user.FieldHashedPassword)
	}
	if m.is_verified != nil {
		fields = append(fields, user.FieldIsVerified)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.deactivated_at != nil {
		fields = append(fields, user.FieldDeactivatedAt)
	}
	if m.locked_until != nil {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.impersonating_user_id != nil {
		fields = append(fields, user.FieldImpersonatingUserID)
	}
	if m.security_timestamp != nil {
		fields = append(fields, user.FieldSecurityTimestamp)
	}
	if m.password_reset_required != nil {
		fields = append(fields, user.FieldPasswordResetRequired)
	}
	if m.roles != nil {
		fields = append(fields, user.FieldRoles)
	}
	if m.mfa_secret != nil {
		fields = append(fields, user.FieldMfaSecret)
	}
	if m.mfa_enabled != nil {
		fields = append(fields, user.FieldMfaEnabled)
	}
	if m.onboarding_started_at != nil {
		fields = append(fields, user.FieldOnboardingStartedAt)
	}
	if m.onboarding_completed_at != nil {
		fields = append(fields, user.FieldOnboardingCompletedAt)
	}
	if m.onboarding_skipped != nil {
		fields = append(fields, user.FieldOnboardingSkipped)
	}
	if m.onboarding_version != nil {
		fields = append(fields, user.FieldOnboardingVersion)
	}
	if m.onboarding_completed != nil {
		fields = append(fields, user.FieldOnboardingCompleted)
	}
	if m.position != nil {
		fields = append(fields, user.FieldPosition)
	}
	if m.analytics_properties != nil {
		fields = append(fields, user.FieldAnalyticsProperties)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldUsername:
		return m.Username()
	case user.FieldHashedPassword:
		return m.HashedPassword()
	case user.FieldIsVerified:
		return m.IsVerified()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldDeactivatedAt:
		return m.DeactivatedAt()
	case user.FieldLockedUntil:
		return m.LockedUntil()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldImpersonatingUserID:
		return m.ImpersonatingUserID()
	case user.FieldSecurityTimestamp:
		return m.SecurityTimestamp()
	case user.FieldPasswordResetRequired:
		return m.PasswordResetRequired()
	case user.FieldRoles:
		return m.Roles()
	case user.FieldMfaSecret:
		return m.MfaSecret()
	case user.FieldMfaEnabled:
		return m.MfaEnabled()
	case user.FieldOnboardingStartedAt:
		return m.OnboardingStartedAt()
	case user.FieldOnboardingCompletedAt:
		return m.OnboardingCompletedAt()
	case user.FieldOnboardingSkipped:
		return m.OnboardingSkipped()
	case user.FieldOnboardingVersion:
		return m.OnboardingVersion()
	case user.FieldOnboardingCompleted:
		return m.OnboardingCompleted()
	case user.FieldPosition:
		return m.Position()
	case user.FieldAnalyticsProperties:
		return m.AnalyticsProperties()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case user.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldDeactivatedAt:
		return m.OldDeactivatedAt(ctx)
	case user.FieldLockedUntil:
		return m.OldLockedUntil(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldImpersonatingUserID:
		return m.OldImpersonatingUserID(ctx)
	case user.FieldSecurityTimestamp:
		return m.OldSecurityTimestamp(ctx)
	case user.FieldPasswordResetRequired:
		return m.OldPasswordResetRequired(ctx)
	case user.FieldRoles:
		return m.OldRoles(ctx)
	case user.FieldMfaSecret:
		return m.OldMfaSecret(ctx)
	case user.FieldMfaEnabled:
		return m.OldMfaEnabled(ctx)
	case user.FieldOnboardingStartedAt:
		return m.OldOnboardingStartedAt(ctx)
	case user.FieldOnboardingCompletedAt:
		return m.OldOnboardingCompletedAt(ctx)
	case user.FieldOnboardingSkipped:
		return m.OldOnboardingSkipped(ctx)
	case user.FieldOnboardingVersion:
		return m.OldOnboardingVersion(ctx)
	case user.FieldOnboardingCompleted:
		return m.OldOnboardingCompleted(ctx)
	case user.FieldPosition:
		return m.OldPosition(ctx)
	case user.FieldAnalyticsProperties:
		return m.OldAnalyticsProperties(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case user.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldDeactivatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeactivatedAt(v)
		return nil
	case user.FieldLockedUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedUntil(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldImpersonatingUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpersonatingUserID(v)
		return nil
	case user.FieldSecurityTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityTimestamp(v)
		return nil
	case user.FieldPasswordResetRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordResetRequired(v)
		return nil
	case user.FieldRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoles(v)
		return nil
	case user.FieldMfaSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaSecret(v)
		return nil
	case user.FieldMfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaEnabled(v)
		return nil
	case user.FieldOnboardingStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingStartedAt(v)
		return nil
	case user.FieldOnboardingCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingCompletedAt(v)
		return nil
	case user.FieldOnboardingSkipped:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingSkipped(v)
		return nil
	case user.FieldOnboardingVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingVersion(v)
		return nil
	case user.FieldOnboardingCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingCompleted(v)
		return nil
	case user.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case user.FieldAnalyticsProperties:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnalyticsProperties(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldHashedPassword) {
		fields = append(fields, user.FieldHashedPassword)
	}
	if m.FieldCleared(user.FieldEmailVerified) {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.FieldCleared(user.FieldDeactivatedAt) {
		fields = append(fields, user.FieldDeactivatedAt)
	}
	if m.FieldCleared(user.FieldLockedUntil) {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.FieldCleared(user.FieldImpersonatingUserID) {
		fields = append(fields, user.FieldImpersonatingUserID)
	}
	if m.FieldCleared(user.FieldMfaSecret) {
		fields = append(fields, user.FieldMfaSecret)
	}
	if m.FieldCleared(user.FieldOnboardingStartedAt) {
		fields = append(fields, user.FieldOnboardingStartedAt)
	}
	if m.FieldCleared(user.FieldOnboardingCompletedAt) {
		fields = append(fields, user.FieldOnboardingCompletedAt)
	}
	if m.FieldCleared(user.FieldOnboardingVersion) {
		fields = append(fields, user.FieldOnboardingVersion)
	}
	if m.FieldCleared(user.FieldPosition) {
		fields = append(fields, user.FieldPosition)
	}
	if m.FieldCleared(user.FieldAnalyticsProperties) {
		fields = append(fields, user.FieldAnalyticsProperties)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldHashedPassword:
		m.ClearHashedPassword()
		return nil
	case user.FieldEmailVerified:
		m.ClearEmailVerified()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case user.FieldDeactivatedAt:
		m.ClearDeactivatedAt()
		return nil
	case user.FieldLockedUntil:
		m.ClearLockedUntil()
		return nil
	case user.FieldImpersonatingUserID:
		m.ClearImpersonatingUserID()
		return nil
	case user.FieldMfaSecret:
		m.ClearMfaSecret()
		return nil
	case user.FieldOnboardingStartedAt:
		m.ClearOnboardingStartedAt()
		return nil
	case user.FieldOnboardingCompletedAt:
		m.ClearOnboardingCompletedAt()
		return nil
	case user.FieldOnboardingVersion:
		m.ClearOnboardingVersion()
		return nil
	case user.FieldPosition:
		m.ClearPosition()
		return nil
	case user.FieldAnalyticsProperties:
		m.ClearAnalyticsProperties()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case user.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldDeactivatedAt:
		m.ResetDeactivatedAt()
		return nil
	case user.FieldLockedUntil:
		m.ResetLockedUntil()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldImpersonatingUserID:
		m.ResetImpersonatingUserID()
		return nil
	case user.FieldSecurityTimestamp:
		m.ResetSecurityTimestamp()
		return nil
	case user.FieldPasswordResetRequired:
		m.ResetPasswordResetRequired()
		return nil
	case user.FieldRoles:
		m.ResetRoles()
		return nil
	case user.FieldMfaSecret:
		m.ResetMfaSecret()
		return nil
	case user.FieldMfaEnabled:
		m.ResetMfaEnabled()
		return nil
	case user.FieldOnboardingStartedAt:
		m.ResetOnboardingStartedAt()
		return nil
	case user.FieldOnboardingCompletedAt:
		m.ResetOnboardingCompletedAt()
		return nil
	case user.FieldOnboardingSkipped:
		m.ResetOnboardingSkipped()
		return nil
	case user.FieldOnboardingVersion:
		m.ResetOnboardingVersion()
		return nil
	case user.FieldOnboardingCompleted:
		m.ResetOnboardingCompleted()
		return nil
	case user.FieldPosition:
		m.ResetPosition()
		return nil
	case user.FieldAnalyticsProperties:
		m.ResetAnalyticsProperties()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 37)
	if m.profile != nil {
		edges = append(edges, user.EdgeProfile)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.tokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	if m.trusted_devices != nil {
		edges = append(edges, user.EdgeTrustedDevices)
	}
	if m.password_history != nil {
		edges = append(edges, user.EdgePasswordHistory)
	}
	if m.team_member != nil {
		edges = append(edges, user.EdgeTeamMember)
	}
	if m.audit_logs != nil {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.jobs != nil {
		edges = append(edges, user.EdgeJobs)
	}
	if m.dashboards != nil {
		edges = append(edges, user.EdgeDashboards)
	}
	if m.analytics_events != nil {
		edges = append(edges, user.EdgeAnalyticsEvents)
	}
	if m.created_reports != nil {
		edges = append(edges, user.EdgeCreatedReports)
	}
	if m.generated_reports != nil {
		edges = append(edges, user.EdgeGeneratedReports)
	}
	if m.report_permissions != nil {
		edges = append(edges, user.EdgeReportPermissions)
	}
	if m.scheduled_reports != nil {
		edges = append(edges, user.EdgeScheduledReports)
	}
	if m.created_programs != nil {
		edges = append(edges, user.EdgeCreatedPrograms)
	}
	if m.updated_programs != nil {
		edges = append(edges, user.EdgeUpdatedPrograms)
	}
	if m.program_enrolments != nil {
		edges = append(edges, user.EdgeProgramEnrolments)
	}
	if m.participant_in != nil {
		edges = append(edges, user.EdgeParticipantIn)
	}
	if m.success_stories != nil {
		edges = append(edges, user.EdgeSuccessStories)
	}
	if m.news_articles != nil {
		edges = append(edges, user.EdgeNewsArticles)
	}
	if m.created_events != nil {
		edges = append(edges, user.EdgeCreatedEvents)
	}
	if m.event_registrations != nil {
		edges = append(edges, user.EdgeEventRegistrations)
	}
	if m.messages_sent != nil {
		edges = append(edges, user.EdgeMessagesSent)
	}
	if m.conversation_links != nil {
		edges = append(edges, user.EdgeConversationLinks)
	}
	if m.volunteer_applications != nil {
		edges = append(edges, user.EdgeVolunteerApplications)
	}
	if m.mentorship_requests != nil {
		edges = append(edges, user.EdgeMentorshipRequests)
	}
	if m.mentorships_mentoring != nil {
		edges = append(edges, user.EdgeMentorshipsMentoring)
	}
	if m.achievements != nil {
		edges = append(edges, user.EdgeAchievements)
	}
	if m.donations != nil {
		edges = append(edges, user.EdgeDonations)
	}
	if m.organization != nil {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.managed_partnerships != nil {
		edges = append(edges, user.EdgeManagedPartnerships)
	}
	if m.partnership_contacts != nil {
		edges = append(edges, user.EdgePartnershipContacts)
	}
	if m.site_visits != nil {
		edges = append(edges, user.EdgeSiteVisits)
	}
	if m.document_uploads != nil {
		edges = append(edges, user.EdgeDocumentUploads)
	}
	if m.activity_logs != nil {
		edges = append(edges, user.EdgeActivityLogs)
	}
	if m.consents != nil {
		edges = append(edges, user.EdgeConsents)
	}
	if m.onboarding != nil {
		edges = append(edges, user.EdgeOnboarding)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTrustedDevices:
		ids := make([]ent.Value, 0, len(m.trusted_devices))
		for id := range m.trusted_devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordHistory:
		ids := make([]ent.Value, 0, len(m.password_history))
		for id := range m.password_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamMember:
		if id := m.team_member; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.audit_logs))
		for id := range m.audit_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDashboards:
		ids := make([]ent.Value, 0, len(m.dashboards))
		for id := range m.dashboards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAnalyticsEvents:
		ids := make([]ent.Value, 0, len(m.analytics_events))
		for id := range m.analytics_events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedReports:
		ids := make([]ent.Value, 0, len(m.created_reports))
		for id := range m.created_reports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGeneratedReports:
		ids := make([]ent.Value, 0, len(m.generated_reports))
		for id := range m.generated_reports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReportPermissions:
		ids := make([]ent.Value, 0, len(m.report_permissions))
		for id := range m.report_permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeScheduledReports:
		ids := make([]ent.Value, 0, len(m.scheduled_reports))
		for id := range m.scheduled_reports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedPrograms:
		ids := make([]ent.Value, 0, len(m.created_programs))
		for id := range m.created_programs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedPrograms:
		ids := make([]ent.Value, 0, len(m.updated_programs))
		for id := range m.updated_programs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProgramEnrolments:
		ids := make([]ent.Value, 0, len(m.program_enrolments))
		for id := range m.program_enrolments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeParticipantIn:
		ids := make([]ent.Value, 0, len(m.participant_in))
		for id := range m.participant_in {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSuccessStories:
		ids := make([]ent.Value, 0, len(m.success_stories))
		for id := range m.success_stories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNewsArticles:
		ids := make([]ent.Value, 0, len(m.news_articles))
		for id := range m.news_articles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedEvents:
		ids := make([]ent.Value, 0, len(m.created_events))
		for id := range m.created_events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEventRegistrations:
		ids := make([]ent.Value, 0, len(m.event_registrations))
		for id := range m.event_registrations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessagesSent:
		ids := make([]ent.Value, 0, len(m.messages_sent))
		for id := range m.messages_sent {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConversationLinks:
		ids := make([]ent.Value, 0, len(m.conversation_links))
		for id := range m.conversation_links {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVolunteerApplications:
		ids := make([]ent.Value, 0, len(m.volunteer_applications))
		for id := range m.volunteer_applications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMentorshipRequests:
		ids := make([]ent.Value, 0, len(m.mentorship_requests))
		for id := range m.mentorship_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMentorshipsMentoring:
		ids := make([]ent.Value, 0, len(m.mentorships_mentoring))
		for id := range m.mentorships_mentoring {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAchievements:
		ids := make([]ent.Value, 0, len(m.achievements))
		for id := range m.achievements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDonations:
		ids := make([]ent.Value, 0, len(m.donations))
		for id := range m.donations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.organization))
		for id := range m.organization {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeManagedPartnerships:
		ids := make([]ent.Value, 0, len(m.managed_partnerships))
		for id := range m.managed_partnerships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePartnershipContacts:
		ids := make([]ent.Value, 0, len(m.partnership_contacts))
		for id := range m.partnership_contacts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSiteVisits:
		ids := make([]ent.Value, 0, len(m.site_visits))
		for id := range m.site_visits {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDocumentUploads:
		ids := make([]ent.Value, 0, len(m.document_uploads))
		for id := range m.document_uploads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActivityLogs:
		ids := make([]ent.Value, 0, len(m.activity_logs))
		for id := range m.activity_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConsents:
		if id := m.consents; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeOnboarding:
		if id := m.onboarding; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 37)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedtokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	if m.removedtrusted_devices != nil {
		edges = append(edges, user.EdgeTrustedDevices)
	}
	if m.removedpassword_history != nil {
		edges = append(edges, user.EdgePasswordHistory)
	}
	if m.removedaudit_logs != nil {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.removedjobs != nil {
		edges = append(edges, user.EdgeJobs)
	}
	if m.removeddashboards != nil {
		edges = append(edges, user.EdgeDashboards)
	}
	if m.removedanalytics_events != nil {
		edges = append(edges, user.EdgeAnalyticsEvents)
	}
	if m.removedcreated_reports != nil {
		edges = append(edges, user.EdgeCreatedReports)
	}
	if m.removedgenerated_reports != nil {
		edges = append(edges, user.EdgeGeneratedReports)
	}
	if m.removedreport_permissions != nil {
		edges = append(edges, user.EdgeReportPermissions)
	}
	if m.removedscheduled_reports != nil {
		edges = append(edges, user.EdgeScheduledReports)
	}
	if m.removedcreated_programs != nil {
		edges = append(edges, user.EdgeCreatedPrograms)
	}
	if m.removedupdated_programs != nil {
		edges = append(edges, user.EdgeUpdatedPrograms)
	}
	if m.removedprogram_enrolments != nil {
		edges = append(edges, user.EdgeProgramEnrolments)
	}
	if m.removedparticipant_in != nil {
		edges = append(edges, user.EdgeParticipantIn)
	}
	if m.removedsuccess_stories != nil {
		edges = append(edges, user.EdgeSuccessStories)
	}
	if m.removednews_articles != nil {
		edges = append(edges, user.EdgeNewsArticles)
	}
	if m.removedcreated_events != nil {
		edges = append(edges, user.EdgeCreatedEvents)
	}
	if m.removedevent_registrations != nil {
		edges = append(edges, user.EdgeEventRegistrations)
	}
	if m.removedmessages_sent != nil {
		edges = append(edges, user.EdgeMessagesSent)
	}
	if m.removedconversation_links != nil {
		edges = append(edges, user.EdgeConversationLinks)
	}
	if m.removedvolunteer_applications != nil {
		edges = append(edges, user.EdgeVolunteerApplications)
	}
	if m.removedmentorship_requests != nil {
		edges = append(edges, user.EdgeMentorshipRequests)
	}
	if m.removedmentorships_mentoring != nil {
		edges = append(edges, user.EdgeMentorshipsMentoring)
	}
	if m.removedachievements != nil {
		edges = append(edges, user.EdgeAchievements)
	}
	if m.removeddonations != nil {
		edges = append(edges, user.EdgeDonations)
	}
	if m.removedorganization != nil {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.removedmanaged_partnerships != nil {
		edges = append(edges, user.EdgeManagedPartnerships)
	}
	if m.removedpartnership_contacts != nil {
		edges = append(edges, user.EdgePartnershipContacts)
	}
	if m.removedsite_visits != nil {
		edges = append(edges, user.EdgeSiteVisits)
	}
	if m.removeddocument_uploads != nil {
		edges = append(edges, user.EdgeDocumentUploads)
	}
	if m.removedactivity_logs != nil {
		edges = append(edges, user.EdgeActivityLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTrustedDevices:
		ids := make([]ent.Value, 0, len(m.removedtrusted_devices))
		for id := range m.removedtrusted_devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordHistory:
		ids := make([]ent.Value, 0, len(m.removedpassword_history))
		for id := range m.removedpassword_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedaudit_logs))
		for id := range m.removedaudit_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDashboards:
		ids := make([]ent.Value, 0, len(m.removeddashboards))
		for id := range m.removeddashboards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAnalyticsEvents:
		ids := make([]ent.Value, 0, len(m.removedanalytics_events))
		for id := range m.removedanalytics_events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedReports:
		ids := make([]ent.Value, 0, len(m.removedcreated_reports))
		for id := range m.removedcreated_reports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGeneratedReports:
		ids := make([]ent.Value, 0, len(m.removedgenerated_reports))
		for id := range m.removedgenerated_reports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReportPermissions:
		ids := make([]ent.Value, 0, len(m.removedreport_permissions))
		for id := range m.removedreport_permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeScheduledReports:
		ids := make([]ent.Value, 0, len(m.removedscheduled_reports))
		for id := range m.removedscheduled_reports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedPrograms:
		ids := make([]ent.Value, 0, len(m.removedcreated_programs))
		for id := range m.removedcreated_programs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedPrograms:
		ids := make([]ent.Value, 0, len(m.removedupdated_programs))
		for id := range m.removedupdated_programs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProgramEnrolments:
		ids := make([]ent.Value, 0, len(m.removedprogram_enrolments))
		for id := range m.removedprogram_enrolments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeParticipantIn:
		ids := make([]ent.Value, 0, len(m.removedparticipant_in))
		for id := range m.removedparticipant_in {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSuccessStories:
		ids := make([]ent.Value, 0, len(m.removedsuccess_stories))
		for id := range m.removedsuccess_stories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNewsArticles:
		ids := make([]ent.Value, 0, len(m.removednews_articles))
		for id := range m.removednews_articles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedEvents:
		ids := make([]ent.Value, 0, len(m.removedcreated_events))
		for id := range m.removedcreated_events {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEventRegistrations:
		ids := make([]ent.Value, 0, len(m.removedevent_registrations))
		for id := range m.removedevent_registrations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessagesSent:
		ids := make([]ent.Value, 0, len(m.removedmessages_sent))
		for id := range m.removedmessages_sent {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConversationLinks:
		ids := make([]ent.Value, 0, len(m.removedconversation_links))
		for id := range m.removedconversation_links {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVolunteerApplications:
		ids := make([]ent.Value, 0, len(m.removedvolunteer_applications))
		for id := range m.removedvolunteer_applications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMentorshipRequests:
		ids := make([]ent.Value, 0, len(m.removedmentorship_requests))
		for id := range m.removedmentorship_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMentorshipsMentoring:
		ids := make([]ent.Value, 0, len(m.removedmentorships_mentoring))
		for id := range m.removedmentorships_mentoring {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAchievements:
		ids := make([]ent.Value, 0, len(m.removedachievements))
		for id := range m.removedachievements {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDonations:
		ids := make([]ent.Value, 0, len(m.removeddonations))
		for id := range m.removeddonations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganization:
		ids := make([]ent.Value, 0, len(m.removedorganization))
		for id := range m.removedorganization {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeManagedPartnerships:
		ids := make([]ent.Value, 0, len(m.removedmanaged_partnerships))
		for id := range m.removedmanaged_partnerships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePartnershipContacts:
		ids := make([]ent.Value, 0, len(m.removedpartnership_contacts))
		for id := range m.removedpartnership_contacts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSiteVisits:
		ids := make([]ent.Value, 0, len(m.removedsite_visits))
		for id := range m.removedsite_visits {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDocumentUploads:
		ids := make([]ent.Value, 0, len(m.removeddocument_uploads))
		for id := range m.removeddocument_uploads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActivityLogs:
		ids := make([]ent.Value, 0, len(m.removedactivity_logs))
		for id := range m.removedactivity_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 37)
	if m.clearedprofile {
		edges = append(edges, user.EdgeProfile)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedtokens {
		edges = append(edges, user.EdgeTokens)
	}
	if m.clearedtrusted_devices {
		edges = append(edges, user.EdgeTrustedDevices)
	}
	if m.clearedpassword_history {
		edges = append(edges, user.EdgePasswordHistory)
	}
	if m.clearedteam_member {
		edges = append(edges, user.EdgeTeamMember)
	}
	if m.clearedaudit_logs {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.clearedjobs {
		edges = append(edges, user.EdgeJobs)
	}
	if m.cleareddashboards {
		edges = append(edges, user.EdgeDashboards)
	}
	if m.clearedanalytics_events {
		edges = append(edges, user.EdgeAnalyticsEvents)
	}
	if m.clearedcreated_reports {
		edges = append(edges, user.EdgeCreatedReports)
	}
	if m.clearedgenerated_reports {
		edges = append(edges, user.EdgeGeneratedReports)
	}
	if m.clearedreport_permissions {
		edges = append(edges, user.EdgeReportPermissions)
	}
	if m.clearedscheduled_reports {
		edges = append(edges, user.EdgeScheduledReports)
	}
	if m.clearedcreated_programs {
		edges = append(edges, user.EdgeCreatedPrograms)
	}
	if m.clearedupdated_programs {
		edges = append(edges, user.EdgeUpdatedPrograms)
	}
	if m.clearedprogram_enrolments {
		edges = append(edges, user.EdgeProgramEnrolments)
	}
	if m.clearedparticipant_in {
		edges = append(edges, user.EdgeParticipantIn)
	}
	if m.clearedsuccess_stories {
		edges = append(edges, user.EdgeSuccessStories)
	}
	if m.clearednews_articles {
		edges = append(edges, user.EdgeNewsArticles)
	}
	if m.clearedcreated_events {
		edges = append(edges, user.EdgeCreatedEvents)
	}
	if m.clearedevent_registrations {
		edges = append(edges, user.EdgeEventRegistrations)
	}
	if m.clearedmessages_sent {
		edges = append(edges, user.EdgeMessagesSent)
	}
	if m.clearedconversation_links {
		edges = append(edges, user.EdgeConversationLinks)
	}
	if m.clearedvolunteer_applications {
		edges = append(edges, user.EdgeVolunteerApplications)
	}
	if m.clearedmentorship_requests {
		edges = append(edges, user.EdgeMentorshipRequests)
	}
	if m.clearedmentorships_mentoring {
		edges = append(edges, user.EdgeMentorshipsMentoring)
	}
	if m.clearedachievements {
		edges = append(edges, user.EdgeAchievements)
	}
	if m.cleareddonations {
		edges = append(edges, user.EdgeDonations)
	}
	if m.clearedorganization {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.clearedmanaged_partnerships {
		edges = append(edges, user.EdgeManagedPartnerships)
	}
	if m.clearedpartnership_contacts {
		edges = append(edges, user.EdgePartnershipContacts)
	}
	if m.clearedsite_visits {
		edges = append(edges, user.EdgeSiteVisits)
	}
	if m.cleareddocument_uploads {
		edges = append(edges, user.EdgeDocumentUploads)
	}
	if m.clearedactivity_logs {
		edges = append(edges, user.EdgeActivityLogs)
	}
	if m.clearedconsents {
		edges = append(edges, user.EdgeConsents)
	}
	if m.clearedonboarding {
		edges = append(edges, user.EdgeOnboarding)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeProfile:
		return m.clearedprofile
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeTokens:
		return m.clearedtokens
	case user.EdgeTrustedDevices:
		return m.clearedtrusted_devices
	case user.EdgePasswordHistory:
		return m.clearedpassword_history
	case user.EdgeTeamMember:
		return m.clearedteam_member
	case user.EdgeAuditLogs:
		return m.clearedaudit_logs
	case user.EdgeJobs:
		return m.clearedjobs
	case user.EdgeDashboards:
		return m.cleareddashboards
	case user.EdgeAnalyticsEvents:
		return m.clearedanalytics_events
	case user.EdgeCreatedReports:
		return m.clearedcreated_reports
	case user.EdgeGeneratedReports:
		return m.clearedgenerated_reports
	case user.EdgeReportPermissions:
		return m.clearedreport_permissions
	case user.EdgeScheduledReports:
		return m.clearedscheduled_reports
	case user.EdgeCreatedPrograms:
		return m.clearedcreated_programs
	case user.EdgeUpdatedPrograms:
		return m.clearedupdated_programs
	case user.EdgeProgramEnrolments:
		return m.clearedprogram_enrolments
	case user.EdgeParticipantIn:
		return m.clearedparticipant_in
	case user.EdgeSuccessStories:
		return m.clearedsuccess_stories
	case user.EdgeNewsArticles:
		return m.clearednews_articles
	case user.EdgeCreatedEvents:
		return m.clearedcreated_events
	case user.EdgeEventRegistrations:
		return m.clearedevent_registrations
	case user.EdgeMessagesSent:
		return m.clearedmessages_sent
	case user.EdgeConversationLinks:
		return m.clearedconversation_links
	case user.EdgeVolunteerApplications:
		return m.clearedvolunteer_applications
	case user.EdgeMentorshipRequests:
		return m.clearedmentorship_requests
	case user.EdgeMentorshipsMentoring:
		return m.clearedmentorships_mentoring
	case user.EdgeAchievements:
		return m.clearedachievements
	case user.EdgeDonations:
		return m.cleareddonations
	case user.EdgeOrganization:
		return m.clearedorganization
	case user.EdgeManagedPartnerships:
		return m.clearedmanaged_partnerships
	case user.EdgePartnershipContacts:
		return m.clearedpartnership_contacts
	case user.EdgeSiteVisits:
		return m.clearedsite_visits
	case user.EdgeDocumentUploads:
		return m.cleareddocument_uploads
	case user.EdgeActivityLogs:
		return m.clearedactivity_logs
	case user.EdgeConsents:
		return m.clearedconsents
	case user.EdgeOnboarding:
		return m.clearedonboarding
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ClearProfile()
		return nil
	case user.EdgeTeamMember:
		m.ClearTeamMember()
		return nil
	case user.EdgeConsents:
		m.ClearConsents()
		return nil
	case user.EdgeOnboarding:
		m.ClearOnboarding()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ResetProfile()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeTokens:
		m.ResetTokens()
		return nil
	case user.EdgeTrustedDevices:
		m.ResetTrustedDevices()
		return nil
	case user.EdgePasswordHistory:
		m.ResetPasswordHistory()
		return nil
	case user.EdgeTeamMember:
		m.ResetTeamMember()
		return nil
	case user.EdgeAuditLogs:
		m.ResetAuditLogs()
		return nil
	case user.EdgeJobs:
		m.ResetJobs()
		return nil
	case user.EdgeDashboards:
		m.ResetDashboards()
		return nil
	case user.EdgeAnalyticsEvents:
		m.ResetAnalyticsEvents()
		return nil
	case user.EdgeCreatedReports:
		m.ResetCreatedReports()
		return nil
	case user.EdgeGeneratedReports:
		m.ResetGeneratedReports()
		return nil
	case user.EdgeReportPermissions:
		m.ResetReportPermissions()
		return nil
	case user.EdgeScheduledReports:
		m.ResetScheduledReports()
		return nil
	case user.EdgeCreatedPrograms:
		m.ResetCreatedPrograms()
		return nil
	case user.EdgeUpdatedPrograms:
		m.ResetUpdatedPrograms()
		return nil
	case user.EdgeProgramEnrolments:
		m.ResetProgramEnrolments()
		return nil
	case user.EdgeParticipantIn:
		m.ResetParticipantIn()
		return nil
	case user.EdgeSuccessStories:
		m.ResetSuccessStories()
		return nil
	case user.EdgeNewsArticles:
		m.ResetNewsArticles()
		return nil
	case user.EdgeCreatedEvents:
		m.ResetCreatedEvents()
		return nil
	case user.EdgeEventRegistrations:
		m.ResetEventRegistrations()
		return nil
	case user.EdgeMessagesSent:
		m.ResetMessagesSent()
		return nil
	case user.EdgeConversationLinks:
		m.ResetConversationLinks()
		return nil
	case user.EdgeVolunteerApplications:
		m.ResetVolunteerApplications()
		return nil
	case user.EdgeMentorshipRequests:
		m.ResetMentorshipRequests()
		return nil
	case user.EdgeMentorshipsMentoring:
		m.ResetMentorshipsMentoring()
		return nil
	case user.EdgeAchievements:
		m.ResetAchievements()
		return nil
	case user.EdgeDonations:
		m.ResetDonations()
		return nil
	case user.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case user.EdgeManagedPartnerships:
		m.ResetManagedPartnerships()
		return nil
	case user.EdgePartnershipContacts:
		m.ResetPartnershipContacts()
		return nil
	case user.EdgeSiteVisits:
		m.ResetSiteVisits()
		return nil
	case user.EdgeDocumentUploads:
		m.ResetDocumentUploads()
		return nil
	case user.EdgeActivityLogs:
		m.ResetActivityLogs()
		return nil
	case user.EdgeConsents:
		m.ResetConsents()
		return nil
	case user.EdgeOnboarding:
		m.ResetOnboarding()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAchievementMutation represents an operation that mutates the UserAchievement nodes in the graph.
type UserAchievementMutation struct {
	config
	op            Op
	typ           string
	id            *int
	awarded_at    *time.Time
	notes         *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	badge         *int
	clearedbadge  bool
	done          bool
	oldValue      func(context.Context) (*UserAchievement, error)
	predicates    []predicate.UserAchievement
}

var _ ent.Mutation = (*UserAchievementMutation)(nil)

// userachievementOption allows management of the mutation configuration using functional options.
type userachievementOption func(*UserAchievementMutation)

// newUserAchievementMutation creates new mutation for the UserAchievement entity.
func newUserAchievementMutation(c config, op Op, opts ...userachievementOption) *UserAchievementMutation {
	m := &UserAchievementMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAchievement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAchievementID sets the ID field of the mutation.
func withUserAchievementID(id int) userachievementOption {
	return func(m *UserAchievementMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAchievement
		)
		m.oldValue = func(ctx context.Context) (*UserAchievement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAchievement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAchievement sets the old UserAchievement of the mutation.
func withUserAchievement(node *UserAchievement) userachievementOption {
	return func(m *UserAchievementMutation) {
		m.oldValue = func(context.Context) (*UserAchievement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAchievementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAchievementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAchievementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAchievementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAchievement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAwardedAt sets the "awarded_at" field.
func (m *UserAchievementMutation) SetAwardedAt(t time.Time) {
	m.awarded_at = &t
}

// AwardedAt returns the value of the "awarded_at" field in the mutation.
func (m *UserAchievementMutation) AwardedAt() (r time.Time, exists bool) {
	v := m.awarded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardedAt returns the old "awarded_at" field's value of the UserAchievement entity.
// If the UserAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAchievementMutation) OldAwardedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardedAt: %w", err)
	}
	return oldValue.AwardedAt, nil
}

// ResetAwardedAt resets all changes to the "awarded_at" field.
func (m *UserAchievementMutation) ResetAwardedAt() {
	m.awarded_at = nil
}

// SetNotes sets the "notes" field.
func (m *UserAchievementMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *UserAchievementMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the UserAchievement entity.
// If the UserAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAchievementMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *UserAchievementMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[userachievement.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *UserAchievementMutation) NotesCleared() bool {
	_, ok := m.clearedFields[userachievement.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *UserAchievementMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, userachievement.FieldNotes)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserAchievementMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAchievementMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAchievementMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserAchievementMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAchievementMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAchievementMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetBadgeID sets the "badge" edge to the Badge entity by id.
func (m *UserAchievementMutation) SetBadgeID(id int) {
	m.badge = &id
}

// ClearBadge clears the "badge" edge to the Badge entity.
func (m *UserAchievementMutation) ClearBadge() {
	m.clearedbadge = true
}

// BadgeCleared reports if the "badge" edge to the Badge entity was cleared.
func (m *UserAchievementMutation) BadgeCleared() bool {
	return m.clearedbadge
}

// BadgeID returns the "badge" edge ID in the mutation.
func (m *UserAchievementMutation) BadgeID() (id int, exists bool) {
	if m.badge != nil {
		return *m.badge, true
	}
	return
}

// BadgeIDs returns the "badge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BadgeID instead. It exists only for internal usage by the builders.
func (m *UserAchievementMutation) BadgeIDs() (ids []int) {
	if id := m.badge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBadge resets all changes to the "badge" edge.
func (m *UserAchievementMutation) ResetBadge() {
	m.badge = nil
	m.clearedbadge = false
}

// Where appends a list predicates to the UserAchievementMutation builder.
func (m *UserAchievementMutation) Where(ps ...predicate.UserAchievement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAchievementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAchievementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAchievement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAchievementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAchievementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAchievement).
func (m *UserAchievementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAchievementMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.awarded_at != nil {
		fields = append(fields, userachievement.FieldAwardedAt)
	}
	if m.notes != nil {
		fields = append(fields, userachievement.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAchievementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userachievement.FieldAwardedAt:
		return m.AwardedAt()
	case userachievement.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAchievementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userachievement.FieldAwardedAt:
		return m.OldAwardedAt(ctx)
	case userachievement.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown UserAchievement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAchievementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userachievement.FieldAwardedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardedAt(v)
		return nil
	case userachievement.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown UserAchievement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAchievementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAchievementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAchievementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAchievement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAchievementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userachievement.FieldNotes) {
		fields = append(fields, userachievement.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAchievementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAchievementMutation) ClearField(name string) error {
	switch name {
	case userachievement.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown UserAchievement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAchievementMutation) ResetField(name string) error {
	switch name {
	case userachievement.FieldAwardedAt:
		m.ResetAwardedAt()
		return nil
	case userachievement.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown UserAchievement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAchievementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userachievement.EdgeUser)
	}
	if m.badge != nil {
		edges = append(edges, userachievement.EdgeBadge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAchievementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userachievement.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userachievement.EdgeBadge:
		if id := m.badge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAchievementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAchievementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAchievementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userachievement.EdgeUser)
	}
	if m.clearedbadge {
		edges = append(edges, userachievement.EdgeBadge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAchievementMutation) EdgeCleared(name string) bool {
	switch name {
	case userachievement.EdgeUser:
		return m.cleareduser
	case userachievement.EdgeBadge:
		return m.clearedbadge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAchievementMutation) ClearEdge(name string) error {
	switch name {
	case userachievement.EdgeUser:
		m.ClearUser()
		return nil
	case userachievement.EdgeBadge:
		m.ClearBadge()
		return nil
	}
	return fmt.Errorf("unknown UserAchievement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAchievementMutation) ResetEdge(name string) error {
	switch name {
	case userachievement.EdgeUser:
		m.ResetUser()
		return nil
	case userachievement.EdgeBadge:
		m.ResetBadge()
		return nil
	}
	return fmt.Errorf("unknown UserAchievement edge %s", name)
}

// UserConsentMutation represents an operation that mutates the UserConsent nodes in the graph.
type UserConsentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	preferences   *map[string]bool
	ip_address    *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserConsent, error)
	predicates    []predicate.UserConsent
}

var _ ent.Mutation = (*UserConsentMutation)(nil)

// userconsentOption allows management of the mutation configuration using functional options.
type userconsentOption func(*UserConsentMutation)

// newUserConsentMutation creates new mutation for the UserConsent entity.
func newUserConsentMutation(c config, op Op, opts ...userconsentOption) *UserConsentMutation {
	m := &UserConsentMutation{
		config:        c,
		op:            op,
		typ:           TypeUserConsent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserConsentID sets the ID field of the mutation.
func withUserConsentID(id int) userconsentOption {
	return func(m *UserConsentMutation) {
		var (
			err   error
			once  sync.Once
			value *UserConsent
		)
		m.oldValue = func(ctx context.Context) (*UserConsent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserConsent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserConsent sets the old UserConsent of the mutation.
func withUserConsent(node *UserConsent) userconsentOption {
	return func(m *UserConsentMutation) {
		m.oldValue = func(context.Context) (*UserConsent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserConsentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserConsentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserConsentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserConsentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserConsent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPreferences sets the "preferences" field.
func (m *UserConsentMutation) SetPreferences(value map[string]bool) {
	m.preferences = &value
}

// Preferences returns the value of the "preferences" field in the mutation.
func (m *UserConsentMutation) Preferences() (r map[string]bool, exists bool) {
	v := m.preferences
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferences returns the old "preferences" field's value of the UserConsent entity.
// If the UserConsent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsentMutation) OldPreferences(ctx context.Context) (v map[string]bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferences: %w", err)
	}
	return oldValue.Preferences, nil
}

// ResetPreferences resets all changes to the "preferences" field.
func (m *UserConsentMutation) ResetPreferences() {
	m.preferences = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *UserConsentMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *UserConsentMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the UserConsent entity.
// If the UserConsent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsentMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *UserConsentMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[userconsent.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *UserConsentMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[userconsent.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *UserConsentMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, userconsent.FieldIPAddress)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserConsentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserConsentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserConsent entity.
// If the UserConsent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserConsentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserConsentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserConsentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserConsent entity.
// If the UserConsent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConsentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserConsentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserConsentMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserConsentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserConsentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserConsentMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserConsentMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserConsentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserConsentMutation builder.
func (m *UserConsentMutation) Where(ps ...predicate.UserConsent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserConsentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserConsentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserConsent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserConsentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserConsentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserConsent).
func (m *UserConsentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserConsentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.preferences != nil {
		fields = append(fields, userconsent.FieldPreferences)
	}
	if m.ip_address != nil {
		fields = append(fields, userconsent.FieldIPAddress)
	}
	if m.created_at != nil {
		fields = append(fields, userconsent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userconsent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserConsentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userconsent.FieldPreferences:
		return m.Preferences()
	case userconsent.FieldIPAddress:
		return m.IPAddress()
	case userconsent.FieldCreatedAt:
		return m.CreatedAt()
	case userconsent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserConsentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userconsent.FieldPreferences:
		return m.OldPreferences(ctx)
	case userconsent.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case userconsent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userconsent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserConsent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserConsentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userconsent.FieldPreferences:
		v, ok := value.(map[string]bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferences(v)
		return nil
	case userconsent.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case userconsent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userconsent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserConsent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserConsentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserConsentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserConsentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserConsent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserConsentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userconsent.FieldIPAddress) {
		fields = append(fields, userconsent.FieldIPAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserConsentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserConsentMutation) ClearField(name string) error {
	switch name {
	case userconsent.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	}
	return fmt.Errorf("unknown UserConsent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserConsentMutation) ResetField(name string) error {
	switch name {
	case userconsent.FieldPreferences:
		m.ResetPreferences()
		return nil
	case userconsent.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case userconsent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userconsent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserConsent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserConsentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userconsent.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserConsentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userconsent.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserConsentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserConsentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserConsentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userconsent.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserConsentMutation) EdgeCleared(name string) bool {
	switch name {
	case userconsent.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserConsentMutation) ClearEdge(name string) error {
	switch name {
	case userconsent.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserConsent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserConsentMutation) ResetEdge(name string) error {
	switch name {
	case userconsent.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserConsent edge %s", name)
}

// UserOnboardingMutation represents an operation that mutates the UserOnboarding nodes in the graph.
type UserOnboardingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	is_completed  *bool
	completed_at  *time.Time
	steps         *map[string]interface{}
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserOnboarding, error)
	predicates    []predicate.UserOnboarding
}

var _ ent.Mutation = (*UserOnboardingMutation)(nil)

// useronboardingOption allows management of the mutation configuration using functional options.
type useronboardingOption func(*UserOnboardingMutation)

// newUserOnboardingMutation creates new mutation for the UserOnboarding entity.
func newUserOnboardingMutation(c config, op Op, opts ...useronboardingOption) *UserOnboardingMutation {
	m := &UserOnboardingMutation{
		config:        c,
		op:            op,
		typ:           TypeUserOnboarding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserOnboardingID sets the ID field of the mutation.
func withUserOnboardingID(id int) useronboardingOption {
	return func(m *UserOnboardingMutation) {
		var (
			err   error
			once  sync.Once
			value *UserOnboarding
		)
		m.oldValue = func(ctx context.Context) (*UserOnboarding, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserOnboarding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserOnboarding sets the old UserOnboarding of the mutation.
func withUserOnboarding(node *UserOnboarding) useronboardingOption {
	return func(m *UserOnboardingMutation) {
		m.oldValue = func(context.Context) (*UserOnboarding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserOnboardingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserOnboardingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserOnboardingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserOnboardingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserOnboarding.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsCompleted sets the "is_completed" field.
func (m *UserOnboardingMutation) SetIsCompleted(b bool) {
	m.is_completed = &b
}

// IsCompleted returns the value of the "is_completed" field in the mutation.
func (m *UserOnboardingMutation) IsCompleted() (r bool, exists bool) {
	v := m.is_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCompleted returns the old "is_completed" field's value of the UserOnboarding entity.
// If the UserOnboarding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOnboardingMutation) OldIsCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCompleted: %w", err)
	}
	return oldValue.IsCompleted, nil
}

// ResetIsCompleted resets all changes to the "is_completed" field.
func (m *UserOnboardingMutation) ResetIsCompleted() {
	m.is_completed = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *UserOnboardingMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *UserOnboardingMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the UserOnboarding entity.
// If the UserOnboarding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOnboardingMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *UserOnboardingMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[useronboarding.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *UserOnboardingMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[useronboarding.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *UserOnboardingMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, useronboarding.FieldCompletedAt)
}

// SetSteps sets the "steps" field.
func (m *UserOnboardingMutation) SetSteps(value map[string]interface{}) {
	m.steps = &value
}

// Steps returns the value of the "steps" field in the mutation.
func (m *UserOnboardingMutation) Steps() (r map[string]interface{}, exists bool) {
	v := m.steps
	if v == nil {
		return
	}
	return *v, true
}

// OldSteps returns the old "steps" field's value of the UserOnboarding entity.
// If the UserOnboarding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOnboardingMutation) OldSteps(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSteps: %w", err)
	}
	return oldValue.Steps, nil
}

// ResetSteps resets all changes to the "steps" field.
func (m *UserOnboardingMutation) ResetSteps() {
	m.steps = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserOnboardingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserOnboardingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserOnboarding entity.
// If the UserOnboarding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOnboardingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserOnboardingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserOnboardingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserOnboardingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserOnboarding entity.
// If the UserOnboarding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserOnboardingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserOnboardingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserOnboardingMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserOnboardingMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserOnboardingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserOnboardingMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserOnboardingMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserOnboardingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserOnboardingMutation builder.
func (m *UserOnboardingMutation) Where(ps ...predicate.UserOnboarding) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserOnboardingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserOnboardingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserOnboarding, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserOnboardingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserOnboardingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserOnboarding).
func (m *UserOnboardingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserOnboardingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.is_completed != nil {
		fields = append(fields, useronboarding.FieldIsCompleted)
	}
	if m.completed_at != nil {
		fields = append(fields, useronboarding.FieldCompletedAt)
	}
	if m.steps != nil {
		fields = append(fields, useronboarding.FieldSteps)
	}
	if m.created_at != nil {
		fields = append(fields, useronboarding.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, useronboarding.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserOnboardingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useronboarding.FieldIsCompleted:
		return m.IsCompleted()
	case useronboarding.FieldCompletedAt:
		return m.CompletedAt()
	case useronboarding.FieldSteps:
		return m.Steps()
	case useronboarding.FieldCreatedAt:
		return m.CreatedAt()
	case useronboarding.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserOnboardingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useronboarding.FieldIsCompleted:
		return m.OldIsCompleted(ctx)
	case useronboarding.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case useronboarding.FieldSteps:
		return m.OldSteps(ctx)
	case useronboarding.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case useronboarding.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserOnboarding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserOnboardingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useronboarding.FieldIsCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCompleted(v)
		return nil
	case useronboarding.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case useronboarding.FieldSteps:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSteps(v)
		return nil
	case useronboarding.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case useronboarding.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserOnboarding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserOnboardingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserOnboardingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserOnboardingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserOnboarding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserOnboardingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useronboarding.FieldCompletedAt) {
		fields = append(fields, useronboarding.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserOnboardingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserOnboardingMutation) ClearField(name string) error {
	switch name {
	case useronboarding.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserOnboarding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserOnboardingMutation) ResetField(name string) error {
	switch name {
	case useronboarding.FieldIsCompleted:
		m.ResetIsCompleted()
		return nil
	case useronboarding.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case useronboarding.FieldSteps:
		m.ResetSteps()
		return nil
	case useronboarding.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case useronboarding.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserOnboarding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserOnboardingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useronboarding.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserOnboardingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useronboarding.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserOnboardingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserOnboardingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserOnboardingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useronboarding.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserOnboardingMutation) EdgeCleared(name string) bool {
	switch name {
	case useronboarding.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserOnboardingMutation) ClearEdge(name string) error {
	switch name {
	case useronboarding.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserOnboarding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserOnboardingMutation) ResetEdge(name string) error {
	switch name {
	case useronboarding.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserOnboarding edge %s", name)
}

// UserProfileMutation represents an operation that mutates the UserProfile nodes in the graph.
type UserProfileMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	first_name         *string
	last_name          *string
	avatar_url         *string
	bio                *string
	phone              *string
	job_title          *string
	company            *string
	linkedin           *string
	twitter            *string
	interests          *[]string
	appendinterests    []string
	completed_pct      *int
	addcompleted_pct   *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	user               *int
	cleareduser        bool
	assignments        map[int]struct{}
	removedassignments map[int]struct{}
	clearedassignments bool
	skills             map[int]struct{}
	removedskills      map[int]struct{}
	clearedskills      bool
	address            *int
	clearedaddress     bool
	done               bool
	oldValue           func(context.Context) (*UserProfile, error)
	predicates         []predicate.UserProfile
}

var _ ent.Mutation = (*UserProfileMutation)(nil)

// userprofileOption allows management of the mutation configuration using functional options.
type userprofileOption func(*UserProfileMutation)

// newUserProfileMutation creates new mutation for the UserProfile entity.
func newUserProfileMutation(c config, op Op, opts ...userprofileOption) *UserProfileMutation {
	m := &UserProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProfileID sets the ID field of the mutation.
func withUserProfileID(id int) userprofileOption {
	return func(m *UserProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProfile
		)
		m.oldValue = func(ctx context.Context) (*UserProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProfile sets the old UserProfile of the mutation.
func withUserProfile(node *UserProfile) userprofileOption {
	return func(m *UserProfileMutation) {
		m.oldValue = func(context.Context) (*UserProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstName sets the "first_name" field.
func (m *UserProfileMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserProfileMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserProfileMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[userprofile.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserProfileMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserProfileMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, userprofile.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserProfileMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserProfileMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserProfileMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[userprofile.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserProfileMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserProfileMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, userprofile.FieldLastName)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserProfileMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserProfileMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserProfileMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[userprofile.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserProfileMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserProfileMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, userprofile.FieldAvatarURL)
}

// SetBio sets the "bio" field.
func (m *UserProfileMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserProfileMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserProfileMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[userprofile.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserProfileMutation) BioCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserProfileMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, userprofile.FieldBio)
}

// SetPhone sets the "phone" field.
func (m *UserProfileMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserProfileMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserProfileMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[userprofile.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserProfileMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserProfileMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, userprofile.FieldPhone)
}

// SetJobTitle sets the "job_title" field.
func (m *UserProfileMutation) SetJobTitle(s string) {
	m.job_title = &s
}

// JobTitle returns the value of the "job_title" field in the mutation.
func (m *UserProfileMutation) JobTitle() (r string, exists bool) {
	v := m.job_title
	if v == nil {
		return
	}
	return *v, true
}

// OldJobTitle returns the old "job_title" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldJobTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobTitle: %w", err)
	}
	return oldValue.JobTitle, nil
}

// ClearJobTitle clears the value of the "job_title" field.
func (m *UserProfileMutation) ClearJobTitle() {
	m.job_title = nil
	m.clearedFields[userprofile.FieldJobTitle] = struct{}{}
}

// JobTitleCleared returns if the "job_title" field was cleared in this mutation.
func (m *UserProfileMutation) JobTitleCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldJobTitle]
	return ok
}

// ResetJobTitle resets all changes to the "job_title" field.
func (m *UserProfileMutation) ResetJobTitle() {
	m.job_title = nil
	delete(m.clearedFields, userprofile.FieldJobTitle)
}

// SetCompany sets the "company" field.
func (m *UserProfileMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *UserProfileMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *UserProfileMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[userprofile.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *UserProfileMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *UserProfileMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, userprofile.FieldCompany)
}

// SetLinkedin sets the "linkedin" field.
func (m *UserProfileMutation) SetLinkedin(s string) {
	m.linkedin = &s
}

// Linkedin returns the value of the "linkedin" field in the mutation.
func (m *UserProfileMutation) Linkedin() (r string, exists bool) {
	v := m.linkedin
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedin returns the old "linkedin" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldLinkedin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedin: %w", err)
	}
	return oldValue.Linkedin, nil
}

// ClearLinkedin clears the value of the "linkedin" field.
func (m *UserProfileMutation) ClearLinkedin() {
	m.linkedin = nil
	m.clearedFields[userprofile.FieldLinkedin] = struct{}{}
}

// LinkedinCleared returns if the "linkedin" field was cleared in this mutation.
func (m *UserProfileMutation) LinkedinCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldLinkedin]
	return ok
}

// ResetLinkedin resets all changes to the "linkedin" field.
func (m *UserProfileMutation) ResetLinkedin() {
	m.linkedin = nil
	delete(m.clearedFields, userprofile.FieldLinkedin)
}

// SetTwitter sets the "twitter" field.
func (m *UserProfileMutation) SetTwitter(s string) {
	m.twitter = &s
}

// Twitter returns the value of the "twitter" field in the mutation.
func (m *UserProfileMutation) Twitter() (r string, exists bool) {
	v := m.twitter
	if v == nil {
		return
	}
	return *v, true
}

// OldTwitter returns the old "twitter" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldTwitter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwitter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwitter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwitter: %w", err)
	}
	return oldValue.Twitter, nil
}

// ClearTwitter clears the value of the "twitter" field.
func (m *UserProfileMutation) ClearTwitter() {
	m.twitter = nil
	m.clearedFields[userprofile.FieldTwitter] = struct{}{}
}

// TwitterCleared returns if the "twitter" field was cleared in this mutation.
func (m *UserProfileMutation) TwitterCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldTwitter]
	return ok
}

// ResetTwitter resets all changes to the "twitter" field.
func (m *UserProfileMutation) ResetTwitter() {
	m.twitter = nil
	delete(m.clearedFields, userprofile.FieldTwitter)
}

// SetInterests sets the "interests" field.
func (m *UserProfileMutation) SetInterests(s []string) {
	m.interests = &s
	m.appendinterests = nil
}

// Interests returns the value of the "interests" field in the mutation.
func (m *UserProfileMutation) Interests() (r []string, exists bool) {
	v := m.interests
	if v == nil {
		return
	}
	return *v, true
}

// OldInterests returns the old "interests" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldInterests(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterests is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterests requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterests: %w", err)
	}
	return oldValue.Interests, nil
}

// AppendInterests adds s to the "interests" field.
func (m *UserProfileMutation) AppendInterests(s []string) {
	m.appendinterests = append(m.appendinterests, s...)
}

// AppendedInterests returns the list of values that were appended to the "interests" field in this mutation.
func (m *UserProfileMutation) AppendedInterests() ([]string, bool) {
	if len(m.appendinterests) == 0 {
		return nil, false
	}
	return m.appendinterests, true
}

// ResetInterests resets all changes to the "interests" field.
func (m *UserProfileMutation) ResetInterests() {
	m.interests = nil
	m.appendinterests = nil
}

// SetCompletedPct sets the "completed_pct" field.
func (m *UserProfileMutation) SetCompletedPct(i int) {
	m.completed_pct = &i
	m.addcompleted_pct = nil
}

// CompletedPct returns the value of the "completed_pct" field in the mutation.
func (m *UserProfileMutation) CompletedPct() (r int, exists bool) {
	v := m.completed_pct
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedPct returns the old "completed_pct" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldCompletedPct(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedPct is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedPct requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedPct: %w", err)
	}
	return oldValue.CompletedPct, nil
}

// AddCompletedPct adds i to the "completed_pct" field.
func (m *UserProfileMutation) AddCompletedPct(i int) {
	if m.addcompleted_pct != nil {
		*m.addcompleted_pct += i
	} else {
		m.addcompleted_pct = &i
	}
}

// AddedCompletedPct returns the value that was added to the "completed_pct" field in this mutation.
func (m *UserProfileMutation) AddedCompletedPct() (r int, exists bool) {
	v := m.addcompleted_pct
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompletedPct resets all changes to the "completed_pct" field.
func (m *UserProfileMutation) ResetCompletedPct() {
	m.completed_pct = nil
	m.addcompleted_pct = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserProfileMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserProfileMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddAssignmentIDs adds the "assignments" edge to the VolunteerAssignment entity by ids.
func (m *UserProfileMutation) AddAssignmentIDs(ids ...int) {
	if m.assignments == nil {
		m.assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the VolunteerAssignment entity.
func (m *UserProfileMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the VolunteerAssignment entity was cleared.
func (m *UserProfileMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the VolunteerAssignment entity by IDs.
func (m *UserProfileMutation) RemoveAssignmentIDs(ids ...int) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the VolunteerAssignment entity.
func (m *UserProfileMutation) RemovedAssignmentsIDs() (ids []int) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *UserProfileMutation) AssignmentsIDs() (ids []int) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *UserProfileMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// AddSkillIDs adds the "skills" edge to the UserSkill entity by ids.
func (m *UserProfileMutation) AddSkillIDs(ids ...int) {
	if m.skills == nil {
		m.skills = make(map[int]struct{})
	}
	for i := range ids {
		m.skills[ids[i]] = struct{}{}
	}
}

// ClearSkills clears the "skills" edge to the UserSkill entity.
func (m *UserProfileMutation) ClearSkills() {
	m.clearedskills = true
}

// SkillsCleared reports if the "skills" edge to the UserSkill entity was cleared.
func (m *UserProfileMutation) SkillsCleared() bool {
	return m.clearedskills
}

// RemoveSkillIDs removes the "skills" edge to the UserSkill entity by IDs.
func (m *UserProfileMutation) RemoveSkillIDs(ids ...int) {
	if m.removedskills == nil {
		m.removedskills = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.skills, ids[i])
		m.removedskills[ids[i]] = struct{}{}
	}
}

// RemovedSkills returns the removed IDs of the "skills" edge to the UserSkill entity.
func (m *UserProfileMutation) RemovedSkillsIDs() (ids []int) {
	for id := range m.removedskills {
		ids = append(ids, id)
	}
	return
}

// SkillsIDs returns the "skills" edge IDs in the mutation.
func (m *UserProfileMutation) SkillsIDs() (ids []int) {
	for id := range m.skills {
		ids = append(ids, id)
	}
	return
}

// ResetSkills resets all changes to the "skills" edge.
func (m *UserProfileMutation) ResetSkills() {
	m.skills = nil
	m.clearedskills = false
	m.removedskills = nil
}

// SetAddressID sets the "address" edge to the Address entity by id.
func (m *UserProfileMutation) SetAddressID(id int) {
	m.address = &id
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *UserProfileMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *UserProfileMutation) AddressCleared() bool {
	return m.clearedaddress
}

// AddressID returns the "address" edge ID in the mutation.
func (m *UserProfileMutation) AddressID() (id int, exists bool) {
	if m.address != nil {
		return *m.address, true
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) AddressIDs() (ids []int) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *UserProfileMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// Where appends a list predicates to the UserProfileMutation builder.
func (m *UserProfileMutation) Where(ps ...predicate.UserProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProfile).
func (m *UserProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProfileMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.first_name != nil {
		fields = append(fields, userprofile.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, userprofile.FieldLastName)
	}
	if m.avatar_url != nil {
		fields = append(fields, userprofile.FieldAvatarURL)
	}
	if m.bio != nil {
		fields = append(fields, userprofile.FieldBio)
	}
	if m.phone != nil {
		fields = append(fields, userprofile.FieldPhone)
	}
	if m.job_title != nil {
		fields = append(fields, userprofile.FieldJobTitle)
	}
	if m.company != nil {
		fields = append(fields, userprofile.FieldCompany)
	}
	if m.linkedin != nil {
		fields = append(fields, userprofile.FieldLinkedin)
	}
	if m.twitter != nil {
		fields = append(fields, userprofile.FieldTwitter)
	}
	if m.interests != nil {
		fields = append(fields, userprofile.FieldInterests)
	}
	if m.completed_pct != nil {
		fields = append(fields, userprofile.FieldCompletedPct)
	}
	if m.created_at != nil {
		fields = append(fields, userprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userprofile.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userprofile.FieldFirstName:
		return m.FirstName()
	case userprofile.FieldLastName:
		return m.LastName()
	case userprofile.FieldAvatarURL:
		return m.AvatarURL()
	case userprofile.FieldBio:
		return m.Bio()
	case userprofile.FieldPhone:
		return m.Phone()
	case userprofile.FieldJobTitle:
		return m.JobTitle()
	case userprofile.FieldCompany:
		return m.Company()
	case userprofile.FieldLinkedin:
		return m.Linkedin()
	case userprofile.FieldTwitter:
		return m.Twitter()
	case userprofile.FieldInterests:
		return m.Interests()
	case userprofile.FieldCompletedPct:
		return m.CompletedPct()
	case userprofile.FieldCreatedAt:
		return m.CreatedAt()
	case userprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userprofile.FieldFirstName:
		return m.OldFirstName(ctx)
	case userprofile.FieldLastName:
		return m.OldLastName(ctx)
	case userprofile.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case userprofile.FieldBio:
		return m.OldBio(ctx)
	case userprofile.FieldPhone:
		return m.OldPhone(ctx)
	case userprofile.FieldJobTitle:
		return m.OldJobTitle(ctx)
	case userprofile.FieldCompany:
		return m.OldCompany(ctx)
	case userprofile.FieldLinkedin:
		return m.OldLinkedin(ctx)
	case userprofile.FieldTwitter:
		return m.OldTwitter(ctx)
	case userprofile.FieldInterests:
		return m.OldInterests(ctx)
	case userprofile.FieldCompletedPct:
		return m.OldCompletedPct(ctx)
	case userprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userprofile.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case userprofile.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case userprofile.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case userprofile.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case userprofile.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case userprofile.FieldJobTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobTitle(v)
		return nil
	case userprofile.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case userprofile.FieldLinkedin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedin(v)
		return nil
	case userprofile.FieldTwitter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwitter(v)
		return nil
	case userprofile.FieldInterests:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterests(v)
		return nil
	case userprofile.FieldCompletedPct:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedPct(v)
		return nil
	case userprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProfileMutation) AddedFields() []string {
	var fields []string
	if m.addcompleted_pct != nil {
		fields = append(fields, userprofile.FieldCompletedPct)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userprofile.FieldCompletedPct:
		return m.AddedCompletedPct()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userprofile.FieldCompletedPct:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletedPct(v)
		return nil
	}
	return fmt.Errorf("unknown UserProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userprofile.FieldFirstName) {
		fields = append(fields, userprofile.FieldFirstName)
	}
	if m.FieldCleared(userprofile.FieldLastName) {
		fields = append(fields, userprofile.FieldLastName)
	}
	if m.FieldCleared(userprofile.FieldAvatarURL) {
		fields = append(fields, userprofile.FieldAvatarURL)
	}
	if m.FieldCleared(userprofile.FieldBio) {
		fields = append(fields, userprofile.FieldBio)
	}
	if m.FieldCleared(userprofile.FieldPhone) {
		fields = append(fields, userprofile.FieldPhone)
	}
	if m.FieldCleared(userprofile.FieldJobTitle) {
		fields = append(fields, userprofile.FieldJobTitle)
	}
	if m.FieldCleared(userprofile.FieldCompany) {
		fields = append(fields, userprofile.FieldCompany)
	}
	if m.FieldCleared(userprofile.FieldLinkedin) {
		fields = append(fields, userprofile.FieldLinkedin)
	}
	if m.FieldCleared(userprofile.FieldTwitter) {
		fields = append(fields, userprofile.FieldTwitter)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProfileMutation) ClearField(name string) error {
	switch name {
	case userprofile.FieldFirstName:
		m.ClearFirstName()
		return nil
	case userprofile.FieldLastName:
		m.ClearLastName()
		return nil
	case userprofile.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case userprofile.FieldBio:
		m.ClearBio()
		return nil
	case userprofile.FieldPhone:
		m.ClearPhone()
		return nil
	case userprofile.FieldJobTitle:
		m.ClearJobTitle()
		return nil
	case userprofile.FieldCompany:
		m.ClearCompany()
		return nil
	case userprofile.FieldLinkedin:
		m.ClearLinkedin()
		return nil
	case userprofile.FieldTwitter:
		m.ClearTwitter()
		return nil
	}
	return fmt.Errorf("unknown UserProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProfileMutation) ResetField(name string) error {
	switch name {
	case userprofile.FieldFirstName:
		m.ResetFirstName()
		return nil
	case userprofile.FieldLastName:
		m.ResetLastName()
		return nil
	case userprofile.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case userprofile.FieldBio:
		m.ResetBio()
		return nil
	case userprofile.FieldPhone:
		m.ResetPhone()
		return nil
	case userprofile.FieldJobTitle:
		m.ResetJobTitle()
		return nil
	case userprofile.FieldCompany:
		m.ResetCompany()
		return nil
	case userprofile.FieldLinkedin:
		m.ResetLinkedin()
		return nil
	case userprofile.FieldTwitter:
		m.ResetTwitter()
		return nil
	case userprofile.FieldInterests:
		m.ResetInterests()
		return nil
	case userprofile.FieldCompletedPct:
		m.ResetCompletedPct()
		return nil
	case userprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, userprofile.EdgeUser)
	}
	if m.assignments != nil {
		edges = append(edges, userprofile.EdgeAssignments)
	}
	if m.skills != nil {
		edges = append(edges, userprofile.EdgeSkills)
	}
	if m.address != nil {
		edges = append(edges, userprofile.EdgeAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userprofile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userprofile.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	case userprofile.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.skills))
		for id := range m.skills {
			ids = append(ids, id)
		}
		return ids
	case userprofile.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedassignments != nil {
		edges = append(edges, userprofile.EdgeAssignments)
	}
	if m.removedskills != nil {
		edges = append(edges, userprofile.EdgeSkills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userprofile.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	case userprofile.EdgeSkills:
		ids := make([]ent.Value, 0, len(m.removedskills))
		for id := range m.removedskills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, userprofile.EdgeUser)
	}
	if m.clearedassignments {
		edges = append(edges, userprofile.EdgeAssignments)
	}
	if m.clearedskills {
		edges = append(edges, userprofile.EdgeSkills)
	}
	if m.clearedaddress {
		edges = append(edges, userprofile.EdgeAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case userprofile.EdgeUser:
		return m.cleareduser
	case userprofile.EdgeAssignments:
		return m.clearedassignments
	case userprofile.EdgeSkills:
		return m.clearedskills
	case userprofile.EdgeAddress:
		return m.clearedaddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProfileMutation) ClearEdge(name string) error {
	switch name {
	case userprofile.EdgeUser:
		m.ClearUser()
		return nil
	case userprofile.EdgeAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown UserProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProfileMutation) ResetEdge(name string) error {
	switch name {
	case userprofile.EdgeUser:
		m.ResetUser()
		return nil
	case userprofile.EdgeAssignments:
		m.ResetAssignments()
		return nil
	case userprofile.EdgeSkills:
		m.ResetSkills()
		return nil
	case userprofile.EdgeAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown UserProfile edge %s", name)
}

// UserSessionMutation represents an operation that mutates the UserSession nodes in the graph.
type UserSessionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	session_token      *string
	expires_at         *time.Time
	ip_address         *string
	user_agent         *string
	created_at         *time.Time
	last_accessed      *time.Time
	device_fingerprint *string
	clearedFields      map[string]struct{}
	user               *int
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*UserSession, error)
	predicates         []predicate.UserSession
}

var _ ent.Mutation = (*UserSessionMutation)(nil)

// usersessionOption allows management of the mutation configuration using functional options.
type usersessionOption func(*UserSessionMutation)

// newUserSessionMutation creates new mutation for the UserSession entity.
func newUserSessionMutation(c config, op Op, opts ...usersessionOption) *UserSessionMutation {
	m := &UserSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSessionID sets the ID field of the mutation.
func withUserSessionID(id int) usersessionOption {
	return func(m *UserSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSession
		)
		m.oldValue = func(ctx context.Context) (*UserSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSession sets the old UserSession of the mutation.
func withUserSession(node *UserSession) usersessionOption {
	return func(m *UserSessionMutation) {
		m.oldValue = func(context.Context) (*UserSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionToken sets the "session_token" field.
func (m *UserSessionMutation) SetSessionToken(s string) {
	m.session_token = &s
}

// SessionToken returns the value of the "session_token" field in the mutation.
func (m *UserSessionMutation) SessionToken() (r string, exists bool) {
	v := m.session_token
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionToken returns the old "session_token" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldSessionToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionToken: %w", err)
	}
	return oldValue.SessionToken, nil
}

// ResetSessionToken resets all changes to the "session_token" field.
func (m *UserSessionMutation) ResetSessionToken() {
	m.session_token = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *UserSessionMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *UserSessionMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *UserSessionMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[usersession.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *UserSessionMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[usersession.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *UserSessionMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, usersession.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *UserSessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *UserSessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *UserSessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[usersession.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *UserSessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[usersession.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *UserSessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, usersession.FieldUserAgent)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLastAccessed sets the "last_accessed" field.
func (m *UserSessionMutation) SetLastAccessed(t time.Time) {
	m.last_accessed = &t
}

// LastAccessed returns the value of the "last_accessed" field in the mutation.
func (m *UserSessionMutation) LastAccessed() (r time.Time, exists bool) {
	v := m.last_accessed
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAccessed returns the old "last_accessed" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldLastAccessed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAccessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAccessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAccessed: %w", err)
	}
	return oldValue.LastAccessed, nil
}

// ResetLastAccessed resets all changes to the "last_accessed" field.
func (m *UserSessionMutation) ResetLastAccessed() {
	m.last_accessed = nil
}

// SetDeviceFingerprint sets the "device_fingerprint" field.
func (m *UserSessionMutation) SetDeviceFingerprint(s string) {
	m.device_fingerprint = &s
}

// DeviceFingerprint returns the value of the "device_fingerprint" field in the mutation.
func (m *UserSessionMutation) DeviceFingerprint() (r string, exists bool) {
	v := m.device_fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceFingerprint returns the old "device_fingerprint" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldDeviceFingerprint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceFingerprint: %w", err)
	}
	return oldValue.DeviceFingerprint, nil
}

// ClearDeviceFingerprint clears the value of the "device_fingerprint" field.
func (m *UserSessionMutation) ClearDeviceFingerprint() {
	m.device_fingerprint = nil
	m.clearedFields[usersession.FieldDeviceFingerprint] = struct{}{}
}

// DeviceFingerprintCleared returns if the "device_fingerprint" field was cleared in this mutation.
func (m *UserSessionMutation) DeviceFingerprintCleared() bool {
	_, ok := m.clearedFields[usersession.FieldDeviceFingerprint]
	return ok
}

// ResetDeviceFingerprint resets all changes to the "device_fingerprint" field.
func (m *UserSessionMutation) ResetDeviceFingerprint() {
	m.device_fingerprint = nil
	delete(m.clearedFields, usersession.FieldDeviceFingerprint)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserSessionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserSessionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserSessionMutation builder.
func (m *UserSessionMutation) Where(ps ...predicate.UserSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSession).
func (m *UserSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSessionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.session_token != nil {
		fields = append(fields, usersession.FieldSessionToken)
	}
	if m.expires_at != nil {
		fields = append(fields, usersession.FieldExpiresAt)
	}
	if m.ip_address != nil {
		fields = append(fields, usersession.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, usersession.FieldUserAgent)
	}
	if m.created_at != nil {
		fields = append(fields, usersession.FieldCreatedAt)
	}
	if m.last_accessed != nil {
		fields = append(fields, usersession.FieldLastAccessed)
	}
	if m.device_fingerprint != nil {
		fields = append(fields, usersession.FieldDeviceFingerprint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersession.FieldSessionToken:
		return m.SessionToken()
	case usersession.FieldExpiresAt:
		return m.ExpiresAt()
	case usersession.FieldIPAddress:
		return m.IPAddress()
	case usersession.FieldUserAgent:
		return m.UserAgent()
	case usersession.FieldCreatedAt:
		return m.CreatedAt()
	case usersession.FieldLastAccessed:
		return m.LastAccessed()
	case usersession.FieldDeviceFingerprint:
		return m.DeviceFingerprint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersession.FieldSessionToken:
		return m.OldSessionToken(ctx)
	case usersession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case usersession.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case usersession.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case usersession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersession.FieldLastAccessed:
		return m.OldLastAccessed(ctx)
	case usersession.FieldDeviceFingerprint:
		return m.OldDeviceFingerprint(ctx)
	}
	return nil, fmt.Errorf("unknown UserSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersession.FieldSessionToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionToken(v)
		return nil
	case usersession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case usersession.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case usersession.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case usersession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersession.FieldLastAccessed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAccessed(v)
		return nil
	case usersession.FieldDeviceFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceFingerprint(v)
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersession.FieldIPAddress) {
		fields = append(fields, usersession.FieldIPAddress)
	}
	if m.FieldCleared(usersession.FieldUserAgent) {
		fields = append(fields, usersession.FieldUserAgent)
	}
	if m.FieldCleared(usersession.FieldDeviceFingerprint) {
		fields = append(fields, usersession.FieldDeviceFingerprint)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSessionMutation) ClearField(name string) error {
	switch name {
	case usersession.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case usersession.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case usersession.FieldDeviceFingerprint:
		m.ClearDeviceFingerprint()
		return nil
	}
	return fmt.Errorf("unknown UserSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSessionMutation) ResetField(name string) error {
	switch name {
	case usersession.FieldSessionToken:
		m.ResetSessionToken()
		return nil
	case usersession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case usersession.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case usersession.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case usersession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersession.FieldLastAccessed:
		m.ResetLastAccessed()
		return nil
	case usersession.FieldDeviceFingerprint:
		m.ResetDeviceFingerprint()
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usersession.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usersession.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersession.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSessionMutation) ClearEdge(name string) error {
	switch name {
	case usersession.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSessionMutation) ResetEdge(name string) error {
	switch name {
	case usersession.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserSession edge %s", name)
}

// UserSkillMutation represents an operation that mutates the UserSkill nodes in the graph.
type UserSkillMutation struct {
	config
	op             Op
	typ            string
	id             *int
	level          *userskill.Level
	clearedFields  map[string]struct{}
	profile        *int
	clearedprofile bool
	skill          *int
	clearedskill   bool
	done           bool
	oldValue       func(context.Context) (*UserSkill, error)
	predicates     []predicate.UserSkill
}

var _ ent.Mutation = (*UserSkillMutation)(nil)

// userskillOption allows management of the mutation configuration using functional options.
type userskillOption func(*UserSkillMutation)

// newUserSkillMutation creates new mutation for the UserSkill entity.
func newUserSkillMutation(c config, op Op, opts ...userskillOption) *UserSkillMutation {
	m := &UserSkillMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSkillID sets the ID field of the mutation.
func withUserSkillID(id int) userskillOption {
	return func(m *UserSkillMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSkill
		)
		m.oldValue = func(ctx context.Context) (*UserSkill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSkill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSkill sets the old UserSkill of the mutation.
func withUserSkill(node *UserSkill) userskillOption {
	return func(m *UserSkillMutation) {
		m.oldValue = func(context.Context) (*UserSkill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSkillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSkillMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSkill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLevel sets the "level" field.
func (m *UserSkillMutation) SetLevel(u userskill.Level) {
	m.level = &u
}

// Level returns the value of the "level" field in the mutation.
func (m *UserSkillMutation) Level() (r userskill.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the UserSkill entity.
// If the UserSkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSkillMutation) OldLevel(ctx context.Context) (v userskill.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *UserSkillMutation) ResetLevel() {
	m.level = nil
}

// SetProfileID sets the "profile" edge to the UserProfile entity by id.
func (m *UserSkillMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the UserProfile entity.
func (m *UserSkillMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the UserProfile entity was cleared.
func (m *UserSkillMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserSkillMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserSkillMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserSkillMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// SetSkillID sets the "skill" edge to the Skill entity by id.
func (m *UserSkillMutation) SetSkillID(id int) {
	m.skill = &id
}

// ClearSkill clears the "skill" edge to the Skill entity.
func (m *UserSkillMutation) ClearSkill() {
	m.clearedskill = true
}

// SkillCleared reports if the "skill" edge to the Skill entity was cleared.
func (m *UserSkillMutation) SkillCleared() bool {
	return m.clearedskill
}

// SkillID returns the "skill" edge ID in the mutation.
func (m *UserSkillMutation) SkillID() (id int, exists bool) {
	if m.skill != nil {
		return *m.skill, true
	}
	return
}

// SkillIDs returns the "skill" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SkillID instead. It exists only for internal usage by the builders.
func (m *UserSkillMutation) SkillIDs() (ids []int) {
	if id := m.skill; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSkill resets all changes to the "skill" edge.
func (m *UserSkillMutation) ResetSkill() {
	m.skill = nil
	m.clearedskill = false
}

// Where appends a list predicates to the UserSkillMutation builder.
func (m *UserSkillMutation) Where(ps ...predicate.UserSkill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSkill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSkill).
func (m *UserSkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSkillMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.level != nil {
		fields = append(fields, userskill.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userskill.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userskill.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown UserSkill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userskill.FieldLevel:
		v, ok := value.(userskill.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown UserSkill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSkill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSkillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSkillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserSkill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSkillMutation) ResetField(name string) error {
	switch name {
	case userskill.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown UserSkill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.profile != nil {
		edges = append(edges, userskill.EdgeProfile)
	}
	if m.skill != nil {
		edges = append(edges, userskill.EdgeSkill)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userskill.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case userskill.EdgeSkill:
		if id := m.skill; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprofile {
		edges = append(edges, userskill.EdgeProfile)
	}
	if m.clearedskill {
		edges = append(edges, userskill.EdgeSkill)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSkillMutation) EdgeCleared(name string) bool {
	switch name {
	case userskill.EdgeProfile:
		return m.clearedprofile
	case userskill.EdgeSkill:
		return m.clearedskill
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSkillMutation) ClearEdge(name string) error {
	switch name {
	case userskill.EdgeProfile:
		m.ClearProfile()
		return nil
	case userskill.EdgeSkill:
		m.ClearSkill()
		return nil
	}
	return fmt.Errorf("unknown UserSkill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSkillMutation) ResetEdge(name string) error {
	switch name {
	case userskill.EdgeProfile:
		m.ResetProfile()
		return nil
	case userskill.EdgeSkill:
		m.ResetSkill()
		return nil
	}
	return fmt.Errorf("unknown UserSkill edge %s", name)
}

// VolunteerApplicationMutation represents an operation that mutates the VolunteerApplication nodes in the graph.
type VolunteerApplicationMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	status                          *volunteerapplication.Status
	motivation                      *string
	availability                    *map[string]interface{}
	background_check                *bool
	background_check_date           *time.Time
	references                      *[]map[string]interface{}
	appendreferences                []map[string]interface{}
	emergency_contact               *map[string]string
	reviewed_by                     *string
	reviewed_at                     *time.Time
	review_notes                    *string
	interview_date                  *time.Time
	created_at                      *time.Time
	updated_at                      *time.Time
	clearedFields                   map[string]struct{}
	user                            *int
	cleareduser                     bool
	interested_opportunities        map[int]struct{}
	removedinterested_opportunities map[int]struct{}
	clearedinterested_opportunities bool
	done                            bool
	oldValue                        func(context.Context) (*VolunteerApplication, error)
	predicates                      []predicate.VolunteerApplication
}

var _ ent.Mutation = (*VolunteerApplicationMutation)(nil)

// volunteerapplicationOption allows management of the mutation configuration using functional options.
type volunteerapplicationOption func(*VolunteerApplicationMutation)

// newVolunteerApplicationMutation creates new mutation for the VolunteerApplication entity.
func newVolunteerApplicationMutation(c config, op Op, opts ...volunteerapplicationOption) *VolunteerApplicationMutation {
	m := &VolunteerApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeVolunteerApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVolunteerApplicationID sets the ID field of the mutation.
func withVolunteerApplicationID(id int) volunteerapplicationOption {
	return func(m *VolunteerApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *VolunteerApplication
		)
		m.oldValue = func(ctx context.Context) (*VolunteerApplication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VolunteerApplication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVolunteerApplication sets the old VolunteerApplication of the mutation.
func withVolunteerApplication(node *VolunteerApplication) volunteerapplicationOption {
	return func(m *VolunteerApplicationMutation) {
		m.oldValue = func(context.Context) (*VolunteerApplication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VolunteerApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VolunteerApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VolunteerApplicationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VolunteerApplicationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VolunteerApplication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *VolunteerApplicationMutation) SetStatus(v volunteerapplication.Status) {
	m.status = &v
}

// Status returns the value of the "status" field in the mutation.
func (m *VolunteerApplicationMutation) Status() (r volunteerapplication.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldStatus(ctx context.Context) (v volunteerapplication.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *VolunteerApplicationMutation) ResetStatus() {
	m.status = nil
}

// SetMotivation sets the "motivation" field.
func (m *VolunteerApplicationMutation) SetMotivation(s string) {
	m.motivation = &s
}

// Motivation returns the value of the "motivation" field in the mutation.
func (m *VolunteerApplicationMutation) Motivation() (r string, exists bool) {
	v := m.motivation
	if v == nil {
		return
	}
	return *v, true
}

// OldMotivation returns the old "motivation" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldMotivation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMotivation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMotivation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMotivation: %w", err)
	}
	return oldValue.Motivation, nil
}

// ResetMotivation resets all changes to the "motivation" field.
func (m *VolunteerApplicationMutation) ResetMotivation() {
	m.motivation = nil
}

// SetAvailability sets the "availability" field.
func (m *VolunteerApplicationMutation) SetAvailability(value map[string]interface{}) {
	m.availability = &value
}

// Availability returns the value of the "availability" field in the mutation.
func (m *VolunteerApplicationMutation) Availability() (r map[string]interface{}, exists bool) {
	v := m.availability
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailability returns the old "availability" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldAvailability(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailability is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailability requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailability: %w", err)
	}
	return oldValue.Availability, nil
}

// ResetAvailability resets all changes to the "availability" field.
func (m *VolunteerApplicationMutation) ResetAvailability() {
	m.availability = nil
}

// SetBackgroundCheck sets the "background_check" field.
func (m *VolunteerApplicationMutation) SetBackgroundCheck(b bool) {
	m.background_check = &b
}

// BackgroundCheck returns the value of the "background_check" field in the mutation.
func (m *VolunteerApplicationMutation) BackgroundCheck() (r bool, exists bool) {
	v := m.background_check
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundCheck returns the old "background_check" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldBackgroundCheck(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundCheck: %w", err)
	}
	return oldValue.BackgroundCheck, nil
}

// ResetBackgroundCheck resets all changes to the "background_check" field.
func (m *VolunteerApplicationMutation) ResetBackgroundCheck() {
	m.background_check = nil
}

// SetBackgroundCheckDate sets the "background_check_date" field.
func (m *VolunteerApplicationMutation) SetBackgroundCheckDate(t time.Time) {
	m.background_check_date = &t
}

// BackgroundCheckDate returns the value of the "background_check_date" field in the mutation.
func (m *VolunteerApplicationMutation) BackgroundCheckDate() (r time.Time, exists bool) {
	v := m.background_check_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundCheckDate returns the old "background_check_date" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldBackgroundCheckDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundCheckDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundCheckDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundCheckDate: %w", err)
	}
	return oldValue.BackgroundCheckDate, nil
}

// ClearBackgroundCheckDate clears the value of the "background_check_date" field.
func (m *VolunteerApplicationMutation) ClearBackgroundCheckDate() {
	m.background_check_date = nil
	m.clearedFields[volunteerapplication.FieldBackgroundCheckDate] = struct{}{}
}

// BackgroundCheckDateCleared returns if the "background_check_date" field was cleared in this mutation.
func (m *VolunteerApplicationMutation) BackgroundCheckDateCleared() bool {
	_, ok := m.clearedFields[volunteerapplication.FieldBackgroundCheckDate]
	return ok
}

// ResetBackgroundCheckDate resets all changes to the "background_check_date" field.
func (m *VolunteerApplicationMutation) ResetBackgroundCheckDate() {
	m.background_check_date = nil
	delete(m.clearedFields, volunteerapplication.FieldBackgroundCheckDate)
}

// SetReferences sets the "references" field.
func (m *VolunteerApplicationMutation) SetReferences(value []map[string]interface{}) {
	m.references = &value
	m.appendreferences = nil
}

// References returns the value of the "references" field in the mutation.
func (m *VolunteerApplicationMutation) References() (r []map[string]interface{}, exists bool) {
	v := m.references
	if v == nil {
		return
	}
	return *v, true
}

// OldReferences returns the old "references" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldReferences(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferences: %w", err)
	}
	return oldValue.References, nil
}

// AppendReferences adds value to the "references" field.
func (m *VolunteerApplicationMutation) AppendReferences(value []map[string]interface{}) {
	m.appendreferences = append(m.appendreferences, value...)
}

// AppendedReferences returns the list of values that were appended to the "references" field in this mutation.
func (m *VolunteerApplicationMutation) AppendedReferences() ([]map[string]interface{}, bool) {
	if len(m.appendreferences) == 0 {
		return nil, false
	}
	return m.appendreferences, true
}

// ClearReferences clears the value of the "references" field.
func (m *VolunteerApplicationMutation) ClearReferences() {
	m.references = nil
	m.appendreferences = nil
	m.clearedFields[volunteerapplication.FieldReferences] = struct{}{}
}

// ReferencesCleared returns if the "references" field was cleared in this mutation.
func (m *VolunteerApplicationMutation) ReferencesCleared() bool {
	_, ok := m.clearedFields[volunteerapplication.FieldReferences]
	return ok
}

// ResetReferences resets all changes to the "references" field.
func (m *VolunteerApplicationMutation) ResetReferences() {
	m.references = nil
	m.appendreferences = nil
	delete(m.clearedFields, volunteerapplication.FieldReferences)
}

// SetEmergencyContact sets the "emergency_contact" field.
func (m *VolunteerApplicationMutation) SetEmergencyContact(value map[string]string) {
	m.emergency_contact = &value
}

// EmergencyContact returns the value of the "emergency_contact" field in the mutation.
func (m *VolunteerApplicationMutation) EmergencyContact() (r map[string]string, exists bool) {
	v := m.emergency_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldEmergencyContact returns the old "emergency_contact" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldEmergencyContact(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmergencyContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmergencyContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmergencyContact: %w", err)
	}
	return oldValue.EmergencyContact, nil
}

// ClearEmergencyContact clears the value of the "emergency_contact" field.
func (m *VolunteerApplicationMutation) ClearEmergencyContact() {
	m.emergency_contact = nil
	m.clearedFields[volunteerapplication.FieldEmergencyContact] = struct{}{}
}

// EmergencyContactCleared returns if the "emergency_contact" field was cleared in this mutation.
func (m *VolunteerApplicationMutation) EmergencyContactCleared() bool {
	_, ok := m.clearedFields[volunteerapplication.FieldEmergencyContact]
	return ok
}

// ResetEmergencyContact resets all changes to the "emergency_contact" field.
func (m *VolunteerApplicationMutation) ResetEmergencyContact() {
	m.emergency_contact = nil
	delete(m.clearedFields, volunteerapplication.FieldEmergencyContact)
}

// SetReviewedBy sets the "reviewed_by" field.
func (m *VolunteerApplicationMutation) SetReviewedBy(s string) {
	m.reviewed_by = &s
}

// ReviewedBy returns the value of the "reviewed_by" field in the mutation.
func (m *VolunteerApplicationMutation) ReviewedBy() (r string, exists bool) {
	v := m.reviewed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedBy returns the old "reviewed_by" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldReviewedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedBy: %w", err)
	}
	return oldValue.ReviewedBy, nil
}

// ClearReviewedBy clears the value of the "reviewed_by" field.
func (m *VolunteerApplicationMutation) ClearReviewedBy() {
	m.reviewed_by = nil
	m.clearedFields[volunteerapplication.FieldReviewedBy] = struct{}{}
}

// ReviewedByCleared returns if the "reviewed_by" field was cleared in this mutation.
func (m *VolunteerApplicationMutation) ReviewedByCleared() bool {
	_, ok := m.clearedFields[volunteerapplication.FieldReviewedBy]
	return ok
}

// ResetReviewedBy resets all changes to the "reviewed_by" field.
func (m *VolunteerApplicationMutation) ResetReviewedBy() {
	m.reviewed_by = nil
	delete(m.clearedFields, volunteerapplication.FieldReviewedBy)
}

// SetReviewedAt sets the "reviewed_at" field.
func (m *VolunteerApplicationMutation) SetReviewedAt(t time.Time) {
	m.reviewed_at = &t
}

// ReviewedAt returns the value of the "reviewed_at" field in the mutation.
func (m *VolunteerApplicationMutation) ReviewedAt() (r time.Time, exists bool) {
	v := m.reviewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedAt returns the old "reviewed_at" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldReviewedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedAt: %w", err)
	}
	return oldValue.ReviewedAt, nil
}

// ClearReviewedAt clears the value of the "reviewed_at" field.
func (m *VolunteerApplicationMutation) ClearReviewedAt() {
	m.reviewed_at = nil
	m.clearedFields[volunteerapplication.FieldReviewedAt] = struct{}{}
}

// ReviewedAtCleared returns if the "reviewed_at" field was cleared in this mutation.
func (m *VolunteerApplicationMutation) ReviewedAtCleared() bool {
	_, ok := m.clearedFields[volunteerapplication.FieldReviewedAt]
	return ok
}

// ResetReviewedAt resets all changes to the "reviewed_at" field.
func (m *VolunteerApplicationMutation) ResetReviewedAt() {
	m.reviewed_at = nil
	delete(m.clearedFields, volunteerapplication.FieldReviewedAt)
}

// SetReviewNotes sets the "review_notes" field.
func (m *VolunteerApplicationMutation) SetReviewNotes(s string) {
	m.review_notes = &s
}

// ReviewNotes returns the value of the "review_notes" field in the mutation.
func (m *VolunteerApplicationMutation) ReviewNotes() (r string, exists bool) {
	v := m.review_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewNotes returns the old "review_notes" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldReviewNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewNotes: %w", err)
	}
	return oldValue.ReviewNotes, nil
}

// ClearReviewNotes clears the value of the "review_notes" field.
func (m *VolunteerApplicationMutation) ClearReviewNotes() {
	m.review_notes = nil
	m.clearedFields[volunteerapplication.FieldReviewNotes] = struct{}{}
}

// ReviewNotesCleared returns if the "review_notes" field was cleared in this mutation.
func (m *VolunteerApplicationMutation) ReviewNotesCleared() bool {
	_, ok := m.clearedFields[volunteerapplication.FieldReviewNotes]
	return ok
}

// ResetReviewNotes resets all changes to the "review_notes" field.
func (m *VolunteerApplicationMutation) ResetReviewNotes() {
	m.review_notes = nil
	delete(m.clearedFields, volunteerapplication.FieldReviewNotes)
}

// SetInterviewDate sets the "interview_date" field.
func (m *VolunteerApplicationMutation) SetInterviewDate(t time.Time) {
	m.interview_date = &t
}

// InterviewDate returns the value of the "interview_date" field in the mutation.
func (m *VolunteerApplicationMutation) InterviewDate() (r time.Time, exists bool) {
	v := m.interview_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInterviewDate returns the old "interview_date" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldInterviewDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterviewDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterviewDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterviewDate: %w", err)
	}
	return oldValue.InterviewDate, nil
}

// ClearInterviewDate clears the value of the "interview_date" field.
func (m *VolunteerApplicationMutation) ClearInterviewDate() {
	m.interview_date = nil
	m.clearedFields[volunteerapplication.FieldInterviewDate] = struct{}{}
}

// InterviewDateCleared returns if the "interview_date" field was cleared in this mutation.
func (m *VolunteerApplicationMutation) InterviewDateCleared() bool {
	_, ok := m.clearedFields[volunteerapplication.FieldInterviewDate]
	return ok
}

// ResetInterviewDate resets all changes to the "interview_date" field.
func (m *VolunteerApplicationMutation) ResetInterviewDate() {
	m.interview_date = nil
	delete(m.clearedFields, volunteerapplication.FieldInterviewDate)
}

// SetCreatedAt sets the "created_at" field.
func (m *VolunteerApplicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VolunteerApplicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VolunteerApplicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VolunteerApplicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VolunteerApplicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VolunteerApplication entity.
// If the VolunteerApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerApplicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VolunteerApplicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *VolunteerApplicationMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *VolunteerApplicationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VolunteerApplicationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *VolunteerApplicationMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VolunteerApplicationMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VolunteerApplicationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddInterestedOpportunityIDs adds the "interested_opportunities" edge to the VolunteerOpportunity entity by ids.
func (m *VolunteerApplicationMutation) AddInterestedOpportunityIDs(ids ...int) {
	if m.interested_opportunities == nil {
		m.interested_opportunities = make(map[int]struct{})
	}
	for i := range ids {
		m.interested_opportunities[ids[i]] = struct{}{}
	}
}

// ClearInterestedOpportunities clears the "interested_opportunities" edge to the VolunteerOpportunity entity.
func (m *VolunteerApplicationMutation) ClearInterestedOpportunities() {
	m.clearedinterested_opportunities = true
}

// InterestedOpportunitiesCleared reports if the "interested_opportunities" edge to the VolunteerOpportunity entity was cleared.
func (m *VolunteerApplicationMutation) InterestedOpportunitiesCleared() bool {
	return m.clearedinterested_opportunities
}

// RemoveInterestedOpportunityIDs removes the "interested_opportunities" edge to the VolunteerOpportunity entity by IDs.
func (m *VolunteerApplicationMutation) RemoveInterestedOpportunityIDs(ids ...int) {
	if m.removedinterested_opportunities == nil {
		m.removedinterested_opportunities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.interested_opportunities, ids[i])
		m.removedinterested_opportunities[ids[i]] = struct{}{}
	}
}

// RemovedInterestedOpportunities returns the removed IDs of the "interested_opportunities" edge to the VolunteerOpportunity entity.
func (m *VolunteerApplicationMutation) RemovedInterestedOpportunitiesIDs() (ids []int) {
	for id := range m.removedinterested_opportunities {
		ids = append(ids, id)
	}
	return
}

// InterestedOpportunitiesIDs returns the "interested_opportunities" edge IDs in the mutation.
func (m *VolunteerApplicationMutation) InterestedOpportunitiesIDs() (ids []int) {
	for id := range m.interested_opportunities {
		ids = append(ids, id)
	}
	return
}

// ResetInterestedOpportunities resets all changes to the "interested_opportunities" edge.
func (m *VolunteerApplicationMutation) ResetInterestedOpportunities() {
	m.interested_opportunities = nil
	m.clearedinterested_opportunities = false
	m.removedinterested_opportunities = nil
}

// Where appends a list predicates to the VolunteerApplicationMutation builder.
func (m *VolunteerApplicationMutation) Where(ps ...predicate.VolunteerApplication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VolunteerApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VolunteerApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VolunteerApplication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VolunteerApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VolunteerApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VolunteerApplication).
func (m *VolunteerApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VolunteerApplicationMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.status != nil {
		fields = append(fields, volunteerapplication.FieldStatus)
	}
	if m.motivation != nil {
		fields = append(fields, volunteerapplication.FieldMotivation)
	}
	if m.availability != nil {
		fields = append(fields, volunteerapplication.FieldAvailability)
	}
	if m.background_check != nil {
		fields = append(fields, volunteerapplication.FieldBackgroundCheck)
	}
	if m.background_check_date != nil {
		fields = append(fields, volunteerapplication.FieldBackgroundCheckDate)
	}
	if m.references != nil {
		fields = append(fields, volunteerapplication.FieldReferences)
	}
	if m.emergency_contact != nil {
		fields = append(fields, volunteerapplication.FieldEmergencyContact)
	}
	if m.reviewed_by != nil {
		fields = append(fields, volunteerapplication.FieldReviewedBy)
	}
	if m.reviewed_at != nil {
		fields = append(fields, volunteerapplication.FieldReviewedAt)
	}
	if m.review_notes != nil {
		fields = append(fields, volunteerapplication.FieldReviewNotes)
	}
	if m.interview_date != nil {
		fields = append(fields, volunteerapplication.FieldInterviewDate)
	}
	if m.created_at != nil {
		fields = append(fields, volunteerapplication.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, volunteerapplication.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VolunteerApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case volunteerapplication.FieldStatus:
		return m.Status()
	case volunteerapplication.FieldMotivation:
		return m.Motivation()
	case volunteerapplication.FieldAvailability:
		return m.Availability()
	case volunteerapplication.FieldBackgroundCheck:
		return m.BackgroundCheck()
	case volunteerapplication.FieldBackgroundCheckDate:
		return m.BackgroundCheckDate()
	case volunteerapplication.FieldReferences:
		return m.References()
	case volunteerapplication.FieldEmergencyContact:
		return m.EmergencyContact()
	case volunteerapplication.FieldReviewedBy:
		return m.ReviewedBy()
	case volunteerapplication.FieldReviewedAt:
		return m.ReviewedAt()
	case volunteerapplication.FieldReviewNotes:
		return m.ReviewNotes()
	case volunteerapplication.FieldInterviewDate:
		return m.InterviewDate()
	case volunteerapplication.FieldCreatedAt:
		return m.CreatedAt()
	case volunteerapplication.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VolunteerApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case volunteerapplication.FieldStatus:
		return m.OldStatus(ctx)
	case volunteerapplication.FieldMotivation:
		return m.OldMotivation(ctx)
	case volunteerapplication.FieldAvailability:
		return m.OldAvailability(ctx)
	case volunteerapplication.FieldBackgroundCheck:
		return m.OldBackgroundCheck(ctx)
	case volunteerapplication.FieldBackgroundCheckDate:
		return m.OldBackgroundCheckDate(ctx)
	case volunteerapplication.FieldReferences:
		return m.OldReferences(ctx)
	case volunteerapplication.FieldEmergencyContact:
		return m.OldEmergencyContact(ctx)
	case volunteerapplication.FieldReviewedBy:
		return m.OldReviewedBy(ctx)
	case volunteerapplication.FieldReviewedAt:
		return m.OldReviewedAt(ctx)
	case volunteerapplication.FieldReviewNotes:
		return m.OldReviewNotes(ctx)
	case volunteerapplication.FieldInterviewDate:
		return m.OldInterviewDate(ctx)
	case volunteerapplication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case volunteerapplication.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VolunteerApplication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VolunteerApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case volunteerapplication.FieldStatus:
		v, ok := value.(volunteerapplication.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case volunteerapplication.FieldMotivation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMotivation(v)
		return nil
	case volunteerapplication.FieldAvailability:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailability(v)
		return nil
	case volunteerapplication.FieldBackgroundCheck:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundCheck(v)
		return nil
	case volunteerapplication.FieldBackgroundCheckDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundCheckDate(v)
		return nil
	case volunteerapplication.FieldReferences:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferences(v)
		return nil
	case volunteerapplication.FieldEmergencyContact:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmergencyContact(v)
		return nil
	case volunteerapplication.FieldReviewedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedBy(v)
		return nil
	case volunteerapplication.FieldReviewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedAt(v)
		return nil
	case volunteerapplication.FieldReviewNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewNotes(v)
		return nil
	case volunteerapplication.FieldInterviewDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterviewDate(v)
		return nil
	case volunteerapplication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case volunteerapplication.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VolunteerApplication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VolunteerApplicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VolunteerApplicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VolunteerApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VolunteerApplication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VolunteerApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(volunteerapplication.FieldBackgroundCheckDate) {
		fields = append(fields, volunteerapplication.FieldBackgroundCheckDate)
	}
	if m.FieldCleared(volunteerapplication.FieldReferences) {
		fields = append(fields, volunteerapplication.FieldReferences)
	}
	if m.FieldCleared(volunteerapplication.FieldEmergencyContact) {
		fields = append(fields, volunteerapplication.FieldEmergencyContact)
	}
	if m.FieldCleared(volunteerapplication.FieldReviewedBy) {
		fields = append(fields, volunteerapplication.FieldReviewedBy)
	}
	if m.FieldCleared(volunteerapplication.FieldReviewedAt) {
		fields = append(fields, volunteerapplication.FieldReviewedAt)
	}
	if m.FieldCleared(volunteerapplication.FieldReviewNotes) {
		fields = append(fields, volunteerapplication.FieldReviewNotes)
	}
	if m.FieldCleared(volunteerapplication.FieldInterviewDate) {
		fields = append(fields, volunteerapplication.FieldInterviewDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VolunteerApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VolunteerApplicationMutation) ClearField(name string) error {
	switch name {
	case volunteerapplication.FieldBackgroundCheckDate:
		m.ClearBackgroundCheckDate()
		return nil
	case volunteerapplication.FieldReferences:
		m.ClearReferences()
		return nil
	case volunteerapplication.FieldEmergencyContact:
		m.ClearEmergencyContact()
		return nil
	case volunteerapplication.FieldReviewedBy:
		m.ClearReviewedBy()
		return nil
	case volunteerapplication.FieldReviewedAt:
		m.ClearReviewedAt()
		return nil
	case volunteerapplication.FieldReviewNotes:
		m.ClearReviewNotes()
		return nil
	case volunteerapplication.FieldInterviewDate:
		m.ClearInterviewDate()
		return nil
	}
	return fmt.Errorf("unknown VolunteerApplication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VolunteerApplicationMutation) ResetField(name string) error {
	switch name {
	case volunteerapplication.FieldStatus:
		m.ResetStatus()
		return nil
	case volunteerapplication.FieldMotivation:
		m.ResetMotivation()
		return nil
	case volunteerapplication.FieldAvailability:
		m.ResetAvailability()
		return nil
	case volunteerapplication.FieldBackgroundCheck:
		m.ResetBackgroundCheck()
		return nil
	case volunteerapplication.FieldBackgroundCheckDate:
		m.ResetBackgroundCheckDate()
		return nil
	case volunteerapplication.FieldReferences:
		m.ResetReferences()
		return nil
	case volunteerapplication.FieldEmergencyContact:
		m.ResetEmergencyContact()
		return nil
	case volunteerapplication.FieldReviewedBy:
		m.ResetReviewedBy()
		return nil
	case volunteerapplication.FieldReviewedAt:
		m.ResetReviewedAt()
		return nil
	case volunteerapplication.FieldReviewNotes:
		m.ResetReviewNotes()
		return nil
	case volunteerapplication.FieldInterviewDate:
		m.ResetInterviewDate()
		return nil
	case volunteerapplication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case volunteerapplication.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown VolunteerApplication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VolunteerApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, volunteerapplication.EdgeUser)
	}
	if m.interested_opportunities != nil {
		edges = append(edges, volunteerapplication.EdgeInterestedOpportunities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VolunteerApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case volunteerapplication.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case volunteerapplication.EdgeInterestedOpportunities:
		ids := make([]ent.Value, 0, len(m.interested_opportunities))
		for id := range m.interested_opportunities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VolunteerApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinterested_opportunities != nil {
		edges = append(edges, volunteerapplication.EdgeInterestedOpportunities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VolunteerApplicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case volunteerapplication.EdgeInterestedOpportunities:
		ids := make([]ent.Value, 0, len(m.removedinterested_opportunities))
		for id := range m.removedinterested_opportunities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VolunteerApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, volunteerapplication.EdgeUser)
	}
	if m.clearedinterested_opportunities {
		edges = append(edges, volunteerapplication.EdgeInterestedOpportunities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VolunteerApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case volunteerapplication.EdgeUser:
		return m.cleareduser
	case volunteerapplication.EdgeInterestedOpportunities:
		return m.clearedinterested_opportunities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VolunteerApplicationMutation) ClearEdge(name string) error {
	switch name {
	case volunteerapplication.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown VolunteerApplication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VolunteerApplicationMutation) ResetEdge(name string) error {
	switch name {
	case volunteerapplication.EdgeUser:
		m.ResetUser()
		return nil
	case volunteerapplication.EdgeInterestedOpportunities:
		m.ResetInterestedOpportunities()
		return nil
	}
	return fmt.Errorf("unknown VolunteerApplication edge %s", name)
}

// VolunteerAssignmentMutation represents an operation that mutates the VolunteerAssignment nodes in the graph.
type VolunteerAssignmentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	status             *string
	start_date         *time.Time
	end_date           *time.Time
	hours_completed    *int
	addhours_completed *int
	hours_committed    *int
	addhours_committed *int
	feedback           *string
	rating             *int
	addrating          *int
	completion_notes   *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	opportunity        *int
	clearedopportunity bool
	volunteer          *int
	clearedvolunteer   bool
	done               bool
	oldValue           func(context.Context) (*VolunteerAssignment, error)
	predicates         []predicate.VolunteerAssignment
}

var _ ent.Mutation = (*VolunteerAssignmentMutation)(nil)

// volunteerassignmentOption allows management of the mutation configuration using functional options.
type volunteerassignmentOption func(*VolunteerAssignmentMutation)

// newVolunteerAssignmentMutation creates new mutation for the VolunteerAssignment entity.
func newVolunteerAssignmentMutation(c config, op Op, opts ...volunteerassignmentOption) *VolunteerAssignmentMutation {
	m := &VolunteerAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeVolunteerAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVolunteerAssignmentID sets the ID field of the mutation.
func withVolunteerAssignmentID(id int) volunteerassignmentOption {
	return func(m *VolunteerAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *VolunteerAssignment
		)
		m.oldValue = func(ctx context.Context) (*VolunteerAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VolunteerAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVolunteerAssignment sets the old VolunteerAssignment of the mutation.
func withVolunteerAssignment(node *VolunteerAssignment) volunteerassignmentOption {
	return func(m *VolunteerAssignmentMutation) {
		m.oldValue = func(context.Context) (*VolunteerAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VolunteerAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VolunteerAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VolunteerAssignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VolunteerAssignmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VolunteerAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *VolunteerAssignmentMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *VolunteerAssignmentMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the VolunteerAssignment entity.
// If the VolunteerAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerAssignmentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *VolunteerAssignmentMutation) ResetStatus() {
	m.status = nil
}

// SetStartDate sets the "start_date" field.
func (m *VolunteerAssignmentMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *VolunteerAssignmentMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the VolunteerAssignment entity.
// If the VolunteerAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerAssignmentMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *VolunteerAssignmentMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *VolunteerAssignmentMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *VolunteerAssignmentMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the VolunteerAssignment entity.
// If the VolunteerAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerAssignmentMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *VolunteerAssignmentMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[volunteerassignment.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *VolunteerAssignmentMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[volunteerassignment.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *VolunteerAssignmentMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, volunteerassignment.FieldEndDate)
}

// SetHoursCompleted sets the "hours_completed" field.
func (m *VolunteerAssignmentMutation) SetHoursCompleted(i int) {
	m.hours_completed = &i
	m.addhours_completed = nil
}

// HoursCompleted returns the value of the "hours_completed" field in the mutation.
func (m *VolunteerAssignmentMutation) HoursCompleted() (r int, exists bool) {
	v := m.hours_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldHoursCompleted returns the old "hours_completed" field's value of the VolunteerAssignment entity.
// If the VolunteerAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerAssignmentMutation) OldHoursCompleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHoursCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHoursCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHoursCompleted: %w", err)
	}
	return oldValue.HoursCompleted, nil
}

// AddHoursCompleted adds i to the "hours_completed" field.
func (m *VolunteerAssignmentMutation) AddHoursCompleted(i int) {
	if m.addhours_completed != nil {
		*m.addhours_completed += i
	} else {
		m.addhours_completed = &i
	}
}

// AddedHoursCompleted returns the value that was added to the "hours_completed" field in this mutation.
func (m *VolunteerAssignmentMutation) AddedHoursCompleted() (r int, exists bool) {
	v := m.addhours_completed
	if v == nil {
		return
	}
	return *v, true
}

// ResetHoursCompleted resets all changes to the "hours_completed" field.
func (m *VolunteerAssignmentMutation) ResetHoursCompleted() {
	m.hours_completed = nil
	m.addhours_completed = nil
}

// SetHoursCommitted sets the "hours_committed" field.
func (m *VolunteerAssignmentMutation) SetHoursCommitted(i int) {
	m.hours_committed = &i
	m.addhours_committed = nil
}

// HoursCommitted returns the value of the "hours_committed" field in the mutation.
func (m *VolunteerAssignmentMutation) HoursCommitted() (r int, exists bool) {
	v := m.hours_committed
	if v == nil {
		return
	}
	return *v, true
}

// OldHoursCommitted returns the old "hours_committed" field's value of the VolunteerAssignment entity.
// If the VolunteerAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerAssignmentMutation) OldHoursCommitted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHoursCommitted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHoursCommitted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHoursCommitted: %w", err)
	}
	return oldValue.HoursCommitted, nil
}

// AddHoursCommitted adds i to the "hours_committed" field.
func (m *VolunteerAssignmentMutation) AddHoursCommitted(i int) {
	if m.addhours_committed != nil {
		*m.addhours_committed += i
	} else {
		m.addhours_committed = &i
	}
}

// AddedHoursCommitted returns the value that was added to the "hours_committed" field in this mutation.
func (m *VolunteerAssignmentMutation) AddedHoursCommitted() (r int, exists bool) {
	v := m.addhours_committed
	if v == nil {
		return
	}
	return *v, true
}

// ResetHoursCommitted resets all changes to the "hours_committed" field.
func (m *VolunteerAssignmentMutation) ResetHoursCommitted() {
	m.hours_committed = nil
	m.addhours_committed = nil
}

// SetFeedback sets the "feedback" field.
func (m *VolunteerAssignmentMutation) SetFeedback(s string) {
	m.feedback = &s
}

// Feedback returns the value of the "feedback" field in the mutation.
func (m *VolunteerAssignmentMutation) Feedback() (r string, exists bool) {
	v := m.feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedback returns the old "feedback" field's value of the VolunteerAssignment entity.
// If the VolunteerAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerAssignmentMutation) OldFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedback: %w", err)
	}
	return oldValue.Feedback, nil
}

// ClearFeedback clears the value of the "feedback" field.
func (m *VolunteerAssignmentMutation) ClearFeedback() {
	m.feedback = nil
	m.clearedFields[volunteerassignment.FieldFeedback] = struct{}{}
}

// FeedbackCleared returns if the "feedback" field was cleared in this mutation.
func (m *VolunteerAssignmentMutation) FeedbackCleared() bool {
	_, ok := m.clearedFields[volunteerassignment.FieldFeedback]
	return ok
}

// ResetFeedback resets all changes to the "feedback" field.
func (m *VolunteerAssignmentMutation) ResetFeedback() {
	m.feedback = nil
	delete(m.clearedFields, volunteerassignment.FieldFeedback)
}

// SetRating sets the "rating" field.
func (m *VolunteerAssignmentMutation) SetRating(i int) {
	m.rating = &i
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *VolunteerAssignmentMutation) Rating() (r int, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the VolunteerAssignment entity.
// If the VolunteerAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerAssignmentMutation) OldRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds i to the "rating" field.
func (m *VolunteerAssignmentMutation) AddRating(i int) {
	if m.addrating != nil {
		*m.addrating += i
	} else {
		m.addrating = &i
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *VolunteerAssignmentMutation) AddedRating() (r int, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ClearRating clears the value of the "rating" field.
func (m *VolunteerAssignmentMutation) ClearRating() {
	m.rating = nil
	m.addrating = nil
	m.clearedFields[volunteerassignment.FieldRating] = struct{}{}
}

// RatingCleared returns if the "rating" field was cleared in this mutation.
func (m *VolunteerAssignmentMutation) RatingCleared() bool {
	_, ok := m.clearedFields[volunteerassignment.FieldRating]
	return ok
}

// ResetRating resets all changes to the "rating" field.
func (m *VolunteerAssignmentMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
	delete(m.clearedFields, volunteerassignment.FieldRating)
}

// SetCompletionNotes sets the "completion_notes" field.
func (m *VolunteerAssignmentMutation) SetCompletionNotes(s string) {
	m.completion_notes = &s
}

// CompletionNotes returns the value of the "completion_notes" field in the mutation.
func (m *VolunteerAssignmentMutation) CompletionNotes() (r string, exists bool) {
	v := m.completion_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionNotes returns the old "completion_notes" field's value of the VolunteerAssignment entity.
// If the VolunteerAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerAssignmentMutation) OldCompletionNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionNotes: %w", err)
	}
	return oldValue.CompletionNotes, nil
}

// ClearCompletionNotes clears the value of the "completion_notes" field.
func (m *VolunteerAssignmentMutation) ClearCompletionNotes() {
	m.completion_notes = nil
	m.clearedFields[volunteerassignment.FieldCompletionNotes] = struct{}{}
}

// CompletionNotesCleared returns if the "completion_notes" field was cleared in this mutation.
func (m *VolunteerAssignmentMutation) CompletionNotesCleared() bool {
	_, ok := m.clearedFields[volunteerassignment.FieldCompletionNotes]
	return ok
}

// ResetCompletionNotes resets all changes to the "completion_notes" field.
func (m *VolunteerAssignmentMutation) ResetCompletionNotes() {
	m.completion_notes = nil
	delete(m.clearedFields, volunteerassignment.FieldCompletionNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *VolunteerAssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VolunteerAssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VolunteerAssignment entity.
// If the VolunteerAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerAssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VolunteerAssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VolunteerAssignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VolunteerAssignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VolunteerAssignment entity.
// If the VolunteerAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerAssignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VolunteerAssignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOpportunityID sets the "opportunity" edge to the VolunteerOpportunity entity by id.
func (m *VolunteerAssignmentMutation) SetOpportunityID(id int) {
	m.opportunity = &id
}

// ClearOpportunity clears the "opportunity" edge to the VolunteerOpportunity entity.
func (m *VolunteerAssignmentMutation) ClearOpportunity() {
	m.clearedopportunity = true
}

// OpportunityCleared reports if the "opportunity" edge to the VolunteerOpportunity entity was cleared.
func (m *VolunteerAssignmentMutation) OpportunityCleared() bool {
	return m.clearedopportunity
}

// OpportunityID returns the "opportunity" edge ID in the mutation.
func (m *VolunteerAssignmentMutation) OpportunityID() (id int, exists bool) {
	if m.opportunity != nil {
		return *m.opportunity, true
	}
	return
}

// OpportunityIDs returns the "opportunity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OpportunityID instead. It exists only for internal usage by the builders.
func (m *VolunteerAssignmentMutation) OpportunityIDs() (ids []int) {
	if id := m.opportunity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOpportunity resets all changes to the "opportunity" edge.
func (m *VolunteerAssignmentMutation) ResetOpportunity() {
	m.opportunity = nil
	m.clearedopportunity = false
}

// SetVolunteerID sets the "volunteer" edge to the UserProfile entity by id.
func (m *VolunteerAssignmentMutation) SetVolunteerID(id int) {
	m.volunteer = &id
}

// ClearVolunteer clears the "volunteer" edge to the UserProfile entity.
func (m *VolunteerAssignmentMutation) ClearVolunteer() {
	m.clearedvolunteer = true
}

// VolunteerCleared reports if the "volunteer" edge to the UserProfile entity was cleared.
func (m *VolunteerAssignmentMutation) VolunteerCleared() bool {
	return m.clearedvolunteer
}

// VolunteerID returns the "volunteer" edge ID in the mutation.
func (m *VolunteerAssignmentMutation) VolunteerID() (id int, exists bool) {
	if m.volunteer != nil {
		return *m.volunteer, true
	}
	return
}

// VolunteerIDs returns the "volunteer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VolunteerID instead. It exists only for internal usage by the builders.
func (m *VolunteerAssignmentMutation) VolunteerIDs() (ids []int) {
	if id := m.volunteer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVolunteer resets all changes to the "volunteer" edge.
func (m *VolunteerAssignmentMutation) ResetVolunteer() {
	m.volunteer = nil
	m.clearedvolunteer = false
}

// Where appends a list predicates to the VolunteerAssignmentMutation builder.
func (m *VolunteerAssignmentMutation) Where(ps ...predicate.VolunteerAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VolunteerAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VolunteerAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VolunteerAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VolunteerAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VolunteerAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VolunteerAssignment).
func (m *VolunteerAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VolunteerAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.status != nil {
		fields = append(fields, volunteerassignment.FieldStatus)
	}
	if m.start_date != nil {
		fields = append(fields, volunteerassignment.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, volunteerassignment.FieldEndDate)
	}
	if m.hours_completed != nil {
		fields = append(fields, volunteerassignment.FieldHoursCompleted)
	}
	if m.hours_committed != nil {
		fields = append(fields, volunteerassignment.FieldHoursCommitted)
	}
	if m.feedback != nil {
		fields = append(fields, volunteerassignment.FieldFeedback)
	}
	if m.rating != nil {
		fields = append(fields, volunteerassignment.FieldRating)
	}
	if m.completion_notes != nil {
		fields = append(fields, volunteerassignment.FieldCompletionNotes)
	}
	if m.created_at != nil {
		fields = append(fields, volunteerassignment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, volunteerassignment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VolunteerAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case volunteerassignment.FieldStatus:
		return m.Status()
	case volunteerassignment.FieldStartDate:
		return m.StartDate()
	case volunteerassignment.FieldEndDate:
		return m.EndDate()
	case volunteerassignment.FieldHoursCompleted:
		return m.HoursCompleted()
	case volunteerassignment.FieldHoursCommitted:
		return m.HoursCommitted()
	case volunteerassignment.FieldFeedback:
		return m.Feedback()
	case volunteerassignment.FieldRating:
		return m.Rating()
	case volunteerassignment.FieldCompletionNotes:
		return m.CompletionNotes()
	case volunteerassignment.FieldCreatedAt:
		return m.CreatedAt()
	case volunteerassignment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VolunteerAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case volunteerassignment.FieldStatus:
		return m.OldStatus(ctx)
	case volunteerassignment.FieldStartDate:
		return m.OldStartDate(ctx)
	case volunteerassignment.FieldEndDate:
		return m.OldEndDate(ctx)
	case volunteerassignment.FieldHoursCompleted:
		return m.OldHoursCompleted(ctx)
	case volunteerassignment.FieldHoursCommitted:
		return m.OldHoursCommitted(ctx)
	case volunteerassignment.FieldFeedback:
		return m.OldFeedback(ctx)
	case volunteerassignment.FieldRating:
		return m.OldRating(ctx)
	case volunteerassignment.FieldCompletionNotes:
		return m.OldCompletionNotes(ctx)
	case volunteerassignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case volunteerassignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VolunteerAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VolunteerAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case volunteerassignment.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case volunteerassignment.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case volunteerassignment.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case volunteerassignment.FieldHoursCompleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHoursCompleted(v)
		return nil
	case volunteerassignment.FieldHoursCommitted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHoursCommitted(v)
		return nil
	case volunteerassignment.FieldFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedback(v)
		return nil
	case volunteerassignment.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case volunteerassignment.FieldCompletionNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionNotes(v)
		return nil
	case volunteerassignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case volunteerassignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VolunteerAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VolunteerAssignmentMutation) AddedFields() []string {
	var fields []string
	if m.addhours_completed != nil {
		fields = append(fields, volunteerassignment.FieldHoursCompleted)
	}
	if m.addhours_committed != nil {
		fields = append(fields, volunteerassignment.FieldHoursCommitted)
	}
	if m.addrating != nil {
		fields = append(fields, volunteerassignment.FieldRating)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VolunteerAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case volunteerassignment.FieldHoursCompleted:
		return m.AddedHoursCompleted()
	case volunteerassignment.FieldHoursCommitted:
		return m.AddedHoursCommitted()
	case volunteerassignment.FieldRating:
		return m.AddedRating()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VolunteerAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case volunteerassignment.FieldHoursCompleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHoursCompleted(v)
		return nil
	case volunteerassignment.FieldHoursCommitted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHoursCommitted(v)
		return nil
	case volunteerassignment.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	}
	return fmt.Errorf("unknown VolunteerAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VolunteerAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(volunteerassignment.FieldEndDate) {
		fields = append(fields, volunteerassignment.FieldEndDate)
	}
	if m.FieldCleared(volunteerassignment.FieldFeedback) {
		fields = append(fields, volunteerassignment.FieldFeedback)
	}
	if m.FieldCleared(volunteerassignment.FieldRating) {
		fields = append(fields, volunteerassignment.FieldRating)
	}
	if m.FieldCleared(volunteerassignment.FieldCompletionNotes) {
		fields = append(fields, volunteerassignment.FieldCompletionNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VolunteerAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VolunteerAssignmentMutation) ClearField(name string) error {
	switch name {
	case volunteerassignment.FieldEndDate:
		m.ClearEndDate()
		return nil
	case volunteerassignment.FieldFeedback:
		m.ClearFeedback()
		return nil
	case volunteerassignment.FieldRating:
		m.ClearRating()
		return nil
	case volunteerassignment.FieldCompletionNotes:
		m.ClearCompletionNotes()
		return nil
	}
	return fmt.Errorf("unknown VolunteerAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VolunteerAssignmentMutation) ResetField(name string) error {
	switch name {
	case volunteerassignment.FieldStatus:
		m.ResetStatus()
		return nil
	case volunteerassignment.FieldStartDate:
		m.ResetStartDate()
		return nil
	case volunteerassignment.FieldEndDate:
		m.ResetEndDate()
		return nil
	case volunteerassignment.FieldHoursCompleted:
		m.ResetHoursCompleted()
		return nil
	case volunteerassignment.FieldHoursCommitted:
		m.ResetHoursCommitted()
		return nil
	case volunteerassignment.FieldFeedback:
		m.ResetFeedback()
		return nil
	case volunteerassignment.FieldRating:
		m.ResetRating()
		return nil
	case volunteerassignment.FieldCompletionNotes:
		m.ResetCompletionNotes()
		return nil
	case volunteerassignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case volunteerassignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown VolunteerAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VolunteerAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.opportunity != nil {
		edges = append(edges, volunteerassignment.EdgeOpportunity)
	}
	if m.volunteer != nil {
		edges = append(edges, volunteerassignment.EdgeVolunteer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VolunteerAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case volunteerassignment.EdgeOpportunity:
		if id := m.opportunity; id != nil {
			return []ent.Value{*id}
		}
	case volunteerassignment.EdgeVolunteer:
		if id := m.volunteer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VolunteerAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VolunteerAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VolunteerAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedopportunity {
		edges = append(edges, volunteerassignment.EdgeOpportunity)
	}
	if m.clearedvolunteer {
		edges = append(edges, volunteerassignment.EdgeVolunteer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VolunteerAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case volunteerassignment.EdgeOpportunity:
		return m.clearedopportunity
	case volunteerassignment.EdgeVolunteer:
		return m.clearedvolunteer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VolunteerAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case volunteerassignment.EdgeOpportunity:
		m.ClearOpportunity()
		return nil
	case volunteerassignment.EdgeVolunteer:
		m.ClearVolunteer()
		return nil
	}
	return fmt.Errorf("unknown VolunteerAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VolunteerAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case volunteerassignment.EdgeOpportunity:
		m.ResetOpportunity()
		return nil
	case volunteerassignment.EdgeVolunteer:
		m.ResetVolunteer()
		return nil
	}
	return fmt.Errorf("unknown VolunteerAssignment edge %s", name)
}

// VolunteerOpportunityMutation represents an operation that mutates the VolunteerOpportunity nodes in the graph.
type VolunteerOpportunityMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	title                        *map[string]string
	description                  *map[string]string
	time_commitment              *string
	location                     *map[string]string
	is_active                    *bool
	max_volunteers               *int
	addmax_volunteers            *int
	current_volunteers           *int
	addcurrent_volunteers        *int
	start_date                   *time.Time
	end_date                     *time.Time
	application_deadline         *time.Time
	required_skills              *[]string
	appendrequired_skills        []string
	preferred_skills             *[]string
	appendpreferred_skills       []string
	tags                         *[]string
	appendtags                   []string
	is_urgent                    *bool
	is_recurring                 *bool
	created_at                   *time.Time
	updated_at                   *time.Time
	clearedFields                map[string]struct{}
	program                      *int
	clearedprogram               bool
	interested_volunteers        map[int]struct{}
	removedinterested_volunteers map[int]struct{}
	clearedinterested_volunteers bool
	assignments                  map[int]struct{}
	removedassignments           map[int]struct{}
	clearedassignments           bool
	done                         bool
	oldValue                     func(context.Context) (*VolunteerOpportunity, error)
	predicates                   []predicate.VolunteerOpportunity
}

var _ ent.Mutation = (*VolunteerOpportunityMutation)(nil)

// volunteeropportunityOption allows management of the mutation configuration using functional options.
type volunteeropportunityOption func(*VolunteerOpportunityMutation)

// newVolunteerOpportunityMutation creates new mutation for the VolunteerOpportunity entity.
func newVolunteerOpportunityMutation(c config, op Op, opts ...volunteeropportunityOption) *VolunteerOpportunityMutation {
	m := &VolunteerOpportunityMutation{
		config:        c,
		op:            op,
		typ:           TypeVolunteerOpportunity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVolunteerOpportunityID sets the ID field of the mutation.
func withVolunteerOpportunityID(id int) volunteeropportunityOption {
	return func(m *VolunteerOpportunityMutation) {
		var (
			err   error
			once  sync.Once
			value *VolunteerOpportunity
		)
		m.oldValue = func(ctx context.Context) (*VolunteerOpportunity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VolunteerOpportunity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVolunteerOpportunity sets the old VolunteerOpportunity of the mutation.
func withVolunteerOpportunity(node *VolunteerOpportunity) volunteeropportunityOption {
	return func(m *VolunteerOpportunityMutation) {
		m.oldValue = func(context.Context) (*VolunteerOpportunity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VolunteerOpportunityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VolunteerOpportunityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VolunteerOpportunityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VolunteerOpportunityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VolunteerOpportunity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *VolunteerOpportunityMutation) SetTitle(value map[string]string) {
	m.title = &value
}

// Title returns the value of the "title" field in the mutation.
func (m *VolunteerOpportunityMutation) Title() (r map[string]string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldTitle(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *VolunteerOpportunityMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *VolunteerOpportunityMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *VolunteerOpportunityMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *VolunteerOpportunityMutation) ResetDescription() {
	m.description = nil
}

// SetTimeCommitment sets the "time_commitment" field.
func (m *VolunteerOpportunityMutation) SetTimeCommitment(s string) {
	m.time_commitment = &s
}

// TimeCommitment returns the value of the "time_commitment" field in the mutation.
func (m *VolunteerOpportunityMutation) TimeCommitment() (r string, exists bool) {
	v := m.time_commitment
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeCommitment returns the old "time_commitment" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldTimeCommitment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeCommitment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeCommitment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeCommitment: %w", err)
	}
	return oldValue.TimeCommitment, nil
}

// ResetTimeCommitment resets all changes to the "time_commitment" field.
func (m *VolunteerOpportunityMutation) ResetTimeCommitment() {
	m.time_commitment = nil
}

// SetLocation sets the "location" field.
func (m *VolunteerOpportunityMutation) SetLocation(value map[string]string) {
	m.location = &value
}

// Location returns the value of the "location" field in the mutation.
func (m *VolunteerOpportunityMutation) Location() (r map[string]string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldLocation(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *VolunteerOpportunityMutation) ResetLocation() {
	m.location = nil
}

// SetIsActive sets the "is_active" field.
func (m *VolunteerOpportunityMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *VolunteerOpportunityMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *VolunteerOpportunityMutation) ResetIsActive() {
	m.is_active = nil
}

// SetMaxVolunteers sets the "max_volunteers" field.
func (m *VolunteerOpportunityMutation) SetMaxVolunteers(i int) {
	m.max_volunteers = &i
	m.addmax_volunteers = nil
}

// MaxVolunteers returns the value of the "max_volunteers" field in the mutation.
func (m *VolunteerOpportunityMutation) MaxVolunteers() (r int, exists bool) {
	v := m.max_volunteers
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxVolunteers returns the old "max_volunteers" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldMaxVolunteers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxVolunteers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxVolunteers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxVolunteers: %w", err)
	}
	return oldValue.MaxVolunteers, nil
}

// AddMaxVolunteers adds i to the "max_volunteers" field.
func (m *VolunteerOpportunityMutation) AddMaxVolunteers(i int) {
	if m.addmax_volunteers != nil {
		*m.addmax_volunteers += i
	} else {
		m.addmax_volunteers = &i
	}
}

// AddedMaxVolunteers returns the value that was added to the "max_volunteers" field in this mutation.
func (m *VolunteerOpportunityMutation) AddedMaxVolunteers() (r int, exists bool) {
	v := m.addmax_volunteers
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxVolunteers clears the value of the "max_volunteers" field.
func (m *VolunteerOpportunityMutation) ClearMaxVolunteers() {
	m.max_volunteers = nil
	m.addmax_volunteers = nil
	m.clearedFields[volunteeropportunity.FieldMaxVolunteers] = struct{}{}
}

// MaxVolunteersCleared returns if the "max_volunteers" field was cleared in this mutation.
func (m *VolunteerOpportunityMutation) MaxVolunteersCleared() bool {
	_, ok := m.clearedFields[volunteeropportunity.FieldMaxVolunteers]
	return ok
}

// ResetMaxVolunteers resets all changes to the "max_volunteers" field.
func (m *VolunteerOpportunityMutation) ResetMaxVolunteers() {
	m.max_volunteers = nil
	m.addmax_volunteers = nil
	delete(m.clearedFields, volunteeropportunity.FieldMaxVolunteers)
}

// SetCurrentVolunteers sets the "current_volunteers" field.
func (m *VolunteerOpportunityMutation) SetCurrentVolunteers(i int) {
	m.current_volunteers = &i
	m.addcurrent_volunteers = nil
}

// CurrentVolunteers returns the value of the "current_volunteers" field in the mutation.
func (m *VolunteerOpportunityMutation) CurrentVolunteers() (r int, exists bool) {
	v := m.current_volunteers
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentVolunteers returns the old "current_volunteers" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldCurrentVolunteers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentVolunteers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentVolunteers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentVolunteers: %w", err)
	}
	return oldValue.CurrentVolunteers, nil
}

// AddCurrentVolunteers adds i to the "current_volunteers" field.
func (m *VolunteerOpportunityMutation) AddCurrentVolunteers(i int) {
	if m.addcurrent_volunteers != nil {
		*m.addcurrent_volunteers += i
	} else {
		m.addcurrent_volunteers = &i
	}
}

// AddedCurrentVolunteers returns the value that was added to the "current_volunteers" field in this mutation.
func (m *VolunteerOpportunityMutation) AddedCurrentVolunteers() (r int, exists bool) {
	v := m.addcurrent_volunteers
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentVolunteers resets all changes to the "current_volunteers" field.
func (m *VolunteerOpportunityMutation) ResetCurrentVolunteers() {
	m.current_volunteers = nil
	m.addcurrent_volunteers = nil
}

// SetStartDate sets the "start_date" field.
func (m *VolunteerOpportunityMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *VolunteerOpportunityMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *VolunteerOpportunityMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[volunteeropportunity.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *VolunteerOpportunityMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[volunteeropportunity.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *VolunteerOpportunityMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, volunteeropportunity.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *VolunteerOpportunityMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *VolunteerOpportunityMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *VolunteerOpportunityMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[volunteeropportunity.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *VolunteerOpportunityMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[volunteeropportunity.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *VolunteerOpportunityMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, volunteeropportunity.FieldEndDate)
}

// SetApplicationDeadline sets the "application_deadline" field.
func (m *VolunteerOpportunityMutation) SetApplicationDeadline(t time.Time) {
	m.application_deadline = &t
}

// ApplicationDeadline returns the value of the "application_deadline" field in the mutation.
func (m *VolunteerOpportunityMutation) ApplicationDeadline() (r time.Time, exists bool) {
	v := m.application_deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationDeadline returns the old "application_deadline" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldApplicationDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationDeadline: %w", err)
	}
	return oldValue.ApplicationDeadline, nil
}

// ClearApplicationDeadline clears the value of the "application_deadline" field.
func (m *VolunteerOpportunityMutation) ClearApplicationDeadline() {
	m.application_deadline = nil
	m.clearedFields[volunteeropportunity.FieldApplicationDeadline] = struct{}{}
}

// ApplicationDeadlineCleared returns if the "application_deadline" field was cleared in this mutation.
func (m *VolunteerOpportunityMutation) ApplicationDeadlineCleared() bool {
	_, ok := m.clearedFields[volunteeropportunity.FieldApplicationDeadline]
	return ok
}

// ResetApplicationDeadline resets all changes to the "application_deadline" field.
func (m *VolunteerOpportunityMutation) ResetApplicationDeadline() {
	m.application_deadline = nil
	delete(m.clearedFields, volunteeropportunity.FieldApplicationDeadline)
}

// SetRequiredSkills sets the "required_skills" field.
func (m *VolunteerOpportunityMutation) SetRequiredSkills(s []string) {
	m.required_skills = &s
	m.appendrequired_skills = nil
}

// RequiredSkills returns the value of the "required_skills" field in the mutation.
func (m *VolunteerOpportunityMutation) RequiredSkills() (r []string, exists bool) {
	v := m.required_skills
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredSkills returns the old "required_skills" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldRequiredSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredSkills: %w", err)
	}
	return oldValue.RequiredSkills, nil
}

// AppendRequiredSkills adds s to the "required_skills" field.
func (m *VolunteerOpportunityMutation) AppendRequiredSkills(s []string) {
	m.appendrequired_skills = append(m.appendrequired_skills, s...)
}

// AppendedRequiredSkills returns the list of values that were appended to the "required_skills" field in this mutation.
func (m *VolunteerOpportunityMutation) AppendedRequiredSkills() ([]string, bool) {
	if len(m.appendrequired_skills) == 0 {
		return nil, false
	}
	return m.appendrequired_skills, true
}

// ResetRequiredSkills resets all changes to the "required_skills" field.
func (m *VolunteerOpportunityMutation) ResetRequiredSkills() {
	m.required_skills = nil
	m.appendrequired_skills = nil
}

// SetPreferredSkills sets the "preferred_skills" field.
func (m *VolunteerOpportunityMutation) SetPreferredSkills(s []string) {
	m.preferred_skills = &s
	m.appendpreferred_skills = nil
}

// PreferredSkills returns the value of the "preferred_skills" field in the mutation.
func (m *VolunteerOpportunityMutation) PreferredSkills() (r []string, exists bool) {
	v := m.preferred_skills
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferredSkills returns the old "preferred_skills" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldPreferredSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferredSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferredSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferredSkills: %w", err)
	}
	return oldValue.PreferredSkills, nil
}

// AppendPreferredSkills adds s to the "preferred_skills" field.
func (m *VolunteerOpportunityMutation) AppendPreferredSkills(s []string) {
	m.appendpreferred_skills = append(m.appendpreferred_skills, s...)
}

// AppendedPreferredSkills returns the list of values that were appended to the "preferred_skills" field in this mutation.
func (m *VolunteerOpportunityMutation) AppendedPreferredSkills() ([]string, bool) {
	if len(m.appendpreferred_skills) == 0 {
		return nil, false
	}
	return m.appendpreferred_skills, true
}

// ResetPreferredSkills resets all changes to the "preferred_skills" field.
func (m *VolunteerOpportunityMutation) ResetPreferredSkills() {
	m.preferred_skills = nil
	m.appendpreferred_skills = nil
}

// SetTags sets the "tags" field.
func (m *VolunteerOpportunityMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *VolunteerOpportunityMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *VolunteerOpportunityMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *VolunteerOpportunityMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *VolunteerOpportunityMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetIsUrgent sets the "is_urgent" field.
func (m *VolunteerOpportunityMutation) SetIsUrgent(b bool) {
	m.is_urgent = &b
}

// IsUrgent returns the value of the "is_urgent" field in the mutation.
func (m *VolunteerOpportunityMutation) IsUrgent() (r bool, exists bool) {
	v := m.is_urgent
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUrgent returns the old "is_urgent" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldIsUrgent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUrgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUrgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUrgent: %w", err)
	}
	return oldValue.IsUrgent, nil
}

// ResetIsUrgent resets all changes to the "is_urgent" field.
func (m *VolunteerOpportunityMutation) ResetIsUrgent() {
	m.is_urgent = nil
}

// SetIsRecurring sets the "is_recurring" field.
func (m *VolunteerOpportunityMutation) SetIsRecurring(b bool) {
	m.is_recurring = &b
}

// IsRecurring returns the value of the "is_recurring" field in the mutation.
func (m *VolunteerOpportunityMutation) IsRecurring() (r bool, exists bool) {
	v := m.is_recurring
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRecurring returns the old "is_recurring" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldIsRecurring(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRecurring is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRecurring requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRecurring: %w", err)
	}
	return oldValue.IsRecurring, nil
}

// ResetIsRecurring resets all changes to the "is_recurring" field.
func (m *VolunteerOpportunityMutation) ResetIsRecurring() {
	m.is_recurring = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VolunteerOpportunityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VolunteerOpportunityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VolunteerOpportunityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VolunteerOpportunityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VolunteerOpportunityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VolunteerOpportunity entity.
// If the VolunteerOpportunity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VolunteerOpportunityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VolunteerOpportunityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProgramID sets the "program" edge to the Program entity by id.
func (m *VolunteerOpportunityMutation) SetProgramID(id int) {
	m.program = &id
}

// ClearProgram clears the "program" edge to the Program entity.
func (m *VolunteerOpportunityMutation) ClearProgram() {
	m.clearedprogram = true
}

// ProgramCleared reports if the "program" edge to the Program entity was cleared.
func (m *VolunteerOpportunityMutation) ProgramCleared() bool {
	return m.clearedprogram
}

// ProgramID returns the "program" edge ID in the mutation.
func (m *VolunteerOpportunityMutation) ProgramID() (id int, exists bool) {
	if m.program != nil {
		return *m.program, true
	}
	return
}

// ProgramIDs returns the "program" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgramID instead. It exists only for internal usage by the builders.
func (m *VolunteerOpportunityMutation) ProgramIDs() (ids []int) {
	if id := m.program; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgram resets all changes to the "program" edge.
func (m *VolunteerOpportunityMutation) ResetProgram() {
	m.program = nil
	m.clearedprogram = false
}

// AddInterestedVolunteerIDs adds the "interested_volunteers" edge to the VolunteerApplication entity by ids.
func (m *VolunteerOpportunityMutation) AddInterestedVolunteerIDs(ids ...int) {
	if m.interested_volunteers == nil {
		m.interested_volunteers = make(map[int]struct{})
	}
	for i := range ids {
		m.interested_volunteers[ids[i]] = struct{}{}
	}
}

// ClearInterestedVolunteers clears the "interested_volunteers" edge to the VolunteerApplication entity.
func (m *VolunteerOpportunityMutation) ClearInterestedVolunteers() {
	m.clearedinterested_volunteers = true
}

// InterestedVolunteersCleared reports if the "interested_volunteers" edge to the VolunteerApplication entity was cleared.
func (m *VolunteerOpportunityMutation) InterestedVolunteersCleared() bool {
	return m.clearedinterested_volunteers
}

// RemoveInterestedVolunteerIDs removes the "interested_volunteers" edge to the VolunteerApplication entity by IDs.
func (m *VolunteerOpportunityMutation) RemoveInterestedVolunteerIDs(ids ...int) {
	if m.removedinterested_volunteers == nil {
		m.removedinterested_volunteers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.interested_volunteers, ids[i])
		m.removedinterested_volunteers[ids[i]] = struct{}{}
	}
}

// RemovedInterestedVolunteers returns the removed IDs of the "interested_volunteers" edge to the VolunteerApplication entity.
func (m *VolunteerOpportunityMutation) RemovedInterestedVolunteersIDs() (ids []int) {
	for id := range m.removedinterested_volunteers {
		ids = append(ids, id)
	}
	return
}

// InterestedVolunteersIDs returns the "interested_volunteers" edge IDs in the mutation.
func (m *VolunteerOpportunityMutation) InterestedVolunteersIDs() (ids []int) {
	for id := range m.interested_volunteers {
		ids = append(ids, id)
	}
	return
}

// ResetInterestedVolunteers resets all changes to the "interested_volunteers" edge.
func (m *VolunteerOpportunityMutation) ResetInterestedVolunteers() {
	m.interested_volunteers = nil
	m.clearedinterested_volunteers = false
	m.removedinterested_volunteers = nil
}

// AddAssignmentIDs adds the "assignments" edge to the VolunteerAssignment entity by ids.
func (m *VolunteerOpportunityMutation) AddAssignmentIDs(ids ...int) {
	if m.assignments == nil {
		m.assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the VolunteerAssignment entity.
func (m *VolunteerOpportunityMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the VolunteerAssignment entity was cleared.
func (m *VolunteerOpportunityMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the VolunteerAssignment entity by IDs.
func (m *VolunteerOpportunityMutation) RemoveAssignmentIDs(ids ...int) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the VolunteerAssignment entity.
func (m *VolunteerOpportunityMutation) RemovedAssignmentsIDs() (ids []int) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *VolunteerOpportunityMutation) AssignmentsIDs() (ids []int) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *VolunteerOpportunityMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// Where appends a list predicates to the VolunteerOpportunityMutation builder.
func (m *VolunteerOpportunityMutation) Where(ps ...predicate.VolunteerOpportunity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VolunteerOpportunityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VolunteerOpportunityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VolunteerOpportunity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VolunteerOpportunityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VolunteerOpportunityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VolunteerOpportunity).
func (m *VolunteerOpportunityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VolunteerOpportunityMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.title != nil {
		fields = append(fields, volunteeropportunity.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, volunteeropportunity.FieldDescription)
	}
	if m.time_commitment != nil {
		fields = append(fields, volunteeropportunity.FieldTimeCommitment)
	}
	if m.location != nil {
		fields = append(fields, volunteeropportunity.FieldLocation)
	}
	if m.is_active != nil {
		fields = append(fields, volunteeropportunity.FieldIsActive)
	}
	if m.max_volunteers != nil {
		fields = append(fields, volunteeropportunity.FieldMaxVolunteers)
	}
	if m.current_volunteers != nil {
		fields = append(fields, volunteeropportunity.FieldCurrentVolunteers)
	}
	if m.start_date != nil {
		fields = append(fields, volunteeropportunity.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, volunteeropportunity.FieldEndDate)
	}
	if m.application_deadline != nil {
		fields = append(fields, volunteeropportunity.FieldApplicationDeadline)
	}
	if m.required_skills != nil {
		fields = append(fields, volunteeropportunity.FieldRequiredSkills)
	}
	if m.preferred_skills != nil {
		fields = append(fields, volunteeropportunity.FieldPreferredSkills)
	}
	if m.tags != nil {
		fields = append(fields, volunteeropportunity.FieldTags)
	}
	if m.is_urgent != nil {
		fields = append(fields, volunteeropportunity.FieldIsUrgent)
	}
	if m.is_recurring != nil {
		fields = append(fields, volunteeropportunity.FieldIsRecurring)
	}
	if m.created_at != nil {
		fields = append(fields, volunteeropportunity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, volunteeropportunity.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VolunteerOpportunityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case volunteeropportunity.FieldTitle:
		return m.Title()
	case volunteeropportunity.FieldDescription:
		return m.Description()
	case volunteeropportunity.FieldTimeCommitment:
		return m.TimeCommitment()
	case volunteeropportunity.FieldLocation:
		return m.Location()
	case volunteeropportunity.FieldIsActive:
		return m.IsActive()
	case volunteeropportunity.FieldMaxVolunteers:
		return m.MaxVolunteers()
	case volunteeropportunity.FieldCurrentVolunteers:
		return m.CurrentVolunteers()
	case volunteeropportunity.FieldStartDate:
		return m.StartDate()
	case volunteeropportunity.FieldEndDate:
		return m.EndDate()
	case volunteeropportunity.FieldApplicationDeadline:
		return m.ApplicationDeadline()
	case volunteeropportunity.FieldRequiredSkills:
		return m.RequiredSkills()
	case volunteeropportunity.FieldPreferredSkills:
		return m.PreferredSkills()
	case volunteeropportunity.FieldTags:
		return m.Tags()
	case volunteeropportunity.FieldIsUrgent:
		return m.IsUrgent()
	case volunteeropportunity.FieldIsRecurring:
		return m.IsRecurring()
	case volunteeropportunity.FieldCreatedAt:
		return m.CreatedAt()
	case volunteeropportunity.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VolunteerOpportunityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case volunteeropportunity.FieldTitle:
		return m.OldTitle(ctx)
	case volunteeropportunity.FieldDescription:
		return m.OldDescription(ctx)
	case volunteeropportunity.FieldTimeCommitment:
		return m.OldTimeCommitment(ctx)
	case volunteeropportunity.FieldLocation:
		return m.OldLocation(ctx)
	case volunteeropportunity.FieldIsActive:
		return m.OldIsActive(ctx)
	case volunteeropportunity.FieldMaxVolunteers:
		return m.OldMaxVolunteers(ctx)
	case volunteeropportunity.FieldCurrentVolunteers:
		return m.OldCurrentVolunteers(ctx)
	case volunteeropportunity.FieldStartDate:
		return m.OldStartDate(ctx)
	case volunteeropportunity.FieldEndDate:
		return m.OldEndDate(ctx)
	case volunteeropportunity.FieldApplicationDeadline:
		return m.OldApplicationDeadline(ctx)
	case volunteeropportunity.FieldRequiredSkills:
		return m.OldRequiredSkills(ctx)
	case volunteeropportunity.FieldPreferredSkills:
		return m.OldPreferredSkills(ctx)
	case volunteeropportunity.FieldTags:
		return m.OldTags(ctx)
	case volunteeropportunity.FieldIsUrgent:
		return m.OldIsUrgent(ctx)
	case volunteeropportunity.FieldIsRecurring:
		return m.OldIsRecurring(ctx)
	case volunteeropportunity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case volunteeropportunity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown VolunteerOpportunity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VolunteerOpportunityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case volunteeropportunity.FieldTitle:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case volunteeropportunity.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case volunteeropportunity.FieldTimeCommitment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeCommitment(v)
		return nil
	case volunteeropportunity.FieldLocation:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case volunteeropportunity.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case volunteeropportunity.FieldMaxVolunteers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxVolunteers(v)
		return nil
	case volunteeropportunity.FieldCurrentVolunteers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentVolunteers(v)
		return nil
	case volunteeropportunity.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case volunteeropportunity.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case volunteeropportunity.FieldApplicationDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationDeadline(v)
		return nil
	case volunteeropportunity.FieldRequiredSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredSkills(v)
		return nil
	case volunteeropportunity.FieldPreferredSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferredSkills(v)
		return nil
	case volunteeropportunity.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case volunteeropportunity.FieldIsUrgent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUrgent(v)
		return nil
	case volunteeropportunity.FieldIsRecurring:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRecurring(v)
		return nil
	case volunteeropportunity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case volunteeropportunity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown VolunteerOpportunity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VolunteerOpportunityMutation) AddedFields() []string {
	var fields []string
	if m.addmax_volunteers != nil {
		fields = append(fields, volunteeropportunity.FieldMaxVolunteers)
	}
	if m.addcurrent_volunteers != nil {
		fields = append(fields, volunteeropportunity.FieldCurrentVolunteers)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VolunteerOpportunityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case volunteeropportunity.FieldMaxVolunteers:
		return m.AddedMaxVolunteers()
	case volunteeropportunity.FieldCurrentVolunteers:
		return m.AddedCurrentVolunteers()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VolunteerOpportunityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case volunteeropportunity.FieldMaxVolunteers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxVolunteers(v)
		return nil
	case volunteeropportunity.FieldCurrentVolunteers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentVolunteers(v)
		return nil
	}
	return fmt.Errorf("unknown VolunteerOpportunity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VolunteerOpportunityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(volunteeropportunity.FieldMaxVolunteers) {
		fields = append(fields, volunteeropportunity.FieldMaxVolunteers)
	}
	if m.FieldCleared(volunteeropportunity.FieldStartDate) {
		fields = append(fields, volunteeropportunity.FieldStartDate)
	}
	if m.FieldCleared(volunteeropportunity.FieldEndDate) {
		fields = append(fields, volunteeropportunity.FieldEndDate)
	}
	if m.FieldCleared(volunteeropportunity.FieldApplicationDeadline) {
		fields = append(fields, volunteeropportunity.FieldApplicationDeadline)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VolunteerOpportunityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VolunteerOpportunityMutation) ClearField(name string) error {
	switch name {
	case volunteeropportunity.FieldMaxVolunteers:
		m.ClearMaxVolunteers()
		return nil
	case volunteeropportunity.FieldStartDate:
		m.ClearStartDate()
		return nil
	case volunteeropportunity.FieldEndDate:
		m.ClearEndDate()
		return nil
	case volunteeropportunity.FieldApplicationDeadline:
		m.ClearApplicationDeadline()
		return nil
	}
	return fmt.Errorf("unknown VolunteerOpportunity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VolunteerOpportunityMutation) ResetField(name string) error {
	switch name {
	case volunteeropportunity.FieldTitle:
		m.ResetTitle()
		return nil
	case volunteeropportunity.FieldDescription:
		m.ResetDescription()
		return nil
	case volunteeropportunity.FieldTimeCommitment:
		m.ResetTimeCommitment()
		return nil
	case volunteeropportunity.FieldLocation:
		m.ResetLocation()
		return nil
	case volunteeropportunity.FieldIsActive:
		m.ResetIsActive()
		return nil
	case volunteeropportunity.FieldMaxVolunteers:
		m.ResetMaxVolunteers()
		return nil
	case volunteeropportunity.FieldCurrentVolunteers:
		m.ResetCurrentVolunteers()
		return nil
	case volunteeropportunity.FieldStartDate:
		m.ResetStartDate()
		return nil
	case volunteeropportunity.FieldEndDate:
		m.ResetEndDate()
		return nil
	case volunteeropportunity.FieldApplicationDeadline:
		m.ResetApplicationDeadline()
		return nil
	case volunteeropportunity.FieldRequiredSkills:
		m.ResetRequiredSkills()
		return nil
	case volunteeropportunity.FieldPreferredSkills:
		m.ResetPreferredSkills()
		return nil
	case volunteeropportunity.FieldTags:
		m.ResetTags()
		return nil
	case volunteeropportunity.FieldIsUrgent:
		m.ResetIsUrgent()
		return nil
	case volunteeropportunity.FieldIsRecurring:
		m.ResetIsRecurring()
		return nil
	case volunteeropportunity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case volunteeropportunity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown VolunteerOpportunity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VolunteerOpportunityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.program != nil {
		edges = append(edges, volunteeropportunity.EdgeProgram)
	}
	if m.interested_volunteers != nil {
		edges = append(edges, volunteeropportunity.EdgeInterestedVolunteers)
	}
	if m.assignments != nil {
		edges = append(edges, volunteeropportunity.EdgeAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VolunteerOpportunityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case volunteeropportunity.EdgeProgram:
		if id := m.program; id != nil {
			return []ent.Value{*id}
		}
	case volunteeropportunity.EdgeInterestedVolunteers:
		ids := make([]ent.Value, 0, len(m.interested_volunteers))
		for id := range m.interested_volunteers {
			ids = append(ids, id)
		}
		return ids
	case volunteeropportunity.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VolunteerOpportunityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedinterested_volunteers != nil {
		edges = append(edges, volunteeropportunity.EdgeInterestedVolunteers)
	}
	if m.removedassignments != nil {
		edges = append(edges, volunteeropportunity.EdgeAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VolunteerOpportunityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case volunteeropportunity.EdgeInterestedVolunteers:
		ids := make([]ent.Value, 0, len(m.removedinterested_volunteers))
		for id := range m.removedinterested_volunteers {
			ids = append(ids, id)
		}
		return ids
	case volunteeropportunity.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VolunteerOpportunityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprogram {
		edges = append(edges, volunteeropportunity.EdgeProgram)
	}
	if m.clearedinterested_volunteers {
		edges = append(edges, volunteeropportunity.EdgeInterestedVolunteers)
	}
	if m.clearedassignments {
		edges = append(edges, volunteeropportunity.EdgeAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VolunteerOpportunityMutation) EdgeCleared(name string) bool {
	switch name {
	case volunteeropportunity.EdgeProgram:
		return m.clearedprogram
	case volunteeropportunity.EdgeInterestedVolunteers:
		return m.clearedinterested_volunteers
	case volunteeropportunity.EdgeAssignments:
		return m.clearedassignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VolunteerOpportunityMutation) ClearEdge(name string) error {
	switch name {
	case volunteeropportunity.EdgeProgram:
		m.ClearProgram()
		return nil
	}
	return fmt.Errorf("unknown VolunteerOpportunity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VolunteerOpportunityMutation) ResetEdge(name string) error {
	switch name {
	case volunteeropportunity.EdgeProgram:
		m.ResetProgram()
		return nil
	case volunteeropportunity.EdgeInterestedVolunteers:
		m.ResetInterestedVolunteers()
		return nil
	case volunteeropportunity.EdgeAssignments:
		m.ResetAssignments()
		return nil
	}
	return fmt.Errorf("unknown VolunteerOpportunity edge %s", name)
}

// VoteMutation represents an operation that mutates the Vote nodes in the graph.
type VoteMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	question           *string
	options            *[]string
	appendoptions      []string
	status             *string
	result             *string
	clearedFields      map[string]struct{}
	agenda_item        *int
	clearedagenda_item bool
	ballots            map[int]struct{}
	removedballots     map[int]struct{}
	clearedballots     bool
	done               bool
	oldValue           func(context.Context) (*Vote, error)
	predicates         []predicate.Vote
}

var _ ent.Mutation = (*VoteMutation)(nil)

// voteOption allows management of the mutation configuration using functional options.
type voteOption func(*VoteMutation)

// newVoteMutation creates new mutation for the Vote entity.
func newVoteMutation(c config, op Op, opts ...voteOption) *VoteMutation {
	m := &VoteMutation{
		config:        c,
		op:            op,
		typ:           TypeVote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoteID sets the ID field of the mutation.
func withVoteID(id int) voteOption {
	return func(m *VoteMutation) {
		var (
			err   error
			once  sync.Once
			value *Vote
		)
		m.oldValue = func(ctx context.Context) (*Vote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVote sets the old Vote of the mutation.
func withVote(node *Vote) voteOption {
	return func(m *VoteMutation) {
		m.oldValue = func(context.Context) (*Vote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuestion sets the "question" field.
func (m *VoteMutation) SetQuestion(s string) {
	m.question = &s
}

// Question returns the value of the "question" field in the mutation.
func (m *VoteMutation) Question() (r string, exists bool) {
	v := m.question
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestion returns the old "question" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldQuestion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestion: %w", err)
	}
	return oldValue.Question, nil
}

// ResetQuestion resets all changes to the "question" field.
func (m *VoteMutation) ResetQuestion() {
	m.question = nil
}

// SetOptions sets the "options" field.
func (m *VoteMutation) SetOptions(s []string) {
	m.options = &s
	m.appendoptions = nil
}

// Options returns the value of the "options" field in the mutation.
func (m *VoteMutation) Options() (r []string, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldOptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// AppendOptions adds s to the "options" field.
func (m *VoteMutation) AppendOptions(s []string) {
	m.appendoptions = append(m.appendoptions, s...)
}

// AppendedOptions returns the list of values that were appended to the "options" field in this mutation.
func (m *VoteMutation) AppendedOptions() ([]string, bool) {
	if len(m.appendoptions) == 0 {
		return nil, false
	}
	return m.appendoptions, true
}

// ResetOptions resets all changes to the "options" field.
func (m *VoteMutation) ResetOptions() {
	m.options = nil
	m.appendoptions = nil
}

// SetStatus sets the "status" field.
func (m *VoteMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *VoteMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *VoteMutation) ResetStatus() {
	m.status = nil
}

// SetResult sets the "result" field.
func (m *VoteMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *VoteMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *VoteMutation) ClearResult() {
	m.result = nil
	m.clearedFields[vote.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *VoteMutation) ResultCleared() bool {
	_, ok := m.clearedFields[vote.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *VoteMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, vote.FieldResult)
}

// SetAgendaItemID sets the "agenda_item" edge to the AgendaItem entity by id.
func (m *VoteMutation) SetAgendaItemID(id int) {
	m.agenda_item = &id
}

// ClearAgendaItem clears the "agenda_item" edge to the AgendaItem entity.
func (m *VoteMutation) ClearAgendaItem() {
	m.clearedagenda_item = true
}

// AgendaItemCleared reports if the "agenda_item" edge to the AgendaItem entity was cleared.
func (m *VoteMutation) AgendaItemCleared() bool {
	return m.clearedagenda_item
}

// AgendaItemID returns the "agenda_item" edge ID in the mutation.
func (m *VoteMutation) AgendaItemID() (id int, exists bool) {
	if m.agenda_item != nil {
		return *m.agenda_item, true
	}
	return
}

// AgendaItemIDs returns the "agenda_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgendaItemID instead. It exists only for internal usage by the builders.
func (m *VoteMutation) AgendaItemIDs() (ids []int) {
	if id := m.agenda_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgendaItem resets all changes to the "agenda_item" edge.
func (m *VoteMutation) ResetAgendaItem() {
	m.agenda_item = nil
	m.clearedagenda_item = false
}

// AddBallotIDs adds the "ballots" edge to the Ballot entity by ids.
func (m *VoteMutation) AddBallotIDs(ids ...int) {
	if m.ballots == nil {
		m.ballots = make(map[int]struct{})
	}
	for i := range ids {
		m.ballots[ids[i]] = struct{}{}
	}
}

// ClearBallots clears the "ballots" edge to the Ballot entity.
func (m *VoteMutation) ClearBallots() {
	m.clearedballots = true
}

// BallotsCleared reports if the "ballots" edge to the Ballot entity was cleared.
func (m *VoteMutation) BallotsCleared() bool {
	return m.clearedballots
}

// RemoveBallotIDs removes the "ballots" edge to the Ballot entity by IDs.
func (m *VoteMutation) RemoveBallotIDs(ids ...int) {
	if m.removedballots == nil {
		m.removedballots = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ballots, ids[i])
		m.removedballots[ids[i]] = struct{}{}
	}
}

// RemovedBallots returns the removed IDs of the "ballots" edge to the Ballot entity.
func (m *VoteMutation) RemovedBallotsIDs() (ids []int) {
	for id := range m.removedballots {
		ids = append(ids, id)
	}
	return
}

// BallotsIDs returns the "ballots" edge IDs in the mutation.
func (m *VoteMutation) BallotsIDs() (ids []int) {
	for id := range m.ballots {
		ids = append(ids, id)
	}
	return
}

// ResetBallots resets all changes to the "ballots" edge.
func (m *VoteMutation) ResetBallots() {
	m.ballots = nil
	m.clearedballots = false
	m.removedballots = nil
}

// Where appends a list predicates to the VoteMutation builder.
func (m *VoteMutation) Where(ps ...predicate.Vote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vote).
func (m *VoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoteMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.question != nil {
		fields = append(fields, vote.FieldQuestion)
	}
	if m.options != nil {
		fields = append(fields, vote.FieldOptions)
	}
	if m.status != nil {
		fields = append(fields, vote.FieldStatus)
	}
	if m.result != nil {
		fields = append(fields, vote.FieldResult)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vote.FieldQuestion:
		return m.Question()
	case vote.FieldOptions:
		return m.Options()
	case vote.FieldStatus:
		return m.Status()
	case vote.FieldResult:
		return m.Result()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vote.FieldQuestion:
		return m.OldQuestion(ctx)
	case vote.FieldOptions:
		return m.OldOptions(ctx)
	case vote.FieldStatus:
		return m.OldStatus(ctx)
	case vote.FieldResult:
		return m.OldResult(ctx)
	}
	return nil, fmt.Errorf("unknown Vote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vote.FieldQuestion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestion(v)
		return nil
	case vote.FieldOptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	case vote.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case vote.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	}
	return fmt.Errorf("unknown Vote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Vote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vote.FieldResult) {
		fields = append(fields, vote.FieldResult)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoteMutation) ClearField(name string) error {
	switch name {
	case vote.FieldResult:
		m.ClearResult()
		return nil
	}
	return fmt.Errorf("unknown Vote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoteMutation) ResetField(name string) error {
	switch name {
	case vote.FieldQuestion:
		m.ResetQuestion()
		return nil
	case vote.FieldOptions:
		m.ResetOptions()
		return nil
	case vote.FieldStatus:
		m.ResetStatus()
		return nil
	case vote.FieldResult:
		m.ResetResult()
		return nil
	}
	return fmt.Errorf("unknown Vote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.agenda_item != nil {
		edges = append(edges, vote.EdgeAgendaItem)
	}
	if m.ballots != nil {
		edges = append(edges, vote.EdgeBallots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vote.EdgeAgendaItem:
		if id := m.agenda_item; id != nil {
			return []ent.Value{*id}
		}
	case vote.EdgeBallots:
		ids := make([]ent.Value, 0, len(m.ballots))
		for id := range m.ballots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedballots != nil {
		edges = append(edges, vote.EdgeBallots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vote.EdgeBallots:
		ids := make([]ent.Value, 0, len(m.removedballots))
		for id := range m.removedballots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedagenda_item {
		edges = append(edges, vote.EdgeAgendaItem)
	}
	if m.clearedballots {
		edges = append(edges, vote.EdgeBallots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoteMutation) EdgeCleared(name string) bool {
	switch name {
	case vote.EdgeAgendaItem:
		return m.clearedagenda_item
	case vote.EdgeBallots:
		return m.clearedballots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoteMutation) ClearEdge(name string) error {
	switch name {
	case vote.EdgeAgendaItem:
		m.ClearAgendaItem()
		return nil
	}
	return fmt.Errorf("unknown Vote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoteMutation) ResetEdge(name string) error {
	switch name {
	case vote.EdgeAgendaItem:
		m.ResetAgendaItem()
		return nil
	case vote.EdgeBallots:
		m.ResetBallots()
		return nil
	}
	return fmt.Errorf("unknown Vote edge %s", name)
}
